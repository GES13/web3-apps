/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@waves.exchange/provider-web/dist/provider-web.es.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@waves.exchange/provider-web/dist/provider-web.es.js ***!
  \***************************************************************************/
/*! exports provided: ProviderWeb */
/*! exports used: ProviderWeb */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProviderWeb; });
/* harmony import */ var _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @waves/waves-browser-bus */ "./node_modules/@waves/waves-browser-bus/dist/index.js");
/* harmony import */ var _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var typed_ts_events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! typed-ts-events */ "./node_modules/typed-ts-events/dist/events.min.js");
/* harmony import */ var typed_ts_events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(typed_ts_events__WEBPACK_IMPORTED_MODULE_1__);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));


class Queue {
  constructor(maxLength) {
    this._actions = [];
    this._maxLength = maxLength;
  }
  get length() {
    return this._actions.length + (this._active == null ? 0 : 1);
  }
  push(action) {
    if (this._actions.length >= this._maxLength) {
      throw new Error("Cant't push action! Queue is full!");
    }
    return new Promise((resolve, reject) => {
      const onEnd = () => {
        this._active = void 0;
        const index = this._actions.map((x) => x.action).indexOf(actionCallback);
        if (index !== -1) {
          this._actions.splice(index, 1);
        }
        this.run();
      };
      const actionCallback = () => action().then((res) => {
        onEnd();
        resolve(res);
      }, (err) => {
        onEnd();
        reject(err);
      });
      this._actions.push({ action: actionCallback, reject });
      if (this.length === 1) {
        this.run();
      }
    });
  }
  clear(error) {
    error = error || new Error("Rejection with clear queue!");
    const e = typeof error === "string" ? new Error(error) : error;
    this._actions.splice(0, this._actions.length).forEach((item) => item.reject(e));
    this._active = void 0;
  }
  canPush() {
    return this._actions.length < this._maxLength;
  }
  run() {
    const item = this._actions.shift();
    if (item == null) {
      return void 0;
    }
    this._active = item.action();
  }
}
const createError = (error) => {
  const commonError = {
    code: 0,
    message: (error == null ? void 0 : error.message) || error
  };
  switch (error == null ? void 0 : error.message) {
    case "SecurityError: Failed to read the 'localStorage' property from 'Window': Access is denied for this document.":
      return __spreadProps(__spreadValues({}, commonError), {
        message: "Local storage is not available! It is possible that the Browser is in incognito mode!"
      });
    default:
      return commonError;
  }
};
class Transport {
  constructor(queueLength) {
    this._events = [];
    this._toRunEvents = [];
    this._queue = new Queue(queueLength);
  }
  dropConnection() {
    this._queue.clear(new Error("User rejection!"));
    this._events.forEach((event) => this._toRunEvents.push(event));
    this._dropTransportConnect();
  }
  sendEvent(callback) {
    this._events.push(callback);
    this._toRunEvents.push(callback);
  }
  dialog(callback) {
    this._runBeforeShow();
    return this._getBus().then((bus) => {
      const action = this._wrapAction(() => callback(bus));
      this._runEvents(bus);
      if (this._queue.canPush()) {
        return this._queue.push(action).then((result) => {
          this._runAfterShow();
          return result;
        }).catch((error) => {
          this._runAfterShow();
          return Promise.reject(createError(error));
        });
      } else {
        return Promise.reject(new Error("Queue is full!"));
      }
    });
  }
  _runBeforeShow() {
    if (this._queue.length === 0) {
      this._beforeShow();
    }
  }
  _runAfterShow() {
    if (this._queue.length === 0) {
      this._afterShow();
    }
  }
  _runEvents(bus) {
    this._toRunEvents.splice(0, this._events.length).forEach((callback) => callback(bus));
  }
  _wrapAction(action) {
    return this._toRunEvents ? () => {
      const result = action();
      result.catch(() => {
        this._events.forEach((event) => this._toRunEvents.push(event));
      });
      return result;
    } : action;
  }
}
const _TransportIframe = class extends Transport {
  constructor(url, queueLength) {
    super(queueLength);
    this._url = url;
    this._initIframe();
  }
  get() {
    if (!this._iframe) {
      this._initIframe();
    }
    return this._iframe;
  }
  _dropTransportConnect() {
    if (this._iframe != null) {
      document.body.removeChild(this._iframe);
      this._initIframe();
    }
    if (this._bus) {
      this._bus.destroy();
      this._bus = void 0;
    }
  }
  _getBus() {
    if (this._bus) {
      return Promise.resolve(this._bus);
    }
    return _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__["WindowAdapter"].createSimpleWindowAdapter(this._iframe).then((adapter) => new Promise((resolve) => {
      this._bus = new _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__["Bus"](adapter, -1);
      this._bus.once("ready", () => {
        resolve(this._bus);
      });
    }));
  }
  _beforeShow() {
    this._showIframe();
  }
  _afterShow() {
    this._hideIframe();
  }
  _initIframe() {
    this._iframe = this._createIframe();
    this._addIframeToDom(this._iframe);
    this._listenFetchURLError(this._iframe);
    this._hideIframe();
  }
  _addIframeToDom(iframe) {
    if (document.body != null) {
      document.body.appendChild(iframe);
    } else {
      document.addEventListener("DOMContentLoaded", () => {
        document.body.appendChild(iframe);
      });
    }
  }
  _createIframe() {
    const iframe = document.createElement("iframe");
    iframe.style.transition = "opacity .2s";
    iframe.style.position = "absolute";
    iframe.style.opacity = "0";
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.left = "0";
    iframe.style.top = "0";
    iframe.style.border = "none";
    iframe.style.position = "fixed";
    return iframe;
  }
  _showIframe() {
    const shownStyles = {
      width: "100%",
      height: "100%",
      left: "0",
      top: "0",
      border: "none",
      position: "fixed",
      display: "block",
      opacity: "0",
      zIndex: "99999999"
    };
    this._applyStyle(shownStyles);
    if (_TransportIframe._timer != null) {
      clearTimeout(_TransportIframe._timer);
    }
    _TransportIframe._timer = setTimeout(() => {
      this._applyStyle({ opacity: "1" });
    }, 0);
  }
  _hideIframe() {
    const hiddenStyle = {
      opacity: "0"
    };
    this._applyStyle(hiddenStyle);
    if (_TransportIframe._timer != null) {
      clearTimeout(_TransportIframe._timer);
    }
    _TransportIframe._timer = setTimeout(() => {
      this._applyStyle({
        width: "10px",
        height: "10px",
        left: "-100px",
        top: "-100px",
        position: "absolute",
        opacity: "0",
        zIndex: "0",
        display: "none"
      });
    }, 200);
  }
  _applyStyle(styles) {
    Object.entries(styles).forEach(([name, value]) => {
      if (value != null) {
        if (this._iframe) {
          this._iframe.style[name] = value;
        }
      }
    });
  }
  _renderErrorPage(bodyElement, onClose, errorMessage) {
    if (bodyElement.parentElement) {
      bodyElement.parentElement.style.height = "100%";
    }
    Object.assign(bodyElement.style, {
      position: "relative",
      boxSizing: "border-box",
      width: "100%",
      height: "100%",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      margin: "0px"
    });
    const backdropElement = document.createElement("div");
    Object.assign(backdropElement.style, {
      position: "fixed",
      zIndex: "-1",
      height: "100%",
      width: "100%",
      overflow: "hidden",
      backgroundColor: "#000",
      opacity: "0.6"
    });
    const wrapperElement = document.createElement("div");
    Object.assign(wrapperElement.style, {
      position: "fixed",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      flexDirection: "column",
      margin: "0",
      backgroundColor: "#292F3C",
      width: "520px",
      borderRadius: "6px",
      padding: "40px",
      boxSizing: "border-box"
    });
    const errorMessageElement = document.createElement("div");
    errorMessageElement.textContent = errorMessage;
    Object.assign(errorMessageElement.style, {
      fontSize: "15px",
      lineHeight: "20px",
      color: "#fff",
      marginBottom: "40px",
      fontFamily: "Roboto, sans-serif"
    });
    const buttonElement = document.createElement("button");
    buttonElement.textContent = "OK";
    buttonElement.addEventListener("click", () => onClose());
    Object.assign(buttonElement.style, {
      width: "100%",
      fontSize: "15px",
      lineHeight: "48px",
      padding: " 0 40px",
      color: "#fff",
      backgroundColor: "#5A81EA",
      outline: "none",
      border: "none",
      cursor: "pointer",
      fontFamily: "Roboto, sans-serif",
      borderRadius: "4px"
    });
    wrapperElement.appendChild(errorMessageElement);
    wrapperElement.appendChild(buttonElement);
    bodyElement.appendChild(backdropElement);
    bodyElement.appendChild(wrapperElement);
  }
  _listenFetchURLError(iframe) {
    fetch(this._url).catch(() => {
      iframe.addEventListener("load", () => {
        if (!iframe.contentDocument) {
          return;
        }
        this._renderErrorPage(iframe.contentDocument.body, () => this.dropConnection(), "The request could not be processed. To resume your further work, disable the installed plugins.");
        this._showIframe();
      });
    });
  }
};
let TransportIframe = _TransportIframe;
TransportIframe._timer = null;
function isBrave() {
  var _a;
  return !!((_a = navigator.brave) == null ? void 0 : _a.isBrave);
}
function isSafari() {
  const userAgent = navigator.userAgent.toLowerCase();
  const isSafariUA = userAgent.includes("safari") && !userAgent.includes("chrome");
  const iOS = navigator.platform != null && /iPad|iPhone|iPod/.test(navigator.platform);
  return iOS || isSafariUA;
}
class ProviderWeb {
  constructor(clientUrl, logs) {
    this.user = null;
    this.emitter = new typed_ts_events__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    this._clientUrl = (clientUrl || "https://waves.exchange/signer/") + `?${ProviderWeb._getCacheClean()}`;
    this._transport = new TransportIframe(this._clientUrl, 3);
    if (logs === true) {
      _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__["config"].console.logLevel = _waves_waves_browser_bus__WEBPACK_IMPORTED_MODULE_0__["config"].console.LOG_LEVEL.VERBOSE;
    }
  }
  static _getCacheClean() {
    return String(Date.now() % (1e3 * 60));
  }
  on(event, handler) {
    this.emitter.on(event, handler);
    return this;
  }
  once(event, handler) {
    this.emitter.once(event, handler);
    return this;
  }
  off(event, handler) {
    this.emitter.once(event, handler);
    return this;
  }
  connect(options) {
    return Promise.resolve(this._transport.sendEvent((bus) => bus.dispatchEvent("connect", options)));
  }
  logout() {
    this.user = null;
    return Promise.resolve(this._transport.dropConnection());
  }
  login() {
    var _a;
    if (this.user) {
      return Promise.resolve(this.user);
    }
    const iframe = this._transport.get();
    if (isSafari() || isBrave()) {
      const win = (_a = iframe.contentWindow) == null ? void 0 : _a.open(this._clientUrl);
      if (!win) {
        throw new Error("Window was blocked");
      }
    }
    iframe.src = this._clientUrl;
    return this._transport.dialog((bus) => bus.request("login").then((userData) => {
      this.user = userData;
      return userData;
    }).catch((err) => {
      this._transport.dropConnection();
      return Promise.reject(createError(err));
    }));
  }
  signMessage(data) {
    return this.login().then(() => this._transport.dialog((bus) => bus.request("sign-message", data)));
  }
  signTypedData(data) {
    return this.login().then(() => this._transport.dialog((bus) => bus.request("sign-typed-data", data)));
  }
  sign(toSign) {
    return this.login().then(() => this._transport.dialog((bus) => bus.request("sign", toSign)));
  }
}



/***/ }),

/***/ "./node_modules/@waves/bignumber/dist/bignumber.umd.min.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@waves/bignumber/dist/bignumber.umd.min.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?t(exports):undefined}(this,function(e){"use strict";var t=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,n=Math.ceil,r=Math.floor,i="[BigNumber Error] ",o=i+"Number primitive has more than 15 significant digits: ",u=1e14,s=14,f=9007199254740991,c=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],l=1e7,a=1e9;function h(e){var t=0|e;return e>0||e===t?t:t-1}function p(e){for(var t,n,r=1,i=e.length,o=e[0]+"";r<i;){for(t=e[r++]+"",n=s-t.length;n--;t="0"+t);o+=t}for(i=o.length;48===o.charCodeAt(--i););return o.slice(0,i+1||1)}function g(e,t){var n,r,i=e.c,o=t.c,u=e.s,s=t.s,f=e.e,c=t.e;if(!u||!s)return null;if(n=i&&!i[0],r=o&&!o[0],n||r)return n?r?0:-s:u;if(u!=s)return u;if(n=u<0,r=f==c,!i||!o)return r?0:!i^n?1:-1;if(!r)return f>c^n?1:-1;for(s=(f=i.length)<(c=o.length)?f:c,u=0;u<s;u++)if(i[u]!=o[u])return i[u]>o[u]^n?1:-1;return f==c?0:f>c^n?1:-1}function m(e,t,n,o){if(e<t||e>n||e!==r(e))throw Error(i+(o||"Argument")+("number"==typeof e?e<t||e>n?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function N(e){var t=e.c.length-1;return h(e.e/s)==t&&e.c[t]%2!=0}function b(e,t){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function w(e,t,n){var r,i;if(t<0){for(i=n+".";++t;i+=n);e=i+e}else if(++t>(r=e.length)){for(i=n,t-=r;--t;i+=n);e+=i}else t<r&&(e=e.slice(0,t)+"."+e.slice(t));return e}var d=function e(d){var y,O,v,E,A,_,U,R,D,L=H.prototype={constructor:H,toString:null,valueOf:null},B=new H(1),S=20,F=4,I=-7,M=21,x=-1e7,P=1e7,T=!1,C=1,G=0,j={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},q="0123456789abcdefghijklmnopqrstuvwxyz";function H(e,n){var i,u,c,l,a,h,p,g,N=this;if(!(N instanceof H))return new H(e,n);if(null==n){if(e&&!0===e._isBigNumber)return N.s=e.s,void(!e.c||e.e>P?N.c=N.e=null:e.e<x?N.c=[N.e=0]:(N.e=e.e,N.c=e.c.slice()));if((h="number"==typeof e)&&0*e==0){if(N.s=1/e<0?(e=-e,-1):1,e===~~e){for(l=0,a=e;a>=10;a/=10,l++);return void(l>P?N.c=N.e=null:(N.e=l,N.c=[e]))}g=String(e)}else{if(!t.test(g=String(e)))return v(N,g,h);N.s=45==g.charCodeAt(0)?(g=g.slice(1),-1):1}(l=g.indexOf("."))>-1&&(g=g.replace(".","")),(a=g.search(/e/i))>0?(l<0&&(l=a),l+=+g.slice(a+1),g=g.substring(0,a)):l<0&&(l=g.length)}else{if(m(n,2,q.length,"Base"),10==n)return z(N=new H(e),S+N.e+1,F);if(g=String(e),h="number"==typeof e){if(0*e!=0)return v(N,g,h,n);if(N.s=1/e<0?(g=g.slice(1),-1):1,H.DEBUG&&g.replace(/^0\.0*|\./,"").length>15)throw Error(o+e)}else N.s=45===g.charCodeAt(0)?(g=g.slice(1),-1):1;for(i=q.slice(0,n),l=a=0,p=g.length;a<p;a++)if(i.indexOf(u=g.charAt(a))<0){if("."==u){if(a>l){l=p;continue}}else if(!c&&(g==g.toUpperCase()&&(g=g.toLowerCase())||g==g.toLowerCase()&&(g=g.toUpperCase()))){c=!0,a=-1,l=0;continue}return v(N,String(e),h,n)}h=!1,(l=(g=O(g,n,10,N.s)).indexOf("."))>-1?g=g.replace(".",""):l=g.length}for(a=0;48===g.charCodeAt(a);a++);for(p=g.length;48===g.charCodeAt(--p););if(g=g.slice(a,++p)){if(p-=a,h&&H.DEBUG&&p>15&&(e>f||e!==r(e)))throw Error(o+N.s*e);if((l=l-a-1)>P)N.c=N.e=null;else if(l<x)N.c=[N.e=0];else{if(N.e=l,N.c=[],a=(l+1)%s,l<0&&(a+=s),a<p){for(a&&N.c.push(+g.slice(0,a)),p-=s;a<p;)N.c.push(+g.slice(a,a+=s));a=s-(g=g.slice(a)).length}else a-=p;for(;a--;g+="0");N.c.push(+g)}}else N.c=[N.e=0]}function V(e,t,n,r){var i,o,u,s,f;if(null==n?n=F:m(n,0,8),!e.c)return e.toString();if(i=e.c[0],u=e.e,null==t)f=p(e.c),f=1==r||2==r&&(u<=I||u>=M)?b(f,u):w(f,u,"0");else if(o=(e=z(new H(e),t,n)).e,s=(f=p(e.c)).length,1==r||2==r&&(t<=o||o<=I)){for(;s<t;f+="0",s++);f=b(f,o)}else if(t-=u,f=w(f,o,"0"),o+1>s){if(--t>0)for(f+=".";t--;f+="0");}else if((t+=o-s)>0)for(o+1==s&&(f+=".");t--;f+="0");return e.s<0&&i?"-"+f:f}function J(e,t){for(var n,r=1,i=new H(e[0]);r<e.length;r++){if(!(n=new H(e[r])).s){i=n;break}t.call(i,n)&&(i=n)}return i}function k(e,t,n){for(var r=1,i=t.length;!t[--i];t.pop());for(i=t[0];i>=10;i/=10,r++);return(n=r+n*s-1)>P?e.c=e.e=null:n<x?e.c=[e.e=0]:(e.e=n,e.c=t),e}function z(e,t,i,o){var f,l,a,h,p,g,m,N=e.c,b=c;if(N){e:{for(f=1,h=N[0];h>=10;h/=10,f++);if((l=t-f)<0)l+=s,a=t,m=(p=N[g=0])/b[f-a-1]%10|0;else if((g=n((l+1)/s))>=N.length){if(!o)break e;for(;N.length<=g;N.push(0));p=m=0,f=1,a=(l%=s)-s+1}else{for(p=h=N[g],f=1;h>=10;h/=10,f++);m=(a=(l%=s)-s+f)<0?0:p/b[f-a-1]%10|0}if(o=o||t<0||null!=N[g+1]||(a<0?p:p%b[f-a-1]),o=i<4?(m||o)&&(0==i||i==(e.s<0?3:2)):m>5||5==m&&(4==i||o||6==i&&(l>0?a>0?p/b[f-a]:0:N[g-1])%10&1||i==(e.s<0?8:7)),t<1||!N[0])return N.length=0,o?(t-=e.e+1,N[0]=b[(s-t%s)%s],e.e=-t||0):N[0]=e.e=0,e;if(0==l?(N.length=g,h=1,g--):(N.length=g+1,h=b[s-l],N[g]=a>0?r(p/b[f-a]%b[a])*h:0),o)for(;;){if(0==g){for(l=1,a=N[0];a>=10;a/=10,l++);for(a=N[0]+=h,h=1;a>=10;a/=10,h++);l!=h&&(e.e++,N[0]==u&&(N[0]=1));break}if(N[g]+=h,N[g]!=u)break;N[g--]=0,h=1}for(l=N.length;0===N[--l];N.pop());}e.e>P?e.c=e.e=null:e.e<x&&(e.c=[e.e=0])}return e}function $(e){var t,n=e.e;return null===n?e.toString():(t=p(e.c),t=n<=I||n>=M?b(t,n):w(t,n,"0"),e.s<0?"-"+t:t)}return H.clone=e,H.ROUND_UP=0,H.ROUND_DOWN=1,H.ROUND_CEIL=2,H.ROUND_FLOOR=3,H.ROUND_HALF_UP=4,H.ROUND_HALF_DOWN=5,H.ROUND_HALF_EVEN=6,H.ROUND_HALF_CEIL=7,H.ROUND_HALF_FLOOR=8,H.EUCLID=9,H.config=H.set=function(e){var t,n;if(null!=e){if("object"!=typeof e)throw Error(i+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(m(n=e[t],0,a,t),S=n),e.hasOwnProperty(t="ROUNDING_MODE")&&(m(n=e[t],0,8,t),F=n),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((n=e[t])&&n.pop?(m(n[0],-a,0,t),m(n[1],0,a,t),I=n[0],M=n[1]):(m(n,-a,a,t),I=-(M=n<0?-n:n))),e.hasOwnProperty(t="RANGE"))if((n=e[t])&&n.pop)m(n[0],-a,-1,t),m(n[1],1,a,t),x=n[0],P=n[1];else{if(m(n,-a,a,t),!n)throw Error(i+t+" cannot be zero: "+n);x=-(P=n<0?-n:n)}if(e.hasOwnProperty(t="CRYPTO")){if((n=e[t])!==!!n)throw Error(i+t+" not true or false: "+n);if(n){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw T=!n,Error(i+"crypto unavailable");T=n}else T=n}if(e.hasOwnProperty(t="MODULO_MODE")&&(m(n=e[t],0,9,t),C=n),e.hasOwnProperty(t="POW_PRECISION")&&(m(n=e[t],0,a,t),G=n),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(n=e[t]))throw Error(i+t+" not an object: "+n);j=n}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(n=e[t])||/^.$|[+-.\s]|(.).*\1/.test(n))throw Error(i+t+" invalid: "+n);q=n}}return{DECIMAL_PLACES:S,ROUNDING_MODE:F,EXPONENTIAL_AT:[I,M],RANGE:[x,P],CRYPTO:T,MODULO_MODE:C,POW_PRECISION:G,FORMAT:j,ALPHABET:q}},H.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!H.DEBUG)return!0;var t,n,o=e.c,f=e.e,c=e.s;e:if("[object Array]"=={}.toString.call(o)){if((1===c||-1===c)&&f>=-a&&f<=a&&f===r(f)){if(0===o[0]){if(0===f&&1===o.length)return!0;break e}if((t=(f+1)%s)<1&&(t+=s),String(o[0]).length==t){for(t=0;t<o.length;t++)if((n=o[t])<0||n>=u||n!==r(n))break e;if(0!==n)return!0}}}else if(null===o&&null===f&&(null===c||1===c||-1===c))return!0;throw Error(i+"Invalid BigNumber: "+e)},H.maximum=H.max=function(){return J(arguments,L.lt)},H.minimum=H.min=function(){return J(arguments,L.gt)},H.random=(E=9007199254740992*Math.random()&2097151?function(){return r(9007199254740992*Math.random())}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,o,u,f,l,h=0,p=[],g=new H(B);if(null==e?e=S:m(e,0,a),f=n(e/s),T)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(f*=2));h<f;)(l=131072*t[h]+(t[h+1]>>>11))>=9e15?(o=crypto.getRandomValues(new Uint32Array(2)),t[h]=o[0],t[h+1]=o[1]):(p.push(l%1e14),h+=2);h=f/2}else{if(!crypto.randomBytes)throw T=!1,Error(i+"crypto unavailable");for(t=crypto.randomBytes(f*=7);h<f;)(l=281474976710656*(31&t[h])+1099511627776*t[h+1]+4294967296*t[h+2]+16777216*t[h+3]+(t[h+4]<<16)+(t[h+5]<<8)+t[h+6])>=9e15?crypto.randomBytes(7).copy(t,h):(p.push(l%1e14),h+=7);h=f/7}if(!T)for(;h<f;)(l=E())<9e15&&(p[h++]=l%1e14);for(f=p[--h],e%=s,f&&e&&(l=c[s-e],p[h]=r(f/l)*l);0===p[h];p.pop(),h--);if(h<0)p=[u=0];else{for(u=-1;0===p[0];p.splice(0,1),u-=s);for(h=1,l=p[0];l>=10;l/=10,h++);h<s&&(u-=s-h)}return g.e=u,g.c=p,g}),H.sum=function(){for(var e=1,t=arguments,n=new H(t[0]);e<t.length;)n=n.plus(t[e++]);return n},O=function(){function e(e,t,n,r){for(var i,o,u=[0],s=0,f=e.length;s<f;){for(o=u.length;o--;u[o]*=t);for(u[0]+=r.indexOf(e.charAt(s++)),i=0;i<u.length;i++)u[i]>n-1&&(null==u[i+1]&&(u[i+1]=0),u[i+1]+=u[i]/n|0,u[i]%=n)}return u.reverse()}return function(t,n,r,i,o){var u,s,f,c,l,a,h,g,m=t.indexOf("."),N=S,b=F;for(m>=0&&(c=G,G=0,t=t.replace(".",""),a=(g=new H(n)).pow(t.length-m),G=c,g.c=e(w(p(a.c),a.e,"0"),10,r,"0123456789"),g.e=g.c.length),f=c=(h=e(t,n,r,o?(u=q,"0123456789"):(u="0123456789",q))).length;0==h[--c];h.pop());if(!h[0])return u.charAt(0);if(m<0?--f:(a.c=h,a.e=f,a.s=i,h=(a=y(a,g,N,b,r)).c,l=a.r,f=a.e),m=h[s=f+N+1],c=r/2,l=l||s<0||null!=h[s+1],l=b<4?(null!=m||l)&&(0==b||b==(a.s<0?3:2)):m>c||m==c&&(4==b||l||6==b&&1&h[s-1]||b==(a.s<0?8:7)),s<1||!h[0])t=l?w(u.charAt(1),-N,u.charAt(0)):u.charAt(0);else{if(h.length=s,l)for(--r;++h[--s]>r;)h[s]=0,s||(++f,h=[1].concat(h));for(c=h.length;!h[--c];);for(m=0,t="";m<=c;t+=u.charAt(h[m++]));t=w(t,f,u.charAt(0))}return t}}(),y=function(){function e(e,t,n){var r,i,o,u,s=0,f=e.length,c=t%l,a=t/l|0;for(e=e.slice();f--;)s=((i=c*(o=e[f]%l)+(r=a*o+(u=e[f]/l|0)*c)%l*l+s)/n|0)+(r/l|0)+a*u,e[f]=i%n;return s&&(e=[s].concat(e)),e}function t(e,t,n,r){var i,o;if(n!=r)o=n>r?1:-1;else for(i=o=0;i<n;i++)if(e[i]!=t[i]){o=e[i]>t[i]?1:-1;break}return o}function n(e,t,n,r){for(var i=0;n--;)e[n]-=i,i=e[n]<t[n]?1:0,e[n]=i*r+e[n]-t[n];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,o,f,c,l){var a,p,g,m,N,b,w,d,y,O,v,E,A,_,U,R,D,L=i.s==o.s?1:-1,B=i.c,S=o.c;if(!(B&&B[0]&&S&&S[0]))return new H(i.s&&o.s&&(B?!S||B[0]!=S[0]:S)?B&&0==B[0]||!S?0*L:L/0:NaN);for(y=(d=new H(L)).c=[],L=f+(p=i.e-o.e)+1,l||(l=u,p=h(i.e/s)-h(o.e/s),L=L/s|0),g=0;S[g]==(B[g]||0);g++);if(S[g]>(B[g]||0)&&p--,L<0)y.push(1),m=!0;else{for(_=B.length,R=S.length,g=0,L+=2,(N=r(l/(S[0]+1)))>1&&(S=e(S,N,l),B=e(B,N,l),R=S.length,_=B.length),A=R,v=(O=B.slice(0,R)).length;v<R;O[v++]=0);D=S.slice(),D=[0].concat(D),U=S[0],S[1]>=l/2&&U++;do{if(N=0,(a=t(S,O,R,v))<0){if(E=O[0],R!=v&&(E=E*l+(O[1]||0)),(N=r(E/U))>1)for(N>=l&&(N=l-1),w=(b=e(S,N,l)).length,v=O.length;1==t(b,O,w,v);)N--,n(b,R<w?D:S,w,l),w=b.length,a=1;else 0==N&&(a=N=1),w=(b=S.slice()).length;if(w<v&&(b=[0].concat(b)),n(O,b,v,l),v=O.length,-1==a)for(;t(S,O,R,v)<1;)N++,n(O,R<v?D:S,v,l),v=O.length}else 0===a&&(N++,O=[0]);y[g++]=N,O[0]?O[v++]=B[A]||0:(O=[B[A]],v=1)}while((A++<_||null!=O[0])&&L--);m=null!=O[0],y[0]||y.splice(0,1)}if(l==u){for(g=1,L=y[0];L>=10;L/=10,g++);z(d,f+(d.e=g+p*s-1)+1,c,m)}else d.e=p,d.r=+m;return d}}(),A=/^(-?)0([xbo])(?=\w[\w.]*$)/i,_=/^([^.]+)\.$/,U=/^\.([^.]+)$/,R=/^-?(Infinity|NaN)$/,D=/^\s*\+(?=[\w.])|^\s+|\s+$/g,v=function(e,t,n,r){var o,u=n?t:t.replace(D,"");if(R.test(u))e.s=isNaN(u)?null:u<0?-1:1;else{if(!n&&(u=u.replace(A,function(e,t,n){return o="x"==(n=n.toLowerCase())?16:"b"==n?2:8,r&&r!=o?e:t}),r&&(o=r,u=u.replace(_,"$1").replace(U,"0.$1")),t!=u))return new H(u,o);if(H.DEBUG)throw Error(i+"Not a"+(r?" base "+r:"")+" number: "+t);e.s=null}e.c=e.e=null},L.absoluteValue=L.abs=function(){var e=new H(this);return e.s<0&&(e.s=1),e},L.comparedTo=function(e,t){return g(this,new H(e,t))},L.decimalPlaces=L.dp=function(e,t){var n,r,i,o=this;if(null!=e)return m(e,0,a),null==t?t=F:m(t,0,8),z(new H(o),e+o.e+1,t);if(!(n=o.c))return null;if(r=((i=n.length-1)-h(this.e/s))*s,i=n[i])for(;i%10==0;i/=10,r--);return r<0&&(r=0),r},L.dividedBy=L.div=function(e,t){return y(this,new H(e,t),S,F)},L.dividedToIntegerBy=L.idiv=function(e,t){return y(this,new H(e,t),0,1)},L.exponentiatedBy=L.pow=function(e,t){var o,u,f,c,l,a,h,p,g=this;if((e=new H(e)).c&&!e.isInteger())throw Error(i+"Exponent not an integer: "+$(e));if(null!=t&&(t=new H(t)),l=e.e>14,!g.c||!g.c[0]||1==g.c[0]&&!g.e&&1==g.c.length||!e.c||!e.c[0])return p=new H(Math.pow(+$(g),l?2-N(e):+$(e))),t?p.mod(t):p;if(a=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new H(NaN);(u=!a&&g.isInteger()&&t.isInteger())&&(g=g.mod(t))}else{if(e.e>9&&(g.e>0||g.e<-1||(0==g.e?g.c[0]>1||l&&g.c[1]>=24e7:g.c[0]<8e13||l&&g.c[0]<=9999975e7)))return c=g.s<0&&N(e)?-0:0,g.e>-1&&(c=1/c),new H(a?1/c:c);G&&(c=n(G/s+2))}for(l?(o=new H(.5),a&&(e.s=1),h=N(e)):h=(f=Math.abs(+$(e)))%2,p=new H(B);;){if(h){if(!(p=p.times(g)).c)break;c?p.c.length>c&&(p.c.length=c):u&&(p=p.mod(t))}if(f){if(0===(f=r(f/2)))break;h=f%2}else if(z(e=e.times(o),e.e+1,1),e.e>14)h=N(e);else{if(0==(f=+$(e)))break;h=f%2}g=g.times(g),c?g.c&&g.c.length>c&&(g.c.length=c):u&&(g=g.mod(t))}return u?p:(a&&(p=B.div(p)),t?p.mod(t):c?z(p,G,F,void 0):p)},L.integerValue=function(e){var t=new H(this);return null==e?e=F:m(e,0,8),z(t,t.e+1,e)},L.isEqualTo=L.eq=function(e,t){return 0===g(this,new H(e,t))},L.isFinite=function(){return!!this.c},L.isGreaterThan=L.gt=function(e,t){return g(this,new H(e,t))>0},L.isGreaterThanOrEqualTo=L.gte=function(e,t){return 1===(t=g(this,new H(e,t)))||0===t},L.isInteger=function(){return!!this.c&&h(this.e/s)>this.c.length-2},L.isLessThan=L.lt=function(e,t){return g(this,new H(e,t))<0},L.isLessThanOrEqualTo=L.lte=function(e,t){return-1===(t=g(this,new H(e,t)))||0===t},L.isNaN=function(){return!this.s},L.isNegative=function(){return this.s<0},L.isPositive=function(){return this.s>0},L.isZero=function(){return!!this.c&&0==this.c[0]},L.minus=function(e,t){var n,r,i,o,f=this,c=f.s;if(t=(e=new H(e,t)).s,!c||!t)return new H(NaN);if(c!=t)return e.s=-t,f.plus(e);var l=f.e/s,a=e.e/s,p=f.c,g=e.c;if(!l||!a){if(!p||!g)return p?(e.s=-t,e):new H(g?f:NaN);if(!p[0]||!g[0])return g[0]?(e.s=-t,e):new H(p[0]?f:3==F?-0:0)}if(l=h(l),a=h(a),p=p.slice(),c=l-a){for((o=c<0)?(c=-c,i=p):(a=l,i=g),i.reverse(),t=c;t--;i.push(0));i.reverse()}else for(r=(o=(c=p.length)<(t=g.length))?c:t,c=t=0;t<r;t++)if(p[t]!=g[t]){o=p[t]<g[t];break}if(o&&(i=p,p=g,g=i,e.s=-e.s),(t=(r=g.length)-(n=p.length))>0)for(;t--;p[n++]=0);for(t=u-1;r>c;){if(p[--r]<g[r]){for(n=r;n&&!p[--n];p[n]=t);--p[n],p[r]+=u}p[r]-=g[r]}for(;0==p[0];p.splice(0,1),--a);return p[0]?k(e,p,a):(e.s=3==F?-1:1,e.c=[e.e=0],e)},L.modulo=L.mod=function(e,t){var n,r,i=this;return e=new H(e,t),!i.c||!e.s||e.c&&!e.c[0]?new H(NaN):!e.c||i.c&&!i.c[0]?new H(i):(9==C?(r=e.s,e.s=1,n=y(i,e,0,3),e.s=r,n.s*=r):n=y(i,e,0,C),(e=i.minus(n.times(e))).c[0]||1!=C||(e.s=i.s),e)},L.multipliedBy=L.times=function(e,t){var n,r,i,o,f,c,a,p,g,m,N,b,w,d,y,O=this,v=O.c,E=(e=new H(e,t)).c;if(!(v&&E&&v[0]&&E[0]))return!O.s||!e.s||v&&!v[0]&&!E||E&&!E[0]&&!v?e.c=e.e=e.s=null:(e.s*=O.s,v&&E?(e.c=[0],e.e=0):e.c=e.e=null),e;for(r=h(O.e/s)+h(e.e/s),e.s*=O.s,(a=v.length)<(m=E.length)&&(w=v,v=E,E=w,i=a,a=m,m=i),i=a+m,w=[];i--;w.push(0));for(d=u,y=l,i=m;--i>=0;){for(n=0,N=E[i]%y,b=E[i]/y|0,o=i+(f=a);o>i;)n=((p=N*(p=v[--f]%y)+(c=b*p+(g=v[f]/y|0)*N)%y*y+w[o]+n)/d|0)+(c/y|0)+b*g,w[o--]=p%d;w[o]=n}return n?++r:w.splice(0,1),k(e,w,r)},L.negated=function(){var e=new H(this);return e.s=-e.s||null,e},L.plus=function(e,t){var n,r=this,i=r.s;if(t=(e=new H(e,t)).s,!i||!t)return new H(NaN);if(i!=t)return e.s=-t,r.minus(e);var o=r.e/s,f=e.e/s,c=r.c,l=e.c;if(!o||!f){if(!c||!l)return new H(i/0);if(!c[0]||!l[0])return l[0]?e:new H(c[0]?r:0*i)}if(o=h(o),f=h(f),c=c.slice(),i=o-f){for(i>0?(f=o,n=l):(i=-i,n=c),n.reverse();i--;n.push(0));n.reverse()}for((i=c.length)-(t=l.length)<0&&(n=l,l=c,c=n,t=i),i=0;t;)i=(c[--t]=c[t]+l[t]+i)/u|0,c[t]=u===c[t]?0:c[t]%u;return i&&(c=[i].concat(c),++f),k(e,c,f)},L.precision=L.sd=function(e,t){var n,r,i,o=this;if(null!=e&&e!==!!e)return m(e,1,a),null==t?t=F:m(t,0,8),z(new H(o),e,t);if(!(n=o.c))return null;if(r=(i=n.length-1)*s+1,i=n[i]){for(;i%10==0;i/=10,r--);for(i=n[0];i>=10;i/=10,r++);}return e&&o.e+1>r&&(r=o.e+1),r},L.shiftedBy=function(e){return m(e,-f,f),this.times("1e"+e)},L.squareRoot=L.sqrt=function(){var e,t,n,r,i,o=this,u=o.c,s=o.s,f=o.e,c=S+4,l=new H("0.5");if(1!==s||!u||!u[0])return new H(!s||s<0&&(!u||u[0])?NaN:u?o:1/0);if(0==(s=Math.sqrt(+$(o)))||s==1/0?(((t=p(u)).length+f)%2==0&&(t+="0"),s=Math.sqrt(+t),f=h((f+1)/2)-(f<0||f%2),n=new H(t=s==1/0?"5e"+f:(t=s.toExponential()).slice(0,t.indexOf("e")+1)+f)):n=new H(s+""),n.c[0])for((s=(f=n.e)+c)<3&&(s=0);;)if(i=n,n=l.times(i.plus(y(o,i,c,1))),p(i.c).slice(0,s)===(t=p(n.c)).slice(0,s)){if(n.e<f&&--s,"9999"!=(t=t.slice(s-3,s+1))&&(r||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(z(n,n.e+S+2,1),e=!n.times(n).eq(o));break}if(!r&&(z(i,i.e+S+2,0),i.times(i).eq(o))){n=i;break}c+=4,s+=4,r=1}return z(n,n.e+S+1,F,e)},L.toExponential=function(e,t){return null!=e&&(m(e,0,a),e++),V(this,e,t,1)},L.toFixed=function(e,t){return null!=e&&(m(e,0,a),e=e+this.e+1),V(this,e,t)},L.toFormat=function(e,t,n){var r,o=this;if(null==n)null!=e&&t&&"object"==typeof t?(n=t,t=null):e&&"object"==typeof e?(n=e,e=t=null):n=j;else if("object"!=typeof n)throw Error(i+"Argument not an object: "+n);if(r=o.toFixed(e,t),o.c){var u,s=r.split("."),f=+n.groupSize,c=+n.secondaryGroupSize,l=n.groupSeparator||"",a=s[0],h=s[1],p=o.s<0,g=p?a.slice(1):a,m=g.length;if(c&&(u=f,f=c,c=u,m-=u),f>0&&m>0){for(u=m%f||f,a=g.substr(0,u);u<m;u+=f)a+=l+g.substr(u,f);c>0&&(a+=l+g.slice(u)),p&&(a="-"+a)}r=h?a+(n.decimalSeparator||"")+((c=+n.fractionGroupSize)?h.replace(new RegExp("\\d{"+c+"}\\B","g"),"$&"+(n.fractionGroupSeparator||"")):h):a}return(n.prefix||"")+r+(n.suffix||"")},L.toFraction=function(e){var t,n,r,o,u,f,l,a,h,g,m,N,b=this,w=b.c;if(null!=e&&(!(l=new H(e)).isInteger()&&(l.c||1!==l.s)||l.lt(B)))throw Error(i+"Argument "+(l.isInteger()?"out of range: ":"not an integer: ")+$(l));if(!w)return new H(b);for(t=new H(B),h=n=new H(B),r=a=new H(B),N=p(w),u=t.e=N.length-b.e-1,t.c[0]=c[(f=u%s)<0?s+f:f],e=!e||l.comparedTo(t)>0?u>0?t:h:l,f=P,P=1/0,l=new H(N),a.c[0]=0;g=y(l,t,0,1),1!=(o=n.plus(g.times(r))).comparedTo(e);)n=r,r=o,h=a.plus(g.times(o=h)),a=o,t=l.minus(g.times(o=t)),l=o;return o=y(e.minus(n),r,0,1),a=a.plus(o.times(h)),n=n.plus(o.times(r)),a.s=h.s=b.s,m=y(h,r,u*=2,F).minus(b).abs().comparedTo(y(a,n,u,F).minus(b).abs())<1?[h,r]:[a,n],P=f,m},L.toNumber=function(){return+$(this)},L.toPrecision=function(e,t){return null!=e&&m(e,1,a),V(this,e,t,2)},L.toString=function(e){var t,n=this,r=n.s,i=n.e;return null===i?r?(t="Infinity",r<0&&(t="-"+t)):t="NaN":(null==e?t=i<=I||i>=M?b(p(n.c),i):w(p(n.c),i,"0"):10===e?t=w(p((n=z(new H(n),S+i+1,F)).c),n.e,"0"):(m(e,2,q.length,"Base"),t=O(w(p(n.c),i,"0"),10,e,r,!0)),r<0&&n.c[0]&&(t="-"+t)),t},L.valueOf=L.toJSON=function(){return $(this)},L._isBigNumber=!0,L[Symbol.toStringTag]="BigNumber",L[Symbol.for("nodejs.util.inspect.custom")]=L.valueOf,null!=d&&H.set(d),H}(),y=function(){return(y=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)},O=function(){function e(){this.format=e.DEFAULT_FORMAT,d.config({FORMAT:this.format})}return e.prototype.set=function(e){"FORMAT"in e&&(this.format=y({},this.format,e.FORMAT),e.FORMAT=this.format),d.config(e)},e.DEFAULT_FORMAT={prefix:"",decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:" ",fractionGroupSize:0,suffix:""},e}();e.BigNumber=function(){function e(t){"object"==typeof t&&e.isBigNumber(t)?this.bn=t.bn.plus(0):this.bn=e.toBigNumberJs(t)}return e.prototype.clone=function(){return new e(this)},e.prototype.add=function(t){return new e(this.bn.plus(e.toBigNumberJs(t)))},e.prototype.sub=function(t){return new e(this.bn.minus(e.toBigNumberJs(t)))},e.prototype.mul=function(t){return new e(this.bn.times(e.toBigNumberJs(t)))},e.prototype.div=function(t){return new e(this.bn.div(e.toBigNumberJs(t)))},e.prototype.pow=function(t){return new e(this.bn.pow(e.toBigNumberJs(t)))},e.prototype.sqrt=function(){return new e(this.bn.sqrt())},e.prototype.abs=function(){return new e(this.bn.abs())},e.prototype.mod=function(t){return new e(this.bn.mod(e.toBigNumberJs(t)))},e.prototype.roundTo=function(t,n){return void 0===t&&(t=0),void 0===n&&(n=4),new e(this.bn.dp(t||0,n))},e.prototype.eq=function(t){return this.bn.eq(e.toBigNumberJs(t))},e.prototype.lt=function(t){return this.bn.lt(e.toBigNumberJs(t))},e.prototype.gt=function(t){return this.bn.gt(e.toBigNumberJs(t))},e.prototype.lte=function(t){return this.bn.lte(e.toBigNumberJs(t))},e.prototype.gte=function(t){return this.bn.gte(e.toBigNumberJs(t))},e.prototype.isNaN=function(){return this.bn.isNaN()},e.prototype.isFinite=function(){return this.bn.isFinite()},e.prototype.isZero=function(){return this.eq(0)},e.prototype.isPositive=function(){return this.gt(0)},e.prototype.isNegative=function(){return this.lt(0)},e.prototype.isInt=function(){return this.bn.isInteger()},e.prototype.getDecimalsCount=function(){return this.bn.dp()},e.prototype.isEven=function(){return this.mod(2).eq(0)},e.prototype.isOdd=function(){return!this.isEven()},e.prototype.isInSignedRange=function(){return this.gte(e.MIN_VALUE)&&this.lte(e.MAX_VALUE)},e.prototype.isInUnsignedRange=function(){return this.gte(e.MIN_UNSIGNED_VALUE)&&this.lte(e.MAX_UNSIGNED_VALUE)},e.prototype.toFormat=function(e,t,n){return this.bn.toFormat(e,t,n)},e.prototype.toFixed=function(e,t){return null==e?this.bn.toFixed():this.bn.toFixed(e,t)},e.prototype.toString=function(){return this.toFixed()},e.prototype.toNumber=function(){return this.bn.toNumber()},e.prototype.toJSON=function(){return this.bn.toFixed()},e.prototype.valueOf=function(){return this.bn.valueOf()},e.prototype.toBytes=function(t){var n=void 0===t?{}:t,r=n.isSigned,i=void 0===r||r,o=n.isLong,u=void 0===o||o;if(!this.isInt())throw new Error("Cant create bytes from number with decimals!");if(!i&&this.isNegative())throw new Error("Cant create bytes from negative number in signed mode!");if(u&&i&&!this.isInSignedRange())throw new Error("Number is not from signed numbers range");if(u&&!i&&!this.isInUnsignedRange())throw new Error("Number is not from unsigned numbers range");var s=i&&this.isNegative(),f=s?"1":"0",c=this.bn.plus(f).toString(2).replace("-",""),l=u?64:8*Math.ceil(c.length/8),a=e._toLength(l,c).split(""),h=[];do{h.push(parseInt(a.splice(0,8).join(""),2))}while(a.length);return s?Uint8Array.from(h.map(function(e){return 255-e})):Uint8Array.from(h)},e.fromBytes=function(t,n){var r=void 0===n?{}:n,i=r.isSigned,o=void 0===i||i,u=r.isLong,s=void 0===u||u;if(s&&8!==t.length)throw new Error("Wrong bytes length! Minimal length is 8 byte!");t=!s&&t.length>0||s?t:[0];var f=!!o&&t[0]>127,c=Array.from(t).map(function(e){return f?255-e:e}).map(function(t){return e._toLength(8,t.toString(2))}).join(""),l=new e(new d(c,2));return f?l.mul(-1).sub(1):l},e.max=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];return e.toBigNumber(t).reduce(function(e,t){return e.gte(t)?e:t})},e.min=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];return e.toBigNumber(t).reduce(function(e,t){return e.lte(t)?e:t})},e.sum=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];return e.toBigNumber(t).reduce(function(e,t){return e.add(t)})},e.isBigNumber=function(t){return t&&"object"==typeof t&&(t instanceof e||Object.entries(e.prototype).filter(function(e){return"_"!==e[0].charAt(0)}).every(function(e){var n=e[0],r=e[1];return n in t&&typeof r==typeof t[n]}))},e.toBigNumber=function(t){return Array.isArray(t)?t.map(function(t){return new e(t)}):new e(t)},e.toBigNumberJs=function(t){return d.isBigNumber(t)?t:t instanceof e?t.bn:new d(t)},e._toLength=function(e,t){return new Array(e).fill("0",0,e).concat(t.split("")).slice(-e).join("")},e.MIN_VALUE=new e("-9223372036854775808"),e.MAX_VALUE=new e("9223372036854775807"),e.MIN_UNSIGNED_VALUE=new e("0"),e.MAX_UNSIGNED_VALUE=new e("18446744073709551615"),e.config=new O,e}(),function(e){!function(e){e[e.ROUND_UP=0]="ROUND_UP",e[e.ROUND_DOWN=1]="ROUND_DOWN",e[e.ROUND_CEIL=2]="ROUND_CEIL",e[e.ROUND_FLOOR=3]="ROUND_FLOOR",e[e.ROUND_HALF_UP=4]="ROUND_HALF_UP",e[e.ROUND_HALF_DOWN=5]="ROUND_HALF_DOWN",e[e.ROUND_HALF_EVEN=6]="ROUND_HALF_EVEN",e[e.ROUND_HALF_CEIL=7]="ROUND_HALF_CEIL",e[e.ROUND_HALF_FLOOR=8]="ROUND_HALF_FLOOR"}(e.ROUND_MODE||(e.ROUND_MODE={}))}(e.BigNumber||(e.BigNumber={}));var v=e.BigNumber;e.default=v,Object.defineProperty(e,"__esModule",{value:!0})});


/***/ }),

/***/ "./node_modules/@waves/client-logs/dist/client-logs.min.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@waves/client-logs/dist/client-logs.min.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! exports used: makeConsole, makeOptions */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n():undefined}(this,(function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=0)}([function(e,n,t){"use strict";t.r(n);var r=["info","log","warn","error"],o={keepMessageCount:100,keepMessageTypes:["error"],logMessageTypes:["error"],namespace:void 0},s=function(e){return e.reduce((function(e,n){return e[n]=!0,e}),Object.create(null))},u=function(){function e(e){this._messages=[],this._maxLength=e}return e.prototype.push=function(e){this._messages.push(e),this._messages.length>this._maxLength&&this._messages.splice(0,this._messages.length-this._maxLength)},e.prototype.getMessages=function(e){var n,t,o=s(null!=(t=null===(n=e)||void 0===n?void 0:n.messageTypes)?t:r);return this._messages.filter((function(e){return o[e.type]}))},e}();function a(e){return e}t.d(n,"makeConsole",(function(){return p})),t.d(n,"version",(function(){return f})),t.d(n,"makeOptions",(function(){return l}));var i=function(){return(i=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++)for(var o in n=arguments[t])Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);return e}).apply(this,arguments)},c=function(){for(var e=0,n=0,t=arguments.length;n<t;n++)e+=arguments[n].length;var r=Array(e),o=0;for(n=0;n<t;n++)for(var s=arguments[n],u=0,a=s.length;u<a;u++,o++)r[o]=s[u];return r},p=function(e){var n=i(i({},o),null!=e?e:{}),t=new u(n.keepMessageCount),p=s(n.logMessageTypes),f=s(n.keepMessageTypes);return r.reduce((function(e,r){var o=null!=n.namespace?function(e){return c([n.namespace],e)}:a,s=p[r]?console[r]:a,u=f[r]?function(e){return t.push({type:r,args:e})}:a;return e[r]=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];var t=o(e);s.apply(void 0,t),u(t)},e}),{getMessages:function(e){return t.getMessages(e)}})},f="1.0.0";function l(e,n){switch(e){case"production":return i(i({},o),{keepMessageTypes:["error"],logMessageTypes:[],namespace:n});case"error":return i(i({},o),{keepMessageTypes:["warn","error"],logMessageTypes:["error"],namespace:n});case"verbose":return i(i({},o),{keepMessageTypes:[],logMessageTypes:r.slice(),namespace:n})}}n.default=p}])}));

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/api-node/addresses/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/api-node/addresses/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! exports used: fetchBalanceDetails */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAddresses = exports.fetchPublicKey = exports.fetchSeed = exports.fetchSeq = exports.fetchEffectiveBalance = exports.fetchEffectiveBalanceConfirmations = exports.fetchBalance = exports.fetchValidate = exports.data = exports.fetchScriptInfo = exports.fetchBalanceConfirmations = exports.fetchBalanceDetails = exports.fetchScriptInfoMeta = exports.fetchDataKey = void 0;
var request_1 = __importDefault(__webpack_require__(/*! ../../tools/request */ "./node_modules/@waves/node-api-js/cjs/tools/request.js"));
var query_1 = __importDefault(__webpack_require__(/*! ../../tools/query */ "./node_modules/@waves/node-api-js/cjs/tools/query.js"));
function fetchDataKey(base, address, key, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/data/" + address + "/" + encodeURIComponent(key),
        options: options
    });
}
exports.fetchDataKey = fetchDataKey;
function fetchScriptInfoMeta(base, address) {
    return request_1.default({
        base: base,
        url: "/addresses/scriptInfo/" + address + "/meta"
    });
}
exports.fetchScriptInfoMeta = fetchScriptInfoMeta;
function fetchBalanceDetails(base, address, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/balance/details/" + address,
        options: options
    });
}
exports.fetchBalanceDetails = fetchBalanceDetails;
function fetchBalanceConfirmations(base, address, confirmations, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/balance/" + address + "/" + confirmations,
        options: options
    });
}
exports.fetchBalanceConfirmations = fetchBalanceConfirmations;
function fetchScriptInfo(base, address, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/scriptInfo/" + address,
        options: options
    });
}
exports.fetchScriptInfo = fetchScriptInfo;
function data(base, address, params, options) {
    if (params === void 0) { params = Object.create(null); }
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/data/" + address + query_1.default(params),
        options: options
    });
}
exports.data = data;
function fetchValidate(base, address) {
    return request_1.default({
        base: base,
        url: "/addresses/validate/" + address
    });
}
exports.fetchValidate = fetchValidate;
function fetchBalance(base, address, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/balance/" + address,
        options: options
    });
}
exports.fetchBalance = fetchBalance;
function fetchEffectiveBalanceConfirmations(base, address, confirmations, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/effectiveBalance/" + address + "/" + confirmations,
        options: options
    });
}
exports.fetchEffectiveBalanceConfirmations = fetchEffectiveBalanceConfirmations;
function fetchEffectiveBalance(base, address, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/addresses/effectiveBalance/" + address,
        options: options
    });
}
exports.fetchEffectiveBalance = fetchEffectiveBalance;
function fetchSeq(base, from, to) {
    return request_1.default({
        base: base,
        url: "/addresses/seq/" + from + "/" + to
    });
}
exports.fetchSeq = fetchSeq;
function fetchSeed(base, address) {
    return request_1.default({
        base: base,
        url: "/addresses/seed/" + address
    });
}
exports.fetchSeed = fetchSeed;
function fetchPublicKey(base, publicKey) {
    return request_1.default({
        base: base,
        url: "/addresses/publicKey/" + publicKey
    });
}
exports.fetchPublicKey = fetchPublicKey;
function fetchAddresses(base) {
    return request_1.default({
        base: base,
        url: '/addresses'
    });
}
exports.fetchAddresses = fetchAddresses;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/api-node/assets/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/api-node/assets/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! exports used: fetchAssetsBalance */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchBalanceAddressAssetId = exports.fetchAssetsBalance = exports.fetchAssetsAddressLimit = exports.fetchAssetDistribution = exports.fetchAssetsDetails = exports.fetchDetails = void 0;
var ts_types_1 = __webpack_require__(/*! @waves/ts-types */ "./node_modules/@waves/ts-types/dist/src/index.js");
var request_1 = __importDefault(__webpack_require__(/*! ../../tools/request */ "./node_modules/@waves/node-api-js/cjs/tools/request.js"));
var utils_1 = __webpack_require__(/*! ../../tools/utils */ "./node_modules/@waves/node-api-js/cjs/tools/utils.js");
function fetchDetails(base, assetId, options) {
    if (options === void 0) { options = Object.create(null); }
    var isOnce = !Array.isArray(assetId);
    return Promise.all(utils_1.toArray(assetId).map(function (id) { return request_1.default({
        base: base,
        url: "/assets/details/" + id,
        options: options
    }); }))
        .then(function (list) { return isOnce ? list[0] : list; });
}
exports.fetchDetails = fetchDetails;
/**
 * GET /assets/details
 * Provides detailed information about the given assets
 */
function fetchAssetsDetails(base, assetIds, options) {
    if (options === void 0) { options = Object.create(null); }
    var params = assetIds
        .map(function (assetId) { return "id=" + assetId; })
        .join('&');
    var query = assetIds.length ? "?" + params : '';
    return request_1.default({ base: base, url: "/assets/details" + query, options: options });
}
exports.fetchAssetsDetails = fetchAssetsDetails;
function fetchAssetDistribution(base, assetId, height, limit, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({ base: base, url: "/assets/" + assetId + "/distribution/" + height + "/limit/" + limit, options: options });
}
exports.fetchAssetDistribution = fetchAssetDistribution;
/**
 * TODO
 * GET /assets/{assetId}/distribution
 * Asset balance distribution
 */
function fetchAssetsAddressLimit(base, address, limit, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({ base: base, url: "assets/nft/" + address + "/limit/" + limit, options: options });
}
exports.fetchAssetsAddressLimit = fetchAssetsAddressLimit;
function fetchAssetsBalance(base, address, options) {
    if (options === void 0) { options = Object.create(null); }
    return __awaiter(this, void 0, void 0, function () {
        var balancesResponse, assetsWithoutIssueTransaction, assetsDetailsResponse;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, request_1.default({ base: base, url: "/assets/balance/" + address, options: options })];
                case 1:
                    balancesResponse = _a.sent();
                    assetsWithoutIssueTransaction = balancesResponse.balances.reduce(function (acc, balance, index) {
                        if (!balance.issueTransaction) {
                            acc[balance.assetId] = index;
                        }
                        return acc;
                    }, {});
                    return [4 /*yield*/, fetchAssetsDetails(base, Object.keys(assetsWithoutIssueTransaction), options)];
                case 2:
                    assetsDetailsResponse = _a.sent();
                    assetsDetailsResponse.forEach(function (assetDetails) {
                        if ('error' in assetDetails) {
                            return;
                        }
                        var assetIndex = assetsWithoutIssueTransaction[assetDetails.assetId];
                        var assetBalance = balancesResponse.balances[assetIndex];
                        if (!assetBalance) {
                            return;
                        }
                        assetBalance.issueTransaction = {
                            id: assetDetails.originTransactionId,
                            name: assetDetails.name,
                            decimals: assetDetails.decimals,
                            description: assetDetails.description,
                            quantity: assetDetails.quantity,
                            reissuable: assetDetails.reissuable,
                            sender: assetDetails.issuer,
                            senderPublicKey: assetDetails.issuerPublicKey,
                            timestamp: assetDetails.issueTimestamp,
                            height: assetDetails.issueHeight,
                            script: assetDetails.scripted ? '-' : null,
                            proofs: [],
                            fee: Math.pow(10, 8),
                            feeAssetId: null,
                            version: 3,
                            type: ts_types_1.TRANSACTION_TYPE.ISSUE,
                            chainId: 0
                        };
                    });
                    return [2 /*return*/, balancesResponse];
            }
        });
    });
}
exports.fetchAssetsBalance = fetchAssetsBalance;
function fetchBalanceAddressAssetId(base, address, assetId, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({ base: base, url: "/assets/balance/" + address + "/" + assetId, options: options });
}
exports.fetchBalanceAddressAssetId = fetchBalanceAddressAssetId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/api-node/blocks/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/api-node/blocks/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchHeightByTimestamp = exports.fetchHeight = exports.fetchDelay = exports.fetchLast = exports.fetchBlocksByAddress = exports.fetchFirst = exports.fetchBlockById = exports.fetchSeq = exports.fetchBlockAt = exports.fetchHeadersById = exports.fetchHeadersAt = exports.fetchHeightById = exports.fetchHeadersLast = exports.fetchHeadersSeq = void 0;
var request_1 = __importDefault(__webpack_require__(/*! ../../tools/request */ "./node_modules/@waves/node-api-js/cjs/tools/request.js"));
/**
 * GET /blocks/headers/seq/{from}/{to}
 * Get block headers at specified heights
 * @param base
 * @param from
 * @param to
 */
function fetchHeadersSeq(base, from, to, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/headers/seq/" + from + "/" + to,
        options: options
    });
}
exports.fetchHeadersSeq = fetchHeadersSeq;
/**
 * GET /blocks/headers/last
 * Last block header
 * @param base
 */
function fetchHeadersLast(base, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/headers/last",
        options: options
    });
}
exports.fetchHeadersLast = fetchHeadersLast;
/**
 * GET /blocks/height/{id}
 * Height of a block by its id
 * @param base
 * @param id
 */
function fetchHeightById(base, id) {
    return request_1.default({
        base: base,
        url: "/blocks/height/" + id
    });
}
exports.fetchHeightById = fetchHeightById;
/**
 * GET /blocks/headers/at/{height}
 * Block header at height
 * @param base
 * @param height
 */
function fetchHeadersAt(base, height, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/headers/at/" + height,
        options: options
    });
}
exports.fetchHeadersAt = fetchHeadersAt;
/**
 * GET /blocks/headers/{id}
 * Get block at specified height
 * @param base
 * @param height
 */
function fetchHeadersById(base, id, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/headers/" + id,
        options: options
    });
}
exports.fetchHeadersById = fetchHeadersById;
/**
 * GET /blocks/at/{height}
 * Get block at specified height
 * @param base
 * @param height
 */
function fetchBlockAt(base, height, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/at/" + height,
        options: options
    });
}
exports.fetchBlockAt = fetchBlockAt;
/**
 * GET /blocks/seq/{from}/{to}
 * Block range
 * @param base
 * @param from
 * @param to
 */
function fetchSeq(base, from, to, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/seq/" + from + "/" + to,
        options: options
    });
}
exports.fetchSeq = fetchSeq;
/**
 * GET /blocks/{id}
 * Get block by its id
 * @param base
 * @param id
 */
function fetchBlockById(base, id, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/" + id,
        options: options
    });
}
exports.fetchBlockById = fetchBlockById;
/**
 * GET /blocks/first
 * Get genesis block
 * @param base
 */
function fetchFirst(base, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/first",
        options: options
    });
}
exports.fetchFirst = fetchFirst;
/**
 * /blocks/address/{address}/{from}/{to}
 * Get list of blocks generated by specified address
 * @param base
 * @param address
 * @param from
 * @param to
 */
function fetchBlocksByAddress(base, address, from, to, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/address/" + address + "/" + from + "/" + to,
        options: options
    });
}
exports.fetchBlocksByAddress = fetchBlocksByAddress;
/**
 * GET /blocks/last
 * Last block
 * @param base
 */
function fetchLast(base, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: '/blocks/last',
        options: options
    });
}
exports.fetchLast = fetchLast;
/**
 * GET /blocks/delay/{id}/{blockNum}
 * Average delay in milliseconds between last blockNum blocks starting from block with id
 * @param base
 * @param id
 * @param blockNum
 */
function fetchDelay(base, id, blockNum) {
    return request_1.default({
        base: base,
        url: "/blocks/delay/" + id + "/" + blockNum
    });
}
exports.fetchDelay = fetchDelay;
/**
 * GET /blocks/height
 * @param base
 */
function fetchHeight(base) {
    return request_1.default({
        base: base,
        url: '/blocks/height'
    });
}
exports.fetchHeight = fetchHeight;
/**
 * GET /blocks/heightByTimestamp
 * @param base
 */
function fetchHeightByTimestamp(base, timestamp, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/blocks/heightByTimestamp/" + timestamp,
        options: options
    });
}
exports.fetchHeightByTimestamp = fetchHeightByTimestamp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/api-node/transactions/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/api-node/transactions/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadcast = exports.fetchStatus = exports.fetchInfo = exports.fetchUnconfirmedInfo = exports.fetchTransactions = exports.fetchUnconfirmed = exports.fetchCalculateFee = exports.fetchUnconfirmedSize = void 0;
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/@waves/node-api-js/cjs/constants.js");
var blocks_1 = __webpack_require__(/*! ../blocks */ "./node_modules/@waves/node-api-js/cjs/api-node/blocks/index.js");
var request_1 = __importDefault(__webpack_require__(/*! ../../tools/request */ "./node_modules/@waves/node-api-js/cjs/tools/request.js"));
var query_1 = __importDefault(__webpack_require__(/*! ../../tools/query */ "./node_modules/@waves/node-api-js/cjs/tools/query.js"));
var utils_1 = __webpack_require__(/*! ../../tools/utils */ "./node_modules/@waves/node-api-js/cjs/tools/utils.js");
var stringify_1 = __importDefault(__webpack_require__(/*! ../../tools/stringify */ "./node_modules/@waves/node-api-js/cjs/tools/stringify.js"));
var transactions_1 = __webpack_require__(/*! ../../tools/transactions/transactions */ "./node_modules/@waves/node-api-js/cjs/tools/transactions/transactions.js");
/**
 * GET /transactions/unconfirmed/size
 * Number of unconfirmed transactions
 */
function fetchUnconfirmedSize(base) {
    return request_1.default({
        base: base,
        url: '/transactions/unconfirmed/size'
    });
}
exports.fetchUnconfirmedSize = fetchUnconfirmedSize;
// @TODO: when correct API key is received
/**
 * POST /transactions/sign/{signerAddress}
 * Sign a transaction with a non-default private key
 */
/**
 * POST /transactions/calculateFee
 * Calculate transaction fee
 */
function fetchCalculateFee(base, tx, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: '/transactions/calculateFee',
        options: utils_1.deepAssign(__assign({}, options), {
            method: 'POST',
            body: stringify_1.default(tx),
            headers: {
                'Content-Type': 'application/json'
            }
        })
    });
}
exports.fetchCalculateFee = fetchCalculateFee;
/**
 * GET /transactions/unconfirmed
 * Unconfirmed transactions
 */
function fetchUnconfirmed(base, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: '/transactions/unconfirmed',
        options: options
    });
}
exports.fetchUnconfirmed = fetchUnconfirmed;
/**
 * Список транзакций по адресу
 * @param address
 * @param limit      максимальное количество транзакций в результате
 * @param after      искать транзакции после ID указанного в after
 * @param retry      количество попыток на выполнение запроса
 */
function fetchTransactions(base, address, limit, after, retry, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/transactions/address/" + address + "/limit/" + limit + query_1.default({ after: after }),
        options: options
    }).then(function (_a) {
        var list = _a[0];
        list.forEach(function (transaction) { return transactions_1.addStateUpdateField(transaction); });
        return list;
    });
}
exports.fetchTransactions = fetchTransactions;
/**
 * GET /transactions/unconfirmed/info/{id}
 * Unconfirmed transaction info
 */
function fetchUnconfirmedInfo(base, id, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/transactions/unconfirmed/info/" + id,
        options: options
    });
}
exports.fetchUnconfirmedInfo = fetchUnconfirmedInfo;
// @TODO when correct API key is received
/**
 * POST /transactions/sign
 * Sign a transaction
 */
/**
 * GET /transactions/info/{id}
 * Transaction info
 */
function fetchInfo(base, id, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: "/transactions/info/" + id,
        options: options
    }).then(function (transaction) { return transactions_1.addStateUpdateField(transaction); });
}
exports.fetchInfo = fetchInfo;
function fetchStatus(base, list) {
    var DEFAULT_STATUS = {
        id: '',
        confirmations: -1,
        height: -1,
        inUTX: false,
        status: constants_1.TRANSACTION_STATUSES.NOT_FOUND
    };
    var loadAllTxInfo = list.map(function (id) {
        return fetchUnconfirmedInfo(base, id)
            .then(function () { return (__assign(__assign({}, DEFAULT_STATUS), { id: id, status: constants_1.TRANSACTION_STATUSES.UNCONFIRMED, inUTX: true })); })
            .catch(function () { return fetchInfo(base, id)
            .then(function (tx) { return (__assign(__assign({}, DEFAULT_STATUS), { id: id, status: constants_1.TRANSACTION_STATUSES.IN_BLOCKCHAIN, height: tx.height, applicationStatus: tx.applicationStatus })); }); })
            .catch(function () { return (__assign(__assign({}, DEFAULT_STATUS), { id: id })); });
    });
    return Promise.all([
        blocks_1.fetchHeight(base),
        Promise.all(loadAllTxInfo)
    ]).then(function (_a) {
        var height = _a[0].height, statuses = _a[1];
        return ({
            height: height,
            statuses: statuses.map(function (item) { return (__assign(__assign({}, item), { confirmations: item.status === constants_1.TRANSACTION_STATUSES.IN_BLOCKCHAIN ? height - item.height : item.confirmations })); })
        });
    });
}
exports.fetchStatus = fetchStatus;
function broadcast(base, tx, options) {
    if (options === void 0) { options = Object.create(null); }
    return request_1.default({
        base: base,
        url: '/transactions/broadcast',
        options: utils_1.deepAssign(__assign({}, options), {
            method: 'POST',
            body: stringify_1.default(tx),
            headers: {
                'Content-Type': 'application/json'
            }
        })
    });
}
exports.broadcast = broadcast;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/constants.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TRANSACTION_STATUSES = exports.NAME_MAP = exports.TYPE_MAP = void 0;
exports.TYPE_MAP = {
    3: 'issue',
    4: 'transfer',
    5: 'reissue',
    6: 'burn',
    7: 'exchange',
    8: 'lease',
    9: 'cancelLease',
    10: 'alias',
    11: 'massTransfer',
    12: 'data',
    13: 'setScript',
    14: 'sponsorship',
    15: 'setAssetScript',
    16: 'invoke',
    17: 'updateAsset'
};
exports.NAME_MAP = {
    'issue': 3,
    'transfer': 4,
    'reissue': 5,
    'burn': 6,
    'exchange': 7,
    'lease': 8,
    'cancelLease': 9,
    'alias': 10,
    'massTransfer': 11,
    'data': 12,
    'setScript': 13,
    'sponsorship': 14,
    'setAssetScript': 15,
    'invoke': 16,
    'updateAsset': 17
};
exports.TRANSACTION_STATUSES = {
    IN_BLOCKCHAIN: 'in_blockchain',
    UNCONFIRMED: 'unconfirmed',
    NOT_FOUND: 'not_found'
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/blocks/getNetworkByte.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/blocks/getNetworkByte.js ***!
  \****************************************************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var blocks_1 = __webpack_require__(/*! ../../api-node/blocks */ "./node_modules/@waves/node-api-js/cjs/api-node/blocks/index.js");
function default_1(base) {
    return blocks_1.fetchHeadersLast(base).then(function (header) { return base58Decode(header.generator)[1]; });
}
exports.default = default_1;
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var ALPHABET_MAP = {};
for (var i = 0; i < ALPHABET.length; i++) {
    ALPHABET_MAP[ALPHABET.charAt(i)] = i;
}
function base58Decode(string) {
    var bytes, c, carry, j, i;
    if (string.length === 0) {
        return new Uint8Array(0);
    }
    i = void 0;
    j = void 0;
    bytes = [0];
    i = 0;
    while (i < string.length) {
        c = string[i];
        if (!(c in ALPHABET_MAP)) {
            throw 'Base58.decode received unacceptable input. Character \'' + c + '\' is not in the Base58 alphabet.';
        }
        j = 0;
        while (j < bytes.length) {
            bytes[j] *= 58;
            j++;
        }
        bytes[0] += ALPHABET_MAP[c];
        carry = 0;
        j = 0;
        while (j < bytes.length) {
            bytes[j] += carry;
            carry = bytes[j] >> 8;
            bytes[j] &= 0xff;
            ++j;
        }
        while (carry) {
            bytes.push(carry & 0xff);
            carry >>= 8;
        }
        i++;
    }
    i = 0;
    while (string[i] === '1' && i < string.length - 1) {
        bytes.push(0);
        i++;
    }
    return new Uint8Array(bytes.reverse());
}
//# sourceMappingURL=getNetworkByte.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/parse.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var reg = new RegExp('((?!\\\\)"\\w+"):\\s*(-?[\\d|\\.]{14,})', 'g');
function default_1(json) {
    return JSON.parse(json.replace(reg, "$1:\"$2\""));
}
exports.default = default_1;
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/query.js":
/*!************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/query.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function default_1(params, evolver) {
    if (evolver === void 0) { evolver = Object.create(null); }
    var query = Object.keys(params)
        .map(function (key) { return [key, params[key]]; })
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return [key, Object.prototype.hasOwnProperty.call(evolver, key) ? evolver[key](value) : value];
    })
        .filter(function (_a) {
        var key = _a[0], value = _a[1];
        return value != null;
    })
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return key + "=" + value;
    })
        .join('&');
    return query.length ? "?" + query : '';
}
exports.default = default_1;
;
//# sourceMappingURL=query.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/request.js":
/*!**************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/request.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var resolve_1 = __importDefault(__webpack_require__(/*! ./resolve */ "./node_modules/@waves/node-api-js/cjs/tools/resolve.js"));
var parse_1 = __importDefault(__webpack_require__(/*! ./parse */ "./node_modules/@waves/node-api-js/cjs/tools/parse.js"));
var request = typeof fetch === 'function' ? fetch : __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
function default_1(params) {
    return request(resolve_1.default(params.url, params.base), updateHeaders(params.options))
        .then(parseResponse);
}
exports.default = default_1;
function parseResponse(r) {
    return r.text().then(function (message) { return r.ok ? parse_1.default(message) : Promise.reject(tryParse(message)); });
}
function tryParse(message) {
    try {
        return JSON.parse(message);
    }
    catch (e) {
        return message;
    }
}
function updateHeaders(options) {
    if (options === void 0) { options = Object.create(null); }
    return __assign({ credentials: 'include' }, options);
}
//# sourceMappingURL=request.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/resolve.js":
/*!**************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/resolve.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function default_1(path, base) {
    return new URL(path, base).toString();
}
exports.default = default_1;
//# sourceMappingURL=resolve.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/stringify.js":
/*!****************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/stringify.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FIELDS = ['amount', 'matcherFee', 'price', 'fee', 'minSponsoredAssetFee', 'quantity', 'sellMatcherFee', 'buyMatcherFee'];
function default_1(data) {
    return JSON.stringify(data, function (key, value) {
        if (FIELDS.includes(key)) {
            return "!" + value + "!";
        }
        else if (key === 'value' && this['type'] === 'integer') {
            return "!" + value + "!";
        }
        else {
            return value;
        }
    }, 0).replace(/"\!(-?\d+)\!"/g, '$1');
}
exports.default = default_1;
//# sourceMappingURL=stringify.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/transactions/broadcast.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/transactions/broadcast.js ***!
  \*****************************************************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var transactions_1 = __webpack_require__(/*! ../../api-node/transactions */ "./node_modules/@waves/node-api-js/cjs/api-node/transactions/index.js");
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@waves/node-api-js/cjs/tools/utils.js");
var wait_1 = __importDefault(__webpack_require__(/*! ./wait */ "./node_modules/@waves/node-api-js/cjs/tools/transactions/wait.js"));
var DEFAULT_BROADCAST_OPTIONS = {
    chain: false,
    confirmations: -1,
    maxWaitTime: 0,
    requestInterval: 0
};
function default_1(base, list, options) {
    var opt = __assign(__assign({}, DEFAULT_BROADCAST_OPTIONS), (options || {}));
    var isOnce = !Array.isArray(list);
    var confirmations = opt.confirmations > 0 ? 1 : 0;
    return (opt.chain
        ? chainBroadcast(base, utils_1.toArray(list), __assign(__assign({}, opt), { confirmations: confirmations }))
        : simpleBroadcast(base, utils_1.toArray(list)))
        .then(function (list) { return opt.confirmations <= 0 ? list : wait_1.default(base, list, opt); })
        .then(function (list) { return isOnce ? utils_1.head(list) : list; });
}
exports.default = default_1;
function simpleBroadcast(base, list) {
    return Promise.all(list.map(function (tx) { return transactions_1.broadcast(base, tx); }));
}
function chainBroadcast(base, list, options) {
    return new Promise(function (resolve, reject) {
        var toBroadcast = list.slice().reverse();
        var result = [];
        var loop = function () {
            if (!toBroadcast.length) {
                resolve(result);
                return null;
            }
            var tx = toBroadcast.pop();
            transactions_1.broadcast(base, tx)
                .then(function (tx) { return wait_1.default(base, tx, options); })
                .then(function (tx) {
                result.push(tx);
                loop();
            }, reject);
        };
        loop();
    });
}
//# sourceMappingURL=broadcast.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/transactions/transactions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/transactions/transactions.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeStateUpdate = exports.addStateUpdateField = void 0;
var bignumber_1 = __webpack_require__(/*! @waves/bignumber */ "./node_modules/@waves/bignumber/dist/bignumber.umd.min.js");
var ts_types_1 = __webpack_require__(/*! @waves/ts-types */ "./node_modules/@waves/ts-types/dist/src/index.js");
function addStateUpdateField(transaction) {
    if (transaction.type === ts_types_1.TRANSACTION_TYPE.INVOKE_SCRIPT && transaction.stateChanges.invokes && transaction.stateChanges.invokes.length) {
        var payments_1 = transaction.payment ? transaction.payment.map(function (p) { return ({
            assetId: p.assetId,
            amount: p.amount
        }); }) : [];
        return Object.defineProperty(transaction, 'stateUpdate', { get: function () { return makeStateUpdate(transaction.stateChanges, payments_1, transaction.dApp, transaction.sender); } });
    }
    else
        return transaction;
}
exports.addStateUpdateField = addStateUpdateField;
function makeStateUpdate(stateChanges, payment, dApp, sender) {
    var payments = payment.map(function (payment) { return ({ payment: payment, dApp: dApp, sender: sender }); });
    var addField = function (array, fieldName) { return array.map(function (item) {
        var _a;
        return (__assign(__assign({}, item), (_a = {}, _a[fieldName] = dApp, _a)));
    }); };
    var transfers = addField(stateChanges.transfers, 'sender');
    var leases = addField(stateChanges.leases, 'sender');
    var issues = addField(stateChanges.issues, 'address');
    var data = addField(stateChanges.data, 'address');
    var reissues = addField(stateChanges.reissues, 'address');
    var burns = addField(stateChanges.burns, 'address');
    var sponsorFees = addField(stateChanges.sponsorFees, 'address');
    var leaseCancels = addField(stateChanges.leaseCancels, 'address');
    var stateUpdate = {
        payments: payments,
        data: data,
        transfers: transfers,
        reissues: reissues,
        issues: issues,
        burns: burns,
        sponsorFees: sponsorFees,
        leases: leases,
        leaseCancels: leaseCancels,
    };
    var recursiveFunction = function (stateChanges, sender) {
        if (stateChanges.invokes.length) {
            stateChanges.invokes.forEach(function (x) {
                //payments
                if (x.payment)
                    x.payment.forEach(function (y) {
                        var index = payments.findIndex(function (z) { return (z.payment.assetId === y.assetId) && (z.dApp === x.dApp) && (sender === x.dApp); });
                        index !== -1
                            ? payments[index].payment.amount = (new bignumber_1.BigNumber(payments[index].payment.amount)).add(y.amount).toNumber()
                            : payments.push({
                                payment: y,
                                sender: sender,
                                dApp: x.dApp
                            });
                    });
                //data
                x.stateChanges.data.forEach(function (y) {
                    var index = stateUpdate.data.findIndex(function (z) { return z.key === y.key && z.address === x.dApp; });
                    index !== -1 ? stateUpdate.data[index] = __assign(__assign({}, y), { address: x.dApp }) : stateUpdate.data.push(__assign(__assign({}, y), { address: x.dApp }));
                });
                //burns
                x.stateChanges.burns.forEach(function (y) {
                    var index = stateUpdate.burns.findIndex(function (z) { return z.assetId === y.assetId; });
                    index !== -1 ? stateUpdate.burns[index].quantity += y.quantity : stateUpdate.burns.push(__assign(__assign({}, y), { address: x.dApp }));
                });
                //issues
                x.stateChanges.issues.forEach(function (y) { return stateUpdate.issues.push(__assign(__assign({}, y), { address: x.dApp })); });
                //reissues
                x.stateChanges.reissues.forEach(function (y) {
                    var index = stateUpdate.reissues.findIndex(function (z) { return z.assetId === y.assetId; });
                    index !== -1 ? stateUpdate.reissues[index].quantity += y.quantity : stateUpdate.reissues.push(__assign(__assign({}, y), { address: x.dApp }));
                });
                //transfers
                x.stateChanges.transfers.forEach(function (y) {
                    var index = stateUpdate.transfers.findIndex(function (z) { return (z.asset === y.asset) && (z.address === y.address) && (x.dApp === z.sender); });
                    index !== -1
                        ? stateUpdate.transfers[index].amount = (new bignumber_1.BigNumber(stateUpdate.transfers[index].amount)).add(y.amount).toNumber()
                        : stateUpdate.transfers.push(__assign(__assign({}, y), { sender: x.dApp }));
                });
                //sponsorFees
                x.stateChanges.sponsorFees.forEach(function (y) {
                    var index = stateUpdate.sponsorFees.findIndex(function (z) { return (z.assetId === y.assetId) && (z.address === x.dApp); });
                    index !== -1
                        ? stateUpdate.sponsorFees[index] = __assign(__assign({}, y), { address: x.dApp })
                        : stateUpdate.sponsorFees.push(__assign(__assign({}, y), { address: x.dApp }));
                });
                //lease and leaseCancels
                x.stateChanges.leases.forEach(function (y) { return stateUpdate.leases.push(__assign(__assign({}, y), { sender: x.dApp })); });
                x.stateChanges.leaseCancels.forEach(function (y) { return stateUpdate.leaseCancels.push(__assign(__assign({}, y), { address: x.dApp })); });
                recursiveFunction(x.stateChanges, x.dApp);
            });
        }
    };
    recursiveFunction(stateChanges, sender);
    return stateUpdate;
}
exports.makeStateUpdate = makeStateUpdate;
//# sourceMappingURL=transactions.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/transactions/wait.js":
/*!************************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/transactions/wait.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@waves/node-api-js/cjs/tools/utils.js");
var transactions_1 = __webpack_require__(/*! ../../api-node/transactions */ "./node_modules/@waves/node-api-js/cjs/api-node/transactions/index.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/@waves/node-api-js/cjs/constants.js");
function default_1(base, tx, options) {
    var isOnce = !Array.isArray(tx);
    var start = Date.now();
    var confirmed = [];
    var confirmations = options && options.confirmations || 0;
    var maxWaitTime = options && options.maxWaitTime || 0;
    var requestInterval = options && options.requestInterval || 250;
    var waitTx = function (list) {
        return transactions_1.fetchStatus(base, list.map(utils_1.prop('id')))
            .then(function (status) {
            var hash = utils_1.indexBy(utils_1.prop('id'), status.statuses);
            var hasError = list.some(function (tx) { return hash[tx.id].status === constants_1.TRANSACTION_STATUSES.NOT_FOUND; });
            if (hasError) {
                throw new Error('One transaction is not in blockchain!');
            }
            var toRequest = list.filter(function (tx) {
                if (hash[tx.id].confirmations >= confirmations) {
                    confirmed.push(tx);
                    return false;
                }
                else {
                    return true;
                }
            });
            if (!toRequest.length) {
                return void 0;
            }
            if (maxWaitTime && Date.now() - start > maxWaitTime) {
                return Promise.reject('Timeout error!');
            }
            return utils_1.wait(requestInterval).then(function () { return waitTx(toRequest); });
        });
    };
    return waitTx(utils_1.toArray(tx)).then(function () { return isOnce ? utils_1.head(confirmed) : confirmed; });
}
exports.default = default_1;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/@waves/node-api-js/cjs/tools/utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@waves/node-api-js/cjs/tools/utils.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.pipe = exports.switchTransactionByType = exports.uniq = exports.indexBy = exports.filter = exports.map = exports.deepAssign = exports.assign = exports.values = exports.entries = exports.keys = exports.prop = exports.wait = exports.head = exports.toArray = exports.isObject = void 0;
function isObject(obj) {
    if (typeof obj === "object" && obj !== null) {
        if (typeof Object.getPrototypeOf === "function") {
            var prototype = Object.getPrototypeOf(obj);
            return prototype === Object.prototype || prototype === null;
        }
        return Object.prototype.toString.call(obj) === "[object Object]";
    }
    return false;
}
exports.isObject = isObject;
function toArray(data) {
    return Array.isArray(data) ? data : [data];
}
exports.toArray = toArray;
function head(data) {
    return data[0];
}
exports.head = head;
function wait(time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
}
exports.wait = wait;
function prop(key) {
    return function (data) { return data[key]; };
}
exports.prop = prop;
exports.keys = function (obj) {
    return Object.keys(obj);
};
exports.entries = function (obj) {
    return exports.keys(obj).map(function (name) { return [name, obj[name]]; });
};
exports.values = function (obj) {
    return exports.keys(obj).map(function (key) { return obj[key]; });
};
exports.assign = function (target, merge) {
    return exports.entries(merge).reduce(function (acc, _a) {
        var key = _a[0], value = _a[1];
        target[key] = value;
        return target;
    }, target);
};
exports.deepAssign = function () {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    return objects.reduce(function (target, merge) {
        exports.keys(merge).forEach(function (key) {
            if (Array.isArray(target[key]) && Array.isArray(merge[key])) {
                target[key] = Array.from(new Set(target[key].concat(merge[key])));
            }
            else if (isObject(target[key]) && isObject(merge[key])) {
                target[key] = exports.deepAssign(target[key], merge[key]);
            }
            else {
                target[key] = merge[key];
            }
        });
        return target;
    }, objects[0] || {});
};
function map(process) {
    return function (list) { return list.map(process); };
}
exports.map = map;
function filter(process) {
    return function (list) { return list.filter(process); };
}
exports.filter = filter;
function indexBy(process, data) {
    return data.reduce(function (acc, item) {
        acc[process(item)] = item;
        return acc;
    }, {});
}
exports.indexBy = indexBy;
exports.uniq = function (list) {
    return exports.keys(list.reduce(function (acc, item) {
        if (item != null)
            acc[item] = item;
        return acc;
    }, Object.create(null)));
};
function switchTransactionByType(choices) {
    return function (tx) { return choices[tx.type] && typeof choices[tx.type] === 'function' ? choices[tx.type](tx) : undefined; };
}
exports.switchTransactionByType = switchTransactionByType;
exports.pipe = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (data) { return args.reduce(function (acc, item) { return item(acc); }, data); };
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@waves/provider-seed/dist/provider-seed.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@waves/provider-seed/dist/provider-seed.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! exports used: ProviderSeed */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():undefined}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=82)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TRANSACTION_TYPE={ISSUE:3,TRANSFER:4,REISSUE:5,BURN:6,EXCHANGE:7,LEASE:8,CANCEL_LEASE:9,ALIAS:10,MASS_TRANSFER:11,DATA:12,SET_SCRIPT:13,SPONSORSHIP:14,SET_ASSET_SCRIPT:15,INVOKE_SCRIPT:16},t.DATA_FIELD_TYPE={INTEGER:"integer",BOOLEAN:"boolean",BINARY:"binary",STRING:"string"}},function(e,t){e.exports={options:{usePureJavaScript:!1}}},function(e,t,r){(function(t,n,i,a){var s=r(1),o=r(89),u=e.exports=s.util=s.util||{};function c(e){if(8!==e&&16!==e&&24!==e&&32!==e)throw new Error("Only 8, 16, 24, or 32 bits supported: "+e)}function l(e){if(this.data="",this.read=0,"string"==typeof e)this.data=e;else if(u.isArrayBuffer(e)||u.isArrayBufferView(e))if(void 0!==a&&e instanceof a)this.data=e.toString("binary");else{var t=new Uint8Array(e);try{this.data=String.fromCharCode.apply(null,t)}catch(e){for(var r=0;r<t.length;++r)this.putByte(t[r])}}else(e instanceof l||"object"==typeof e&&"string"==typeof e.data&&"number"==typeof e.read)&&(this.data=e.data,this.read=e.read);this._constructedStringLength=0}!function(){if(void 0!==t&&t.nextTick&&!t.browser)return u.nextTick=t.nextTick,void(u.setImmediate="function"==typeof n?n:u.nextTick);if("function"==typeof n)return u.setImmediate=function(){return n.apply(void 0,arguments)},void(u.nextTick=function(e){return n(e)});if(u.setImmediate=function(e){setTimeout(e,0)},"undefined"!=typeof window&&"function"==typeof window.postMessage){var e="forge.setImmediate",r=[];u.setImmediate=function(t){r.push(t),1===r.length&&window.postMessage(e,"*")},window.addEventListener("message",(function(t){if(t.source===window&&t.data===e){t.stopPropagation();var n=r.slice();r.length=0,n.forEach((function(e){e()}))}}),!0)}if("undefined"!=typeof MutationObserver){var i=Date.now(),a=!0,s=document.createElement("div");r=[];new MutationObserver((function(){var e=r.slice();r.length=0,e.forEach((function(e){e()}))})).observe(s,{attributes:!0});var o=u.setImmediate;u.setImmediate=function(e){Date.now()-i>15?(i=Date.now(),o(e)):(r.push(e),1===r.length&&s.setAttribute("a",a=!a))}}u.nextTick=u.setImmediate}(),u.isNodejs=void 0!==t&&t.versions&&t.versions.node,u.globalScope=u.isNodejs?i:"undefined"==typeof self?window:self,u.isArray=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},u.isArrayBuffer=function(e){return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer},u.isArrayBufferView=function(e){return e&&u.isArrayBuffer(e.buffer)&&void 0!==e.byteLength},u.ByteBuffer=l,u.ByteStringBuffer=l;u.ByteStringBuffer.prototype._optimizeConstructedString=function(e){this._constructedStringLength+=e,this._constructedStringLength>4096&&(this.data.substr(0,1),this._constructedStringLength=0)},u.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read},u.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0},u.ByteStringBuffer.prototype.putByte=function(e){return this.putBytes(String.fromCharCode(e))},u.ByteStringBuffer.prototype.fillWithByte=function(e,t){e=String.fromCharCode(e);for(var r=this.data;t>0;)1&t&&(r+=e),(t>>>=1)>0&&(e+=e);return this.data=r,this._optimizeConstructedString(t),this},u.ByteStringBuffer.prototype.putBytes=function(e){return this.data+=e,this._optimizeConstructedString(e.length),this},u.ByteStringBuffer.prototype.putString=function(e){return this.putBytes(u.encodeUtf8(e))},u.ByteStringBuffer.prototype.putInt16=function(e){return this.putBytes(String.fromCharCode(e>>8&255)+String.fromCharCode(255&e))},u.ByteStringBuffer.prototype.putInt24=function(e){return this.putBytes(String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(255&e))},u.ByteStringBuffer.prototype.putInt32=function(e){return this.putBytes(String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(255&e))},u.ByteStringBuffer.prototype.putInt16Le=function(e){return this.putBytes(String.fromCharCode(255&e)+String.fromCharCode(e>>8&255))},u.ByteStringBuffer.prototype.putInt24Le=function(e){return this.putBytes(String.fromCharCode(255&e)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255))},u.ByteStringBuffer.prototype.putInt32Le=function(e){return this.putBytes(String.fromCharCode(255&e)+String.fromCharCode(e>>8&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>24&255))},u.ByteStringBuffer.prototype.putInt=function(e,t){c(t);var r="";do{t-=8,r+=String.fromCharCode(e>>t&255)}while(t>0);return this.putBytes(r)},u.ByteStringBuffer.prototype.putSignedInt=function(e,t){return e<0&&(e+=2<<t-1),this.putInt(e,t)},u.ByteStringBuffer.prototype.putBuffer=function(e){return this.putBytes(e.getBytes())},u.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)},u.ByteStringBuffer.prototype.getInt16=function(){var e=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,e},u.ByteStringBuffer.prototype.getInt24=function(){var e=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,e},u.ByteStringBuffer.prototype.getInt32=function(){var e=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,e},u.ByteStringBuffer.prototype.getInt16Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,e},u.ByteStringBuffer.prototype.getInt24Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,e},u.ByteStringBuffer.prototype.getInt32Le=function(){var e=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,e},u.ByteStringBuffer.prototype.getInt=function(e){c(e);var t=0;do{t=(t<<8)+this.data.charCodeAt(this.read++),e-=8}while(e>0);return t},u.ByteStringBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),r=2<<e-2;return t>=r&&(t-=r<<1),t},u.ByteStringBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):0===e?t="":(t=0===this.read?this.data:this.data.slice(this.read),this.clear()),t},u.ByteStringBuffer.prototype.bytes=function(e){return void 0===e?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},u.ByteStringBuffer.prototype.at=function(e){return this.data.charCodeAt(this.read+e)},u.ByteStringBuffer.prototype.setAt=function(e,t){return this.data=this.data.substr(0,this.read+e)+String.fromCharCode(t)+this.data.substr(this.read+e+1),this},u.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)},u.ByteStringBuffer.prototype.copy=function(){var e=u.createBuffer(this.data);return e.read=this.read,e},u.ByteStringBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this},u.ByteStringBuffer.prototype.clear=function(){return this.data="",this.read=0,this},u.ByteStringBuffer.prototype.truncate=function(e){var t=Math.max(0,this.length()-e);return this.data=this.data.substr(this.read,t),this.read=0,this},u.ByteStringBuffer.prototype.toHex=function(){for(var e="",t=this.read;t<this.data.length;++t){var r=this.data.charCodeAt(t);r<16&&(e+="0"),e+=r.toString(16)}return e},u.ByteStringBuffer.prototype.toString=function(){return u.decodeUtf8(this.bytes())},u.DataBuffer=function(e,t){t=t||{},this.read=t.readOffset||0,this.growSize=t.growSize||1024;var r=u.isArrayBuffer(e),n=u.isArrayBufferView(e);if(r||n)return this.data=r?new DataView(e):new DataView(e.buffer,e.byteOffset,e.byteLength),void(this.write="writeOffset"in t?t.writeOffset:this.data.byteLength);this.data=new DataView(new ArrayBuffer(0)),this.write=0,null!=e&&this.putBytes(e),"writeOffset"in t&&(this.write=t.writeOffset)},u.DataBuffer.prototype.length=function(){return this.write-this.read},u.DataBuffer.prototype.isEmpty=function(){return this.length()<=0},u.DataBuffer.prototype.accommodate=function(e,t){if(this.length()>=e)return this;t=Math.max(t||this.growSize,e);var r=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength),n=new Uint8Array(this.length()+t);return n.set(r),this.data=new DataView(n.buffer),this},u.DataBuffer.prototype.putByte=function(e){return this.accommodate(1),this.data.setUint8(this.write++,e),this},u.DataBuffer.prototype.fillWithByte=function(e,t){this.accommodate(t);for(var r=0;r<t;++r)this.data.setUint8(e);return this},u.DataBuffer.prototype.putBytes=function(e,t){if(u.isArrayBufferView(e)){var r=(n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).byteLength-n.byteOffset;return this.accommodate(r),new Uint8Array(this.data.buffer,this.write).set(n),this.write+=r,this}if(u.isArrayBuffer(e)){var n=new Uint8Array(e);return this.accommodate(n.byteLength),new Uint8Array(this.data.buffer).set(n,this.write),this.write+=n.byteLength,this}if(e instanceof u.DataBuffer||"object"==typeof e&&"number"==typeof e.read&&"number"==typeof e.write&&u.isArrayBufferView(e.data)){n=new Uint8Array(e.data.byteLength,e.read,e.length());return this.accommodate(n.byteLength),new Uint8Array(e.data.byteLength,this.write).set(n),this.write+=n.byteLength,this}if(e instanceof u.ByteStringBuffer&&(e=e.data,t="binary"),t=t||"binary","string"==typeof e){var i;if("hex"===t)return this.accommodate(Math.ceil(e.length/2)),i=new Uint8Array(this.data.buffer,this.write),this.write+=u.binary.hex.decode(e,i,this.write),this;if("base64"===t)return this.accommodate(3*Math.ceil(e.length/4)),i=new Uint8Array(this.data.buffer,this.write),this.write+=u.binary.base64.decode(e,i,this.write),this;if("utf8"===t&&(e=u.encodeUtf8(e),t="binary"),"binary"===t||"raw"===t)return this.accommodate(e.length),i=new Uint8Array(this.data.buffer,this.write),this.write+=u.binary.raw.decode(i),this;if("utf16"===t)return this.accommodate(2*e.length),i=new Uint16Array(this.data.buffer,this.write),this.write+=u.text.utf16.encode(i),this;throw new Error("Invalid encoding: "+t)}throw Error("Invalid parameter: "+e)},u.DataBuffer.prototype.putBuffer=function(e){return this.putBytes(e),e.clear(),this},u.DataBuffer.prototype.putString=function(e){return this.putBytes(e,"utf16")},u.DataBuffer.prototype.putInt16=function(e){return this.accommodate(2),this.data.setInt16(this.write,e),this.write+=2,this},u.DataBuffer.prototype.putInt24=function(e){return this.accommodate(3),this.data.setInt16(this.write,e>>8&65535),this.data.setInt8(this.write,e>>16&255),this.write+=3,this},u.DataBuffer.prototype.putInt32=function(e){return this.accommodate(4),this.data.setInt32(this.write,e),this.write+=4,this},u.DataBuffer.prototype.putInt16Le=function(e){return this.accommodate(2),this.data.setInt16(this.write,e,!0),this.write+=2,this},u.DataBuffer.prototype.putInt24Le=function(e){return this.accommodate(3),this.data.setInt8(this.write,e>>16&255),this.data.setInt16(this.write,e>>8&65535,!0),this.write+=3,this},u.DataBuffer.prototype.putInt32Le=function(e){return this.accommodate(4),this.data.setInt32(this.write,e,!0),this.write+=4,this},u.DataBuffer.prototype.putInt=function(e,t){c(t),this.accommodate(t/8);do{t-=8,this.data.setInt8(this.write++,e>>t&255)}while(t>0);return this},u.DataBuffer.prototype.putSignedInt=function(e,t){return c(t),this.accommodate(t/8),e<0&&(e+=2<<t-1),this.putInt(e,t)},u.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++)},u.DataBuffer.prototype.getInt16=function(){var e=this.data.getInt16(this.read);return this.read+=2,e},u.DataBuffer.prototype.getInt24=function(){var e=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);return this.read+=3,e},u.DataBuffer.prototype.getInt32=function(){var e=this.data.getInt32(this.read);return this.read+=4,e},u.DataBuffer.prototype.getInt16Le=function(){var e=this.data.getInt16(this.read,!0);return this.read+=2,e},u.DataBuffer.prototype.getInt24Le=function(){var e=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,!0)<<8;return this.read+=3,e},u.DataBuffer.prototype.getInt32Le=function(){var e=this.data.getInt32(this.read,!0);return this.read+=4,e},u.DataBuffer.prototype.getInt=function(e){c(e);var t=0;do{t=(t<<8)+this.data.getInt8(this.read++),e-=8}while(e>0);return t},u.DataBuffer.prototype.getSignedInt=function(e){var t=this.getInt(e),r=2<<e-2;return t>=r&&(t-=r<<1),t},u.DataBuffer.prototype.getBytes=function(e){var t;return e?(e=Math.min(this.length(),e),t=this.data.slice(this.read,this.read+e),this.read+=e):0===e?t="":(t=0===this.read?this.data:this.data.slice(this.read),this.clear()),t},u.DataBuffer.prototype.bytes=function(e){return void 0===e?this.data.slice(this.read):this.data.slice(this.read,this.read+e)},u.DataBuffer.prototype.at=function(e){return this.data.getUint8(this.read+e)},u.DataBuffer.prototype.setAt=function(e,t){return this.data.setUint8(e,t),this},u.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1)},u.DataBuffer.prototype.copy=function(){return new u.DataBuffer(this)},u.DataBuffer.prototype.compact=function(){if(this.read>0){var e=new Uint8Array(this.data.buffer,this.read),t=new Uint8Array(e.byteLength);t.set(e),this.data=new DataView(t),this.write-=this.read,this.read=0}return this},u.DataBuffer.prototype.clear=function(){return this.data=new DataView(new ArrayBuffer(0)),this.read=this.write=0,this},u.DataBuffer.prototype.truncate=function(e){return this.write=Math.max(0,this.length()-e),this.read=Math.min(this.read,this.write),this},u.DataBuffer.prototype.toHex=function(){for(var e="",t=this.read;t<this.data.byteLength;++t){var r=this.data.getUint8(t);r<16&&(e+="0"),e+=r.toString(16)}return e},u.DataBuffer.prototype.toString=function(e){var t=new Uint8Array(this.data,this.read,this.length());if("binary"===(e=e||"utf8")||"raw"===e)return u.binary.raw.encode(t);if("hex"===e)return u.binary.hex.encode(t);if("base64"===e)return u.binary.base64.encode(t);if("utf8"===e)return u.text.utf8.decode(t);if("utf16"===e)return u.text.utf16.decode(t);throw new Error("Invalid encoding: "+e)},u.createBuffer=function(e,t){return t=t||"raw",void 0!==e&&"utf8"===t&&(e=u.encodeUtf8(e)),new u.ByteBuffer(e)},u.fillString=function(e,t){for(var r="";t>0;)1&t&&(r+=e),(t>>>=1)>0&&(e+=e);return r},u.xorBytes=function(e,t,r){for(var n="",i="",a="",s=0,o=0;r>0;--r,++s)i=e.charCodeAt(s)^t.charCodeAt(s),o>=10&&(n+=a,a="",o=0),a+=String.fromCharCode(i),++o;return n+=a},u.hexToBytes=function(e){var t="",r=0;for(!0&e.length&&(r=1,t+=String.fromCharCode(parseInt(e[0],16)));r<e.length;r+=2)t+=String.fromCharCode(parseInt(e.substr(r,2),16));return t},u.bytesToHex=function(e){return u.createBuffer(e).toHex()},u.int32ToBytes=function(e){return String.fromCharCode(e>>24&255)+String.fromCharCode(e>>16&255)+String.fromCharCode(e>>8&255)+String.fromCharCode(255&e)};var f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",h=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51],p="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";u.encode64=function(e,t){for(var r,n,i,a="",s="",o=0;o<e.length;)r=e.charCodeAt(o++),n=e.charCodeAt(o++),i=e.charCodeAt(o++),a+=f.charAt(r>>2),a+=f.charAt((3&r)<<4|n>>4),isNaN(n)?a+="==":(a+=f.charAt((15&n)<<2|i>>6),a+=isNaN(i)?"=":f.charAt(63&i)),t&&a.length>t&&(s+=a.substr(0,t)+"\r\n",a=a.substr(t));return s+=a},u.decode64=function(e){e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(var t,r,n,i,a="",s=0;s<e.length;)t=h[e.charCodeAt(s++)-43],r=h[e.charCodeAt(s++)-43],n=h[e.charCodeAt(s++)-43],i=h[e.charCodeAt(s++)-43],a+=String.fromCharCode(t<<2|r>>4),64!==n&&(a+=String.fromCharCode((15&r)<<4|n>>2),64!==i&&(a+=String.fromCharCode((3&n)<<6|i)));return a},u.encodeUtf8=function(e){return unescape(encodeURIComponent(e))},u.decodeUtf8=function(e){return decodeURIComponent(escape(e))},u.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:o.encode,decode:o.decode}},u.binary.raw.encode=function(e){return String.fromCharCode.apply(null,e)},u.binary.raw.decode=function(e,t,r){var n=t;n||(n=new Uint8Array(e.length));for(var i=r=r||0,a=0;a<e.length;++a)n[i++]=e.charCodeAt(a);return t?i-r:n},u.binary.hex.encode=u.bytesToHex,u.binary.hex.decode=function(e,t,r){var n=t;n||(n=new Uint8Array(Math.ceil(e.length/2)));var i=0,a=r=r||0;for(1&e.length&&(i=1,n[a++]=parseInt(e[0],16));i<e.length;i+=2)n[a++]=parseInt(e.substr(i,2),16);return t?a-r:n},u.binary.base64.encode=function(e,t){for(var r,n,i,a="",s="",o=0;o<e.byteLength;)r=e[o++],n=e[o++],i=e[o++],a+=f.charAt(r>>2),a+=f.charAt((3&r)<<4|n>>4),isNaN(n)?a+="==":(a+=f.charAt((15&n)<<2|i>>6),a+=isNaN(i)?"=":f.charAt(63&i)),t&&a.length>t&&(s+=a.substr(0,t)+"\r\n",a=a.substr(t));return s+=a},u.binary.base64.decode=function(e,t,r){var n,i,a,s,o=t;o||(o=new Uint8Array(3*Math.ceil(e.length/4))),e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(var u=0,c=r=r||0;u<e.length;)n=h[e.charCodeAt(u++)-43],i=h[e.charCodeAt(u++)-43],a=h[e.charCodeAt(u++)-43],s=h[e.charCodeAt(u++)-43],o[c++]=n<<2|i>>4,64!==a&&(o[c++]=(15&i)<<4|a>>2,64!==s&&(o[c++]=(3&a)<<6|s));return t?c-r:o.subarray(0,c)},u.binary.base58.encode=function(e,t){return u.binary.baseN.encode(e,p,t)},u.binary.base58.decode=function(e,t){return u.binary.baseN.decode(e,p,t)},u.text={utf8:{},utf16:{}},u.text.utf8.encode=function(e,t,r){e=u.encodeUtf8(e);var n=t;n||(n=new Uint8Array(e.length));for(var i=r=r||0,a=0;a<e.length;++a)n[i++]=e.charCodeAt(a);return t?i-r:n},u.text.utf8.decode=function(e){return u.decodeUtf8(String.fromCharCode.apply(null,e))},u.text.utf16.encode=function(e,t,r){var n=t;n||(n=new Uint8Array(2*e.length));for(var i=new Uint16Array(n.buffer),a=r=r||0,s=r,o=0;o<e.length;++o)i[s++]=e.charCodeAt(o),a+=2;return t?a-r:n},u.text.utf16.decode=function(e){return String.fromCharCode.apply(null,new Uint16Array(e.buffer))},u.deflate=function(e,t,r){if(t=u.decode64(e.deflate(u.encode64(t)).rval),r){var n=2;32&t.charCodeAt(1)&&(n=6),t=t.substring(n,t.length-4)}return t},u.inflate=function(e,t,r){var n=e.inflate(u.encode64(t)).rval;return null===n?null:u.decode64(n)};var d=function(e,t,r){if(!e)throw new Error("WebStorage not available.");var n;if(null===r?n=e.removeItem(t):(r=u.encode64(JSON.stringify(r)),n=e.setItem(t,r)),void 0!==n&&!0!==n.rval){var i=new Error(n.error.message);throw i.id=n.error.id,i.name=n.error.name,i}},y=function(e,t){if(!e)throw new Error("WebStorage not available.");var r=e.getItem(t);if(e.init)if(null===r.rval){if(r.error){var n=new Error(r.error.message);throw n.id=r.error.id,n.name=r.error.name,n}r=null}else r=r.rval;return null!==r&&(r=JSON.parse(u.decode64(r))),r},g=function(e,t,r,n){var i=y(e,t);null===i&&(i={}),i[r]=n,d(e,t,i)},m=function(e,t,r){var n=y(e,t);return null!==n&&(n=r in n?n[r]:null),n},v=function(e,t,r){var n=y(e,t);if(null!==n&&r in n){delete n[r];var i=!0;for(var a in n){i=!1;break}i&&(n=null),d(e,t,n)}},b=function(e,t){d(e,t,null)},E=function(e,t,r){var n,i=null;void 0===r&&(r=["web","flash"]);var a=!1,s=null;for(var o in r){n=r[o];try{if("flash"===n||"both"===n){if(null===t[0])throw new Error("Flash local storage not available.");i=e.apply(this,t),a="flash"===n}"web"!==n&&"both"!==n||(t[0]=localStorage,i=e.apply(this,t),a=!0)}catch(e){s=e}if(a)break}if(!a)throw s;return i};u.setItem=function(e,t,r,n,i){E(g,arguments,i)},u.getItem=function(e,t,r,n){return E(m,arguments,n)},u.removeItem=function(e,t,r,n){E(v,arguments,n)},u.clearItems=function(e,t,r){E(b,arguments,r)},u.parseUrl=function(e){var t=/^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;t.lastIndex=0;var r=t.exec(e),n=null===r?null:{full:e,scheme:r[1],host:r[2],port:r[3],path:r[4]};return n&&(n.fullHost=n.host,n.port?80!==n.port&&"http"===n.scheme?n.fullHost+=":"+n.port:443!==n.port&&"https"===n.scheme&&(n.fullHost+=":"+n.port):"http"===n.scheme?n.port=80:"https"===n.scheme&&(n.port=443),n.full=n.scheme+"://"+n.fullHost),n};var S=null;u.getQueryVariables=function(e){var t,r=function(e){for(var t={},r=e.split("&"),n=0;n<r.length;n++){var i,a,s=r[n].indexOf("=");s>0?(i=r[n].substring(0,s),a=r[n].substring(s+1)):(i=r[n],a=null),i in t||(t[i]=[]),i in Object.prototype||null===a||t[i].push(unescape(a))}return t};return void 0===e?(null===S&&(S="undefined"!=typeof window&&window.location&&window.location.search?r(window.location.search.substring(1)):{}),t=S):t=r(e),t},u.parseFragment=function(e){var t=e,r="",n=e.indexOf("?");n>0&&(t=e.substring(0,n),r=e.substring(n+1));var i=t.split("/");return i.length>0&&""===i[0]&&i.shift(),{pathString:t,queryString:r,path:i,query:""===r?{}:u.getQueryVariables(r)}},u.makeRequest=function(e){var t=u.parseFragment(e),r={path:t.pathString,query:t.queryString,getPath:function(e){return void 0===e?t.path:t.path[e]},getQuery:function(e,r){var n;return void 0===e?n=t.query:(n=t.query[e])&&void 0!==r&&(n=n[r]),n},getQueryLast:function(e,t){var n=r.getQuery(e);return n?n[n.length-1]:t}};return r},u.makeLink=function(e,t,r){e=jQuery.isArray(e)?e.join("/"):e;var n=jQuery.param(t||{});return r=r||"",e+(n.length>0?"?"+n:"")+(r.length>0?"#"+r:"")},u.setPath=function(e,t,r){if("object"==typeof e&&null!==e)for(var n=0,i=t.length;n<i;){var a=t[n++];if(n==i)e[a]=r;else{var s=a in e;(!s||s&&"object"!=typeof e[a]||s&&null===e[a])&&(e[a]={}),e=e[a]}}},u.getPath=function(e,t,r){for(var n=0,i=t.length,a=!0;a&&n<i&&"object"==typeof e&&null!==e;){var s=t[n++];(a=s in e)&&(e=e[s])}return a?e:r},u.deletePath=function(e,t){if("object"==typeof e&&null!==e)for(var r=0,n=t.length;r<n;){var i=t[r++];if(r==n)delete e[i];else{if(!(i in e)||"object"!=typeof e[i]||null===e[i])break;e=e[i]}}},u.isEmpty=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},u.format=function(e){for(var t,r,n=/%./g,i=0,a=[],s=0;t=n.exec(e);){(r=e.substring(s,n.lastIndex-2)).length>0&&a.push(r),s=n.lastIndex;var o=t[0][1];switch(o){case"s":case"o":i<arguments.length?a.push(arguments[1+i++]):a.push("<?>");break;case"%":a.push("%");break;default:a.push("<%"+o+"?>")}}return a.push(e.substring(s)),a.join("")},u.formatNumber=function(e,t,r,n){var i=e,a=isNaN(t=Math.abs(t))?2:t,s=void 0===r?",":r,o=void 0===n?".":n,u=i<0?"-":"",c=parseInt(i=Math.abs(+i||0).toFixed(a),10)+"",l=c.length>3?c.length%3:0;return u+(l?c.substr(0,l)+o:"")+c.substr(l).replace(/(\d{3})(?=\d)/g,"$1"+o)+(a?s+Math.abs(i-c).toFixed(a).slice(2):"")},u.formatSize=function(e){return e=e>=1073741824?u.formatNumber(e/1073741824,2,".","")+" GiB":e>=1048576?u.formatNumber(e/1048576,2,".","")+" MiB":e>=1024?u.formatNumber(e/1024,0)+" KiB":u.formatNumber(e,0)+" bytes"},u.bytesFromIP=function(e){return-1!==e.indexOf(".")?u.bytesFromIPv4(e):-1!==e.indexOf(":")?u.bytesFromIPv6(e):null},u.bytesFromIPv4=function(e){if(4!==(e=e.split(".")).length)return null;for(var t=u.createBuffer(),r=0;r<e.length;++r){var n=parseInt(e[r],10);if(isNaN(n))return null;t.putByte(n)}return t.getBytes()},u.bytesFromIPv6=function(e){for(var t=0,r=2*(8-(e=e.split(":").filter((function(e){return 0===e.length&&++t,!0}))).length+t),n=u.createBuffer(),i=0;i<8;++i)if(e[i]&&0!==e[i].length){var a=u.hexToBytes(e[i]);a.length<2&&n.putByte(0),n.putBytes(a)}else n.fillWithByte(0,r),r=0;return n.getBytes()},u.bytesToIP=function(e){return 4===e.length?u.bytesToIPv4(e):16===e.length?u.bytesToIPv6(e):null},u.bytesToIPv4=function(e){if(4!==e.length)return null;for(var t=[],r=0;r<e.length;++r)t.push(e.charCodeAt(r));return t.join(".")},u.bytesToIPv6=function(e){if(16!==e.length)return null;for(var t=[],r=[],n=0,i=0;i<e.length;i+=2){for(var a=u.bytesToHex(e[i]+e[i+1]);"0"===a[0]&&"0"!==a;)a=a.substr(1);if("0"===a){var s=r[r.length-1],o=t.length;s&&o===s.end+1?(s.end=o,s.end-s.start>r[n].end-r[n].start&&(n=r.length-1)):r.push({start:o,end:o})}t.push(a)}if(r.length>0){var c=r[n];c.end-c.start>0&&(t.splice(c.start,c.end-c.start+1,""),0===c.start&&t.unshift(""),7===c.end&&t.push(""))}return t.join(":")},u.estimateCores=function(e,t){if("function"==typeof e&&(t=e,e={}),e=e||{},"cores"in u&&!e.update)return t(null,u.cores);if("undefined"!=typeof navigator&&"hardwareConcurrency"in navigator&&navigator.hardwareConcurrency>0)return u.cores=navigator.hardwareConcurrency,t(null,u.cores);if("undefined"==typeof Worker)return u.cores=1,t(null,u.cores);if("undefined"==typeof Blob)return u.cores=2,t(null,u.cores);var r=URL.createObjectURL(new Blob(["(",function(){self.addEventListener("message",(function(e){for(var t=Date.now(),r=t+4;Date.now()<r;);self.postMessage({st:t,et:r})}))}.toString(),")()"],{type:"application/javascript"}));!function e(n,i,a){if(0===i){var s=Math.floor(n.reduce((function(e,t){return e+t}),0)/n.length);return u.cores=Math.max(1,s),URL.revokeObjectURL(r),t(null,u.cores)}!function(e,t){for(var n=[],i=[],a=0;a<e;++a){var s=new Worker(r);s.addEventListener("message",(function(r){if(i.push(r.data),i.length===e){for(var a=0;a<e;++a)n[a].terminate();t(null,i)}})),n.push(s)}for(a=0;a<e;++a)n[a].postMessage(a)}(a,(function(t,r){n.push(function(e,t){for(var r=[],n=0;n<e;++n)for(var i=t[n],a=r[n]=[],s=0;s<e;++s)if(n!==s){var o=t[s];(i.st>o.st&&i.st<o.et||o.st>i.st&&o.st<i.et)&&a.push(s)}return r.reduce((function(e,t){return Math.max(e,t.length)}),0)}(a,r)),e(n,i-1,a)}))}([],5,16)}}).call(this,r(18),r(87).setImmediate,r(17),r(13).Buffer)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(21),i=r(67),a=r(113),s=r(114);t.json=s;const o=r(26);t.serializePrimitives=o;const u=r(37);t.parsePrimitives=u;const c=r(21);t.schemas=c;const l={serializerFromSchema:i.serializerFromSchema,serializeTx:i.serializeTx,serializeOrder:i.serializeOrder,parserFromSchema:a.parserFromSchema,parseTx:a.parseTx,parseOrder:a.parseOrder};function f(e,t,r,n){const s=i.serializerFromSchema(t,n),o=a.parserFromSchema(t,r)(s(e)).value;return Object.assign({},e,o)}t.binary=l,t.convertLongFields=f,t.convertTxLongFields=function(e,t,r){const{type:i,version:a}=e;return f(e,n.getTransactionSchema(i,a),t,r)}},function(e,t,r){"use strict";var n;Object.defineProperty(t,"__esModule",{value:!0});var i=r(51),a=r(53);t.seedWordsList=a.seedWordsList;var s=r(56);t.ChaidId=s.ChaidId;var o=r(55);t.Seed=o.Seed;var u=r(34);t.isPrivateKey=u.isPrivateKey,t.isPublicKey=u.isPublicKey;var c=r(51);t.crypto=c.crypto,function(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}(r(20)),t.signBytes=(n=i.crypto({output:"Base58"})).signBytes,t.keyPair=n.keyPair,t.publicKey=n.publicKey,t.privateKey=n.privateKey,t.address=n.address,t.blake2b=n.blake2b,t.keccak=n.keccak,t.sha256=n.sha256,t.sharedKey=n.sharedKey,t.seedWithNonce=n.seedWithNonce,t.base64Encode=n.base64Encode,t.base64Decode=n.base64Decode,t.base58Encode=n.base58Encode,t.base58Decode=n.base58Decode,t.base16Encode=n.base16Encode,t.base16Decode=n.base16Decode,t.stringToBytes=n.stringToBytes,t.bytesToString=n.bytesToString,t.random=n.random,t.randomSeed=n.randomSeed,t.randomBytes=n.randomBytes,t.verifySignature=n.verifySignature,t.verifyPublicKey=n.verifyPublicKey,t.verifyAddress=n.verifyAddress,t.messageDecrypt=n.messageDecrypt,t.messageEncrypt=n.messageEncrypt,t.aesDecrypt=n.aesDecrypt,t.aesEncrypt=n.aesEncrypt,t.encryptSeed=n.encryptSeed,t.decryptSeed=n.decryptSeed,t.rsaKeyPair=n.rsaKeyPair,t.rsaKeyPairSync=n.rsaKeyPairSync,t.rsaSign=n.rsaSign,t.rsaVerify=n.rsaVerify,t.merkleVerify=n.merkleVerify,t.split=n.split,t.concat=n.concat},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}(r(6));const n=r(116),i=r(117),a=r(118),s=r(119),o=r(120),u=r(121),c=r(122),l=r(123),f=r(124),h=r(125),p=r(126),d=r(127),y=r(128),g=r(129),m=r(68),v=r(130),b=r(131),E=r(132),S=r(133);t.validate={transfer:n.transferValidator,massTransfer:i.massTransferValidator,alias:a.aliasValidator,issue:p.issueValidator,reissue:h.reissueValidator,sponsorship:c.sponsorshipValidator,burn:s.burnValidator,setAssetScript:l.setAssetScriptValidator,cancelLease:o.cancelLeaseValidator,data:u.dataValidator,lease:d.leaseValidator,setScript:f.setScriptValidator,invokeScript:y.invokeValidator,exchange:g.exchangeValidator,cancelOrder:v.cancelOrderValidator,customData:b.customDataValidator,order:m.orderValidator,wavesAuth:S.authValidator,auth:E.authValidator}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=140,a={AVAILABLE_CHARS:"-.0123456789@_abcdefghijklmnopqrstuvwxyz",MAX_ALIAS_LENGTH:30,MIN_ALIAS_LENGTH:4},s=4,o=16,u=1e3;t.defaultValue=e=>()=>e,t.nope=e=>e,t.pipe=(...e)=>t=>e.reduce((e,t)=>t(e),t),t.validatePipe=(...e)=>t=>{let r=!0;for(const n of e)if(r=!!n(t),!r)return!1;return r},t.prop=e=>t=>t?t[e]:void 0,t.lte=e=>t=>e>=t,t.gte=e=>t=>e<=t,t.ifElse=(e,t,r)=>n=>e(n)?t(n):r(n),t.isEq=e=>r=>{switch(!0){case t.isNumber(r)&&t.isNumber(e):return Number(r)===Number(e);case t.isString(r)&&t.isString(e):return String(e)===String(r);case t.isBoolean(r)&&t.isBoolean(e):return Boolean(r)===Boolean(e);default:return e===r}},t.orEq=e=>r=>e.some(t.isEq(r)),t.isRequired=e=>t=>!e||null!=t,t.isString=e=>"string"==typeof e||e instanceof String,t.isNumber=e=>("number"==typeof e||e instanceof Number)&&!isNaN(Number(e)),t.isNumberLike=e=>!(null==e||isNaN(Number(e))||!e&&0!==e),t.isBoolean=e=>null!=e&&("boolean"==typeof e||e instanceof Boolean),t.isByteArray=e=>{if(!e)return!1;const r=new Uint8Array(e);return r.length===e.length&&r.every((r,n)=>t.isEq(r)(e[n]))},t.isArray=e=>Array.isArray(e),t.bytesLength=e=>t=>{try{return Uint8Array.from(t).length===e}catch(e){return!1}},t.isBase58=e=>{try{n.base58Decode(e)}catch(e){return!1}return!0},t.isBase64=e=>{try{e=e.replace(/^base64:/,""),n.base64Decode(e)}catch(e){return!1}return!0},t.isValidAddress=(e,r)=>{if("string"!=typeof e||!t.isBase58(e))return!1;let i=n.base58Decode(e);if(1!==i[0])return!1;if(null!=r&&i[1]!=r)return!1;let a=i.slice(0,22),s=i.slice(22,26),o=n.keccak(n.blake2b(a)).slice(0,4);for(let e=0;e<4;e++)if(s[e]!==o[e])return!1;return!0};var c;t.isValidAliasName=t.ifElse((c=a.AVAILABLE_CHARS,e=>e.split("").every(e=>c.includes(e))),t.pipe(t.prop("length"),t.validatePipe(t.lte(a.MAX_ALIAS_LENGTH),t.gte(a.MIN_ALIAS_LENGTH))),t.defaultValue(!1)),t.isValidAlias=t.validatePipe(t.isString,t.pipe(e=>e.split(":"),t.ifElse(e=>"alias"!==e[0]||3!==e.length,t.defaultValue(!1),t.pipe(t.prop(2),t.isValidAliasName)))),t.isHash=t.validatePipe(t.isRequired(!0),t.isBase58,t.pipe(e=>n.base58Decode(e),t.bytesLength(32))),t.isPublicKey=t.isHash,t.isAssetId=t.ifElse(t.orEq(["",null,void 0,"WAVES"]),t.defaultValue(!0),t.isHash),t.isAttachment=t.ifElse(t.orEq([null,void 0]),t.defaultValue(!0),t.pipe(t.ifElse(t.isBase58,n.base58Decode,t.nope),t.ifElse(t.isByteArray,t.pipe(t.prop("length"),t.lte(i)),t.defaultValue(!1))));const l={integer:t.isNumberLike,boolean:t.isBoolean,string:t.isString,binary:t.isBase64};t.isValidDataPair=e=>!(!l[e.type]||!l[e.type](e.value)),t.isValidData=t.validatePipe(t.isRequired(!0),t.pipe(t.prop("key"),t.validatePipe(t.isString,e=>!!e)),t.isValidDataPair),t.isValidAssetName=t.validatePipe(t.isRequired(!0),t.isString,t.pipe(n.stringToBytes,t.prop("length"),t.ifElse(t.gte(s),t.lte(o),t.defaultValue(!1)))),t.isValidAssetDescription=t.ifElse(t.isRequired(!1),t.defaultValue(!0),t.pipe(n.stringToBytes,t.prop("length"),t.lte(u))),t.exception=e=>{throw new Error(e)},t.isRecipient=t.ifElse(t.isValidAddress,t.defaultValue(!0),t.isValidAlias),t.validateByShema=(e,r)=>n=>(Object.entries(e).forEach(([e,i])=>{const a=t.prop(e)(n||{});i(a)||t.exception(r(e,a))}),!0),t.getError=(e,t)=>`tx "${e}", has wrong data: ${JSON.stringify(t)}. Check tx data.`},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4);t.mapObj=(e,t)=>Object.entries(e).map(([e,r])=>[e,t(r)]).reduce((e,[t,r])=>Object.assign({},e,{[t]:r}),{}),t.getSenderPublicKey=function(e,t){if(0===e.length&&null==t.senderPublicKey)throw new Error("Please provide either seed or senderPublicKey");return null==t.senderPublicKey?n.publicKey(e[0][0]):t.senderPublicKey},t.base64Prefix=e=>null==e||"base64:"===e.slice(0,7)?e:"base64:"+e,t.addProof=function(e,t,r){if(null==r)return e.proofs=[...e.proofs,t],e;if(null!=e.proofs&&e.proofs[r])throw new Error(`Proof at index ${r} already exists.`);for(let t=e.proofs.length;t<r;t++)e.proofs.push("");return e.proofs[r]=t,e},t.convertToPairs=function(e){return null==e?[]:"string"==typeof e?[[e,void 0]]:"privateKey"in e?[[e,void 0]]:Array.isArray(e)?e.map((e,t)=>[e,t]).filter(([e,t])=>e):Object.keys(e).map(e=>parseInt(e)).filter(e=>!isNaN(e)).sort().map(t=>[e[t],t])},t.isOrder=e=>void 0!==e.assetPair,t.networkByte=function(e,t){switch(typeof e){case"string":return e.charCodeAt(0);case"number":return e;default:return t}},t.fee=function(e,t){return e.fee?e.fee:e.additionalFee?t+e.additionalFee:t},t.normalizeAssetId=function(e){return"WAVES"===(e=e||null)?null:e}},function(e,t,r){"use strict";var n=r(73),i=r(138),a=Object.prototype.toString;function s(e){return"[object Array]"===a.call(e)}function o(e){return null!==e&&"object"==typeof e}function u(e){return"[object Function]"===a.call(e)}function c(e,t){if(null!=e)if("object"!=typeof e&&(e=[e]),s(e))for(var r=0,n=e.length;r<n;r++)t.call(null,e[r],r,e);else for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.call(null,e[i],i,e)}e.exports={isArray:s,isArrayBuffer:function(e){return"[object ArrayBuffer]"===a.call(e)},isBuffer:i,isFormData:function(e){return"undefined"!=typeof FormData&&e instanceof FormData},isArrayBufferView:function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&e.buffer instanceof ArrayBuffer},isString:function(e){return"string"==typeof e},isNumber:function(e){return"number"==typeof e},isObject:o,isUndefined:function(e){return void 0===e},isDate:function(e){return"[object Date]"===a.call(e)},isFile:function(e){return"[object File]"===a.call(e)},isBlob:function(e){return"[object Blob]"===a.call(e)},isFunction:u,isStream:function(e){return o(e)&&u(e.pipe)},isURLSearchParams:function(e){return"undefined"!=typeof URLSearchParams&&e instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:c,merge:function e(){var t={};function r(r,n){"object"==typeof t[n]&&"object"==typeof r?t[n]=e(t[n],r):t[n]=r}for(var n=0,i=arguments.length;n<i;n++)c(arguments[n],r);return t},deepMerge:function e(){var t={};function r(r,n){"object"==typeof t[n]&&"object"==typeof r?t[n]=e(t[n],r):t[n]="object"==typeof r?e({},r):r}for(var n=0,i=arguments.length;n<i;n++)c(arguments[n],r);return t},extend:function(e,t,r){return c(t,(function(t,i){e[i]=r&&"function"==typeof t?n(t,r):t})),e},trim:function(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")}}},function(e,t,r){var n=r(1);e.exports=n.md=n.md||{},n.md.algorithms=n.md.algorithms||{}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,a=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=a.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=a.return)&&r.call(a)}finally{if(i)throw i.error}}return s},i=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(11),s=r(93);t.stringToBytes=function(e,t){if(void 0===t&&(t="utf8"),"utf8"===t)return s.strToUtf8Array(e);if("raw"===t)return Uint8Array.from(i(e).map((function(e){return e.charCodeAt(0)})));throw new Error("Unsupported encoding "+t)},t.bytesToString=function(e,t){if(void 0===t&&(t="utf8"),"utf8"===t)return s.utf8ArrayToStr(Array.from(a._fromIn(e)));if("raw"===t)return String.fromCharCode.apply(null,Array.from(a._fromIn(e)));throw new Error("Unsupported encoding "+t)},t.binaryStringToBytes=function(e){return Uint8Array.from(i(e).map((function(e){return e.charCodeAt(0)})))},t.bytesToBinaryString=function(e){return String.fromCharCode.apply(null,Array.from(a._fromIn(e)))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(23),i=r(10),a=function(e){return"string"==typeof e||e instanceof String},s=function(e){return e instanceof Uint8Array};t._fromIn=function(e){return a(e)?n.base58Decode(e):s(e)?e:Uint8Array.from(e)},t._fromRawIn=function(e){return a(e)?i.stringToBytes(e):s(e)?e:Uint8Array.from(e)}},function(e,t,r){var n=r(1);r(29),r(90),r(91),r(2),n.random&&n.random.getBytes?e.exports=n.random:function(t){var r={},i=new Array(4),a=n.util.createBuffer();function s(){var e=n.prng.create(r);return e.getBytes=function(t,r){return e.generate(t,r)},e.getBytesSync=function(t){return e.generate(t)},e}r.formatKey=function(e){var t=n.util.createBuffer(e);return(e=new Array(4))[0]=t.getInt32(),e[1]=t.getInt32(),e[2]=t.getInt32(),e[3]=t.getInt32(),n.aes._expandKey(e,!1)},r.formatSeed=function(e){var t=n.util.createBuffer(e);return(e=new Array(4))[0]=t.getInt32(),e[1]=t.getInt32(),e[2]=t.getInt32(),e[3]=t.getInt32(),e},r.cipher=function(e,t){return n.aes._updateBlock(e,t,i,!1),a.putInt32(i[0]),a.putInt32(i[1]),a.putInt32(i[2]),a.putInt32(i[3]),a.getBytes()},r.increment=function(e){return++e[3],e},r.md=n.md.sha256;var o=s(),u=null,c=n.util.globalScope,l=c.crypto||c.msCrypto;if(l&&l.getRandomValues&&(u=function(e){return l.getRandomValues(e)}),n.options.usePureJavaScript||!n.util.isNodejs&&!u){if("undefined"==typeof window||window.document,o.collectInt(+new Date,32),"undefined"!=typeof navigator){var f="";for(var h in navigator)try{"string"==typeof navigator[h]&&(f+=navigator[h])}catch(e){}o.collect(f),f=null}t&&(t().mousemove((function(e){o.collectInt(e.clientX,16),o.collectInt(e.clientY,16)})),t().keypress((function(e){o.collectInt(e.charCode,8)})))}if(n.random)for(var h in o)n.random[h]=o[h];else n.random=o;n.random.createInstance=s,e.exports=n.random}("undefined"!=typeof jQuery?jQuery:null)},function(e,t,r){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
var n=r(28),i=r(85),a=r(86);function s(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function o(e,t){if(s()<t)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=u.prototype:(null===e&&(e=new u(t)),e.length=t),e}function u(e,t,r){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return f(this,e)}return c(this,e,t,r)}function c(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);u.TYPED_ARRAY_SUPPORT?(e=t).__proto__=u.prototype:e=h(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!u.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|d(t,r),i=(e=o(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function(e,t){if(u.isBuffer(t)){var r=0|p(t.length);return 0===(e=o(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?o(e,0):h(e,t);if("Buffer"===t.type&&a(t.data))return h(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function l(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function f(e,t){if(l(t),e=o(e,t<0?0:0|p(t)),!u.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function h(e,t){var r=t.length<0?0:0|p(t.length);e=o(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function p(e){if(e>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|e}function d(e,t){if(u.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return j(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return F(e).length;default:if(n)return j(e).length;t=(""+t).toLowerCase(),n=!0}}function y(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return _(this,t,r);case"utf8":case"utf-8":return w(this,t,r);case"ascii":return N(this,t,r);case"latin1":case"binary":return R(this,t,r);case"base64":return I(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return P(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function g(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function m(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=u.from(t,n)),u.isBuffer(t))return 0===t.length?-1:v(e,t,r,n,i);if("number"==typeof t)return t&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):v(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function v(e,t,r,n,i){var a,s=1,o=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;s=2,o/=2,u/=2,r/=2}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var l=-1;for(a=r;a<o;a++)if(c(e,a)===c(t,-1===l?0:a-l)){if(-1===l&&(l=a),a-l+1===u)return l*s}else-1!==l&&(a-=a-l),l=-1}else for(r+u>o&&(r=o-u),a=r;a>=0;a--){for(var f=!0,h=0;h<u;h++)if(c(e,a+h)!==c(t,h)){f=!1;break}if(f)return a}return-1}function b(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var a=t.length;if(a%2!=0)throw new TypeError("Invalid hex string");n>a/2&&(n=a/2);for(var s=0;s<n;++s){var o=parseInt(t.substr(2*s,2),16);if(isNaN(o))return s;e[r+s]=o}return s}function E(e,t,r,n){return q(j(t,e.length-r),e,r,n)}function S(e,t,r,n){return q(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function T(e,t,r,n){return S(e,t,r,n)}function C(e,t,r,n){return q(F(t),e,r,n)}function A(e,t,r,n){return q(function(e,t){for(var r,n,i,a=[],s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,a.push(i),a.push(n);return a}(t,e.length-r),e,r,n)}function I(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function w(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var a,s,o,u,c=e[i],l=null,f=c>239?4:c>223?3:c>191?2:1;if(i+f<=r)switch(f){case 1:c<128&&(l=c);break;case 2:128==(192&(a=e[i+1]))&&(u=(31&c)<<6|63&a)>127&&(l=u);break;case 3:a=e[i+1],s=e[i+2],128==(192&a)&&128==(192&s)&&(u=(15&c)<<12|(63&a)<<6|63&s)>2047&&(u<55296||u>57343)&&(l=u);break;case 4:a=e[i+1],s=e[i+2],o=e[i+3],128==(192&a)&&128==(192&s)&&128==(192&o)&&(u=(15&c)<<18|(63&a)<<12|(63&s)<<6|63&o)>65535&&u<1114112&&(l=u)}null===l?(l=65533,f=1):l>65535&&(l-=65536,n.push(l>>>10&1023|55296),l=56320|1023&l),n.push(l),i+=f}return function(e){var t=e.length;if(t<=B)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=B));return r}(n)}t.Buffer=u,t.SlowBuffer=function(e){+e!=e&&(e=0);return u.alloc(+e)},t.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=s(),u.poolSize=8192,u._augment=function(e){return e.__proto__=u.prototype,e},u.from=function(e,t,r){return c(null,e,t,r)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(e,t,r){return function(e,t,r,n){return l(t),t<=0?o(e,t):void 0!==r?"string"==typeof n?o(e,t).fill(r,n):o(e,t).fill(r):o(e,t)}(null,e,t,r)},u.allocUnsafe=function(e){return f(null,e)},u.allocUnsafeSlow=function(e){return f(null,e)},u.isBuffer=function(e){return!(null==e||!e._isBuffer)},u.compare=function(e,t){if(!u.isBuffer(e)||!u.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,a=Math.min(r,n);i<a;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(e,t){if(!a(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=u.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var s=e[r];if(!u.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(n,i),i+=s.length}return n},u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)g(this,t,t+1);return this},u.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)g(this,t,t+3),g(this,t+1,t+2);return this},u.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)g(this,t,t+7),g(this,t+1,t+6),g(this,t+2,t+5),g(this,t+3,t+4);return this},u.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?w(this,0,e):y.apply(this,arguments)},u.prototype.equals=function(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},u.prototype.compare=function(e,t,r,n,i){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(this===e)return 0;for(var a=(i>>>=0)-(n>>>=0),s=(r>>>=0)-(t>>>=0),o=Math.min(a,s),c=this.slice(n,i),l=e.slice(t,r),f=0;f<o;++f)if(c[f]!==l[f]){a=c[f],s=l[f];break}return a<s?-1:s<a?1:0},u.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},u.prototype.indexOf=function(e,t,r){return m(this,e,t,r,!0)},u.prototype.lastIndexOf=function(e,t,r){return m(this,e,t,r,!1)},u.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var a=!1;;)switch(n){case"hex":return b(this,e,t,r);case"utf8":case"utf-8":return E(this,e,t,r);case"ascii":return S(this,e,t,r);case"latin1":case"binary":return T(this,e,t,r);case"base64":return C(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,e,t,r);default:if(a)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),a=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var B=4096;function N(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function R(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function _(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",a=t;a<r;++a)i+=M(e[a]);return i}function P(e,t,r){for(var n=e.slice(t,r),i="",a=0;a<n.length;a+=2)i+=String.fromCharCode(n[a]+256*n[a+1]);return i}function O(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function k(e,t,r,n,i,a){if(!u.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<a)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function U(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,a=Math.min(e.length-r,2);i<a;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function L(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,a=Math.min(e.length-r,4);i<a;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function D(e,t,r,n,i,a){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function V(e,t,r,n,a){return a||D(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function x(e,t,r,n,a){return a||D(e,0,r,8),i.write(e,t,r,n,52,8),r+8}u.prototype.slice=function(e,t){var r,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),u.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=u.prototype;else{var i=t-e;r=new u(i,void 0);for(var a=0;a<i;++a)r[a]=this[a+e]}return r},u.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var n=this[e],i=1,a=0;++a<t&&(i*=256);)n+=this[e+a]*i;return n},u.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},u.prototype.readUInt8=function(e,t){return t||O(e,1,this.length),this[e]},u.prototype.readUInt16LE=function(e,t){return t||O(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUInt16BE=function(e,t){return t||O(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUInt32LE=function(e,t){return t||O(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUInt32BE=function(e,t){return t||O(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var n=this[e],i=1,a=0;++a<t&&(i*=256);)n+=this[e+a]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},u.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var n=t,i=1,a=this[e+--n];n>0&&(i*=256);)a+=this[e+--n]*i;return a>=(i*=128)&&(a-=Math.pow(2,8*t)),a},u.prototype.readInt8=function(e,t){return t||O(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function(e,t){t||O(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(e,t){t||O(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(e,t){return t||O(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function(e,t){return t||O(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readFloatLE=function(e,t){return t||O(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function(e,t){return t||O(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function(e,t){return t||O(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function(e,t){return t||O(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||k(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,a=0;for(this[t]=255&e;++a<r&&(i*=256);)this[t+a]=e/i&255;return t+r},u.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||k(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,a=1;for(this[t+i]=255&e;--i>=0&&(a*=256);)this[t+i]=e/a&255;return t+r},u.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,1,255,0),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},u.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):U(this,e,t,!0),t+2},u.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):U(this,e,t,!1),t+2},u.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):L(this,e,t,!0),t+4},u.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):L(this,e,t,!1),t+4},u.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);k(this,e,t,r,i-1,-i)}var a=0,s=1,o=0;for(this[t]=255&e;++a<r&&(s*=256);)e<0&&0===o&&0!==this[t+a-1]&&(o=1),this[t+a]=(e/s>>0)-o&255;return t+r},u.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);k(this,e,t,r,i-1,-i)}var a=r-1,s=1,o=0;for(this[t+a]=255&e;--a>=0&&(s*=256);)e<0&&0===o&&0!==this[t+a+1]&&(o=1),this[t+a]=(e/s>>0)-o&255;return t+r},u.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,1,127,-128),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},u.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):U(this,e,t,!0),t+2},u.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):U(this,e,t,!1),t+2},u.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):L(this,e,t,!0),t+4},u.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||k(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),u.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):L(this,e,t,!1),t+4},u.prototype.writeFloatLE=function(e,t,r){return V(this,e,t,!0,r)},u.prototype.writeFloatBE=function(e,t,r){return V(this,e,t,!1,r)},u.prototype.writeDoubleLE=function(e,t,r){return x(this,e,t,!0,r)},u.prototype.writeDoubleBE=function(e,t,r){return x(this,e,t,!1,r)},u.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,a=n-r;if(this===e&&r<t&&t<n)for(i=a-1;i>=0;--i)e[i+t]=this[i+r];else if(a<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<a;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+a),t);return a},u.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var a;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{var s=u.isBuffer(e)?e:j(new u(e,n).toString()),o=s.length;for(a=0;a<r-t;++a)this[a+t]=s[a%o]}return this};var K=/[^+\/0-9A-Za-z-_]/g;function M(e){return e<16?"0"+e.toString(16):e.toString(16)}function j(e,t){var r;t=t||1/0;for(var n=e.length,i=null,a=[],s=0;s<n;++s){if((r=e.charCodeAt(s))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&a.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&a.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&a.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;a.push(r)}else if(r<2048){if((t-=2)<0)break;a.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;a.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return a}function F(e){return n.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(K,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function q(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}}).call(this,r(17))},function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});var i=r(11),a=r(94),s=n(r(32)),o=n(r(9)),u=n(r(95)),c=r(10);t._hashChain=function(e){return i._fromIn(t.keccak(t.blake2b(i._fromIn(e))))},t.sha256=function(e){var t=o.algorithms.sha256.create();return t.update(c.bytesToString(e,"raw")),c.stringToBytes(t.digest().getBytes(),"raw")},t.blake2b=function(e){return u.blake2b(i._fromIn(e),null,32)},t.keccak=function(e){return i._fromIn(a.keccak256.array(i._fromIn(e)))},t.hmacSHA256=function(e,t){var r=s.create();return r.start("sha256",c.bytesToString(i._fromIn(t),"raw")),r.update(c.bytesToString(i._fromIn(e),"raw")),c.stringToBytes(r.digest().getBytes(),"raw")}},function(e,t,r){var n=r(1);r(2),r(16);var i=e.exports=n.asn1=n.asn1||{};function a(e,t,r){if(r>t){var n=new Error("Too few bytes to parse DER.");throw n.available=e.length(),n.remaining=t,n.requested=r,n}}i.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192},i.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30},i.create=function(e,t,r,a,s){if(n.util.isArray(a)){for(var o=[],u=0;u<a.length;++u)void 0!==a[u]&&o.push(a[u]);a=o}var c={tagClass:e,type:t,constructed:r,composed:r||n.util.isArray(a),value:a};return s&&"bitStringContents"in s&&(c.bitStringContents=s.bitStringContents,c.original=i.copy(c)),c},i.copy=function(e,t){var r;if(n.util.isArray(e)){r=[];for(var a=0;a<e.length;++a)r.push(i.copy(e[a],t));return r}return"string"==typeof e?e:(r={tagClass:e.tagClass,type:e.type,constructed:e.constructed,composed:e.composed,value:i.copy(e.value,t)},t&&!t.excludeBitStringContents&&(r.bitStringContents=e.bitStringContents),r)},i.equals=function(e,t,r){if(n.util.isArray(e)){if(!n.util.isArray(t))return!1;if(e.length!==t.length)return!1;for(var a=0;a<e.length;++a)if(!i.equals(e[a],t[a]))return!1;return!0}if(typeof e!=typeof t)return!1;if("string"==typeof e)return e===t;var s=e.tagClass===t.tagClass&&e.type===t.type&&e.constructed===t.constructed&&e.composed===t.composed&&i.equals(e.value,t.value);return r&&r.includeBitStringContents&&(s=s&&e.bitStringContents===t.bitStringContents),s},i.getBerValueLength=function(e){var t=e.getByte();if(128!==t)return 128&t?e.getInt((127&t)<<3):t};var s=function(e,t){var r=e.getByte();if(t--,128!==r){var n;if(128&r){var i=127&r;a(e,t,i),n=e.getInt(i<<3)}else n=r;if(n<0)throw new Error("Negative length: "+n);return n}};i.fromDer=function(e,t){return void 0===t&&(t={strict:!0,decodeBitStrings:!0}),"boolean"==typeof t&&(t={strict:t,decodeBitStrings:!0}),"strict"in t||(t.strict=!0),"decodeBitStrings"in t||(t.decodeBitStrings=!0),"string"==typeof e&&(e=n.util.createBuffer(e)),function e(t,r,n,o){var u;a(t,r,2);var c=t.getByte();r--;var l=192&c,f=31&c;u=t.length();var h,p,d=s(t,r);if(r-=u-t.length(),void 0!==d&&d>r){if(o.strict){var y=new Error("Too few bytes to read ASN.1 value.");throw y.available=t.length(),y.remaining=r,y.requested=d,y}d=r}var g=32==(32&c);if(g)if(h=[],void 0===d)for(;;){if(a(t,r,2),t.bytes(2)===String.fromCharCode(0,0)){t.getBytes(2),r-=2;break}u=t.length(),h.push(e(t,r,n+1,o)),r-=u-t.length()}else for(;d>0;)u=t.length(),h.push(e(t,d,n+1,o)),r-=u-t.length(),d-=u-t.length();void 0===h&&l===i.Class.UNIVERSAL&&f===i.Type.BITSTRING&&(p=t.bytes(d));if(void 0===h&&o.decodeBitStrings&&l===i.Class.UNIVERSAL&&f===i.Type.BITSTRING&&d>1){var m=t.read,v=r,b=0;if(f===i.Type.BITSTRING&&(a(t,r,1),b=t.getByte(),r--),0===b)try{u=t.length();var E={verbose:o.verbose,strict:!0,decodeBitStrings:!0},S=e(t,r,n+1,E),T=u-t.length();r-=T,f==i.Type.BITSTRING&&T++;var C=S.tagClass;T!==d||C!==i.Class.UNIVERSAL&&C!==i.Class.CONTEXT_SPECIFIC||(h=[S])}catch(e){}void 0===h&&(t.read=m,r=v)}if(void 0===h){if(void 0===d){if(o.strict)throw new Error("Non-constructed ASN.1 object of indefinite length.");d=r}if(f===i.Type.BMPSTRING)for(h="";d>0;d-=2)a(t,r,2),h+=String.fromCharCode(t.getInt16()),r-=2;else h=t.getBytes(d)}var A=void 0===p?null:{bitStringContents:p};return i.create(l,f,g,h,A)}(e,e.length(),0,t)},i.toDer=function(e){var t=n.util.createBuffer(),r=e.tagClass|e.type,a=n.util.createBuffer(),s=!1;if("bitStringContents"in e&&(s=!0,e.original&&(s=i.equals(e,e.original))),s)a.putBytes(e.bitStringContents);else if(e.composed){e.constructed?r|=32:a.putByte(0);for(var o=0;o<e.value.length;++o)void 0!==e.value[o]&&a.putBuffer(i.toDer(e.value[o]))}else if(e.type===i.Type.BMPSTRING)for(o=0;o<e.value.length;++o)a.putInt16(e.value.charCodeAt(o));else e.type===i.Type.INTEGER&&e.value.length>1&&(0===e.value.charCodeAt(0)&&0==(128&e.value.charCodeAt(1))||255===e.value.charCodeAt(0)&&128==(128&e.value.charCodeAt(1)))?a.putBytes(e.value.substr(1)):a.putBytes(e.value);if(t.putByte(r),a.length()<=127)t.putByte(127&a.length());else{var u=a.length(),c="";do{c+=String.fromCharCode(255&u),u>>>=8}while(u>0);t.putByte(128|c.length);for(o=c.length-1;o>=0;--o)t.putByte(c.charCodeAt(o))}return t.putBuffer(a),t},i.oidToDer=function(e){var t,r,i,a,s=e.split("."),o=n.util.createBuffer();o.putByte(40*parseInt(s[0],10)+parseInt(s[1],10));for(var u=2;u<s.length;++u){t=!0,r=[],i=parseInt(s[u],10);do{a=127&i,i>>>=7,t||(a|=128),r.push(a),t=!1}while(i>0);for(var c=r.length-1;c>=0;--c)o.putByte(r[c])}return o},i.derToOid=function(e){var t;"string"==typeof e&&(e=n.util.createBuffer(e));var r=e.getByte();t=Math.floor(r/40)+"."+r%40;for(var i=0;e.length()>0;)i<<=7,128&(r=e.getByte())?i+=127&r:(t+="."+(i+r),i=0);return t},i.utcTimeToDate=function(e){var t=new Date,r=parseInt(e.substr(0,2),10);r=r>=50?1900+r:2e3+r;var n=parseInt(e.substr(2,2),10)-1,i=parseInt(e.substr(4,2),10),a=parseInt(e.substr(6,2),10),s=parseInt(e.substr(8,2),10),o=0;if(e.length>11){var u=e.charAt(10),c=10;"+"!==u&&"-"!==u&&(o=parseInt(e.substr(10,2),10),c+=2)}if(t.setUTCFullYear(r,n,i),t.setUTCHours(a,s,o,0),c&&("+"===(u=e.charAt(c))||"-"===u)){var l=60*parseInt(e.substr(c+1,2),10)+parseInt(e.substr(c+4,2),10);l*=6e4,"+"===u?t.setTime(+t-l):t.setTime(+t+l)}return t},i.generalizedTimeToDate=function(e){var t=new Date,r=parseInt(e.substr(0,4),10),n=parseInt(e.substr(4,2),10)-1,i=parseInt(e.substr(6,2),10),a=parseInt(e.substr(8,2),10),s=parseInt(e.substr(10,2),10),o=parseInt(e.substr(12,2),10),u=0,c=0,l=!1;"Z"===e.charAt(e.length-1)&&(l=!0);var f=e.length-5,h=e.charAt(f);"+"!==h&&"-"!==h||(c=60*parseInt(e.substr(f+1,2),10)+parseInt(e.substr(f+4,2),10),c*=6e4,"+"===h&&(c*=-1),l=!0);return"."===e.charAt(14)&&(u=1e3*parseFloat(e.substr(14),10)),l?(t.setUTCFullYear(r,n,i),t.setUTCHours(a,s,o,u),t.setTime(+t+c)):(t.setFullYear(r,n,i),t.setHours(a,s,o,u)),t},i.dateToUtcTime=function(e){if("string"==typeof e)return e;var t="",r=[];r.push((""+e.getUTCFullYear()).substr(2)),r.push(""+(e.getUTCMonth()+1)),r.push(""+e.getUTCDate()),r.push(""+e.getUTCHours()),r.push(""+e.getUTCMinutes()),r.push(""+e.getUTCSeconds());for(var n=0;n<r.length;++n)r[n].length<2&&(t+="0"),t+=r[n];return t+="Z"},i.dateToGeneralizedTime=function(e){if("string"==typeof e)return e;var t="",r=[];r.push(""+e.getUTCFullYear()),r.push(""+(e.getUTCMonth()+1)),r.push(""+e.getUTCDate()),r.push(""+e.getUTCHours()),r.push(""+e.getUTCMinutes()),r.push(""+e.getUTCSeconds());for(var n=0;n<r.length;++n)r[n].length<2&&(t+="0"),t+=r[n];return t+="Z"},i.integerToDer=function(e){var t=n.util.createBuffer();if(e>=-128&&e<128)return t.putSignedInt(e,8);if(e>=-32768&&e<32768)return t.putSignedInt(e,16);if(e>=-8388608&&e<8388608)return t.putSignedInt(e,24);if(e>=-2147483648&&e<2147483648)return t.putSignedInt(e,32);var r=new Error("Integer too large; max is 32-bits.");throw r.integer=e,r},i.derToInteger=function(e){"string"==typeof e&&(e=n.util.createBuffer(e));var t=8*e.length();if(t>32)throw new Error("Integer too large; max is 32-bits.");return e.getSignedInt(t)},i.validate=function(e,t,r,a){var s=!1;if(e.tagClass!==t.tagClass&&void 0!==t.tagClass||e.type!==t.type&&void 0!==t.type)a&&(e.tagClass!==t.tagClass&&a.push("["+t.name+'] Expected tag class "'+t.tagClass+'", got "'+e.tagClass+'"'),e.type!==t.type&&a.push("["+t.name+'] Expected type "'+t.type+'", got "'+e.type+'"'));else if(e.constructed===t.constructed||void 0===t.constructed){if(s=!0,t.value&&n.util.isArray(t.value))for(var o=0,u=0;s&&u<t.value.length;++u)s=t.value[u].optional||!1,e.value[o]&&((s=i.validate(e.value[o],t.value[u],r,a))?++o:t.value[u].optional&&(s=!0)),!s&&a&&a.push("["+t.name+'] Tag class "'+t.tagClass+'", type "'+t.type+'" expected value length "'+t.value.length+'", got "'+e.value.length+'"');if(s&&r)if(t.capture&&(r[t.capture]=e.value),t.captureAsn1&&(r[t.captureAsn1]=e),t.captureBitStringContents&&"bitStringContents"in e&&(r[t.captureBitStringContents]=e.bitStringContents),t.captureBitStringValue&&"bitStringContents"in e)if(e.bitStringContents.length<2)r[t.captureBitStringValue]="";else{if(0!==e.bitStringContents.charCodeAt(0))throw new Error("captureBitStringValue only supported for zero unused bits");r[t.captureBitStringValue]=e.bitStringContents.slice(1)}}else a&&a.push("["+t.name+'] Expected constructed "'+t.constructed+'", got "'+e.constructed+'"');return s};var o=/[^\\u0000-\\u00ff]/;i.prettyPrint=function(e,t,r){var a="";r=r||2,(t=t||0)>0&&(a+="\n");for(var s="",u=0;u<t*r;++u)s+=" ";switch(a+=s+"Tag: ",e.tagClass){case i.Class.UNIVERSAL:a+="Universal:";break;case i.Class.APPLICATION:a+="Application:";break;case i.Class.CONTEXT_SPECIFIC:a+="Context-Specific:";break;case i.Class.PRIVATE:a+="Private:"}if(e.tagClass===i.Class.UNIVERSAL)switch(a+=e.type,e.type){case i.Type.NONE:a+=" (None)";break;case i.Type.BOOLEAN:a+=" (Boolean)";break;case i.Type.INTEGER:a+=" (Integer)";break;case i.Type.BITSTRING:a+=" (Bit string)";break;case i.Type.OCTETSTRING:a+=" (Octet string)";break;case i.Type.NULL:a+=" (Null)";break;case i.Type.OID:a+=" (Object Identifier)";break;case i.Type.ODESC:a+=" (Object Descriptor)";break;case i.Type.EXTERNAL:a+=" (External or Instance of)";break;case i.Type.REAL:a+=" (Real)";break;case i.Type.ENUMERATED:a+=" (Enumerated)";break;case i.Type.EMBEDDED:a+=" (Embedded PDV)";break;case i.Type.UTF8:a+=" (UTF8)";break;case i.Type.ROID:a+=" (Relative Object Identifier)";break;case i.Type.SEQUENCE:a+=" (Sequence)";break;case i.Type.SET:a+=" (Set)";break;case i.Type.PRINTABLESTRING:a+=" (Printable String)";break;case i.Type.IA5String:a+=" (IA5String (ASCII))";break;case i.Type.UTCTIME:a+=" (UTC time)";break;case i.Type.GENERALIZEDTIME:a+=" (Generalized time)";break;case i.Type.BMPSTRING:a+=" (BMP String)"}else a+=e.type;if(a+="\n",a+=s+"Constructed: "+e.constructed+"\n",e.composed){var c=0,l="";for(u=0;u<e.value.length;++u)void 0!==e.value[u]&&(c+=1,l+=i.prettyPrint(e.value[u],t+1,r),u+1<e.value.length&&(l+=","));a+=s+"Sub values: "+c+l}else{if(a+=s+"Value: ",e.type===i.Type.OID){var f=i.derToOid(e.value);a+=f,n.pki&&n.pki.oids&&f in n.pki.oids&&(a+=" ("+n.pki.oids[f]+") ")}if(e.type===i.Type.INTEGER)try{a+=i.derToInteger(e.value)}catch(t){a+="0x"+n.util.bytesToHex(e.value)}else if(e.type===i.Type.BITSTRING){if(e.value.length>1?a+="0x"+n.util.bytesToHex(e.value.slice(1)):a+="(none)",e.value.length>0){var h=e.value.charCodeAt(0);1==h?a+=" (1 unused bit shown)":h>1&&(a+=" ("+h+" unused bits shown)")}}else e.type===i.Type.OCTETSTRING?(o.test(e.value)||(a+="("+e.value+") "),a+="0x"+n.util.bytesToHex(e.value)):e.type===i.Type.UTF8?a+=n.util.decodeUtf8(e.value):e.type===i.Type.PRINTABLESTRING||e.type===i.Type.IA5String?a+=e.value:o.test(e.value)?a+="0x"+n.util.bytesToHex(e.value):0===e.value.length?a+="[null]":a+=e.value}return a}},function(e,t,r){var n=r(1);n.pki=n.pki||{};var i=e.exports=n.pki.oids=n.oids=n.oids||{};function a(e,t){i[e]=t,i[t]=e}function s(e,t){i[e]=t}a("1.2.840.113549.1.1.1","rsaEncryption"),a("1.2.840.113549.1.1.4","md5WithRSAEncryption"),a("1.2.840.113549.1.1.5","sha1WithRSAEncryption"),a("1.2.840.113549.1.1.7","RSAES-OAEP"),a("1.2.840.113549.1.1.8","mgf1"),a("1.2.840.113549.1.1.9","pSpecified"),a("1.2.840.113549.1.1.10","RSASSA-PSS"),a("1.2.840.113549.1.1.11","sha256WithRSAEncryption"),a("1.2.840.113549.1.1.12","sha384WithRSAEncryption"),a("1.2.840.113549.1.1.13","sha512WithRSAEncryption"),a("1.2.840.10040.4.3","dsa-with-sha1"),a("1.3.14.3.2.7","desCBC"),a("1.3.14.3.2.26","sha1"),a("2.16.840.1.101.3.4.2.1","sha256"),a("2.16.840.1.101.3.4.2.2","sha384"),a("2.16.840.1.101.3.4.2.3","sha512"),a("1.2.840.113549.2.5","md5"),a("1.2.840.113549.1.7.1","data"),a("1.2.840.113549.1.7.2","signedData"),a("1.2.840.113549.1.7.3","envelopedData"),a("1.2.840.113549.1.7.4","signedAndEnvelopedData"),a("1.2.840.113549.1.7.5","digestedData"),a("1.2.840.113549.1.7.6","encryptedData"),a("1.2.840.113549.1.9.1","emailAddress"),a("1.2.840.113549.1.9.2","unstructuredName"),a("1.2.840.113549.1.9.3","contentType"),a("1.2.840.113549.1.9.4","messageDigest"),a("1.2.840.113549.1.9.5","signingTime"),a("1.2.840.113549.1.9.6","counterSignature"),a("1.2.840.113549.1.9.7","challengePassword"),a("1.2.840.113549.1.9.8","unstructuredAddress"),a("1.2.840.113549.1.9.14","extensionRequest"),a("1.2.840.113549.1.9.20","friendlyName"),a("1.2.840.113549.1.9.21","localKeyId"),a("1.2.840.113549.1.9.22.1","x509Certificate"),a("1.2.840.113549.1.12.10.1.1","keyBag"),a("1.2.840.113549.1.12.10.1.2","pkcs8ShroudedKeyBag"),a("1.2.840.113549.1.12.10.1.3","certBag"),a("1.2.840.113549.1.12.10.1.4","crlBag"),a("1.2.840.113549.1.12.10.1.5","secretBag"),a("1.2.840.113549.1.12.10.1.6","safeContentsBag"),a("1.2.840.113549.1.5.13","pkcs5PBES2"),a("1.2.840.113549.1.5.12","pkcs5PBKDF2"),a("1.2.840.113549.1.12.1.1","pbeWithSHAAnd128BitRC4"),a("1.2.840.113549.1.12.1.2","pbeWithSHAAnd40BitRC4"),a("1.2.840.113549.1.12.1.3","pbeWithSHAAnd3-KeyTripleDES-CBC"),a("1.2.840.113549.1.12.1.4","pbeWithSHAAnd2-KeyTripleDES-CBC"),a("1.2.840.113549.1.12.1.5","pbeWithSHAAnd128BitRC2-CBC"),a("1.2.840.113549.1.12.1.6","pbewithSHAAnd40BitRC2-CBC"),a("1.2.840.113549.2.7","hmacWithSHA1"),a("1.2.840.113549.2.8","hmacWithSHA224"),a("1.2.840.113549.2.9","hmacWithSHA256"),a("1.2.840.113549.2.10","hmacWithSHA384"),a("1.2.840.113549.2.11","hmacWithSHA512"),a("1.2.840.113549.3.7","des-EDE3-CBC"),a("2.16.840.1.101.3.4.1.2","aes128-CBC"),a("2.16.840.1.101.3.4.1.22","aes192-CBC"),a("2.16.840.1.101.3.4.1.42","aes256-CBC"),a("2.5.4.3","commonName"),a("2.5.4.5","serialName"),a("2.5.4.6","countryName"),a("2.5.4.7","localityName"),a("2.5.4.8","stateOrProvinceName"),a("2.5.4.10","organizationName"),a("2.5.4.11","organizationalUnitName"),a("2.5.4.13","description"),a("2.16.840.1.113730.1.1","nsCertType"),a("2.16.840.1.113730.1.13","nsComment"),s("2.5.29.1","authorityKeyIdentifier"),s("2.5.29.2","keyAttributes"),s("2.5.29.3","certificatePolicies"),s("2.5.29.4","keyUsageRestriction"),s("2.5.29.5","policyMapping"),s("2.5.29.6","subtreesConstraint"),s("2.5.29.7","subjectAltName"),s("2.5.29.8","issuerAltName"),s("2.5.29.9","subjectDirectoryAttributes"),s("2.5.29.10","basicConstraints"),s("2.5.29.11","nameConstraints"),s("2.5.29.12","policyConstraints"),s("2.5.29.13","basicConstraints"),a("2.5.29.14","subjectKeyIdentifier"),a("2.5.29.15","keyUsage"),s("2.5.29.16","privateKeyUsagePeriod"),a("2.5.29.17","subjectAltName"),a("2.5.29.18","issuerAltName"),a("2.5.29.19","basicConstraints"),s("2.5.29.20","cRLNumber"),s("2.5.29.21","cRLReason"),s("2.5.29.22","expirationDate"),s("2.5.29.23","instructionCode"),s("2.5.29.24","invalidityDate"),s("2.5.29.25","cRLDistributionPoints"),s("2.5.29.26","issuingDistributionPoint"),s("2.5.29.27","deltaCRLIndicator"),s("2.5.29.28","issuingDistributionPoint"),s("2.5.29.29","certificateIssuer"),s("2.5.29.30","nameConstraints"),a("2.5.29.31","cRLDistributionPoints"),a("2.5.29.32","certificatePolicies"),s("2.5.29.33","policyMappings"),s("2.5.29.34","policyConstraints"),a("2.5.29.35","authorityKeyIdentifier"),s("2.5.29.36","policyConstraints"),a("2.5.29.37","extKeyUsage"),s("2.5.29.46","freshestCRL"),s("2.5.29.54","inhibitAnyPolicy"),a("1.3.6.1.4.1.11129.2.4.2","timestampList"),a("1.3.6.1.5.5.7.1.1","authorityInfoAccess"),a("1.3.6.1.5.5.7.3.1","serverAuth"),a("1.3.6.1.5.5.7.3.2","clientAuth"),a("1.3.6.1.5.5.7.3.3","codeSigning"),a("1.3.6.1.5.5.7.3.4","emailProtection"),a("1.3.6.1.5.5.7.3.8","timeStamping")},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t){var r,n,i=e.exports={};function a(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function o(e){if(r===setTimeout)return setTimeout(e,0);if((r===a||!r)&&setTimeout)return r=setTimeout,setTimeout(e,0);try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:a}catch(e){r=a}try{n="function"==typeof clearTimeout?clearTimeout:s}catch(e){n=s}}();var u,c=[],l=!1,f=-1;function h(){l&&u&&(l=!1,u.length?c=u.concat(c):f=-1,c.length&&p())}function p(){if(!l){var e=o(h);l=!0;for(var t=c.length;t;){for(u=c,c=[];++f<t;)u&&u[f].run();f=-1,t=c.length}u=null,l=!1,function(e){if(n===clearTimeout)return clearTimeout(e);if((n===s||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(e);try{n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}(e)}}function d(e,t){this.fun=e,this.array=t}function y(){}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];c.push(new d(e,t)),1!==c.length||l||o(p)},d.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=y,i.addListener=y,i.once=y,i.off=y,i.removeListener=y,i.removeAllListeners=y,i.emit=y,i.prependListener=y,i.prependOnceListener=y,i.listeners=function(e){return[]},i.binding=function(e){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(e){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,a=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=a.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=a.return)&&r.call(a)}finally{if(i)throw i.error}}return s},i=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(n(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var a=r(11);t.concat=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return e.reduce((function(e,t){return Uint8Array.from(i(e,a._fromIn(t)))}),new Uint8Array(0))},t.split=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var n=t.reduce((function(e,t){return{arr:e.arr.slice(t),r:i(e.r,[e.arr.slice(0,t)])}}),{arr:a._fromIn(e),r:[]}),s=n.r,o=n.arr;return i(s,[o])}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PUBLIC_KEY_LENGTH=32,t.PRIVATE_KEY_LENGTH=32,t.SIGNATURE_LENGTH=64,t.ADDRESS_LENGTH=26,t.MAIN_NET_CHAIN_ID=87,t.TEST_NET_CHAIN_ID=84},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(26),i=r(37),a=r(112),s=r(67);var o;!function(e){e[e.GENESIS=1]="GENESIS",e[e.PAYMENT=2]="PAYMENT",e[e.ISSUE=3]="ISSUE",e[e.TRANSFER=4]="TRANSFER",e[e.REISSUE=5]="REISSUE",e[e.BURN=6]="BURN",e[e.EXCHANGE=7]="EXCHANGE",e[e.LEASE=8]="LEASE",e[e.CANCEL_LEASE=9]="CANCEL_LEASE",e[e.ALIAS=10]="ALIAS",e[e.MASS_TRANSFER=11]="MASS_TRANSFER",e[e.DATA=12]="DATA",e[e.SET_SCRIPT=13]="SET_SCRIPT",e[e.SPONSORSHIP=14]="SPONSORSHIP",e[e.SET_ASSET_SCRIPT=15]="SET_ASSET_SCRIPT",e[e.INVOKE_SCRIPT=16]="INVOKE_SCRIPT"}(o=t.TRANSACTION_TYPE||(t.TRANSACTION_TYPE={}));const u={toBytes:n.SHORT,fromBytes:i.P_SHORT},c={toBytes:n.INT,fromBytes:i.P_INT};var l;!function(e){e.longField=e=>[e,{toBytes:n.LONG,fromBytes:i.P_LONG}],e.byteField=e=>[e,{toBytes:n.BYTE,fromBytes:i.P_BYTE}],e.booleanField=e=>[e,{toBytes:n.BOOL,fromBytes:i.P_BOOLEAN}],e.stringField=e=>[e,{toBytes:n.LEN(n.SHORT)(n.STRING),fromBytes:i.P_STRING_VAR(i.P_SHORT)}],e.base58field32=e=>[e,{toBytes:n.BASE58_STRING,fromBytes:i.P_BASE58_FIXED(32)}],e.base58Option32=e=>[e,{toBytes:e=>"WAVES"===e?n.OPTION(n.BASE58_STRING)(null):n.OPTION(n.BASE58_STRING)(e),fromBytes:i.P_OPTION(i.P_BASE58_FIXED(32))}],e.base64field=e=>[e,{toBytes:n.LEN(n.SHORT)(n.BASE64_STRING),fromBytes:i.P_BASE64(i.P_SHORT)}],e.byteConstant=e=>["noname",{toBytes:()=>Uint8Array.from([e]),fromBytes:()=>({value:void 0,shift:1})}],e.alias=["alias",{toBytes:n.LEN(n.SHORT)(n.STRING),fromBytes:i.byteNewAliasToString}],e.amount=e.longField("amount"),e.assetDescription=e.stringField("description"),e.assetId=e.base58field32("assetId"),e.assetName=e.stringField("name"),e.attachment=["attachment",{toBytes:n.LEN(n.SHORT)(n.BASE58_STRING),fromBytes:i.P_BASE58_VAR(i.P_SHORT)}],e.chainId=e.byteField("chainId"),e.decimals=e.byteField("decimals"),e.fee=e.longField("fee"),e.leaseAssetId=e.base58Option32("leaseAssetId"),e.leaseId=e.base58field32("leaseId"),e.optionalAssetId=e.base58Option32("assetId"),e.quantity=e.longField("quantity"),e.reissuable=e.booleanField("reissuable"),e.recipient=["recipient",{toBytes:n.ADDRESS_OR_ALIAS,fromBytes:i.byteToAddressOrAlias}],e.script=["script",{toBytes:n.SCRIPT,fromBytes:i.byteToScript}],e.senderPublicKey=e.base58field32("senderPublicKey"),e.signature=["signature",{toBytes:n.BASE58_STRING,fromBytes:i.P_BASE58_FIXED(64)}],e.timestamp=e.longField("timestamp"),e.type=e.byteField("type"),e.version=e.byteField("version"),e.proofs=["proofs",{type:"array",items:{toBytes:n.LEN(n.SHORT)(n.BASE58_STRING),fromBytes:i.P_BASE58_VAR(i.P_SHORT)}}];const t={type:"object",schema:[e.recipient,e.amount]};e.transfers=["transfers",{type:"array",items:t}];const r={type:"dataTxField",items:new Map([[a.DATA_FIELD_TYPE.INTEGER,{toBytes:n.LONG,fromBytes:i.P_LONG}],[a.DATA_FIELD_TYPE.BOOLEAN,{toBytes:n.BOOL,fromBytes:i.P_BOOLEAN}],[a.DATA_FIELD_TYPE.BINARY,{toBytes:n.LEN(n.SHORT)(n.BASE64_STRING),fromBytes:i.P_BASE64(i.P_SHORT)}],[a.DATA_FIELD_TYPE.STRING,{toBytes:n.LEN(n.SHORT)(n.STRING),fromBytes:i.P_STRING_VAR(i.P_SHORT)}]])};e.data=["data",{type:"array",items:r}];const s=a.anyOf([[0,{toBytes:n.LONG,fromBytes:i.P_LONG},"integer"],[1,{toBytes:n.LEN(n.INT)(n.BASE64_STRING),fromBytes:i.P_BASE64(i.P_INT)},"binary"],[2,{toBytes:n.LEN(n.INT)(n.STRING),fromBytes:i.P_STRING_VAR(i.P_INT)},"string"],[6,{toBytes:()=>Uint8Array.from([]),fromBytes:()=>({value:!0,shift:0})},"boolean"],[7,{toBytes:()=>Uint8Array.from([]),fromBytes:()=>({value:!1,shift:0})},"boolean"]],{valueField:"value"});e.functionCall=["call",{type:"object",optional:!0,schema:[e.byteConstant(9),e.byteConstant(1),["function",{toBytes:n.LEN(n.INT)(n.STRING),fromBytes:i.P_STRING_VAR(i.P_INT)}],["args",{type:"array",toBytes:n.INT,fromBytes:i.P_INT,items:s}]]}],e.payment={type:"object",withLength:u,schema:[e.amount,e.optionalAssetId]},e.payments=["payment",{type:"array",items:e.payment}]}(l=t.txFields||(t.txFields={})),t.orderSchemaV1={type:"object",schema:[l.senderPublicKey,l.base58field32("matcherPublicKey"),["assetPair",{type:"object",schema:[l.base58Option32("amountAsset"),l.base58Option32("priceAsset")]}],["orderType",{toBytes:e=>n.BYTE("sell"===e?1:0),fromBytes:(e,t=0)=>1===i.P_BYTE(e,t).value?{value:"sell",shift:1}:{value:"buy",shift:1}}],l.longField("price"),l.longField("amount"),l.timestamp,l.longField("expiration"),l.longField("matcherFee")]},t.orderSchemaV2={type:"object",schema:[l.version,...t.orderSchemaV1.schema]},t.orderSchemaV3={type:"object",schema:[...t.orderSchemaV2.schema,["matcherFeeAssetId",l.optionalAssetId[1]]]},t.aliasSchemaV2={type:"object",schema:[l.type,l.version,l.senderPublicKey,[["alias","chainId"],{type:"object",withLength:u,schema:[l.byteConstant(2),l.chainId,l.alias]}],l.fee,l.timestamp]},t.burnSchemaV2={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.assetId,l.quantity,l.fee,l.timestamp]},t.cancelLeaseSchemaV2={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.fee,l.timestamp,l.leaseId]},t.invokeScriptSchemaV1={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,["dApp",l.recipient[1]],l.functionCall,l.payments,l.fee,["feeAssetId",l.optionalAssetId[1]],l.timestamp]},t.dataSchemaV1={type:"object",schema:[l.type,l.version,l.senderPublicKey,l.data,l.timestamp,l.fee]},t.proofsSchemaV0={type:"object",schema:[["signature",{toBytes:n.BASE58_STRING,fromBytes:i.P_BASE58_FIXED(64)}]]},t.proofsSchemaV1={type:"object",schema:[l.byteConstant(1),l.proofs]};const f={type:"object",schema:[...t.orderSchemaV1.schema,l.signature]};t.exchangeSchemaV1={type:"object",schema:[l.type,["order1",{fromBytes:()=>({value:void 0,shift:4}),toBytes:e=>n.INT(s.serializerFromSchema(f)(e).length)}],["order2",{fromBytes:()=>({value:void 0,shift:4}),toBytes:e=>n.INT(s.serializerFromSchema(f)(e).length)}],["order1",f],["order2",f],l.longField("price"),l.longField("amount"),l.longField("buyMatcherFee"),l.longField("sellMatcherFee"),l.longField("fee"),l.longField("timestamp")]};const h=a.anyOf([[1,{type:"object",withLength:{toBytes:e=>n.INT(e-1),fromBytes:e=>{const{value:t,shift:r}=i.P_INT(e);return{value:t+1,shift:r}}},schema:[l.byteConstant(1),...t.orderSchemaV1.schema,...t.proofsSchemaV0.schema]}],[2,{type:"object",withLength:c,schema:[...t.orderSchemaV2.schema,...t.proofsSchemaV1.schema]}]],{discriminatorField:"version",discriminatorBytePos:4});t.exchangeSchemaV2={type:"object",schema:[l.byteConstant(0),l.type,l.version,["order1",h],["order2",h],l.longField("price"),l.longField("amount"),l.longField("buyMatcherFee"),l.longField("sellMatcherFee"),l.longField("fee"),l.longField("timestamp")]},t.issueSchemaV2={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.assetName,l.assetDescription,l.quantity,l.decimals,l.reissuable,l.fee,l.timestamp,l.script]},t.leaseSchemaV2={type:"object",schema:[l.type,l.version,l.leaseAssetId,l.senderPublicKey,l.recipient,l.amount,l.fee,l.timestamp]},t.massTransferSchemaV1={type:"object",schema:[l.type,l.version,l.senderPublicKey,l.optionalAssetId,l.transfers,l.timestamp,l.fee,l.attachment]},t.reissueSchemaV2={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.assetId,l.quantity,l.reissuable,l.fee,l.timestamp]},t.setAssetScriptSchemaV1={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.assetId,l.fee,l.timestamp,l.script]},t.setScriptSchemaV1={type:"object",schema:[l.type,l.version,l.chainId,l.senderPublicKey,l.script,l.fee,l.timestamp]},t.sponsorshipSchemaV1={type:"object",schema:[l.type,l.version,l.senderPublicKey,l.assetId,l.longField("minSponsoredAssetFee"),l.fee,l.timestamp]},t.transferSchemaV2={type:"object",schema:[l.type,l.version,l.senderPublicKey,l.optionalAssetId,["feeAssetId",l.optionalAssetId[1]],l.timestamp,l.amount,l.fee,l.recipient,l.attachment]},t.schemasByTypeMap={[o.GENESIS]:{},[o.PAYMENT]:{},[o.ISSUE]:{2:t.issueSchemaV2},[o.TRANSFER]:{2:t.transferSchemaV2},[o.REISSUE]:{2:t.reissueSchemaV2},[o.BURN]:{2:t.burnSchemaV2},[o.EXCHANGE]:{1:t.exchangeSchemaV1,2:t.exchangeSchemaV2},[o.LEASE]:{2:t.leaseSchemaV2},[o.CANCEL_LEASE]:{2:t.cancelLeaseSchemaV2},[o.ALIAS]:{2:t.aliasSchemaV2},[o.MASS_TRANSFER]:{1:t.massTransferSchemaV1},[o.DATA]:{1:t.dataSchemaV1},[o.SET_SCRIPT]:{1:t.setScriptSchemaV1},[o.SPONSORSHIP]:{1:t.sponsorshipSchemaV1},[o.SET_ASSET_SCRIPT]:{1:t.setAssetScriptSchemaV1},[o.INVOKE_SCRIPT]:{1:t.invokeScriptSchemaV1}},t.orderVersionMap={1:t.orderSchemaV1,2:t.orderSchemaV2,3:t.orderSchemaV3},t.getTransactionSchema=function(e,r){const n=t.schemasByTypeMap[e];if("object"!=typeof n)throw new Error(`Incorrect tx type: ${e}`);const i=n[r||1];if("object"!=typeof i)throw new Error(`Incorrect tx version: ${r}`);return i}},function(e,t,r){"use strict";(function(e){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var i=n(r(12)),a=r(53),s=r(10),o=function(e){return s.stringToBytes(i.default.getBytesSync(e),"raw")};t.random=function(r,n){switch(n){case"Array8":return Array.from(o(r));case"Array16":return Array.from(t.random(r,"Uint16Array"));case"Array32":return Array.from(t.random(r,"Uint32Array"));case"Buffer":return function(){try{new e(1)}catch(e){throw new Error("Buffer not supported in this environment. Use Node.js or Browserify for browser support.")}}(),e.from(o(r));case"Uint8Array":return o(r);case"Uint16Array":return new Uint16Array(r).map((function(e){return o(2).reduce((function(e,t,r){return e|t<<8*(1-r)}),0)}));case"Uint32Array":return new Uint32Array(r).map((function(e){return o(4).reduce((function(e,t,r){return e|t<<8*(1-r)}),0)}));default:throw new Error(n+" is unsupported.")}},t.randomBytes=function(e){return t.random(e,"Uint8Array")},t.randomSeed=function(e){return void 0===e&&(e=15),t.random(e,"Array32").map((function(e){return a.seedWordsList[e%a.seedWordsList.length]})).join(" ")}}).call(this,r(13).Buffer)},function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var i=r(2),a=n(r(92)),s=r(11),o=r(10);t.base64Decode=function(e){return o.stringToBytes(i.decode64(e),"raw")},t.base64Encode=function(e){return i.encode64(o.bytesToString(s._fromIn(e),"raw"))},t.base58Decode=function(e){return a.default.decode(e)},t.base58Encode=function(e){return a.default.encode(s._fromIn(e))},t.base16Decode=function(e){return o.stringToBytes(i.hexToBytes(e),"raw")},t.base16Encode=function(e){return i.bytesToHex(o.bytesToString(s._fromIn(e),"raw"))}},function(e,t,r){"use strict";t.__esModule=!0;var n=Object.create(null),i=function(e){var t,r=new Float64Array(16);if(e)for(t=0;t<e.length;t++)r[t]=e[t];return r},a=(new Uint8Array(16),new Uint8Array(32));a[0]=9;var s=i(),o=i([1]),u=i([56129,1]),c=i([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),l=i([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),f=i([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),h=i([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),p=i([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function d(e,t,r,n){e[t]=r>>24&255,e[t+1]=r>>16&255,e[t+2]=r>>8&255,e[t+3]=255&r,e[t+4]=n>>24&255,e[t+5]=n>>16&255,e[t+6]=n>>8&255,e[t+7]=255&n}function y(e,t,r,n){return function(e,t,r,n,i){var a,s=0;for(a=0;a<i;a++)s|=e[t+a]^r[n+a];return(1&s-1>>>8)-1}(e,t,r,n,32)}function g(e,t){for(var r=0;r<16;r++)e[r]=0|t[r]}function m(e){var t,r,n=1;for(t=0;t<16;t++)r=e[t]+n+65535,n=Math.floor(r/65536),e[t]=r-65536*n;e[0]+=n-1+37*(n-1)}function v(e,t,r){for(var n,i=~(r-1),a=0;a<16;a++)n=i&(e[a]^t[a]),e[a]^=n,t[a]^=n}function b(e,t){var r,n,a,s=i(),o=i();for(r=0;r<16;r++)o[r]=t[r];for(m(o),m(o),m(o),n=0;n<2;n++){for(s[0]=o[0]-65517,r=1;r<15;r++)s[r]=o[r]-65535-(s[r-1]>>16&1),s[r-1]&=65535;s[15]=o[15]-32767-(s[14]>>16&1),a=s[15]>>16&1,s[14]&=65535,v(o,s,1-a)}for(r=0;r<16;r++)e[2*r]=255&o[r],e[2*r+1]=o[r]>>8}function E(e,t){var r=new Uint8Array(32),n=new Uint8Array(32);return b(r,e),b(n,t),y(r,0,n,0)}function S(e){var t=new Uint8Array(32);return b(t,e),1&t[0]}function T(e,t){for(var r=0;r<16;r++)e[r]=t[2*r]+(t[2*r+1]<<8);e[15]&=32767}function C(e,t,r){for(var n=0;n<16;n++)e[n]=t[n]+r[n]}function A(e,t,r){for(var n=0;n<16;n++)e[n]=t[n]-r[n]}function I(e,t,r){var n,i,a=0,s=0,o=0,u=0,c=0,l=0,f=0,h=0,p=0,d=0,y=0,g=0,m=0,v=0,b=0,E=0,S=0,T=0,C=0,A=0,I=0,w=0,B=0,N=0,R=0,_=0,P=0,O=0,k=0,U=0,L=0,D=r[0],V=r[1],x=r[2],K=r[3],M=r[4],j=r[5],F=r[6],q=r[7],z=r[8],G=r[9],H=r[10],Y=r[11],Q=r[12],W=r[13],X=r[14],$=r[15];a+=(n=t[0])*D,s+=n*V,o+=n*x,u+=n*K,c+=n*M,l+=n*j,f+=n*F,h+=n*q,p+=n*z,d+=n*G,y+=n*H,g+=n*Y,m+=n*Q,v+=n*W,b+=n*X,E+=n*$,s+=(n=t[1])*D,o+=n*V,u+=n*x,c+=n*K,l+=n*M,f+=n*j,h+=n*F,p+=n*q,d+=n*z,y+=n*G,g+=n*H,m+=n*Y,v+=n*Q,b+=n*W,E+=n*X,S+=n*$,o+=(n=t[2])*D,u+=n*V,c+=n*x,l+=n*K,f+=n*M,h+=n*j,p+=n*F,d+=n*q,y+=n*z,g+=n*G,m+=n*H,v+=n*Y,b+=n*Q,E+=n*W,S+=n*X,T+=n*$,u+=(n=t[3])*D,c+=n*V,l+=n*x,f+=n*K,h+=n*M,p+=n*j,d+=n*F,y+=n*q,g+=n*z,m+=n*G,v+=n*H,b+=n*Y,E+=n*Q,S+=n*W,T+=n*X,C+=n*$,c+=(n=t[4])*D,l+=n*V,f+=n*x,h+=n*K,p+=n*M,d+=n*j,y+=n*F,g+=n*q,m+=n*z,v+=n*G,b+=n*H,E+=n*Y,S+=n*Q,T+=n*W,C+=n*X,A+=n*$,l+=(n=t[5])*D,f+=n*V,h+=n*x,p+=n*K,d+=n*M,y+=n*j,g+=n*F,m+=n*q,v+=n*z,b+=n*G,E+=n*H,S+=n*Y,T+=n*Q,C+=n*W,A+=n*X,I+=n*$,f+=(n=t[6])*D,h+=n*V,p+=n*x,d+=n*K,y+=n*M,g+=n*j,m+=n*F,v+=n*q,b+=n*z,E+=n*G,S+=n*H,T+=n*Y,C+=n*Q,A+=n*W,I+=n*X,w+=n*$,h+=(n=t[7])*D,p+=n*V,d+=n*x,y+=n*K,g+=n*M,m+=n*j,v+=n*F,b+=n*q,E+=n*z,S+=n*G,T+=n*H,C+=n*Y,A+=n*Q,I+=n*W,w+=n*X,B+=n*$,p+=(n=t[8])*D,d+=n*V,y+=n*x,g+=n*K,m+=n*M,v+=n*j,b+=n*F,E+=n*q,S+=n*z,T+=n*G,C+=n*H,A+=n*Y,I+=n*Q,w+=n*W,B+=n*X,N+=n*$,d+=(n=t[9])*D,y+=n*V,g+=n*x,m+=n*K,v+=n*M,b+=n*j,E+=n*F,S+=n*q,T+=n*z,C+=n*G,A+=n*H,I+=n*Y,w+=n*Q,B+=n*W,N+=n*X,R+=n*$,y+=(n=t[10])*D,g+=n*V,m+=n*x,v+=n*K,b+=n*M,E+=n*j,S+=n*F,T+=n*q,C+=n*z,A+=n*G,I+=n*H,w+=n*Y,B+=n*Q,N+=n*W,R+=n*X,_+=n*$,g+=(n=t[11])*D,m+=n*V,v+=n*x,b+=n*K,E+=n*M,S+=n*j,T+=n*F,C+=n*q,A+=n*z,I+=n*G,w+=n*H,B+=n*Y,N+=n*Q,R+=n*W,_+=n*X,P+=n*$,m+=(n=t[12])*D,v+=n*V,b+=n*x,E+=n*K,S+=n*M,T+=n*j,C+=n*F,A+=n*q,I+=n*z,w+=n*G,B+=n*H,N+=n*Y,R+=n*Q,_+=n*W,P+=n*X,O+=n*$,v+=(n=t[13])*D,b+=n*V,E+=n*x,S+=n*K,T+=n*M,C+=n*j,A+=n*F,I+=n*q,w+=n*z,B+=n*G,N+=n*H,R+=n*Y,_+=n*Q,P+=n*W,O+=n*X,k+=n*$,b+=(n=t[14])*D,E+=n*V,S+=n*x,T+=n*K,C+=n*M,A+=n*j,I+=n*F,w+=n*q,B+=n*z,N+=n*G,R+=n*H,_+=n*Y,P+=n*Q,O+=n*W,k+=n*X,U+=n*$,E+=(n=t[15])*D,s+=38*(T+=n*x),o+=38*(C+=n*K),u+=38*(A+=n*M),c+=38*(I+=n*j),l+=38*(w+=n*F),f+=38*(B+=n*q),h+=38*(N+=n*z),p+=38*(R+=n*G),d+=38*(_+=n*H),y+=38*(P+=n*Y),g+=38*(O+=n*Q),m+=38*(k+=n*W),v+=38*(U+=n*X),b+=38*(L+=n*$),a=(n=(a+=38*(S+=n*V))+(i=1)+65535)-65536*(i=Math.floor(n/65536)),s=(n=s+i+65535)-65536*(i=Math.floor(n/65536)),o=(n=o+i+65535)-65536*(i=Math.floor(n/65536)),u=(n=u+i+65535)-65536*(i=Math.floor(n/65536)),c=(n=c+i+65535)-65536*(i=Math.floor(n/65536)),l=(n=l+i+65535)-65536*(i=Math.floor(n/65536)),f=(n=f+i+65535)-65536*(i=Math.floor(n/65536)),h=(n=h+i+65535)-65536*(i=Math.floor(n/65536)),p=(n=p+i+65535)-65536*(i=Math.floor(n/65536)),d=(n=d+i+65535)-65536*(i=Math.floor(n/65536)),y=(n=y+i+65535)-65536*(i=Math.floor(n/65536)),g=(n=g+i+65535)-65536*(i=Math.floor(n/65536)),m=(n=m+i+65535)-65536*(i=Math.floor(n/65536)),v=(n=v+i+65535)-65536*(i=Math.floor(n/65536)),b=(n=b+i+65535)-65536*(i=Math.floor(n/65536)),E=(n=E+i+65535)-65536*(i=Math.floor(n/65536)),a=(n=(a+=i-1+37*(i-1))+(i=1)+65535)-65536*(i=Math.floor(n/65536)),s=(n=s+i+65535)-65536*(i=Math.floor(n/65536)),o=(n=o+i+65535)-65536*(i=Math.floor(n/65536)),u=(n=u+i+65535)-65536*(i=Math.floor(n/65536)),c=(n=c+i+65535)-65536*(i=Math.floor(n/65536)),l=(n=l+i+65535)-65536*(i=Math.floor(n/65536)),f=(n=f+i+65535)-65536*(i=Math.floor(n/65536)),h=(n=h+i+65535)-65536*(i=Math.floor(n/65536)),p=(n=p+i+65535)-65536*(i=Math.floor(n/65536)),d=(n=d+i+65535)-65536*(i=Math.floor(n/65536)),y=(n=y+i+65535)-65536*(i=Math.floor(n/65536)),g=(n=g+i+65535)-65536*(i=Math.floor(n/65536)),m=(n=m+i+65535)-65536*(i=Math.floor(n/65536)),v=(n=v+i+65535)-65536*(i=Math.floor(n/65536)),b=(n=b+i+65535)-65536*(i=Math.floor(n/65536)),E=(n=E+i+65535)-65536*(i=Math.floor(n/65536)),a+=i-1+37*(i-1),e[0]=a,e[1]=s,e[2]=o,e[3]=u,e[4]=c,e[5]=l,e[6]=f,e[7]=h,e[8]=p,e[9]=d,e[10]=y,e[11]=g,e[12]=m,e[13]=v,e[14]=b,e[15]=E}function w(e,t){I(e,t,t)}function B(e,t){var r,n=i();for(r=0;r<16;r++)n[r]=t[r];for(r=253;r>=0;r--)w(n,n),2!==r&&4!==r&&I(n,n,t);for(r=0;r<16;r++)e[r]=n[r]}function N(e,t,r){var n,a,s=new Uint8Array(32),o=new Float64Array(80),c=i(),l=i(),f=i(),h=i(),p=i(),d=i();for(a=0;a<31;a++)s[a]=t[a];for(s[31]=127&t[31]|64,s[0]&=248,T(o,r),a=0;a<16;a++)l[a]=o[a],h[a]=c[a]=f[a]=0;for(c[0]=h[0]=1,a=254;a>=0;--a)v(c,l,n=s[a>>>3]>>>(7&a)&1),v(f,h,n),C(p,c,f),A(c,c,f),C(f,l,h),A(l,l,h),w(h,p),w(d,c),I(c,f,c),I(f,l,p),C(p,c,f),A(c,c,f),w(l,c),A(f,h,d),I(c,f,u),C(c,c,h),I(f,f,c),I(c,h,d),I(h,l,o),w(l,p),v(c,l,n),v(f,h,n);for(a=0;a<16;a++)o[a+16]=c[a],o[a+32]=f[a],o[a+48]=l[a],o[a+64]=h[a];var y=o.subarray(32),g=o.subarray(16);return B(y,y),I(g,g,y),b(e,g),0}var R=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function _(e,t,r,n){for(var i,a,s,o,u,c,l,f,h,p,d,y,g,m,v,b,E,S,T,C,A,I,w,B,N,_,P=new Int32Array(16),O=new Int32Array(16),k=e[0],U=e[1],L=e[2],D=e[3],V=e[4],x=e[5],K=e[6],M=e[7],j=t[0],F=t[1],q=t[2],z=t[3],G=t[4],H=t[5],Y=t[6],Q=t[7],W=0;n>=128;){for(T=0;T<16;T++)C=8*T+W,P[T]=r[C+0]<<24|r[C+1]<<16|r[C+2]<<8|r[C+3],O[T]=r[C+4]<<24|r[C+5]<<16|r[C+6]<<8|r[C+7];for(T=0;T<80;T++)if(i=k,a=U,s=L,o=D,u=V,c=x,l=K,M,h=j,p=F,d=q,y=z,g=G,m=H,v=Y,Q,w=65535&(I=Q),B=I>>>16,N=65535&(A=M),_=A>>>16,w+=65535&(I=(G>>>14|V<<18)^(G>>>18|V<<14)^(V>>>9|G<<23)),B+=I>>>16,N+=65535&(A=(V>>>14|G<<18)^(V>>>18|G<<14)^(G>>>9|V<<23)),_+=A>>>16,w+=65535&(I=G&H^~G&Y),B+=I>>>16,N+=65535&(A=V&x^~V&K),_+=A>>>16,A=R[2*T],w+=65535&(I=R[2*T+1]),B+=I>>>16,N+=65535&A,_+=A>>>16,A=P[T%16],B+=(I=O[T%16])>>>16,N+=65535&A,_+=A>>>16,N+=(B+=(w+=65535&I)>>>16)>>>16,w=65535&(I=S=65535&w|B<<16),B=I>>>16,N=65535&(A=E=65535&N|(_+=N>>>16)<<16),_=A>>>16,w+=65535&(I=(j>>>28|k<<4)^(k>>>2|j<<30)^(k>>>7|j<<25)),B+=I>>>16,N+=65535&(A=(k>>>28|j<<4)^(j>>>2|k<<30)^(j>>>7|k<<25)),_+=A>>>16,B+=(I=j&F^j&q^F&q)>>>16,N+=65535&(A=k&U^k&L^U&L),_+=A>>>16,f=65535&(N+=(B+=(w+=65535&I)>>>16)>>>16)|(_+=N>>>16)<<16,b=65535&w|B<<16,w=65535&(I=y),B=I>>>16,N=65535&(A=o),_=A>>>16,B+=(I=S)>>>16,N+=65535&(A=E),_+=A>>>16,U=i,L=a,D=s,V=o=65535&(N+=(B+=(w+=65535&I)>>>16)>>>16)|(_+=N>>>16)<<16,x=u,K=c,M=l,k=f,F=h,q=p,z=d,G=y=65535&w|B<<16,H=g,Y=m,Q=v,j=b,T%16==15)for(C=0;C<16;C++)A=P[C],w=65535&(I=O[C]),B=I>>>16,N=65535&A,_=A>>>16,A=P[(C+9)%16],w+=65535&(I=O[(C+9)%16]),B+=I>>>16,N+=65535&A,_+=A>>>16,E=P[(C+1)%16],w+=65535&(I=((S=O[(C+1)%16])>>>1|E<<31)^(S>>>8|E<<24)^(S>>>7|E<<25)),B+=I>>>16,N+=65535&(A=(E>>>1|S<<31)^(E>>>8|S<<24)^E>>>7),_+=A>>>16,E=P[(C+14)%16],B+=(I=((S=O[(C+14)%16])>>>19|E<<13)^(E>>>29|S<<3)^(S>>>6|E<<26))>>>16,N+=65535&(A=(E>>>19|S<<13)^(S>>>29|E<<3)^E>>>6),_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,P[C]=65535&N|_<<16,O[C]=65535&w|B<<16;w=65535&(I=j),B=I>>>16,N=65535&(A=k),_=A>>>16,A=e[0],B+=(I=t[0])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[0]=k=65535&N|_<<16,t[0]=j=65535&w|B<<16,w=65535&(I=F),B=I>>>16,N=65535&(A=U),_=A>>>16,A=e[1],B+=(I=t[1])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[1]=U=65535&N|_<<16,t[1]=F=65535&w|B<<16,w=65535&(I=q),B=I>>>16,N=65535&(A=L),_=A>>>16,A=e[2],B+=(I=t[2])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[2]=L=65535&N|_<<16,t[2]=q=65535&w|B<<16,w=65535&(I=z),B=I>>>16,N=65535&(A=D),_=A>>>16,A=e[3],B+=(I=t[3])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[3]=D=65535&N|_<<16,t[3]=z=65535&w|B<<16,w=65535&(I=G),B=I>>>16,N=65535&(A=V),_=A>>>16,A=e[4],B+=(I=t[4])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[4]=V=65535&N|_<<16,t[4]=G=65535&w|B<<16,w=65535&(I=H),B=I>>>16,N=65535&(A=x),_=A>>>16,A=e[5],B+=(I=t[5])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[5]=x=65535&N|_<<16,t[5]=H=65535&w|B<<16,w=65535&(I=Y),B=I>>>16,N=65535&(A=K),_=A>>>16,A=e[6],B+=(I=t[6])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[6]=K=65535&N|_<<16,t[6]=Y=65535&w|B<<16,w=65535&(I=Q),B=I>>>16,N=65535&(A=M),_=A>>>16,A=e[7],B+=(I=t[7])>>>16,N+=65535&A,_+=A>>>16,_+=(N+=(B+=(w+=65535&I)>>>16)>>>16)>>>16,e[7]=M=65535&N|_<<16,t[7]=Q=65535&w|B<<16,W+=128,n-=128}return n}function P(e,t,r){var n,i=new Int32Array(8),a=new Int32Array(8),s=new Uint8Array(256),o=r;for(i[0]=1779033703,i[1]=3144134277,i[2]=1013904242,i[3]=2773480762,i[4]=1359893119,i[5]=2600822924,i[6]=528734635,i[7]=1541459225,a[0]=4089235720,a[1]=2227873595,a[2]=4271175723,a[3]=1595750129,a[4]=2917565137,a[5]=725511199,a[6]=4215389547,a[7]=327033209,_(i,a,t,r),r%=128,n=0;n<r;n++)s[n]=t[o-r+n];for(s[r]=128,s[(r=256-128*(r<112?1:0))-9]=0,d(s,r-8,o/536870912|0,o<<3),_(i,a,s,r),n=0;n<8;n++)d(e,8*n,i[n],a[n]);return 0}function O(e,t){var r=i(),n=i(),a=i(),s=i(),o=i(),u=i(),c=i(),f=i(),h=i();A(r,e[1],e[0]),A(h,t[1],t[0]),I(r,r,h),C(n,e[0],e[1]),C(h,t[0],t[1]),I(n,n,h),I(a,e[3],t[3]),I(a,a,l),I(s,e[2],t[2]),C(s,s,s),A(o,n,r),A(u,s,a),C(c,s,a),C(f,n,r),I(e[0],o,u),I(e[1],f,c),I(e[2],c,u),I(e[3],o,f)}function k(e,t,r){for(var n=0;n<4;n++)v(e[n],t[n],r)}function U(e,t){var r=i(),n=i(),a=i();B(a,t[2]),I(r,t[0],a),I(n,t[1],a),b(e,n),e[31]^=S(r)<<7}function L(e,t,r){var n,i;for(g(e[0],s),g(e[1],o),g(e[2],o),g(e[3],s),i=255;i>=0;--i)k(e,t,n=r[i/8|0]>>(7&i)&1),O(t,e),O(e,e),k(e,t,n)}function D(e,t){var r=[i(),i(),i(),i()];g(r[0],f),g(r[1],h),g(r[2],o),I(r[3],f,h),L(e,r,t)}var V=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function x(e,t){var r,n,i,a;for(n=63;n>=32;--n){for(r=0,i=n-32,a=n-12;i<a;++i)t[i]+=r-16*t[n]*V[i-(n-32)],r=t[i]+128>>8,t[i]-=256*r;t[i]+=r,t[n]=0}for(r=0,i=0;i<32;i++)t[i]+=r-(t[31]>>4)*V[i],r=t[i]>>8,t[i]&=255;for(i=0;i<32;i++)t[i]-=r*V[i];for(n=0;n<32;n++)t[n+1]+=t[n]>>8,e[n]=255&t[n]}function K(e){var t,r=new Float64Array(64);for(t=0;t<64;t++)r[t]=e[t];for(t=0;t<64;t++)e[t]=0;x(e,r)}function M(e,t,r,n,a){for(var s=new Uint8Array(64),o=[i(),i(),i(),i()],u=0;u<32;u++)s[u]=n[u];s[0]&=248,s[31]&=127,s[31]|=64,D(o,s),U(s.subarray(32),o);var c,l=128&s[63];return c=a?function(e,t,r,n,a){new Uint8Array(64);var s,o,u=new Uint8Array(64),c=new Uint8Array(64),l=new Float64Array(64),f=[i(),i(),i(),i()];for(e[0]=254,s=1;s<32;s++)e[s]=255;for(s=0;s<32;s++)e[32+s]=n[s];for(s=0;s<r;s++)e[64+s]=t[s];for(s=0;s<64;s++)e[r+64+s]=a[s];for(P(c,e,r+128),K(c),D(f,c),U(e,f),s=0;s<32;s++)e[s+32]=n[32+s];for(P(u,e,r+64),K(u),s=0;s<64;s++)e[r+64+s]=0;for(s=0;s<64;s++)l[s]=0;for(s=0;s<32;s++)l[s]=c[s];for(s=0;s<32;s++)for(o=0;o<32;o++)l[s+o]+=u[s]*n[o];return x(e.subarray(32,r+64),l),r+64}(e,t,r,s,a):function(e,t,r,n){new Uint8Array(64);var a,s,o=new Uint8Array(64),u=new Uint8Array(64),c=new Float64Array(64),l=[i(),i(),i(),i()];for(a=0;a<r;a++)e[64+a]=t[a];for(a=0;a<32;a++)e[32+a]=n[a];for(P(u,e.subarray(32),r+32),K(u),D(l,u),U(e,l),a=0;a<32;a++)e[a+32]=n[32+a];for(P(o,e,r+64),K(o),a=0;a<64;a++)c[a]=0;for(a=0;a<32;a++)c[a]=u[a];for(a=0;a<32;a++)for(s=0;s<32;s++)c[a+s]+=o[a]*n[s];return x(e.subarray(32),c),r+64}(e,t,r,s),e[63]|=l,c}function j(e,t){var r=i(),n=i(),a=i(),u=i(),l=i(),f=i(),h=i();return g(e[2],o),T(e[1],t),w(a,e[1]),I(u,a,c),A(a,a,e[2]),C(u,e[2],u),w(l,u),w(f,l),I(h,f,l),I(r,h,a),I(r,r,u),function(e,t){var r,n=i();for(r=0;r<16;r++)n[r]=t[r];for(r=250;r>=0;r--)w(n,n),1!==r&&I(n,n,t);for(r=0;r<16;r++)e[r]=n[r]}(r,r),I(r,r,a),I(r,r,u),I(r,r,u),I(e[0],r,u),w(n,e[0]),I(n,n,u),E(n,a)&&I(e[0],e[0],p),w(n,e[0]),I(n,n,u),E(n,a)?-1:(S(e[0])===t[31]>>7&&A(e[0],s,e[0]),I(e[3],e[0],e[1]),0)}function F(e,t,r,n){var a=function(e){var t=new Uint8Array(32),r=i(),n=i(),a=i();return T(r,e),C(n,r,o),A(a,r,o),B(n,n),I(n,n,a),b(t,n),t}(n);return a[31]|=128&t[63],t[63]&=127,function(e,t,r,n){var a,s=new Uint8Array(32),o=new Uint8Array(64),u=[i(),i(),i(),i()],c=[i(),i(),i(),i()];if(-1,r<64)return-1;if(j(c,n))return-1;for(a=0;a<r;a++)e[a]=t[a];for(a=0;a<32;a++)e[a+32]=n[a];if(P(o,e,r),K(o),L(u,c,o),D(c,t.subarray(32)),O(u,c),U(s,u),r-=64,y(t,0,s,0)){for(a=0;a<r;a++)e[a]=0;return-1}for(a=0;a<r;a++)e[a]=t[a+64];return r}(e,t,r,a)}function q(){for(var e,t,r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];for(t=0;t<arguments.length;t++)if("[object Uint8Array]"!==(e=Object.prototype.toString.call(arguments[t])))throw new TypeError("unexpected type "+e+", use Uint8Array")}n.sharedKey=function(e,t){if(q(t,e),32!==t.length)throw new Error("wrong public key length");if(32!==e.length)throw new Error("wrong secret key length");var r=new Uint8Array(32);return N(r,e,t),r},n.signMessage=function(e,t,r){if(q(t,e),32!==e.length)throw new Error("wrong secret key length");if(r){if(q(r),64!==r.length)throw new Error("wrong random data length");var n=new Uint8Array(128+t.length);return M(n,t,t.length,e,r),new Uint8Array(n.subarray(0,64+t.length))}var i=new Uint8Array(64+t.length);return M(i,t,t.length,e),i},n.openMessage=function(e,t){if(q(t,e),32!==e.length)throw new Error("wrong public key length");var r=new Uint8Array(t.length),n=F(r,t,t.length,e);if(n<0)return null;for(var i=new Uint8Array(n),a=0;a<i.length;a++)i[a]=r[a];return i},n.sign=function(e,t,r){if(q(e,t),32!==e.length)throw new Error("wrong secret key length");if(r&&(q(r),64!==r.length))throw new Error("wrong random data length");var n=new Uint8Array((r?128:64)+t.length);M(n,t,t.length,e,r);for(var i=new Uint8Array(64),a=0;a<i.length;a++)i[a]=n[a];return i},n.verify=function(e,t,r){if(q(t,r,e),64!==r.length)throw new Error("wrong signature length");if(32!==e.length)throw new Error("wrong public key length");var n,i=new Uint8Array(64+t.length),a=new Uint8Array(64+t.length);for(n=0;n<64;n++)i[n]=r[n];for(n=0;n<t.length;n++)i[n+64]=t[n];return F(a,i,i.length,e)>=0},n.generateKeyPair=function(e){if(q(e),32!==e.length)throw new Error("wrong seed length");for(var t=new Uint8Array(32),r=new Uint8Array(32),n=0;n<32;n++)t[n]=e[n];return N(r,t,a),t[0]&=248,t[31]&=127,t[31]|=64,r[31]&=127,{public:r,private:t}},t.default=n},function(e,t,r){var n=r(1);if(r(15),r(60),r(16),r(101),r(102),r(12),r(2),void 0===i)var i=n.jsbn.BigInteger;var a=n.util.isNodejs?r(31):null,s=n.asn1,o=n.util;n.pki=n.pki||{},e.exports=n.pki.rsa=n.rsa=n.rsa||{};var u=n.pki,c=[6,4,2,4,2,4,6,2],l={name:"PrivateKeyInfo",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:s.Class.UNIVERSAL,type:s.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:s.Class.UNIVERSAL,type:s.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},f={name:"RSAPrivateKey",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},h={name:"RSAPublicKey",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:s.Class.UNIVERSAL,type:s.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},p=n.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:s.Class.UNIVERSAL,type:s.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:s.Class.UNIVERSAL,type:s.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:s.Class.UNIVERSAL,type:s.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},d=function(e){var t;if(!(e.algorithm in u.oids)){var r=new Error("Unknown message digest algorithm.");throw r.algorithm=e.algorithm,r}t=u.oids[e.algorithm];var n=s.oidToDer(t).getBytes(),i=s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[]),a=s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[]);a.value.push(s.create(s.Class.UNIVERSAL,s.Type.OID,!1,n)),a.value.push(s.create(s.Class.UNIVERSAL,s.Type.NULL,!1,""));var o=s.create(s.Class.UNIVERSAL,s.Type.OCTETSTRING,!1,e.digest().getBytes());return i.value.push(a),i.value.push(o),s.toDer(i).getBytes()},y=function(e,t,r){if(r)return e.modPow(t.e,t.n);if(!t.p||!t.q)return e.modPow(t.d,t.n);var a;t.dP||(t.dP=t.d.mod(t.p.subtract(i.ONE))),t.dQ||(t.dQ=t.d.mod(t.q.subtract(i.ONE))),t.qInv||(t.qInv=t.q.modInverse(t.p));do{a=new i(n.util.bytesToHex(n.random.getBytes(t.n.bitLength()/8)),16)}while(a.compareTo(t.n)>=0||!a.gcd(t.n).equals(i.ONE));for(var s=(e=e.multiply(a.modPow(t.e,t.n)).mod(t.n)).mod(t.p).modPow(t.dP,t.p),o=e.mod(t.q).modPow(t.dQ,t.q);s.compareTo(o)<0;)s=s.add(t.p);var u=s.subtract(o).multiply(t.qInv).mod(t.p).multiply(t.q).add(o);return u=u.multiply(a.modInverse(t.n)).mod(t.n)};function g(e,t,r){var i=n.util.createBuffer(),a=Math.ceil(t.n.bitLength()/8);if(e.length>a-11){var s=new Error("Message is too long for PKCS#1 v1.5 padding.");throw s.length=e.length,s.max=a-11,s}i.putByte(0),i.putByte(r);var o,u=a-3-e.length;if(0===r||1===r){o=0===r?0:255;for(var c=0;c<u;++c)i.putByte(o)}else for(;u>0;){var l=0,f=n.random.getBytes(u);for(c=0;c<u;++c)0===(o=f.charCodeAt(c))?++l:i.putByte(o);u=l}return i.putByte(0),i.putBytes(e),i}function m(e,t,r,i){var a=Math.ceil(t.n.bitLength()/8),s=n.util.createBuffer(e),o=s.getByte(),u=s.getByte();if(0!==o||r&&0!==u&&1!==u||!r&&2!=u||r&&0===u&&void 0===i)throw new Error("Encryption block is invalid.");var c=0;if(0===u){c=a-3-i;for(var l=0;l<c;++l)if(0!==s.getByte())throw new Error("Encryption block is invalid.")}else if(1===u)for(c=0;s.length()>1;){if(255!==s.getByte()){--s.read;break}++c}else if(2===u)for(c=0;s.length()>1;){if(0===s.getByte()){--s.read;break}++c}if(0!==s.getByte()||c!==a-3-s.length())throw new Error("Encryption block is invalid.");return s.getBytes()}function v(e,t,r){"function"==typeof t&&(r=t,t={});var a={algorithm:{name:(t=t||{}).algorithm||"PRIMEINC",options:{workers:t.workers||2,workLoad:t.workLoad||100,workerScript:t.workerScript}}};function s(){o(e.pBits,(function(t,n){return t?r(t):(e.p=n,null!==e.q?c(t,e.q):void o(e.qBits,c))}))}function o(e,t){n.prime.generateProbablePrime(e,a,t)}function c(t,n){if(t)return r(t);if(e.q=n,e.p.compareTo(e.q)<0){var a=e.p;e.p=e.q,e.q=a}if(0!==e.p.subtract(i.ONE).gcd(e.e).compareTo(i.ONE))return e.p=null,void s();if(0!==e.q.subtract(i.ONE).gcd(e.e).compareTo(i.ONE))return e.q=null,void o(e.qBits,c);if(e.p1=e.p.subtract(i.ONE),e.q1=e.q.subtract(i.ONE),e.phi=e.p1.multiply(e.q1),0!==e.phi.gcd(e.e).compareTo(i.ONE))return e.p=e.q=null,void s();if(e.n=e.p.multiply(e.q),e.n.bitLength()!==e.bits)return e.q=null,void o(e.qBits,c);var l=e.e.modInverse(e.phi);e.keys={privateKey:u.rsa.setPrivateKey(e.n,e.e,l,e.p,e.q,l.mod(e.p1),l.mod(e.q1),e.q.modInverse(e.p)),publicKey:u.rsa.setPublicKey(e.n,e.e)},r(null,e.keys)}"prng"in t&&(a.prng=t.prng),s()}function b(e){var t=e.toString(16);t[0]>="8"&&(t="00"+t);var r=n.util.hexToBytes(t);return r.length>1&&(0===r.charCodeAt(0)&&0==(128&r.charCodeAt(1))||255===r.charCodeAt(0)&&128==(128&r.charCodeAt(1)))?r.substr(1):r}function E(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}function S(e){return n.util.isNodejs&&"function"==typeof a[e]}function T(e){return void 0!==o.globalScope&&"object"==typeof o.globalScope.crypto&&"object"==typeof o.globalScope.crypto.subtle&&"function"==typeof o.globalScope.crypto.subtle[e]}function C(e){return void 0!==o.globalScope&&"object"==typeof o.globalScope.msCrypto&&"object"==typeof o.globalScope.msCrypto.subtle&&"function"==typeof o.globalScope.msCrypto.subtle[e]}function A(e){for(var t=n.util.hexToBytes(e.toString(16)),r=new Uint8Array(t.length),i=0;i<t.length;++i)r[i]=t.charCodeAt(i);return r}u.rsa.encrypt=function(e,t,r){var a,s=r,o=Math.ceil(t.n.bitLength()/8);!1!==r&&!0!==r?(s=2===r,a=g(e,t,r)):(a=n.util.createBuffer()).putBytes(e);for(var u=new i(a.toHex(),16),c=y(u,t,s).toString(16),l=n.util.createBuffer(),f=o-Math.ceil(c.length/2);f>0;)l.putByte(0),--f;return l.putBytes(n.util.hexToBytes(c)),l.getBytes()},u.rsa.decrypt=function(e,t,r,a){var s=Math.ceil(t.n.bitLength()/8);if(e.length!==s){var o=new Error("Encrypted message length is invalid.");throw o.length=e.length,o.expected=s,o}var u=new i(n.util.createBuffer(e).toHex(),16);if(u.compareTo(t.n)>=0)throw new Error("Encrypted message is invalid.");for(var c=y(u,t,r).toString(16),l=n.util.createBuffer(),f=s-Math.ceil(c.length/2);f>0;)l.putByte(0),--f;return l.putBytes(n.util.hexToBytes(c)),!1!==a?m(l.getBytes(),t,r):l.getBytes()},u.rsa.createKeyPairGenerationState=function(e,t,r){"string"==typeof e&&(e=parseInt(e,10)),e=e||2048;var a,s=(r=r||{}).prng||n.random,o={nextBytes:function(e){for(var t=s.getBytesSync(e.length),r=0;r<e.length;++r)e[r]=t.charCodeAt(r)}},u=r.algorithm||"PRIMEINC";if("PRIMEINC"!==u)throw new Error("Invalid key generation algorithm: "+u);return(a={algorithm:u,state:0,bits:e,rng:o,eInt:t||65537,e:new i(null),p:null,q:null,qBits:e>>1,pBits:e-(e>>1),pqState:0,num:null,keys:null}).e.fromInt(a.eInt),a},u.rsa.stepKeyPairGenerationState=function(e,t){"algorithm"in e||(e.algorithm="PRIMEINC");var r=new i(null);r.fromInt(30);for(var n,a=0,s=function(e,t){return e|t},o=+new Date,l=0;null===e.keys&&(t<=0||l<t);){if(0===e.state){var f=null===e.p?e.pBits:e.qBits,h=f-1;0===e.pqState?(e.num=new i(f,e.rng),e.num.testBit(h)||e.num.bitwiseTo(i.ONE.shiftLeft(h),s,e.num),e.num.dAddOffset(31-e.num.mod(r).byteValue(),0),a=0,++e.pqState):1===e.pqState?e.num.bitLength()>f?e.pqState=0:e.num.isProbablePrime(E(e.num.bitLength()))?++e.pqState:e.num.dAddOffset(c[a++%8],0):2===e.pqState?e.pqState=0===e.num.subtract(i.ONE).gcd(e.e).compareTo(i.ONE)?3:0:3===e.pqState&&(e.pqState=0,null===e.p?e.p=e.num:e.q=e.num,null!==e.p&&null!==e.q&&++e.state,e.num=null)}else if(1===e.state)e.p.compareTo(e.q)<0&&(e.num=e.p,e.p=e.q,e.q=e.num),++e.state;else if(2===e.state)e.p1=e.p.subtract(i.ONE),e.q1=e.q.subtract(i.ONE),e.phi=e.p1.multiply(e.q1),++e.state;else if(3===e.state)0===e.phi.gcd(e.e).compareTo(i.ONE)?++e.state:(e.p=null,e.q=null,e.state=0);else if(4===e.state)e.n=e.p.multiply(e.q),e.n.bitLength()===e.bits?++e.state:(e.q=null,e.state=0);else if(5===e.state){var p=e.e.modInverse(e.phi);e.keys={privateKey:u.rsa.setPrivateKey(e.n,e.e,p,e.p,e.q,p.mod(e.p1),p.mod(e.q1),e.q.modInverse(e.p)),publicKey:u.rsa.setPublicKey(e.n,e.e)}}l+=(n=+new Date)-o,o=n}return null!==e.keys},u.rsa.generateKeyPair=function(e,t,r,i){if(1===arguments.length?"object"==typeof e?(r=e,e=void 0):"function"==typeof e&&(i=e,e=void 0):2===arguments.length?"number"==typeof e?"function"==typeof t?(i=t,t=void 0):"number"!=typeof t&&(r=t,t=void 0):(r=e,i=t,e=void 0,t=void 0):3===arguments.length&&("number"==typeof t?"function"==typeof r&&(i=r,r=void 0):(i=r,r=t,t=void 0)),r=r||{},void 0===e&&(e=r.bits||2048),void 0===t&&(t=r.e||65537),!n.options.usePureJavaScript&&!r.prng&&e>=256&&e<=16384&&(65537===t||3===t))if(i){if(S("generateKeyPair"))return a.generateKeyPair("rsa",{modulusLength:e,publicExponent:t,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},(function(e,t,r){if(e)return i(e);i(null,{privateKey:u.privateKeyFromPem(r),publicKey:u.publicKeyFromPem(t)})}));if(T("generateKey")&&T("exportKey"))return o.globalScope.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:A(t),hash:{name:"SHA-256"}},!0,["sign","verify"]).then((function(e){return o.globalScope.crypto.subtle.exportKey("pkcs8",e.privateKey)})).then(void 0,(function(e){i(e)})).then((function(e){if(e){var t=u.privateKeyFromAsn1(s.fromDer(n.util.createBuffer(e)));i(null,{privateKey:t,publicKey:u.setRsaPublicKey(t.n,t.e)})}}));if(C("generateKey")&&C("exportKey")){var c=o.globalScope.msCrypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:A(t),hash:{name:"SHA-256"}},!0,["sign","verify"]);return c.oncomplete=function(e){var t=e.target.result,r=o.globalScope.msCrypto.subtle.exportKey("pkcs8",t.privateKey);r.oncomplete=function(e){var t=e.target.result,r=u.privateKeyFromAsn1(s.fromDer(n.util.createBuffer(t)));i(null,{privateKey:r,publicKey:u.setRsaPublicKey(r.n,r.e)})},r.onerror=function(e){i(e)}},void(c.onerror=function(e){i(e)})}}else if(S("generateKeyPairSync")){var l=a.generateKeyPairSync("rsa",{modulusLength:e,publicExponent:t,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}});return{privateKey:u.privateKeyFromPem(l.privateKey),publicKey:u.publicKeyFromPem(l.publicKey)}}var f=u.rsa.createKeyPairGenerationState(e,t,r);if(!i)return u.rsa.stepKeyPairGenerationState(f,0),f.keys;v(f,r,i)},u.setRsaPublicKey=u.rsa.setPublicKey=function(e,t){var r={n:e,e:t,encrypt:function(e,t,i){if("string"==typeof t?t=t.toUpperCase():void 0===t&&(t="RSAES-PKCS1-V1_5"),"RSAES-PKCS1-V1_5"===t)t={encode:function(e,t,r){return g(e,t,2).getBytes()}};else if("RSA-OAEP"===t||"RSAES-OAEP"===t)t={encode:function(e,t){return n.pkcs1.encode_rsa_oaep(t,e,i)}};else if(-1!==["RAW","NONE","NULL",null].indexOf(t))t={encode:function(e){return e}};else if("string"==typeof t)throw new Error('Unsupported encryption scheme: "'+t+'".');var a=t.encode(e,r,!0);return u.rsa.encrypt(a,r,!0)},verify:function(e,t,n){"string"==typeof n?n=n.toUpperCase():void 0===n&&(n="RSASSA-PKCS1-V1_5"),"RSASSA-PKCS1-V1_5"===n?n={verify:function(e,t){return t=m(t,r,!0),e===s.fromDer(t).value[1].value}}:"NONE"!==n&&"NULL"!==n&&null!==n||(n={verify:function(e,t){return e===(t=m(t,r,!0))}});var i=u.rsa.decrypt(t,r,!0,!1);return n.verify(e,i,r.n.bitLength())}};return r},u.setRsaPrivateKey=u.rsa.setPrivateKey=function(e,t,r,i,a,s,o,c){var l={n:e,e:t,d:r,p:i,q:a,dP:s,dQ:o,qInv:c,decrypt:function(e,t,r){"string"==typeof t?t=t.toUpperCase():void 0===t&&(t="RSAES-PKCS1-V1_5");var i=u.rsa.decrypt(e,l,!1,!1);if("RSAES-PKCS1-V1_5"===t)t={decode:m};else if("RSA-OAEP"===t||"RSAES-OAEP"===t)t={decode:function(e,t){return n.pkcs1.decode_rsa_oaep(t,e,r)}};else{if(-1===["RAW","NONE","NULL",null].indexOf(t))throw new Error('Unsupported encryption scheme: "'+t+'".');t={decode:function(e){return e}}}return t.decode(i,l,!1)},sign:function(e,t){var r=!1;"string"==typeof t&&(t=t.toUpperCase()),void 0===t||"RSASSA-PKCS1-V1_5"===t?(t={encode:d},r=1):"NONE"!==t&&"NULL"!==t&&null!==t||(t={encode:function(){return e}},r=1);var n=t.encode(e,l.n.bitLength());return u.rsa.encrypt(n,l,r)}};return l},u.wrapRsaPrivateKey=function(e){return s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,s.integerToDer(0).getBytes()),s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.OID,!1,s.oidToDer(u.oids.rsaEncryption).getBytes()),s.create(s.Class.UNIVERSAL,s.Type.NULL,!1,"")]),s.create(s.Class.UNIVERSAL,s.Type.OCTETSTRING,!1,s.toDer(e).getBytes())])},u.privateKeyFromAsn1=function(e){var t,r,a,o,c,h,p,d,y={},g=[];if(s.validate(e,l,y,g)&&(e=s.fromDer(n.util.createBuffer(y.privateKey))),y={},g=[],!s.validate(e,f,y,g)){var m=new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");throw m.errors=g,m}return t=n.util.createBuffer(y.privateKeyModulus).toHex(),r=n.util.createBuffer(y.privateKeyPublicExponent).toHex(),a=n.util.createBuffer(y.privateKeyPrivateExponent).toHex(),o=n.util.createBuffer(y.privateKeyPrime1).toHex(),c=n.util.createBuffer(y.privateKeyPrime2).toHex(),h=n.util.createBuffer(y.privateKeyExponent1).toHex(),p=n.util.createBuffer(y.privateKeyExponent2).toHex(),d=n.util.createBuffer(y.privateKeyCoefficient).toHex(),u.setRsaPrivateKey(new i(t,16),new i(r,16),new i(a,16),new i(o,16),new i(c,16),new i(h,16),new i(p,16),new i(d,16))},u.privateKeyToAsn1=u.privateKeyToRSAPrivateKey=function(e){return s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,s.integerToDer(0).getBytes()),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.n)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.e)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.d)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.p)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.q)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.dP)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.dQ)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.qInv))])},u.publicKeyFromAsn1=function(e){var t={},r=[];if(s.validate(e,p,t,r)){var a,o=s.derToOid(t.publicKeyOid);if(o!==u.oids.rsaEncryption)throw(a=new Error("Cannot read public key. Unknown OID.")).oid=o,a;e=t.rsaPublicKey}if(r=[],!s.validate(e,h,t,r))throw(a=new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.")).errors=r,a;var c=n.util.createBuffer(t.publicKeyModulus).toHex(),l=n.util.createBuffer(t.publicKeyExponent).toHex();return u.setRsaPublicKey(new i(c,16),new i(l,16))},u.publicKeyToAsn1=u.publicKeyToSubjectPublicKeyInfo=function(e){return s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.OID,!1,s.oidToDer(u.oids.rsaEncryption).getBytes()),s.create(s.Class.UNIVERSAL,s.Type.NULL,!1,"")]),s.create(s.Class.UNIVERSAL,s.Type.BITSTRING,!1,[u.publicKeyToRSAPublicKey(e)])])},u.publicKeyToRSAPublicKey=function(e){return s.create(s.Class.UNIVERSAL,s.Type.SEQUENCE,!0,[s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.n)),s.create(s.Class.UNIVERSAL,s.Type.INTEGER,!1,b(e.e))])}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(65),i=r(28),a=r(36),s=r(66);t.empty=Uint8Array.from([]),t.zero=Uint8Array.from([0]),t.one=Uint8Array.from([1]),t.BASE58_STRING=e=>n.default.decode(e),t.BASE64_STRING=e=>i.toByteArray(e.replace("base64:","")),t.STRING=e=>e?(e=>Uint8Array.from([...unescape(encodeURIComponent(e))].map(e=>e.charCodeAt(0))))(e):t.empty,t.BYTE=e=>Uint8Array.from([e]),t.BOOL=e=>t.BYTE(e?1:0),t.BYTES=e=>Uint8Array.from(e),t.SHORT=e=>{const t=new s.BigNumber(Math.floor(e)).toBytes();return Uint8Array.from(Array.from({length:2},(e,r)=>t[r-2+t.length]||0))},t.INT=e=>{const t=new s.BigNumber(Math.floor(e)).toBytes();return Uint8Array.from(Array.from({length:4},(e,r)=>t[r-4+t.length]||0))},t.OPTION=e=>r=>null==r||"string"==typeof r&&0==r.length?t.zero:a.concat(t.one,e(r)),t.LEN=e=>t=>r=>{const n=t(r),i=e(n.length);return a.concat(i,n)},t.COUNT=e=>t=>r=>{const n=a.concat(...r.map(e=>t(e))),i=e(r.length);return a.concat(i,n)},t.LONG=e=>{let t;if("number"==typeof e){if(e>Math.pow(2,53)-1)throw new Error(`${e} is too big to be precisely represented as js number. Use string instead`);t=new s.BigNumber(Math.floor(e)).toBytes()}else t=new s.BigNumber(e).toBytes();return Uint8Array.from(Array.from({length:8},(e,r)=>t[r-8+t.length]||0))},t.SCRIPT=e=>t.OPTION(t.LEN(t.SHORT)(t.BASE64_STRING))(e?e.slice(7):null),t.ALIAS=e=>{const[r,n,i]=e.split(":");if(!n||1!==n.length)throw new Error("Invalid network byte in alias");if(!i||0===i.length)throw new Error("Invalid alias body");return a.concat([2],[n.charCodeAt(0)],t.LEN(t.SHORT)(t.STRING)(i))},t.ADDRESS_OR_ALIAS=e=>e.startsWith("alias")?t.ALIAS(e):t.BASE58_STRING(e)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(7),a=r(4),s=r(3),o=r(5);t.massTransfer=function(e,t){const r=n.TRANSACTION_TYPE.MASS_TRANSFER,u=e.version||1,c=i.convertToPairs(t),l=i.getSenderPublicKey(c,e);if(!Array.isArray(e.transfers))throw new Error('["transfers should be array"]');const f={type:r,version:u,senderPublicKey:l,assetId:i.normalizeAssetId(e.assetId),transfers:e.transfers,fee:i.fee(e,1e5+1e5*Math.ceil(.5*e.transfers.length)),timestamp:e.timestamp||Date.now(),attachment:e.attachment||"",proofs:e.proofs||[],id:""};o.validate.massTransfer(f);const h=s.binary.serializeTx(f);return c.forEach(([e,t])=>i.addProof(f,a.signBytes(e,h),t)),f.id=a.base58Encode(a.blake2b(h)),f}},function(e,t,r){"use strict";t.byteLength=function(e){var t=c(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,n=c(e),s=n[0],o=n[1],u=new a(function(e,t,r){return 3*(t+r)/4-r}(0,s,o)),l=0,f=o>0?s-4:s;for(r=0;r<f;r+=4)t=i[e.charCodeAt(r)]<<18|i[e.charCodeAt(r+1)]<<12|i[e.charCodeAt(r+2)]<<6|i[e.charCodeAt(r+3)],u[l++]=t>>16&255,u[l++]=t>>8&255,u[l++]=255&t;2===o&&(t=i[e.charCodeAt(r)]<<2|i[e.charCodeAt(r+1)]>>4,u[l++]=255&t);1===o&&(t=i[e.charCodeAt(r)]<<10|i[e.charCodeAt(r+1)]<<4|i[e.charCodeAt(r+2)]>>2,u[l++]=t>>8&255,u[l++]=255&t);return u},t.fromByteArray=function(e){for(var t,r=e.length,i=r%3,a=[],s=0,o=r-i;s<o;s+=16383)a.push(l(e,s,s+16383>o?o:s+16383));1===i?(t=e[r-1],a.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[r-2]<<8)+e[r-1],a.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return a.join("")};for(var n=[],i=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,u=s.length;o<u;++o)n[o]=s[o],i[s.charCodeAt(o)]=o;function c(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function l(e,t,r){for(var i,a,s=[],o=t;o<r;o+=3)i=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),s.push(n[(a=i)>>18&63]+n[a>>12&63]+n[a>>6&63]+n[63&a]);return s.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,t,r){var n=r(1);function i(e,t){n.cipher.registerAlgorithm(e,(function(){return new n.aes.Algorithm(e,t)}))}r(30),r(52),r(2),e.exports=n.aes=n.aes||{},n.aes.startEncrypting=function(e,t,r,n){var i=y({key:e,output:r,decrypt:!1,mode:n});return i.start(t),i},n.aes.createEncryptionCipher=function(e,t){return y({key:e,output:null,decrypt:!1,mode:t})},n.aes.startDecrypting=function(e,t,r,n){var i=y({key:e,output:r,decrypt:!0,mode:n});return i.start(t),i},n.aes.createDecryptionCipher=function(e,t){return y({key:e,output:null,decrypt:!0,mode:t})},n.aes.Algorithm=function(e,t){l||h();var r=this;r.name=e,r.mode=new t({blockSize:16,cipher:{encrypt:function(e,t){return d(r._w,e,t,!1)},decrypt:function(e,t){return d(r._w,e,t,!0)}}}),r._init=!1},n.aes.Algorithm.prototype.initialize=function(e){if(!this._init){var t,r=e.key;if("string"!=typeof r||16!==r.length&&24!==r.length&&32!==r.length){if(n.util.isArray(r)&&(16===r.length||24===r.length||32===r.length)){t=r,r=n.util.createBuffer();for(var i=0;i<t.length;++i)r.putByte(t[i])}}else r=n.util.createBuffer(r);if(!n.util.isArray(r)){t=r,r=[];var a=t.length();if(16===a||24===a||32===a){a>>>=2;for(i=0;i<a;++i)r.push(t.getInt32())}}if(!n.util.isArray(r)||4!==r.length&&6!==r.length&&8!==r.length)throw new Error("Invalid key parameter.");var s=this.mode.name,o=-1!==["CFB","OFB","CTR","GCM"].indexOf(s);this._w=p(r,e.decrypt&&!o),this._init=!0}},n.aes._expandKey=function(e,t){return l||h(),p(e,t)},n.aes._updateBlock=d,i("AES-ECB",n.cipher.modes.ecb),i("AES-CBC",n.cipher.modes.cbc),i("AES-CFB",n.cipher.modes.cfb),i("AES-OFB",n.cipher.modes.ofb),i("AES-CTR",n.cipher.modes.ctr),i("AES-GCM",n.cipher.modes.gcm);var a,s,o,u,c,l=!1,f=4;function h(){l=!0,o=[0,1,2,4,8,16,32,64,128,27,54];for(var e=new Array(256),t=0;t<128;++t)e[t]=t<<1,e[t+128]=t+128<<1^283;a=new Array(256),s=new Array(256),u=new Array(4),c=new Array(4);for(t=0;t<4;++t)u[t]=new Array(256),c[t]=new Array(256);var r,n,i,f,h,p,d,y=0,g=0;for(t=0;t<256;++t){f=(f=g^g<<1^g<<2^g<<3^g<<4)>>8^255&f^99,a[y]=f,s[f]=y,p=(h=e[f])<<24^f<<16^f<<8^f^h,d=((r=e[y])^(n=e[r])^(i=e[n]))<<24^(y^i)<<16^(y^n^i)<<8^y^r^i;for(var m=0;m<4;++m)u[m][y]=p,c[m][f]=d,p=p<<24|p>>>8,d=d<<24|d>>>8;0===y?y=g=1:(y=r^e[e[e[r^i]]],g^=e[e[g]])}}function p(e,t){for(var r,n=e.slice(0),i=1,s=n.length,u=f*(s+6+1),l=s;l<u;++l)r=n[l-1],l%s==0?(r=a[r>>>16&255]<<24^a[r>>>8&255]<<16^a[255&r]<<8^a[r>>>24]^o[i]<<24,i++):s>6&&l%s==4&&(r=a[r>>>24]<<24^a[r>>>16&255]<<16^a[r>>>8&255]<<8^a[255&r]),n[l]=n[l-s]^r;if(t){for(var h,p=c[0],d=c[1],y=c[2],g=c[3],m=n.slice(0),v=(l=0,(u=n.length)-f);l<u;l+=f,v-=f)if(0===l||l===u-f)m[l]=n[v],m[l+1]=n[v+3],m[l+2]=n[v+2],m[l+3]=n[v+1];else for(var b=0;b<f;++b)h=n[v+b],m[l+(3&-b)]=p[a[h>>>24]]^d[a[h>>>16&255]]^y[a[h>>>8&255]]^g[a[255&h]];n=m}return n}function d(e,t,r,n){var i,o,l,f,h,p,d,y,g,m,v,b,E=e.length/4-1;n?(i=c[0],o=c[1],l=c[2],f=c[3],h=s):(i=u[0],o=u[1],l=u[2],f=u[3],h=a),p=t[0]^e[0],d=t[n?3:1]^e[1],y=t[2]^e[2],g=t[n?1:3]^e[3];for(var S=3,T=1;T<E;++T)m=i[p>>>24]^o[d>>>16&255]^l[y>>>8&255]^f[255&g]^e[++S],v=i[d>>>24]^o[y>>>16&255]^l[g>>>8&255]^f[255&p]^e[++S],b=i[y>>>24]^o[g>>>16&255]^l[p>>>8&255]^f[255&d]^e[++S],g=i[g>>>24]^o[p>>>16&255]^l[d>>>8&255]^f[255&y]^e[++S],p=m,d=v,y=b;r[0]=h[p>>>24]<<24^h[d>>>16&255]<<16^h[y>>>8&255]<<8^h[255&g]^e[++S],r[n?3:1]=h[d>>>24]<<24^h[y>>>16&255]<<16^h[g>>>8&255]<<8^h[255&p]^e[++S],r[2]=h[y>>>24]<<24^h[g>>>16&255]<<16^h[p>>>8&255]<<8^h[255&d]^e[++S],r[n?1:3]=h[g>>>24]<<24^h[p>>>16&255]<<16^h[d>>>8&255]<<8^h[255&y]^e[++S]}function y(e){var t,r="AES-"+((e=e||{}).mode||"CBC").toUpperCase(),i=(t=e.decrypt?n.cipher.createDecipher(r,e.key):n.cipher.createCipher(r,e.key)).start;return t.start=function(e,r){var a=null;r instanceof n.util.ByteBuffer&&(a=r,r={}),(r=r||{}).output=a,r.iv=e,i.call(t,r)},t}},function(e,t,r){var n=r(1);r(2),e.exports=n.cipher=n.cipher||{},n.cipher.algorithms=n.cipher.algorithms||{},n.cipher.createCipher=function(e,t){var r=e;if("string"==typeof r&&(r=n.cipher.getAlgorithm(r))&&(r=r()),!r)throw new Error("Unsupported algorithm: "+e);return new n.cipher.BlockCipher({algorithm:r,key:t,decrypt:!1})},n.cipher.createDecipher=function(e,t){var r=e;if("string"==typeof r&&(r=n.cipher.getAlgorithm(r))&&(r=r()),!r)throw new Error("Unsupported algorithm: "+e);return new n.cipher.BlockCipher({algorithm:r,key:t,decrypt:!0})},n.cipher.registerAlgorithm=function(e,t){e=e.toUpperCase(),n.cipher.algorithms[e]=t},n.cipher.getAlgorithm=function(e){return(e=e.toUpperCase())in n.cipher.algorithms?n.cipher.algorithms[e]:null};var i=n.cipher.BlockCipher=function(e){this.algorithm=e.algorithm,this.mode=this.algorithm.mode,this.blockSize=this.mode.blockSize,this._finish=!1,this._input=null,this.output=null,this._op=e.decrypt?this.mode.decrypt:this.mode.encrypt,this._decrypt=e.decrypt,this.algorithm.initialize(e)};i.prototype.start=function(e){e=e||{};var t={};for(var r in e)t[r]=e[r];t.decrypt=this._decrypt,this._finish=!1,this._input=n.util.createBuffer(),this.output=e.output||n.util.createBuffer(),this.mode.start(t)},i.prototype.update=function(e){for(e&&this._input.putBuffer(e);!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish;);this._input.compact()},i.prototype.finish=function(e){!e||"ECB"!==this.mode.name&&"CBC"!==this.mode.name||(this.mode.pad=function(t){return e(this.blockSize,t,!1)},this.mode.unpad=function(t){return e(this.blockSize,t,!0)});var t={};return t.decrypt=this._decrypt,t.overflow=this._input.length()%this.blockSize,!(!this._decrypt&&this.mode.pad&&!this.mode.pad(this._input,t))&&(this._finish=!0,this.update(),!(this._decrypt&&this.mode.unpad&&!this.mode.unpad(this.output,t))&&!(this.mode.afterFinish&&!this.mode.afterFinish(this.output,t)))}},function(e,t){},function(e,t,r){var n=r(1);r(9),r(2),(e.exports=n.hmac=n.hmac||{}).create=function(){var e=null,t=null,r=null,i=null,a={start:function(a,s){if(null!==a)if("string"==typeof a){if(!((a=a.toLowerCase())in n.md.algorithms))throw new Error('Unknown hash algorithm "'+a+'"');t=n.md.algorithms[a].create()}else t=a;if(null===s)s=e;else{if("string"==typeof s)s=n.util.createBuffer(s);else if(n.util.isArray(s)){var o=s;s=n.util.createBuffer();for(var u=0;u<o.length;++u)s.putByte(o[u])}var c=s.length();c>t.blockLength&&(t.start(),t.update(s.bytes()),s=t.digest()),r=n.util.createBuffer(),i=n.util.createBuffer(),c=s.length();for(u=0;u<c;++u){o=s.at(u);r.putByte(54^o),i.putByte(92^o)}if(c<t.blockLength)for(o=t.blockLength-c,u=0;u<o;++u)r.putByte(54),i.putByte(92);e=s,r=r.bytes(),i=i.bytes()}t.start(),t.update(r)},update:function(e){t.update(e)},getMac:function(){var e=t.digest().bytes();return t.start(),t.update(i),t.update(e),t.digest()}};return a.digest=a.getMac,a}},function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var i=r(20),a=r(55),s=r(14),o=r(11),u=r(19),c=r(34),l=n(r(24));t.seedWithNonce=function(e,t){return{seed:a.Seed.toBinary(e).seed,nonce:t}};t.keyPair=function(e){var t=a.Seed.toBinary(e),r=function(e,t){var r=[0,0,0,0];if(t&&t>0)for(var n=t,i=3;i>=0;i--)r[3-i]=Math.floor(n/Math.pow(2,8*i)),n%=Math.pow(2,8*i);var a=u.concat(r,e),o=s._hashChain(a);return s.sha256(o)}(t.seed,t.nonce),n=l.default.generateKeyPair(r);return{privateKey:n.private,publicKey:n.public}},t.address=function(e,r){return void 0===r&&(r=i.MAIN_NET_CHAIN_ID),c.isPublicKey(e)?function(e,t){void 0===t&&(t=i.MAIN_NET_CHAIN_ID);var r=[1,"string"==typeof t?t.charCodeAt(0):t],n=s._hashChain(e).slice(0,20),a=u.concat(r,n),o=s._hashChain(a).slice(0,4);return u.concat(a,o)}(o._fromIn(e.publicKey),r):t.address(t.keyPair(e),r)},t.publicKey=function(e){return c.isPrivateKey(e)?l.default.generateKeyPair(o._fromIn(e.privateKey)).public:t.keyPair(e).publicKey},t.privateKey=function(e){return t.keyPair(e).privateKey}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isPublicKey=function(e){return void 0!==e.publicKey},t.isPrivateKey=function(e){return void 0!==e.privateKey}},function(e,t,r){var n=r(1);r(2);var i=e.exports=n.pem=n.pem||{};function a(e){for(var t=e.name+": ",r=[],n=function(e,t){return" "+t},i=0;i<e.values.length;++i)r.push(e.values[i].replace(/^(\S+\r\n)/,n));t+=r.join(",")+"\r\n";var a=0,s=-1;for(i=0;i<t.length;++i,++a)if(a>65&&-1!==s){var o=t[s];","===o?(++s,t=t.substr(0,s)+"\r\n "+t.substr(s)):t=t.substr(0,s)+"\r\n"+o+t.substr(s+1),a=i-s-1,s=-1,++i}else" "!==t[i]&&"\t"!==t[i]&&","!==t[i]||(s=i);return t}function s(e){return e.replace(/^\s+/,"")}i.encode=function(e,t){t=t||{};var r,i="-----BEGIN "+e.type+"-----\r\n";if(e.procType&&(i+=a(r={name:"Proc-Type",values:[String(e.procType.version),e.procType.type]})),e.contentDomain&&(i+=a(r={name:"Content-Domain",values:[e.contentDomain]})),e.dekInfo&&(r={name:"DEK-Info",values:[e.dekInfo.algorithm]},e.dekInfo.parameters&&r.values.push(e.dekInfo.parameters),i+=a(r)),e.headers)for(var s=0;s<e.headers.length;++s)i+=a(e.headers[s]);return e.procType&&(i+="\r\n"),i+=n.util.encode64(e.body,t.maxline||64)+"\r\n",i+="-----END "+e.type+"-----\r\n"},i.decode=function(e){for(var t,r=[],i=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,a=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,o=/\r?\n/;t=i.exec(e);){var u={type:t[1],procType:null,contentDomain:null,dekInfo:null,headers:[],body:n.util.decode64(t[3])};if(r.push(u),t[2]){for(var c=t[2].split(o),l=0;t&&l<c.length;){for(var f=c[l].replace(/\s+$/,""),h=l+1;h<c.length;++h){var p=c[h];if(!/\s/.test(p[0]))break;f+=p,l=h}if(t=f.match(a)){for(var d={name:t[1],values:[]},y=t[2].split(","),g=0;g<y.length;++g)d.values.push(s(y[g]));if(u.procType)if(u.contentDomain||"Content-Domain"!==d.name)if(u.dekInfo||"DEK-Info"!==d.name)u.headers.push(d);else{if(0===d.values.length)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');u.dekInfo={algorithm:y[0],parameters:y[1]||null}}else u.contentDomain=y[0]||"";else{if("Proc-Type"!==d.name)throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');if(2!==d.values.length)throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');u.procType={version:y[0],type:y[1]}}}++l}if("ENCRYPTED"===u.procType&&!u.dekInfo)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')}}if(0===r.length)throw new Error("Invalid PEM formatted message.");return r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.concat=(...e)=>e.reduce((e,t)=>Uint8Array.from([...e,...t]),new Uint8Array(0)),t.range=(e,t,r=1)=>Array.from({length:t-e}).map((t,n)=>n*r+e)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(111),i=r(65),a=r(28),s=r(66);t.ALIAS_VERSION=2;t.P_OPTION=e=>(t,r=0)=>{if(0===t[r])return{value:null,shift:1};const n=e(t,r+1);return{value:n.value,shift:n.shift+1}},t.P_BYTE=(e,t=0)=>({value:e[t],shift:1}),t.P_SHORT=(e,t=0)=>({value:256*e[t]+e[t+1],shift:2}),t.P_INT=(e,t=0)=>({value:Math.pow(2,24)*e[t]+Math.pow(2,16)*e[t+1]+Math.pow(2,8)*e[t+2]+e[t+3],shift:4}),t.P_LONG=(e,t=0)=>({value:s.BigNumber.fromBytes(Array.from(e.slice(t,t+8))).toString(),shift:8}),t.P_BOOLEAN=(e,t=0)=>{return{value:!!e[t],shift:1}},t.P_STRING_FIXED=e=>(t,r=0)=>{const i=n.Utf8ArrayToStr(t.slice(r,r+e));return{shift:e,value:i}},t.P_STRING_VAR=e=>(r,n=0)=>{const i=e(r,n),{value:a}=t.P_STRING_FIXED(i.value)(r,n+i.shift);return{shift:i.value+i.shift,value:a}},t.P_BASE58_FIXED=e=>(t,r=0)=>{return{value:i.default.encode(t.slice(r,r+e)),shift:e}},t.P_BASE58_VAR=e=>(r,n=0)=>{const i=e(r,n),{value:a}=t.P_BASE58_FIXED(i.value)(r,n+2);return{shift:i.value+2,value:a}},t.P_BASE64=e=>(t,r=0)=>{const n=e(t,r),i=`base64:${a.fromByteArray(t.slice(r+n.shift,r+n.shift+n.value))}`;return{shift:n.value+n.shift,value:i}};t.byteToStringWithLength=(e,r=0)=>{const i=t.P_SHORT(e,r),{value:a}=(e=>(t,r)=>{const i=n.Utf8ArrayToStr(t.slice(r,r+e));return{shift:e,value:i}})(i.value)(e,r+2);return{shift:i.value+2,value:a}},t.byteToBase58=(e,t=0,r)=>{const n=r||32;return{value:i.default.encode(e.slice(t,t+n)),shift:n}},t.byteToBase58WithLength=(e,r=0)=>{const n=t.P_SHORT(e,r);return{value:i.default.encode(e.slice(r+n.shift,r+n.shift+n.value)),shift:n.shift+n.value}},t.byteToAddressOrAlias=(e,r=0)=>{if(e[r]===t.ALIAS_VERSION){const n=t.byteToStringWithLength(e,r+2);return{shift:n.shift+2,value:`alias:${String.fromCharCode(e[r+1])}:${n.value}`}}return t.byteToBase58(e,r,26)},t.byteNewAliasToString=(e,r=0)=>{const n=t.P_SHORT(e,r).value+2,{value:i}=t.byteToStringWithLength(e,r);return{shift:n,value:i}},t.byteToScript=(e,r=0)=>{if(0===e[r])return{shift:1,value:null};const n=t.P_SHORT(e,r+1),i=r+1+n.shift,s=r+1+n.shift+n.value;return{value:`base64:${a.fromByteArray(e.slice(i,s))}`,shift:s-r}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.reissue=function(e,t){const r=n.TRANSACTION_TYPE.REISSUE,u=e.version||2,c=a.convertToPairs(t),l={type:r,version:u,senderPublicKey:a.getSenderPublicKey(c,e),assetId:e.assetId,quantity:e.quantity,reissuable:e.reissuable,chainId:a.networkByte(e.chainId,87),fee:a.fee(e,1e8),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};o.validate.reissue(l);const f=s.binary.serializeTx(l);return c.forEach(([e,t])=>a.addProof(l,i.signBytes(e,f),t)),l.id=i.base58Encode(i.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(3),a=r(4),s=r(7),o=r(5);t.burn=function(e,t){const r=n.TRANSACTION_TYPE.BURN,u=e.version||2,c=s.convertToPairs(t),l={type:r,version:u,senderPublicKey:s.getSenderPublicKey(c,e),assetId:e.assetId,quantity:e.quantity,chainId:s.networkByte(e.chainId,87),fee:s.fee(e,1e5),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};o.validate.burn(l);const f=i.binary.serializeTx(l);return c.forEach(([e,t])=>s.addProof(l,a.signBytes(e,f),t)),l.id=a.base58Encode(a.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(3),a=r(4),s=r(7),o=r(5);t.exchange=function(e,t){const r=n.TRANSACTION_TYPE.EXCHANGE,u=e.version||2,c=s.convertToPairs(t),l={type:r,version:u,senderPublicKey:s.getSenderPublicKey(c,e),order1:e.order1,order2:e.order2,price:e.price,amount:e.amount,buyMatcherFee:e.buyMatcherFee,sellMatcherFee:e.sellMatcherFee,fee:s.fee(e,1e5),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};o.validate.exchange(l);const f=i.binary.serializeTx(l);return c.forEach(([e,t])=>s.addProof(l,a.signBytes(e,f),t)),Object.assign({},l,{id:a.base58Encode(a.blake2b(f))})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.lease=function(e,t){const r=n.TRANSACTION_TYPE.LEASE,u=e.version||2,c=a.convertToPairs(t),l={type:r,version:u,senderPublicKey:a.getSenderPublicKey(c,e),amount:e.amount,recipient:e.recipient,fee:a.fee(e,1e5),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};o.validate.lease(l);const f=s.binary.serializeTx(l);return c.forEach(([e,t])=>a.addProof(l,i.signBytes(e,f),t)),l.id=i.base58Encode(i.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(3),a=r(4),s=r(7),o=r(5);t.cancelLease=function(e,t){const r=n.TRANSACTION_TYPE.CANCEL_LEASE,u=e.version||2,c=s.convertToPairs(t),l={type:r,version:u,senderPublicKey:s.getSenderPublicKey(c,e),leaseId:e.leaseId,fee:s.fee(e,1e5),timestamp:e.timestamp||Date.now(),chainId:s.networkByte(e.chainId,87),proofs:e.proofs||[],id:""};o.validate.cancelLease(l);const f=i.binary.serializeTx(l);return c.forEach(([e,t])=>s.addProof(l,a.signBytes(e,f),t)),l.id=a.base58Encode(a.blake2b(f)),l}},function(e,t,r){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});const n=r(3),{BASE58_STRING:i,BASE64_STRING:a,BYTE:s,BYTES:o,COUNT:u,LEN:c,LONG:l,SHORT:f,STRING:h}=n.serializePrimitives,p=r(4),d=r(0),y=r(7),g=r(3),m=r(5),v={integer:["integer",0,l],number:["integer",0,l],boolean:["boolean",1,s],string:["string",3,c(f)(h)],binary:["binary",2,e=>c(f)(a)(e.slice(7))],_:["binary",2,c(f)(o)]},b=e=>v[typeof e]||v._;t.data=function(t,r){const n=d.TRANSACTION_TYPE.DATA,a=t.version||1,o=y.convertToPairs(r),v=y.getSenderPublicKey(o,t);if(!Array.isArray(t.data))throw new Error('["data should be array"]');const E=t.timestamp||Date.now();let S=p.concat(s(d.TRANSACTION_TYPE.DATA),s(1),i(v),u(f)(e=>p.concat(c(f)(h)(e.key),[b(e.value)[1]],b(e.value)[2](e.value)))(t.data),l(E));const T=1e5*Math.floor(1+(S.length+8-1)/1024),C={type:n,version:a,senderPublicKey:v,fee:y.fee(t,T),timestamp:E,proofs:t.proofs||[],id:"",data:t.data&&t.data.map(t=>{if(t.type)return t;{const r=b(t.value)[0];return{type:r,key:t.key,value:"binary"===r?"base64:"+e.from(t.value).toString("base64"):t.value}}})};m.validate.data(C);const A=g.binary.serializeTx(C);return o.forEach(([e,t])=>y.addProof(C,p.signBytes(e,A),t)),C.id=p.base58Encode(p.blake2b(A)),C}}).call(this,r(13).Buffer)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.issue=function(e,t){const r=n.TRANSACTION_TYPE.ISSUE,u=e.version||2,c=a.convertToPairs(t),l={type:r,version:u,senderPublicKey:a.getSenderPublicKey(c,e),name:e.name,description:e.description,quantity:e.quantity,script:null==e.script?void 0:a.base64Prefix(e.script),decimals:null==e.decimals?8:e.decimals,reissuable:e.reissuable||!1,fee:1===e.quantity?a.fee(e,1e6):a.fee(e,1e8),timestamp:e.timestamp||Date.now(),chainId:a.networkByte(e.chainId,87),proofs:e.proofs||[],id:""};o.validate.issue(l);const f=s.binary.serializeTx(l);return c.forEach(([e,t])=>a.addProof(l,i.signBytes(e,f),t)),l.id=i.base58Encode(i.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(5),o=r(3);t.transfer=function(e,t){const r=n.TRANSACTION_TYPE.TRANSFER,u=e.version||2,c=a.convertToPairs(t),l={type:r,version:u,senderPublicKey:a.getSenderPublicKey(c,e),assetId:a.normalizeAssetId(e.assetId),recipient:e.recipient,amount:e.amount,attachment:e.attachment||"",fee:a.fee(e,1e5),feeAssetId:a.normalizeAssetId(e.feeAssetId),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};s.validate.transfer(l);const f=o.binary.serializeTx(l);return c.forEach(([e,t])=>a.addProof(l,i.signBytes(e,f),t)),l.id=i.base58Encode(i.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(3),a=r(4),s=r(7),o=r(5);t.alias=function(e,t){const r=n.TRANSACTION_TYPE.ALIAS,u=e.version||2,c=s.convertToPairs(t),l={type:r,version:u,senderPublicKey:s.getSenderPublicKey(c,e),alias:e.alias,fee:s.fee(e,1e5),timestamp:e.timestamp||Date.now(),chainId:s.networkByte(e.chainId,87),proofs:e.proofs||[],id:""};o.validate.alias(l);const f=i.binary.serializeTx(l);c.forEach(([e,t])=>s.addProof(l,a.signBytes(e,f),t));const h=[f[0],...f.slice(36,-16)];return l.id=a.base58Encode(a.blake2b(Uint8Array.from(h))),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.setScript=function(e,t){const r=n.TRANSACTION_TYPE.SET_SCRIPT,u=e.version||1,c=a.convertToPairs(t),l=a.getSenderPublicKey(c,e);if(void 0===e.script)throw new Error("Script field cannot be undefined. Use null explicitly to remove script");const f={type:r,version:u,senderPublicKey:l,chainId:a.networkByte(e.chainId,87),fee:a.fee(e,1e6),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:"",script:a.base64Prefix(e.script)};o.validate.setScript(f);const h=s.binary.serializeTx(f);return c.forEach(([e,t])=>a.addProof(f,i.signBytes(e,h),t)),f.id=i.base58Encode(i.blake2b(h)),f}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.setAssetScript=function(e,t){const r=n.TRANSACTION_TYPE.SET_ASSET_SCRIPT,u=e.version||1,c=a.convertToPairs(t),l=a.getSenderPublicKey(c,e);if(null==e.script)throw new Error("Asset script cannot be empty");const f={type:r,version:u,senderPublicKey:l,assetId:e.assetId,chainId:a.networkByte(e.chainId,87),fee:a.fee(e,1e8),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:"",script:a.base64Prefix(e.script)};o.validate.setAssetScript(f);const h=s.binary.serializeTx(f);return c.forEach(([e,t])=>a.addProof(f,i.signBytes(e,h),t)),f.id=i.base58Encode(i.blake2b(h)),f}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.sponsorship=function(e,t){const r=n.TRANSACTION_TYPE.SPONSORSHIP,u=e.version||1,c=a.convertToPairs(t),l={type:r,version:u,senderPublicKey:a.getSenderPublicKey(c,e),minSponsoredAssetFee:e.minSponsoredAssetFee,assetId:e.assetId,fee:a.fee(e,1e8),timestamp:e.timestamp||Date.now(),proofs:e.proofs||[],id:""};o.validate.sponsorship(l);const f=s.binary.serializeTx(l);return c.forEach(([e,t])=>a.addProof(l,i.signBytes(e,f),t)),l.id=i.base58Encode(i.blake2b(f)),l}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(4),a=r(7),s=r(3),o=r(5);t.invokeScript=function(e,t){const r=n.TRANSACTION_TYPE.INVOKE_SCRIPT,c=e.version||1,l=a.convertToPairs(t),f={type:r,version:c,senderPublicKey:a.getSenderPublicKey(l,e),dApp:e.dApp,call:e.call&&Object.assign({args:[]},e.call),payment:u(e.payment),fee:a.fee(e,5e5),feeAssetId:a.normalizeAssetId(e.feeAssetId),timestamp:e.timestamp||Date.now(),chainId:a.networkByte(e.chainId,87),proofs:e.proofs||[],id:""};o.validate.invokeScript(f);const h=s.binary.serializeTx(f);return l.forEach(([e,t])=>a.addProof(f,i.signBytes(e,h),t)),f.id=i.base58Encode(i.base58Encode(i.blake2b(h))),f};const u=e=>null==e?[]:e.map(e=>Object.assign({},e,{assetId:"WAVES"===e.assetId?null:e.assetId}))},function(e,t,r){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var i in t=arguments[r])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)},i=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,a=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=a.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=a.return)&&r.call(a)}finally{if(i)throw i.error}}return s},a=this&&this.__spread||function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(i(arguments[t]));return e};Object.defineProperty(t,"__esModule",{value:!0});var s=r(22),o=r(54),u=r(23),c=r(10),l=r(19),f=r(14),h=r(33),p=r(96),d=r(97),y=r(98),g=r(109),m=r(110);t.crypto=function(e){if(e&&""==e.seed)throw new Error("Empty seed is not allowed.");var t,r=function(e,t){return function(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];return e.apply(void 0,a([t],r))}},i=function(t){return function(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];var i=t.apply(void 0,a(r));return!e||e&&"Base58"===e.output?u.base58Encode(i):i}},v=e&&e.seed?e.seed:void 0,b={seedWithNonce:v?r(h.seedWithNonce,v):h.seedWithNonce,signBytes:i(v?r(p.signBytes,v):p.signBytes),keyPair:(t=v?r(h.keyPair,v):h.keyPair,function(){for(var r=[],n=0;n<arguments.length;n++)r[n]=arguments[n];var i=t.apply(void 0,a(r));return!e||e&&"Base58"===e.output?{privateKey:u.base58Encode(i.privateKey),publicKey:u.base58Encode(i.publicKey)}:i}),publicKey:i(v?r(h.publicKey,v):h.publicKey),privateKey:i(v?r(h.privateKey,v):h.privateKey),address:i(v?r(h.address,v):h.address)};return n({},b,{sharedKey:i(o.sharedKey),blake2b:f.blake2b,keccak:f.keccak,sha256:f.sha256,base64Encode:u.base64Encode,base64Decode:u.base64Decode,base58Encode:u.base58Encode,base58Decode:u.base58Decode,base16Encode:u.base16Encode,base16Decode:u.base16Decode,stringToBytes:c.stringToBytes,bytesToString:c.bytesToString,random:s.random,randomSeed:s.randomSeed,randomBytes:s.randomBytes,verifySignature:d.verifySignature,verifyPublicKey:d.verifyPublicKey,verifyAddress:d.verifyAddress,messageDecrypt:o.messageDecrypt,messageEncrypt:o.messageEncrypt,aesDecrypt:o.aesDecrypt,aesEncrypt:o.aesEncrypt,encryptSeed:g.encryptSeed,decryptSeed:g.decryptSeed,rsaKeyPair:y.rsaKeyPair,rsaKeyPairSync:y.rsaKeyPairSync,rsaSign:y.rsaSign,rsaVerify:y.rsaVerify,merkleVerify:m.merkleVerify,split:l.split,concat:l.concat})}},function(e,t,r){var n=r(1);r(2),n.cipher=n.cipher||{};var i=e.exports=n.cipher.modes=n.cipher.modes||{};function a(e){if("string"==typeof e&&(e=n.util.createBuffer(e)),n.util.isArray(e)&&e.length>4){var t=e;e=n.util.createBuffer();for(var r=0;r<t.length;++r)e.putByte(t[r])}return n.util.isArray(e)||(e=[e.getInt32(),e.getInt32(),e.getInt32(),e.getInt32()]),e}function s(e){e[e.length-1]=e[e.length-1]+1&4294967295}function o(e){return[e/4294967296|0,4294967295&e]}i.ecb=function(e){e=e||{},this.name="ECB",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)},i.ecb.prototype.start=function(e){},i.ecb.prototype.encrypt=function(e,t,r){if(e.length()<this.blockSize&&!(r&&e.length()>0))return!0;for(var n=0;n<this._ints;++n)this._inBlock[n]=e.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(n=0;n<this._ints;++n)t.putInt32(this._outBlock[n])},i.ecb.prototype.decrypt=function(e,t,r){if(e.length()<this.blockSize&&!(r&&e.length()>0))return!0;for(var n=0;n<this._ints;++n)this._inBlock[n]=e.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(n=0;n<this._ints;++n)t.putInt32(this._outBlock[n])},i.ecb.prototype.pad=function(e,t){var r=e.length()===this.blockSize?this.blockSize:this.blockSize-e.length();return e.fillWithByte(r,r),!0},i.ecb.prototype.unpad=function(e,t){if(t.overflow>0)return!1;var r=e.length(),n=e.at(r-1);return!(n>this.blockSize<<2)&&(e.truncate(n),!0)},i.cbc=function(e){e=e||{},this.name="CBC",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)},i.cbc.prototype.start=function(e){if(null===e.iv){if(!this._prev)throw new Error("Invalid IV parameter.");this._iv=this._prev.slice(0)}else{if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=a(e.iv),this._prev=this._iv.slice(0)}},i.cbc.prototype.encrypt=function(e,t,r){if(e.length()<this.blockSize&&!(r&&e.length()>0))return!0;for(var n=0;n<this._ints;++n)this._inBlock[n]=this._prev[n]^e.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(n=0;n<this._ints;++n)t.putInt32(this._outBlock[n]);this._prev=this._outBlock},i.cbc.prototype.decrypt=function(e,t,r){if(e.length()<this.blockSize&&!(r&&e.length()>0))return!0;for(var n=0;n<this._ints;++n)this._inBlock[n]=e.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(n=0;n<this._ints;++n)t.putInt32(this._prev[n]^this._outBlock[n]);this._prev=this._inBlock.slice(0)},i.cbc.prototype.pad=function(e,t){var r=e.length()===this.blockSize?this.blockSize:this.blockSize-e.length();return e.fillWithByte(r,r),!0},i.cbc.prototype.unpad=function(e,t){if(t.overflow>0)return!1;var r=e.length(),n=e.at(r-1);return!(n>this.blockSize<<2)&&(e.truncate(n),!0)},i.cfb=function(e){e=e||{},this.name="CFB",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialBlock=new Array(this._ints),this._partialOutput=n.util.createBuffer(),this._partialBytes=0},i.cfb.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=a(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},i.cfb.prototype.encrypt=function(e,t,r){var n=e.length();if(0===n)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),0===this._partialBytes&&n>=this.blockSize)for(var i=0;i<this._ints;++i)this._inBlock[i]=e.getInt32()^this._outBlock[i],t.putInt32(this._inBlock[i]);else{var a=(this.blockSize-n)%this.blockSize;a>0&&(a=this.blockSize-a),this._partialOutput.clear();for(i=0;i<this._ints;++i)this._partialBlock[i]=e.getInt32()^this._outBlock[i],this._partialOutput.putInt32(this._partialBlock[i]);if(a>0)e.read-=this.blockSize;else for(i=0;i<this._ints;++i)this._inBlock[i]=this._partialBlock[i];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),a>0&&!r)return t.putBytes(this._partialOutput.getBytes(a-this._partialBytes)),this._partialBytes=a,!0;t.putBytes(this._partialOutput.getBytes(n-this._partialBytes)),this._partialBytes=0}},i.cfb.prototype.decrypt=function(e,t,r){var n=e.length();if(0===n)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),0===this._partialBytes&&n>=this.blockSize)for(var i=0;i<this._ints;++i)this._inBlock[i]=e.getInt32(),t.putInt32(this._inBlock[i]^this._outBlock[i]);else{var a=(this.blockSize-n)%this.blockSize;a>0&&(a=this.blockSize-a),this._partialOutput.clear();for(i=0;i<this._ints;++i)this._partialBlock[i]=e.getInt32(),this._partialOutput.putInt32(this._partialBlock[i]^this._outBlock[i]);if(a>0)e.read-=this.blockSize;else for(i=0;i<this._ints;++i)this._inBlock[i]=this._partialBlock[i];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),a>0&&!r)return t.putBytes(this._partialOutput.getBytes(a-this._partialBytes)),this._partialBytes=a,!0;t.putBytes(this._partialOutput.getBytes(n-this._partialBytes)),this._partialBytes=0}},i.ofb=function(e){e=e||{},this.name="OFB",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=n.util.createBuffer(),this._partialBytes=0},i.ofb.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=a(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},i.ofb.prototype.encrypt=function(e,t,r){var n=e.length();if(0===e.length())return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),0===this._partialBytes&&n>=this.blockSize)for(var i=0;i<this._ints;++i)t.putInt32(e.getInt32()^this._outBlock[i]),this._inBlock[i]=this._outBlock[i];else{var a=(this.blockSize-n)%this.blockSize;a>0&&(a=this.blockSize-a),this._partialOutput.clear();for(i=0;i<this._ints;++i)this._partialOutput.putInt32(e.getInt32()^this._outBlock[i]);if(a>0)e.read-=this.blockSize;else for(i=0;i<this._ints;++i)this._inBlock[i]=this._outBlock[i];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),a>0&&!r)return t.putBytes(this._partialOutput.getBytes(a-this._partialBytes)),this._partialBytes=a,!0;t.putBytes(this._partialOutput.getBytes(n-this._partialBytes)),this._partialBytes=0}},i.ofb.prototype.decrypt=i.ofb.prototype.encrypt,i.ctr=function(e){e=e||{},this.name="CTR",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=n.util.createBuffer(),this._partialBytes=0},i.ctr.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");this._iv=a(e.iv),this._inBlock=this._iv.slice(0),this._partialBytes=0},i.ctr.prototype.encrypt=function(e,t,r){var n=e.length();if(0===n)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),0===this._partialBytes&&n>=this.blockSize)for(var i=0;i<this._ints;++i)t.putInt32(e.getInt32()^this._outBlock[i]);else{var a=(this.blockSize-n)%this.blockSize;a>0&&(a=this.blockSize-a),this._partialOutput.clear();for(i=0;i<this._ints;++i)this._partialOutput.putInt32(e.getInt32()^this._outBlock[i]);if(a>0&&(e.read-=this.blockSize),this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),a>0&&!r)return t.putBytes(this._partialOutput.getBytes(a-this._partialBytes)),this._partialBytes=a,!0;t.putBytes(this._partialOutput.getBytes(n-this._partialBytes)),this._partialBytes=0}s(this._inBlock)},i.ctr.prototype.decrypt=i.ctr.prototype.encrypt,i.gcm=function(e){e=e||{},this.name="GCM",this.cipher=e.cipher,this.blockSize=e.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints),this._partialOutput=n.util.createBuffer(),this._partialBytes=0,this._R=3774873600},i.gcm.prototype.start=function(e){if(!("iv"in e))throw new Error("Invalid IV parameter.");var t,r=n.util.createBuffer(e.iv);if(this._cipherLength=0,t="additionalData"in e?n.util.createBuffer(e.additionalData):n.util.createBuffer(),this._tagLength="tagLength"in e?e.tagLength:128,this._tag=null,e.decrypt&&(this._tag=n.util.createBuffer(e.tag).getBytes(),this._tag.length!==this._tagLength/8))throw new Error("Authentication tag does not match tag length.");this._hashBlock=new Array(this._ints),this.tag=null,this._hashSubkey=new Array(this._ints),this.cipher.encrypt([0,0,0,0],this._hashSubkey),this.componentBits=4,this._m=this.generateHashTable(this._hashSubkey,this.componentBits);var i=r.length();if(12===i)this._j0=[r.getInt32(),r.getInt32(),r.getInt32(),1];else{for(this._j0=[0,0,0,0];r.length()>0;)this._j0=this.ghash(this._hashSubkey,this._j0,[r.getInt32(),r.getInt32(),r.getInt32(),r.getInt32()]);this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(o(8*i)))}this._inBlock=this._j0.slice(0),s(this._inBlock),this._partialBytes=0,t=n.util.createBuffer(t),this._aDataLength=o(8*t.length());var a=t.length()%this.blockSize;for(a&&t.fillWithByte(0,this.blockSize-a),this._s=[0,0,0,0];t.length()>0;)this._s=this.ghash(this._hashSubkey,this._s,[t.getInt32(),t.getInt32(),t.getInt32(),t.getInt32()])},i.gcm.prototype.encrypt=function(e,t,r){var n=e.length();if(0===n)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),0===this._partialBytes&&n>=this.blockSize){for(var i=0;i<this._ints;++i)t.putInt32(this._outBlock[i]^=e.getInt32());this._cipherLength+=this.blockSize}else{var a=(this.blockSize-n)%this.blockSize;a>0&&(a=this.blockSize-a),this._partialOutput.clear();for(i=0;i<this._ints;++i)this._partialOutput.putInt32(e.getInt32()^this._outBlock[i]);if(a<=0||r){if(r){var o=n%this.blockSize;this._cipherLength+=o,this._partialOutput.truncate(this.blockSize-o)}else this._cipherLength+=this.blockSize;for(i=0;i<this._ints;++i)this._outBlock[i]=this._partialOutput.getInt32();this._partialOutput.read-=this.blockSize}if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),a>0&&!r)return e.read-=this.blockSize,t.putBytes(this._partialOutput.getBytes(a-this._partialBytes)),this._partialBytes=a,!0;t.putBytes(this._partialOutput.getBytes(n-this._partialBytes)),this._partialBytes=0}this._s=this.ghash(this._hashSubkey,this._s,this._outBlock),s(this._inBlock)},i.gcm.prototype.decrypt=function(e,t,r){var n=e.length();if(n<this.blockSize&&!(r&&n>0))return!0;this.cipher.encrypt(this._inBlock,this._outBlock),s(this._inBlock),this._hashBlock[0]=e.getInt32(),this._hashBlock[1]=e.getInt32(),this._hashBlock[2]=e.getInt32(),this._hashBlock[3]=e.getInt32(),this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);for(var i=0;i<this._ints;++i)t.putInt32(this._outBlock[i]^this._hashBlock[i]);n<this.blockSize?this._cipherLength+=n%this.blockSize:this._cipherLength+=this.blockSize},i.gcm.prototype.afterFinish=function(e,t){var r=!0;t.decrypt&&t.overflow&&e.truncate(this.blockSize-t.overflow),this.tag=n.util.createBuffer();var i=this._aDataLength.concat(o(8*this._cipherLength));this._s=this.ghash(this._hashSubkey,this._s,i);var a=[];this.cipher.encrypt(this._j0,a);for(var s=0;s<this._ints;++s)this.tag.putInt32(this._s[s]^a[s]);return this.tag.truncate(this.tag.length()%(this._tagLength/8)),t.decrypt&&this.tag.bytes()!==this._tag&&(r=!1),r},i.gcm.prototype.multiply=function(e,t){for(var r=[0,0,0,0],n=t.slice(0),i=0;i<128;++i){e[i/32|0]&1<<31-i%32&&(r[0]^=n[0],r[1]^=n[1],r[2]^=n[2],r[3]^=n[3]),this.pow(n,n)}return r},i.gcm.prototype.pow=function(e,t){for(var r=1&e[3],n=3;n>0;--n)t[n]=e[n]>>>1|(1&e[n-1])<<31;t[0]=e[0]>>>1,r&&(t[0]^=this._R)},i.gcm.prototype.tableMultiply=function(e){for(var t=[0,0,0,0],r=0;r<32;++r){var n=e[r/8|0]>>>4*(7-r%8)&15,i=this._m[r][n];t[0]^=i[0],t[1]^=i[1],t[2]^=i[2],t[3]^=i[3]}return t},i.gcm.prototype.ghash=function(e,t,r){return t[0]^=r[0],t[1]^=r[1],t[2]^=r[2],t[3]^=r[3],this.tableMultiply(t)},i.gcm.prototype.generateHashTable=function(e,t){for(var r=8/t,n=4*r,i=16*r,a=new Array(i),s=0;s<i;++s){var o=[0,0,0,0],u=(n-1-s%n)*t;o[s/n|0]=1<<t-1<<u,a[s]=this.generateSubHashTable(this.multiply(o,e),t)}return a},i.gcm.prototype.generateSubHashTable=function(e,t){var r=1<<t,n=r>>>1,i=new Array(r);i[n]=e.slice(0);for(var a=n>>>1;a>0;)this.pow(i[2*a],i[a]=[]),a>>=1;for(a=2;a<n;){for(var s=1;s<a;++s){var o=i[a],u=i[s];i[a+s]=[o[0]^u[0],o[1]^u[1],o[2]^u[2],o[3]^u[3]]}a*=2}for(i[0]=[0,0,0,0],a=n+1;a<r;++a){var c=i[a^n];i[a]=[e[0]^c[0],e[1]^c[1],e[2]^c[2],e[3]^c[3]]}return i}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.seedWordsList=["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"]},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,a=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=a.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=a.return)&&r.call(a)}finally{if(i)throw i.error}}return s},i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t},a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var s=i(r(30)),o=i(r(2)),u=r(22),c=r(11),l=r(14),f=r(19),h=a(r(24)),p=r(10);t.aesEncrypt=function(e,t,r,n){void 0===r&&(r="CBC");var i=s.createCipher("AES-"+r,p.bytesToString(c._fromIn(t),"raw"));return i.start({iv:n&&o.createBuffer(p.bytesToString(c._fromIn(n),"raw"))}),i.update(o.createBuffer(p.bytesToString(e,"raw"))),i.finish(),p.stringToBytes(i.output.getBytes(),"raw")},t.aesDecrypt=function(e,t,r,n){void 0===r&&(r="CBC");var i=s.createDecipher("AES-"+r,p.bytesToString(c._fromIn(t),"raw"));i.start({iv:n&&o.createBuffer(p.bytesToString(c._fromIn(n),"raw"))});var a=o.createBuffer(p.bytesToString(c._fromIn(e),"raw"));if(i.update(a),!i.finish())throw new Error("Failed to decrypt data with provided key");return p.stringToBytes(i.output.getBytes(),"raw")},t.messageEncrypt=function(e,r){var n=Uint8Array.from([1]),i=u.randomBytes(32),a=u.randomBytes(16),s=p.stringToBytes(r),o=t.aesEncrypt(s,i,"CTR",a),c=t.aesEncrypt(i,e,"ECB"),h=l.hmacSHA256(s,i),d=l.hmacSHA256(f.concat(i,a),e);return f.concat(n,c,d,h,a,o)},t.messageDecrypt=function(e,r){var i=n(f.split(r,1,48,32,32,16),6),a=(i[0],i[1]),s=i[2],o=i[3],u=i[4],h=i[5],d=t.aesDecrypt(a,e,"ECB");if(!c._fromIn(l.hmacSHA256(f.concat(d,u),c._fromIn(e))).every((function(e,t){return e===s[t]})))throw new Error("Invalid key");var y=t.aesDecrypt(h,d,"CTR",u);if(!c._fromIn(l.hmacSHA256(y,d)).every((function(e,t){return e===o[t]})))throw new Error("Invalid message");return p.bytesToString(y)},t.sharedKey=function(e,t,r){var n=h.default.sharedKey(c._fromIn(e),c._fromIn(t)),i=l.sha256(c._fromRawIn(r));return l.hmacSHA256(n,i)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(11),i=r(10);t.Seed={isSeedWithNonce:function(e){return void 0!==e.nonce},toBinary:function(e){return t.Seed.isSeedWithNonce(e)?{seed:t.Seed.toBinary(e.seed).seed,nonce:e.nonce}:{seed:n._fromRawIn(e),nonce:void 0}},toString:function(e){return i.bytesToString(t.Seed.toBinary(e).seed)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(20),i=r(20);t.ChaidId={toNumber:function(e){return"string"==typeof e?e.charCodeAt(0):e},isMainnet:function(e){return t.ChaidId.toNumber(e)===n.MAIN_NET_CHAIN_ID},isTestnet:function(e){return t.ChaidId.toNumber(e)===i.TEST_NET_CHAIN_ID}}},function(e,t,r){var n=r(1);if(r(29),r(15),r(58),r(9),r(16),r(59),r(35),r(12),r(100),r(25),r(2),void 0===i)var i=n.jsbn.BigInteger;var a=n.asn1,s=n.pki=n.pki||{};e.exports=s.pbe=n.pbe=n.pbe||{};var o=s.oids,u={name:"EncryptedPrivateKeyInfo",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:a.Class.UNIVERSAL,type:a.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:a.Class.UNIVERSAL,type:a.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},c={name:"PBES2Algorithms",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:a.Class.UNIVERSAL,type:a.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:a.Class.UNIVERSAL,type:a.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:a.Class.UNIVERSAL,type:a.Type.INTEGER,constructed:!1,capture:"kdfIterationCount"},{name:"PBES2Algorithms.params.keyLength",tagClass:a.Class.UNIVERSAL,type:a.Type.INTEGER,constructed:!1,optional:!0,capture:"keyLength"},{name:"PBES2Algorithms.params.prf",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,optional:!0,value:[{name:"PBES2Algorithms.params.prf.algorithm",tagClass:a.Class.UNIVERSAL,type:a.Type.OID,constructed:!1,capture:"prfOid"}]}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:a.Class.UNIVERSAL,type:a.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:a.Class.UNIVERSAL,type:a.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},l={name:"pkcs-12PbeParams",tagClass:a.Class.UNIVERSAL,type:a.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:a.Class.UNIVERSAL,type:a.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:a.Class.UNIVERSAL,type:a.Type.INTEGER,constructed:!1,capture:"iterations"}]};function f(e,t){return e.start().update(t).digest().getBytes()}function h(e){var t;if(e){if(!(t=s.oids[a.derToOid(e)])){var r=new Error("Unsupported PRF OID.");throw r.oid=e,r.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],r}}else t="hmacWithSHA1";return p(t)}function p(e){var t=n.md;switch(e){case"hmacWithSHA224":t=n.md.sha512;case"hmacWithSHA1":case"hmacWithSHA256":case"hmacWithSHA384":case"hmacWithSHA512":e=e.substr(8).toLowerCase();break;default:var r=new Error("Unsupported PRF algorithm.");throw r.algorithm=e,r.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],r}if(!(t&&e in t))throw new Error("Unknown hash algorithm: "+e);return t[e].create()}s.encryptPrivateKeyInfo=function(e,t,r){(r=r||{}).saltSize=r.saltSize||8,r.count=r.count||2048,r.algorithm=r.algorithm||"aes128",r.prfAlgorithm=r.prfAlgorithm||"sha1";var i,u,c,l=n.random.getBytesSync(r.saltSize),f=r.count,h=a.integerToDer(f);if(0===r.algorithm.indexOf("aes")||"des"===r.algorithm){var d,y,g;switch(r.algorithm){case"aes128":i=16,d=16,y=o["aes128-CBC"],g=n.aes.createEncryptionCipher;break;case"aes192":i=24,d=16,y=o["aes192-CBC"],g=n.aes.createEncryptionCipher;break;case"aes256":i=32,d=16,y=o["aes256-CBC"],g=n.aes.createEncryptionCipher;break;case"des":i=8,d=8,y=o.desCBC,g=n.des.createEncryptionCipher;break;default:throw(T=new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm=r.algorithm,T}var m="hmacWith"+r.prfAlgorithm.toUpperCase(),v=p(m),b=n.pkcs5.pbkdf2(t,l,f,i,v),E=n.random.getBytesSync(d);(C=g(b)).start(E),C.update(a.toDer(e)),C.finish(),c=C.output.getBytes();var S=function(e,t,r,i){var o=a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OCTETSTRING,!1,e),a.create(a.Class.UNIVERSAL,a.Type.INTEGER,!1,t.getBytes())]);"hmacWithSHA1"!==i&&o.value.push(a.create(a.Class.UNIVERSAL,a.Type.INTEGER,!1,n.util.hexToBytes(r.toString(16))),a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OID,!1,a.oidToDer(s.oids[i]).getBytes()),a.create(a.Class.UNIVERSAL,a.Type.NULL,!1,"")]));return o}(l,h,i,m);u=a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OID,!1,a.oidToDer(o.pkcs5PBES2).getBytes()),a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OID,!1,a.oidToDer(o.pkcs5PBKDF2).getBytes()),S]),a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OID,!1,a.oidToDer(y).getBytes()),a.create(a.Class.UNIVERSAL,a.Type.OCTETSTRING,!1,E)])])])}else{var T;if("3des"!==r.algorithm)throw(T=new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm=r.algorithm,T;i=24;var C,A=new n.util.ByteBuffer(l);b=s.pbe.generatePkcs12Key(t,A,1,f,i),E=s.pbe.generatePkcs12Key(t,A,2,f,i);(C=n.des.createEncryptionCipher(b)).start(E),C.update(a.toDer(e)),C.finish(),c=C.output.getBytes(),u=a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OID,!1,a.oidToDer(o["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[a.create(a.Class.UNIVERSAL,a.Type.OCTETSTRING,!1,l),a.create(a.Class.UNIVERSAL,a.Type.INTEGER,!1,h.getBytes())])])}return a.create(a.Class.UNIVERSAL,a.Type.SEQUENCE,!0,[u,a.create(a.Class.UNIVERSAL,a.Type.OCTETSTRING,!1,c)])},s.decryptPrivateKeyInfo=function(e,t){var r=null,i={},o=[];if(!a.validate(e,u,i,o)){var c=new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw c.errors=o,c}var l=a.derToOid(i.encryptionOid),f=s.pbe.getCipher(l,i.encryptionParams,t),h=n.util.createBuffer(i.encryptedData);return f.update(h),f.finish()&&(r=a.fromDer(f.output)),r},s.encryptedPrivateKeyToPem=function(e,t){var r={type:"ENCRYPTED PRIVATE KEY",body:a.toDer(e).getBytes()};return n.pem.encode(r,{maxline:t})},s.encryptedPrivateKeyFromPem=function(e){var t=n.pem.decode(e)[0];if("ENCRYPTED PRIVATE KEY"!==t.type){var r=new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');throw r.headerType=t.type,r}if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");return a.fromDer(t.body)},s.encryptRsaPrivateKey=function(e,t,r){if(!(r=r||{}).legacy){var i=s.wrapRsaPrivateKey(s.privateKeyToAsn1(e));return i=s.encryptPrivateKeyInfo(i,t,r),s.encryptedPrivateKeyToPem(i)}var o,u,c,l;switch(r.algorithm){case"aes128":o="AES-128-CBC",c=16,u=n.random.getBytesSync(16),l=n.aes.createEncryptionCipher;break;case"aes192":o="AES-192-CBC",c=24,u=n.random.getBytesSync(16),l=n.aes.createEncryptionCipher;break;case"aes256":o="AES-256-CBC",c=32,u=n.random.getBytesSync(16),l=n.aes.createEncryptionCipher;break;case"3des":o="DES-EDE3-CBC",c=24,u=n.random.getBytesSync(8),l=n.des.createEncryptionCipher;break;case"des":o="DES-CBC",c=8,u=n.random.getBytesSync(8),l=n.des.createEncryptionCipher;break;default:var f=new Error('Could not encrypt RSA private key; unsupported encryption algorithm "'+r.algorithm+'".');throw f.algorithm=r.algorithm,f}var h=l(n.pbe.opensslDeriveBytes(t,u.substr(0,8),c));h.start(u),h.update(a.toDer(s.privateKeyToAsn1(e))),h.finish();var p={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:o,parameters:n.util.bytesToHex(u).toUpperCase()},body:h.output.getBytes()};return n.pem.encode(p)},s.decryptRsaPrivateKey=function(e,t){var r=null,i=n.pem.decode(e)[0];if("ENCRYPTED PRIVATE KEY"!==i.type&&"PRIVATE KEY"!==i.type&&"RSA PRIVATE KEY"!==i.type)throw(c=new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".')).headerType=c,c;if(i.procType&&"ENCRYPTED"===i.procType.type){var o,u;switch(i.dekInfo.algorithm){case"DES-CBC":o=8,u=n.des.createDecryptionCipher;break;case"DES-EDE3-CBC":o=24,u=n.des.createDecryptionCipher;break;case"AES-128-CBC":o=16,u=n.aes.createDecryptionCipher;break;case"AES-192-CBC":o=24,u=n.aes.createDecryptionCipher;break;case"AES-256-CBC":o=32,u=n.aes.createDecryptionCipher;break;case"RC2-40-CBC":o=5,u=function(e){return n.rc2.createDecryptionCipher(e,40)};break;case"RC2-64-CBC":o=8,u=function(e){return n.rc2.createDecryptionCipher(e,64)};break;case"RC2-128-CBC":o=16,u=function(e){return n.rc2.createDecryptionCipher(e,128)};break;default:var c;throw(c=new Error('Could not decrypt private key; unsupported encryption algorithm "'+i.dekInfo.algorithm+'".')).algorithm=i.dekInfo.algorithm,c}var l=n.util.hexToBytes(i.dekInfo.parameters),f=u(n.pbe.opensslDeriveBytes(t,l.substr(0,8),o));if(f.start(l),f.update(n.util.createBuffer(i.body)),!f.finish())return r;r=f.output.getBytes()}else r=i.body;return null!==(r="ENCRYPTED PRIVATE KEY"===i.type?s.decryptPrivateKeyInfo(a.fromDer(r),t):a.fromDer(r))&&(r=s.privateKeyFromAsn1(r)),r},s.pbe.generatePkcs12Key=function(e,t,r,i,a,s){var o,u;if(null==s){if(!("sha1"in n.md))throw new Error('"sha1" hash algorithm unavailable.');s=n.md.sha1.create()}var c=s.digestLength,l=s.blockLength,f=new n.util.ByteBuffer,h=new n.util.ByteBuffer;if(null!=e){for(u=0;u<e.length;u++)h.putInt16(e.charCodeAt(u));h.putInt16(0)}var p=h.length(),d=t.length(),y=new n.util.ByteBuffer;y.fillWithByte(r,l);var g=l*Math.ceil(d/l),m=new n.util.ByteBuffer;for(u=0;u<g;u++)m.putByte(t.at(u%d));var v=l*Math.ceil(p/l),b=new n.util.ByteBuffer;for(u=0;u<v;u++)b.putByte(h.at(u%p));var E=m;E.putBuffer(b);for(var S=Math.ceil(a/c),T=1;T<=S;T++){var C=new n.util.ByteBuffer;C.putBytes(y.bytes()),C.putBytes(E.bytes());for(var A=0;A<i;A++)s.start(),s.update(C.getBytes()),C=s.digest();var I=new n.util.ByteBuffer;for(u=0;u<l;u++)I.putByte(C.at(u%c));var w=Math.ceil(d/l)+Math.ceil(p/l),B=new n.util.ByteBuffer;for(o=0;o<w;o++){var N=new n.util.ByteBuffer(E.getBytes(l)),R=511;for(u=I.length()-1;u>=0;u--)R>>=8,R+=I.at(u)+N.at(u),N.setAt(u,255&R);B.putBuffer(N)}E=B,f.putBuffer(C)}return f.truncate(f.length()-a),f},s.pbe.getCipher=function(e,t,r){switch(e){case s.oids.pkcs5PBES2:return s.pbe.getCipherForPBES2(e,t,r);case s.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case s.oids["pbewithSHAAnd40BitRC2-CBC"]:return s.pbe.getCipherForPKCS12PBE(e,t,r);default:var n=new Error("Cannot read encrypted PBE data block. Unsupported OID.");throw n.oid=e,n.supportedOids=["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"],n}},s.pbe.getCipherForPBES2=function(e,t,r){var i,o={},u=[];if(!a.validate(t,c,o,u))throw(i=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors=u,i;if((e=a.derToOid(o.kdfOid))!==s.oids.pkcs5PBKDF2)throw(i=new Error("Cannot read encrypted private key. Unsupported key derivation function OID.")).oid=e,i.supportedOids=["pkcs5PBKDF2"],i;if((e=a.derToOid(o.encOid))!==s.oids["aes128-CBC"]&&e!==s.oids["aes192-CBC"]&&e!==s.oids["aes256-CBC"]&&e!==s.oids["des-EDE3-CBC"]&&e!==s.oids.desCBC)throw(i=new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.")).oid=e,i.supportedOids=["aes128-CBC","aes192-CBC","aes256-CBC","des-EDE3-CBC","desCBC"],i;var l,f,p=o.kdfSalt,d=n.util.createBuffer(o.kdfIterationCount);switch(d=d.getInt(d.length()<<3),s.oids[e]){case"aes128-CBC":l=16,f=n.aes.createDecryptionCipher;break;case"aes192-CBC":l=24,f=n.aes.createDecryptionCipher;break;case"aes256-CBC":l=32,f=n.aes.createDecryptionCipher;break;case"des-EDE3-CBC":l=24,f=n.des.createDecryptionCipher;break;case"desCBC":l=8,f=n.des.createDecryptionCipher}var y=h(o.prfOid),g=n.pkcs5.pbkdf2(r,p,d,l,y),m=o.encIv,v=f(g);return v.start(m),v},s.pbe.getCipherForPKCS12PBE=function(e,t,r){var i={},o=[];if(!a.validate(t,l,i,o))throw(y=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors=o,y;var u,c,f,p=n.util.createBuffer(i.salt),d=n.util.createBuffer(i.iterations);switch(d=d.getInt(d.length()<<3),e){case s.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:u=24,c=8,f=n.des.startDecrypting;break;case s.oids["pbewithSHAAnd40BitRC2-CBC"]:u=5,c=8,f=function(e,t){var r=n.rc2.createDecryptionCipher(e,40);return r.start(t,null),r};break;default:var y;throw(y=new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.")).oid=e,y}var g=h(i.prfOid),m=s.pbe.generatePkcs12Key(r,p,1,d,u,g);return g.start(),f(m,s.pbe.generatePkcs12Key(r,p,2,d,c,g))},s.pbe.opensslDeriveBytes=function(e,t,r,i){if(null==i){if(!("md5"in n.md))throw new Error('"md5" hash algorithm unavailable.');i=n.md.md5.create()}null===t&&(t="");for(var a=[f(i,e+t)],s=16,o=1;s<r;++o,s+=16)a.push(f(i,a[o-1]+e+t));return a.join("").substr(0,r)}},function(e,t,r){var n=r(1);function i(e,t){n.cipher.registerAlgorithm(e,(function(){return new n.des.Algorithm(e,t)}))}r(30),r(52),r(2),e.exports=n.des=n.des||{},n.des.startEncrypting=function(e,t,r,n){var i=d({key:e,output:r,decrypt:!1,mode:n||(null===t?"ECB":"CBC")});return i.start(t),i},n.des.createEncryptionCipher=function(e,t){return d({key:e,output:null,decrypt:!1,mode:t})},n.des.startDecrypting=function(e,t,r,n){var i=d({key:e,output:r,decrypt:!0,mode:n||(null===t?"ECB":"CBC")});return i.start(t),i},n.des.createDecryptionCipher=function(e,t){return d({key:e,output:null,decrypt:!0,mode:t})},n.des.Algorithm=function(e,t){var r=this;r.name=e,r.mode=new t({blockSize:8,cipher:{encrypt:function(e,t){return p(r._keys,e,t,!1)},decrypt:function(e,t){return p(r._keys,e,t,!0)}}}),r._init=!1},n.des.Algorithm.prototype.initialize=function(e){if(!this._init){var t=n.util.createBuffer(e.key);if(0===this.name.indexOf("3DES")&&24!==t.length())throw new Error("Invalid Triple-DES key size: "+8*t.length());this._keys=function(e){for(var t,r=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],n=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],i=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],a=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],s=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],o=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],u=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],c=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],l=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],f=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],h=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],p=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],d=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],y=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],g=e.length()>8?3:1,m=[],v=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],b=0,E=0;E<g;E++){var S=e.getInt32(),T=e.getInt32();S^=(t=252645135&(S>>>4^T))<<4,S^=t=65535&((T^=t)>>>-16^S),S^=(t=858993459&(S>>>2^(T^=t<<-16)))<<2,S^=t=65535&((T^=t)>>>-16^S),S^=(t=1431655765&(S>>>1^(T^=t<<-16)))<<1,S^=t=16711935&((T^=t)>>>8^S),t=(S^=(t=1431655765&(S>>>1^(T^=t<<8)))<<1)<<8|(T^=t)>>>20&240,S=T<<24|T<<8&16711680|T>>>8&65280|T>>>24&240,T=t;for(var C=0;C<v.length;++C){v[C]?(S=S<<2|S>>>26,T=T<<2|T>>>26):(S=S<<1|S>>>27,T=T<<1|T>>>27);var A=r[(S&=-15)>>>28]|n[S>>>24&15]|i[S>>>20&15]|a[S>>>16&15]|s[S>>>12&15]|o[S>>>8&15]|u[S>>>4&15],I=c[(T&=-15)>>>28]|l[T>>>24&15]|f[T>>>20&15]|h[T>>>16&15]|p[T>>>12&15]|d[T>>>8&15]|y[T>>>4&15];t=65535&(I>>>16^A),m[b++]=A^t,m[b++]=I^t<<16}}return m}(t),this._init=!0}},i("DES-ECB",n.cipher.modes.ecb),i("DES-CBC",n.cipher.modes.cbc),i("DES-CFB",n.cipher.modes.cfb),i("DES-OFB",n.cipher.modes.ofb),i("DES-CTR",n.cipher.modes.ctr),i("3DES-ECB",n.cipher.modes.ecb),i("3DES-CBC",n.cipher.modes.cbc),i("3DES-CFB",n.cipher.modes.cfb),i("3DES-OFB",n.cipher.modes.ofb),i("3DES-CTR",n.cipher.modes.ctr);var a=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],s=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],o=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],u=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],c=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],l=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],f=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],h=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];function p(e,t,r,n){var i,p,d=32===e.length?3:9;i=3===d?n?[30,-2,-2]:[0,32,2]:n?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];var y=t[0],g=t[1];y^=(p=252645135&(y>>>4^g))<<4,y^=(p=65535&(y>>>16^(g^=p)))<<16,y^=p=858993459&((g^=p)>>>2^y),y^=p=16711935&((g^=p<<2)>>>8^y),y=(y^=(p=1431655765&(y>>>1^(g^=p<<8)))<<1)<<1|y>>>31,g=(g^=p)<<1|g>>>31;for(var m=0;m<d;m+=3){for(var v=i[m+1],b=i[m+2],E=i[m];E!=v;E+=b){var S=g^e[E],T=(g>>>4|g<<28)^e[E+1];p=y,y=g,g=p^(s[S>>>24&63]|u[S>>>16&63]|l[S>>>8&63]|h[63&S]|a[T>>>24&63]|o[T>>>16&63]|c[T>>>8&63]|f[63&T])}p=y,y=g,g=p}g=g>>>1|g<<31,g^=p=1431655765&((y=y>>>1|y<<31)>>>1^g),g^=(p=16711935&(g>>>8^(y^=p<<1)))<<8,g^=(p=858993459&(g>>>2^(y^=p)))<<2,g^=p=65535&((y^=p)>>>16^g),g^=p=252645135&((y^=p<<16)>>>4^g),y^=p<<4,r[0]=y,r[1]=g}function d(e){var t,r="DES-"+((e=e||{}).mode||"CBC").toUpperCase(),i=(t=e.decrypt?n.cipher.createDecipher(r,e.key):n.cipher.createCipher(r,e.key)).start;return t.start=function(e,r){var a=null;r instanceof n.util.ByteBuffer&&(a=r,r={}),(r=r||{}).output=a,r.iv=e,i.call(t,r)},t}},function(e,t,r){(function(t){var n=r(1);r(32),r(9),r(2);var i,a=n.pkcs5=n.pkcs5||{};n.util.isNodejs&&!n.options.usePureJavaScript&&(i=r(31)),e.exports=n.pbkdf2=a.pbkdf2=function(e,r,a,s,o,u){if("function"==typeof o&&(u=o,o=null),n.util.isNodejs&&!n.options.usePureJavaScript&&i.pbkdf2&&(null===o||"object"!=typeof o)&&(i.pbkdf2Sync.length>4||!o||"sha1"===o))return"string"!=typeof o&&(o="sha1"),e=t.from(e,"binary"),r=t.from(r,"binary"),u?4===i.pbkdf2Sync.length?i.pbkdf2(e,r,a,s,(function(e,t){if(e)return u(e);u(null,t.toString("binary"))})):i.pbkdf2(e,r,a,s,o,(function(e,t){if(e)return u(e);u(null,t.toString("binary"))})):4===i.pbkdf2Sync.length?i.pbkdf2Sync(e,r,a,s).toString("binary"):i.pbkdf2Sync(e,r,a,s,o).toString("binary");if(null==o&&(o="sha1"),"string"==typeof o){if(!(o in n.md.algorithms))throw new Error("Unknown hash algorithm: "+o);o=n.md[o].create()}var c=o.digestLength;if(s>4294967295*c){var l=new Error("Derived key is too long.");if(u)return u(l);throw l}var f=Math.ceil(s/c),h=s-(f-1)*c,p=n.hmac.create();p.start(o,e);var d,y,g,m="";if(!u){for(var v=1;v<=f;++v){p.start(null,null),p.update(r),p.update(n.util.int32ToBytes(v)),d=g=p.digest().getBytes();for(var b=2;b<=a;++b)p.start(null,null),p.update(g),y=p.digest().getBytes(),d=n.util.xorBytes(d,y,c),g=y;m+=v<f?d:d.substr(0,h)}return m}v=1;function E(){if(v>f)return u(null,m);p.start(null,null),p.update(r),p.update(n.util.int32ToBytes(v)),d=g=p.digest().getBytes(),b=2,S()}function S(){if(b<=a)return p.start(null,null),p.update(g),y=p.digest().getBytes(),d=n.util.xorBytes(d,y,c),g=y,++b,n.util.setImmediate(S);m+=v<f?d:d.substr(0,h),++v,E()}E()}}).call(this,r(13).Buffer)},function(e,t,r){var n,i=r(1);e.exports=i.jsbn=i.jsbn||{};function a(e,t,r){this.data=[],null!=e&&("number"==typeof e?this.fromNumber(e,t,r):null==t&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function s(){return new a(null)}function o(e,t,r,n,i,a){for(var s=16383&t,o=t>>14;--a>=0;){var u=16383&this.data[e],c=this.data[e++]>>14,l=o*u+c*s;i=((u=s*u+((16383&l)<<14)+r.data[n]+i)>>28)+(l>>14)+o*c,r.data[n++]=268435455&u}return i}i.jsbn.BigInteger=a,"undefined"==typeof navigator?(a.prototype.am=o,n=28):"Microsoft Internet Explorer"==navigator.appName?(a.prototype.am=function(e,t,r,n,i,a){for(var s=32767&t,o=t>>15;--a>=0;){var u=32767&this.data[e],c=this.data[e++]>>15,l=o*u+c*s;i=((u=s*u+((32767&l)<<15)+r.data[n]+(1073741823&i))>>>30)+(l>>>15)+o*c+(i>>>30),r.data[n++]=1073741823&u}return i},n=30):"Netscape"!=navigator.appName?(a.prototype.am=function(e,t,r,n,i,a){for(;--a>=0;){var s=t*this.data[e++]+r.data[n]+i;i=Math.floor(s/67108864),r.data[n++]=67108863&s}return i},n=26):(a.prototype.am=o,n=28),a.prototype.DB=n,a.prototype.DM=(1<<n)-1,a.prototype.DV=1<<n;a.prototype.FV=Math.pow(2,52),a.prototype.F1=52-n,a.prototype.F2=2*n-52;var u,c,l="0123456789abcdefghijklmnopqrstuvwxyz",f=new Array;for(u="0".charCodeAt(0),c=0;c<=9;++c)f[u++]=c;for(u="a".charCodeAt(0),c=10;c<36;++c)f[u++]=c;for(u="A".charCodeAt(0),c=10;c<36;++c)f[u++]=c;function h(e){return l.charAt(e)}function p(e,t){var r=f[e.charCodeAt(t)];return null==r?-1:r}function d(e){var t=s();return t.fromInt(e),t}function y(e){var t,r=1;return 0!=(t=e>>>16)&&(e=t,r+=16),0!=(t=e>>8)&&(e=t,r+=8),0!=(t=e>>4)&&(e=t,r+=4),0!=(t=e>>2)&&(e=t,r+=2),0!=(t=e>>1)&&(e=t,r+=1),r}function g(e){this.m=e}function m(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function v(e,t){return e&t}function b(e,t){return e|t}function E(e,t){return e^t}function S(e,t){return e&~t}function T(e){if(0==e)return-1;var t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function C(e){for(var t=0;0!=e;)e&=e-1,++t;return t}function A(){}function I(e){return e}function w(e){this.r2=s(),this.q3=s(),a.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}g.prototype.convert=function(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e},g.prototype.revert=function(e){return e},g.prototype.reduce=function(e){e.divRemTo(this.m,null,e)},g.prototype.mulTo=function(e,t,r){e.multiplyTo(t,r),this.reduce(r)},g.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},m.prototype.convert=function(e){var t=s();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(a.ZERO)>0&&this.m.subTo(t,t),t},m.prototype.revert=function(e){var t=s();return e.copyTo(t),this.reduce(t),t},m.prototype.reduce=function(e){for(;e.t<=this.mt2;)e.data[e.t++]=0;for(var t=0;t<this.m.t;++t){var r=32767&e.data[t],n=r*this.mpl+((r*this.mph+(e.data[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(r=t+this.m.t,e.data[r]+=this.m.am(0,n,e,t,0,this.m.t);e.data[r]>=e.DV;)e.data[r]-=e.DV,e.data[++r]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)},m.prototype.mulTo=function(e,t,r){e.multiplyTo(t,r),this.reduce(r)},m.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)},a.prototype.copyTo=function(e){for(var t=this.t-1;t>=0;--t)e.data[t]=this.data[t];e.t=this.t,e.s=this.s},a.prototype.fromInt=function(e){this.t=1,this.s=e<0?-1:0,e>0?this.data[0]=e:e<-1?this.data[0]=e+this.DV:this.t=0},a.prototype.fromString=function(e,t){var r;if(16==t)r=4;else if(8==t)r=3;else if(256==t)r=8;else if(2==t)r=1;else if(32==t)r=5;else{if(4!=t)return void this.fromRadix(e,t);r=2}this.t=0,this.s=0;for(var n=e.length,i=!1,s=0;--n>=0;){var o=8==r?255&e[n]:p(e,n);o<0?"-"==e.charAt(n)&&(i=!0):(i=!1,0==s?this.data[this.t++]=o:s+r>this.DB?(this.data[this.t-1]|=(o&(1<<this.DB-s)-1)<<s,this.data[this.t++]=o>>this.DB-s):this.data[this.t-1]|=o<<s,(s+=r)>=this.DB&&(s-=this.DB))}8==r&&0!=(128&e[0])&&(this.s=-1,s>0&&(this.data[this.t-1]|=(1<<this.DB-s)-1<<s)),this.clamp(),i&&a.ZERO.subTo(this,this)},a.prototype.clamp=function(){for(var e=this.s&this.DM;this.t>0&&this.data[this.t-1]==e;)--this.t},a.prototype.dlShiftTo=function(e,t){var r;for(r=this.t-1;r>=0;--r)t.data[r+e]=this.data[r];for(r=e-1;r>=0;--r)t.data[r]=0;t.t=this.t+e,t.s=this.s},a.prototype.drShiftTo=function(e,t){for(var r=e;r<this.t;++r)t.data[r-e]=this.data[r];t.t=Math.max(this.t-e,0),t.s=this.s},a.prototype.lShiftTo=function(e,t){var r,n=e%this.DB,i=this.DB-n,a=(1<<i)-1,s=Math.floor(e/this.DB),o=this.s<<n&this.DM;for(r=this.t-1;r>=0;--r)t.data[r+s+1]=this.data[r]>>i|o,o=(this.data[r]&a)<<n;for(r=s-1;r>=0;--r)t.data[r]=0;t.data[s]=o,t.t=this.t+s+1,t.s=this.s,t.clamp()},a.prototype.rShiftTo=function(e,t){t.s=this.s;var r=Math.floor(e/this.DB);if(r>=this.t)t.t=0;else{var n=e%this.DB,i=this.DB-n,a=(1<<n)-1;t.data[0]=this.data[r]>>n;for(var s=r+1;s<this.t;++s)t.data[s-r-1]|=(this.data[s]&a)<<i,t.data[s-r]=this.data[s]>>n;n>0&&(t.data[this.t-r-1]|=(this.s&a)<<i),t.t=this.t-r,t.clamp()}},a.prototype.subTo=function(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this.data[r]-e.data[r],t.data[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n-=e.s;r<this.t;)n+=this.data[r],t.data[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n-=e.data[r],t.data[r++]=n&this.DM,n>>=this.DB;n-=e.s}t.s=n<0?-1:0,n<-1?t.data[r++]=this.DV+n:n>0&&(t.data[r++]=n),t.t=r,t.clamp()},a.prototype.multiplyTo=function(e,t){var r=this.abs(),n=e.abs(),i=r.t;for(t.t=i+n.t;--i>=0;)t.data[i]=0;for(i=0;i<n.t;++i)t.data[i+r.t]=r.am(0,n.data[i],t,i,0,r.t);t.s=0,t.clamp(),this.s!=e.s&&a.ZERO.subTo(t,t)},a.prototype.squareTo=function(e){for(var t=this.abs(),r=e.t=2*t.t;--r>=0;)e.data[r]=0;for(r=0;r<t.t-1;++r){var n=t.am(r,t.data[r],e,2*r,0,1);(e.data[r+t.t]+=t.am(r+1,2*t.data[r],e,2*r+1,n,t.t-r-1))>=t.DV&&(e.data[r+t.t]-=t.DV,e.data[r+t.t+1]=1)}e.t>0&&(e.data[e.t-1]+=t.am(r,t.data[r],e,2*r,0,1)),e.s=0,e.clamp()},a.prototype.divRemTo=function(e,t,r){var n=e.abs();if(!(n.t<=0)){var i=this.abs();if(i.t<n.t)return null!=t&&t.fromInt(0),void(null!=r&&this.copyTo(r));null==r&&(r=s());var o=s(),u=this.s,c=e.s,l=this.DB-y(n.data[n.t-1]);l>0?(n.lShiftTo(l,o),i.lShiftTo(l,r)):(n.copyTo(o),i.copyTo(r));var f=o.t,h=o.data[f-1];if(0!=h){var p=h*(1<<this.F1)+(f>1?o.data[f-2]>>this.F2:0),d=this.FV/p,g=(1<<this.F1)/p,m=1<<this.F2,v=r.t,b=v-f,E=null==t?s():t;for(o.dlShiftTo(b,E),r.compareTo(E)>=0&&(r.data[r.t++]=1,r.subTo(E,r)),a.ONE.dlShiftTo(f,E),E.subTo(o,o);o.t<f;)o.data[o.t++]=0;for(;--b>=0;){var S=r.data[--v]==h?this.DM:Math.floor(r.data[v]*d+(r.data[v-1]+m)*g);if((r.data[v]+=o.am(0,S,r,b,0,f))<S)for(o.dlShiftTo(b,E),r.subTo(E,r);r.data[v]<--S;)r.subTo(E,r)}null!=t&&(r.drShiftTo(f,t),u!=c&&a.ZERO.subTo(t,t)),r.t=f,r.clamp(),l>0&&r.rShiftTo(l,r),u<0&&a.ZERO.subTo(r,r)}}},a.prototype.invDigit=function(){if(this.t<1)return 0;var e=this.data[0];if(0==(1&e))return 0;var t=3&e;return(t=(t=(t=(t=t*(2-(15&e)*t)&15)*(2-(255&e)*t)&255)*(2-((65535&e)*t&65535))&65535)*(2-e*t%this.DV)%this.DV)>0?this.DV-t:-t},a.prototype.isEven=function(){return 0==(this.t>0?1&this.data[0]:this.s)},a.prototype.exp=function(e,t){if(e>4294967295||e<1)return a.ONE;var r=s(),n=s(),i=t.convert(this),o=y(e)-1;for(i.copyTo(r);--o>=0;)if(t.sqrTo(r,n),(e&1<<o)>0)t.mulTo(n,i,r);else{var u=r;r=n,n=u}return t.revert(r)},a.prototype.toString=function(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}var r,n=(1<<t)-1,i=!1,a="",s=this.t,o=this.DB-s*this.DB%t;if(s-- >0)for(o<this.DB&&(r=this.data[s]>>o)>0&&(i=!0,a=h(r));s>=0;)o<t?(r=(this.data[s]&(1<<o)-1)<<t-o,r|=this.data[--s]>>(o+=this.DB-t)):(r=this.data[s]>>(o-=t)&n,o<=0&&(o+=this.DB,--s)),r>0&&(i=!0),i&&(a+=h(r));return i?a:"0"},a.prototype.negate=function(){var e=s();return a.ZERO.subTo(this,e),e},a.prototype.abs=function(){return this.s<0?this.negate():this},a.prototype.compareTo=function(e){var t=this.s-e.s;if(0!=t)return t;var r=this.t;if(0!=(t=r-e.t))return this.s<0?-t:t;for(;--r>=0;)if(0!=(t=this.data[r]-e.data[r]))return t;return 0},a.prototype.bitLength=function(){return this.t<=0?0:this.DB*(this.t-1)+y(this.data[this.t-1]^this.s&this.DM)},a.prototype.mod=function(e){var t=s();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(a.ZERO)>0&&e.subTo(t,t),t},a.prototype.modPowInt=function(e,t){var r;return r=e<256||t.isEven()?new g(t):new m(t),this.exp(e,r)},a.ZERO=d(0),a.ONE=d(1),A.prototype.convert=I,A.prototype.revert=I,A.prototype.mulTo=function(e,t,r){e.multiplyTo(t,r)},A.prototype.sqrTo=function(e,t){e.squareTo(t)},w.prototype.convert=function(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=s();return e.copyTo(t),this.reduce(t),t},w.prototype.revert=function(e){return e},w.prototype.reduce=function(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)},w.prototype.mulTo=function(e,t,r){e.multiplyTo(t,r),this.reduce(r)},w.prototype.sqrTo=function(e,t){e.squareTo(t),this.reduce(t)};var B=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],N=(1<<26)/B[B.length-1];a.prototype.chunkSize=function(e){return Math.floor(Math.LN2*this.DB/Math.log(e))},a.prototype.toRadix=function(e){if(null==e&&(e=10),0==this.signum()||e<2||e>36)return"0";var t=this.chunkSize(e),r=Math.pow(e,t),n=d(r),i=s(),a=s(),o="";for(this.divRemTo(n,i,a);i.signum()>0;)o=(r+a.intValue()).toString(e).substr(1)+o,i.divRemTo(n,i,a);return a.intValue().toString(e)+o},a.prototype.fromRadix=function(e,t){this.fromInt(0),null==t&&(t=10);for(var r=this.chunkSize(t),n=Math.pow(t,r),i=!1,s=0,o=0,u=0;u<e.length;++u){var c=p(e,u);c<0?"-"==e.charAt(u)&&0==this.signum()&&(i=!0):(o=t*o+c,++s>=r&&(this.dMultiply(n),this.dAddOffset(o,0),s=0,o=0))}s>0&&(this.dMultiply(Math.pow(t,s)),this.dAddOffset(o,0)),i&&a.ZERO.subTo(this,this)},a.prototype.fromNumber=function(e,t,r){if("number"==typeof t)if(e<2)this.fromInt(1);else for(this.fromNumber(e,r),this.testBit(e-1)||this.bitwiseTo(a.ONE.shiftLeft(e-1),b,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(t);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(a.ONE.shiftLeft(e-1),this);else{var n=new Array,i=7&e;n.length=1+(e>>3),t.nextBytes(n),i>0?n[0]&=(1<<i)-1:n[0]=0,this.fromString(n,256)}},a.prototype.bitwiseTo=function(e,t,r){var n,i,a=Math.min(e.t,this.t);for(n=0;n<a;++n)r.data[n]=t(this.data[n],e.data[n]);if(e.t<this.t){for(i=e.s&this.DM,n=a;n<this.t;++n)r.data[n]=t(this.data[n],i);r.t=this.t}else{for(i=this.s&this.DM,n=a;n<e.t;++n)r.data[n]=t(i,e.data[n]);r.t=e.t}r.s=t(this.s,e.s),r.clamp()},a.prototype.changeBit=function(e,t){var r=a.ONE.shiftLeft(e);return this.bitwiseTo(r,t,r),r},a.prototype.addTo=function(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this.data[r]+e.data[r],t.data[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n+=e.s;r<this.t;)n+=this.data[r],t.data[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n+=e.data[r],t.data[r++]=n&this.DM,n>>=this.DB;n+=e.s}t.s=n<0?-1:0,n>0?t.data[r++]=n:n<-1&&(t.data[r++]=this.DV+n),t.t=r,t.clamp()},a.prototype.dMultiply=function(e){this.data[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()},a.prototype.dAddOffset=function(e,t){if(0!=e){for(;this.t<=t;)this.data[this.t++]=0;for(this.data[t]+=e;this.data[t]>=this.DV;)this.data[t]-=this.DV,++t>=this.t&&(this.data[this.t++]=0),++this.data[t]}},a.prototype.multiplyLowerTo=function(e,t,r){var n,i=Math.min(this.t+e.t,t);for(r.s=0,r.t=i;i>0;)r.data[--i]=0;for(n=r.t-this.t;i<n;++i)r.data[i+this.t]=this.am(0,e.data[i],r,i,0,this.t);for(n=Math.min(e.t,t);i<n;++i)this.am(0,e.data[i],r,i,0,t-i);r.clamp()},a.prototype.multiplyUpperTo=function(e,t,r){--t;var n=r.t=this.t+e.t-t;for(r.s=0;--n>=0;)r.data[n]=0;for(n=Math.max(t-this.t,0);n<e.t;++n)r.data[this.t+n-t]=this.am(t-n,e.data[n],r,0,0,this.t+n-t);r.clamp(),r.drShiftTo(1,r)},a.prototype.modInt=function(e){if(e<=0)return 0;var t=this.DV%e,r=this.s<0?e-1:0;if(this.t>0)if(0==t)r=this.data[0]%e;else for(var n=this.t-1;n>=0;--n)r=(t*r+this.data[n])%e;return r},a.prototype.millerRabin=function(e){var t=this.subtract(a.ONE),r=t.getLowestSetBit();if(r<=0)return!1;for(var n,i=t.shiftRight(r),s={nextBytes:function(e){for(var t=0;t<e.length;++t)e[t]=Math.floor(256*Math.random())}},o=0;o<e;++o){do{n=new a(this.bitLength(),s)}while(n.compareTo(a.ONE)<=0||n.compareTo(t)>=0);var u=n.modPow(i,this);if(0!=u.compareTo(a.ONE)&&0!=u.compareTo(t)){for(var c=1;c++<r&&0!=u.compareTo(t);)if(0==(u=u.modPowInt(2,this)).compareTo(a.ONE))return!1;if(0!=u.compareTo(t))return!1}}return!0},a.prototype.clone=function(){var e=s();return this.copyTo(e),e},a.prototype.intValue=function(){if(this.s<0){if(1==this.t)return this.data[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this.data[0];if(0==this.t)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]},a.prototype.byteValue=function(){return 0==this.t?this.s:this.data[0]<<24>>24},a.prototype.shortValue=function(){return 0==this.t?this.s:this.data[0]<<16>>16},a.prototype.signum=function(){return this.s<0?-1:this.t<=0||1==this.t&&this.data[0]<=0?0:1},a.prototype.toByteArray=function(){var e=this.t,t=new Array;t[0]=this.s;var r,n=this.DB-e*this.DB%8,i=0;if(e-- >0)for(n<this.DB&&(r=this.data[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);e>=0;)n<8?(r=(this.data[e]&(1<<n)-1)<<8-n,r|=this.data[--e]>>(n+=this.DB-8)):(r=this.data[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),0!=(128&r)&&(r|=-256),0==i&&(128&this.s)!=(128&r)&&++i,(i>0||r!=this.s)&&(t[i++]=r);return t},a.prototype.equals=function(e){return 0==this.compareTo(e)},a.prototype.min=function(e){return this.compareTo(e)<0?this:e},a.prototype.max=function(e){return this.compareTo(e)>0?this:e},a.prototype.and=function(e){var t=s();return this.bitwiseTo(e,v,t),t},a.prototype.or=function(e){var t=s();return this.bitwiseTo(e,b,t),t},a.prototype.xor=function(e){var t=s();return this.bitwiseTo(e,E,t),t},a.prototype.andNot=function(e){var t=s();return this.bitwiseTo(e,S,t),t},a.prototype.not=function(){for(var e=s(),t=0;t<this.t;++t)e.data[t]=this.DM&~this.data[t];return e.t=this.t,e.s=~this.s,e},a.prototype.shiftLeft=function(e){var t=s();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t},a.prototype.shiftRight=function(e){var t=s();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t},a.prototype.getLowestSetBit=function(){for(var e=0;e<this.t;++e)if(0!=this.data[e])return e*this.DB+T(this.data[e]);return this.s<0?this.t*this.DB:-1},a.prototype.bitCount=function(){for(var e=0,t=this.s&this.DM,r=0;r<this.t;++r)e+=C(this.data[r]^t);return e},a.prototype.testBit=function(e){var t=Math.floor(e/this.DB);return t>=this.t?0!=this.s:0!=(this.data[t]&1<<e%this.DB)},a.prototype.setBit=function(e){return this.changeBit(e,b)},a.prototype.clearBit=function(e){return this.changeBit(e,S)},a.prototype.flipBit=function(e){return this.changeBit(e,E)},a.prototype.add=function(e){var t=s();return this.addTo(e,t),t},a.prototype.subtract=function(e){var t=s();return this.subTo(e,t),t},a.prototype.multiply=function(e){var t=s();return this.multiplyTo(e,t),t},a.prototype.divide=function(e){var t=s();return this.divRemTo(e,t,null),t},a.prototype.remainder=function(e){var t=s();return this.divRemTo(e,null,t),t},a.prototype.divideAndRemainder=function(e){var t=s(),r=s();return this.divRemTo(e,t,r),new Array(t,r)},a.prototype.modPow=function(e,t){var r,n,i=e.bitLength(),a=d(1);if(i<=0)return a;r=i<18?1:i<48?3:i<144?4:i<768?5:6,n=i<8?new g(t):t.isEven()?new w(t):new m(t);var o=new Array,u=3,c=r-1,l=(1<<r)-1;if(o[1]=n.convert(this),r>1){var f=s();for(n.sqrTo(o[1],f);u<=l;)o[u]=s(),n.mulTo(f,o[u-2],o[u]),u+=2}var h,p,v=e.t-1,b=!0,E=s();for(i=y(e.data[v])-1;v>=0;){for(i>=c?h=e.data[v]>>i-c&l:(h=(e.data[v]&(1<<i+1)-1)<<c-i,v>0&&(h|=e.data[v-1]>>this.DB+i-c)),u=r;0==(1&h);)h>>=1,--u;if((i-=u)<0&&(i+=this.DB,--v),b)o[h].copyTo(a),b=!1;else{for(;u>1;)n.sqrTo(a,E),n.sqrTo(E,a),u-=2;u>0?n.sqrTo(a,E):(p=a,a=E,E=p),n.mulTo(E,o[h],a)}for(;v>=0&&0==(e.data[v]&1<<i);)n.sqrTo(a,E),p=a,a=E,E=p,--i<0&&(i=this.DB-1,--v)}return n.revert(a)},a.prototype.modInverse=function(e){var t=e.isEven();if(this.isEven()&&t||0==e.signum())return a.ZERO;for(var r=e.clone(),n=this.clone(),i=d(1),s=d(0),o=d(0),u=d(1);0!=r.signum();){for(;r.isEven();)r.rShiftTo(1,r),t?(i.isEven()&&s.isEven()||(i.addTo(this,i),s.subTo(e,s)),i.rShiftTo(1,i)):s.isEven()||s.subTo(e,s),s.rShiftTo(1,s);for(;n.isEven();)n.rShiftTo(1,n),t?(o.isEven()&&u.isEven()||(o.addTo(this,o),u.subTo(e,u)),o.rShiftTo(1,o)):u.isEven()||u.subTo(e,u),u.rShiftTo(1,u);r.compareTo(n)>=0?(r.subTo(n,r),t&&i.subTo(o,i),s.subTo(u,s)):(n.subTo(r,n),t&&o.subTo(i,o),u.subTo(s,u))}return 0!=n.compareTo(a.ONE)?a.ZERO:u.compareTo(e)>=0?u.subtract(e):u.signum()<0?(u.addTo(e,u),u.signum()<0?u.add(e):u):u},a.prototype.pow=function(e){return this.exp(e,new A)},a.prototype.gcd=function(e){var t=this.s<0?this.negate():this.clone(),r=e.s<0?e.negate():e.clone();if(t.compareTo(r)<0){var n=t;t=r,r=n}var i=t.getLowestSetBit(),a=r.getLowestSetBit();if(a<0)return t;for(i<a&&(a=i),a>0&&(t.rShiftTo(a,t),r.rShiftTo(a,r));t.signum()>0;)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=r.getLowestSetBit())>0&&r.rShiftTo(i,r),t.compareTo(r)>=0?(t.subTo(r,t),t.rShiftTo(1,t)):(r.subTo(t,r),r.rShiftTo(1,r));return a>0&&r.lShiftTo(a,r),r},a.prototype.isProbablePrime=function(e){var t,r=this.abs();if(1==r.t&&r.data[0]<=B[B.length-1]){for(t=0;t<B.length;++t)if(r.data[0]==B[t])return!0;return!1}if(r.isEven())return!1;for(t=1;t<B.length;){for(var n=B[t],i=t+1;i<B.length&&n<N;)n*=B[i++];for(n=r.modInt(n);t<i;)if(n%B[t++]==0)return!1}return r.millerRabin(e)}},function(e,t,r){var n=r(1);r(9),r(2);var i=e.exports=n.sha1=n.sha1||{};n.md.sha1=n.md.algorithms.sha1=i,i.create=function(){s||(a=String.fromCharCode(128),a+=n.util.fillString(String.fromCharCode(0),64),s=!0);var e=null,t=n.util.createBuffer(),r=new Array(80),i={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0,fullMessageLength:null,messageLengthSize:8,start:function(){i.messageLength=0,i.fullMessageLength=i.messageLength64=[];for(var r=i.messageLengthSize/4,a=0;a<r;++a)i.fullMessageLength.push(0);return t=n.util.createBuffer(),e={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},i}};return i.start(),i.update=function(a,s){"utf8"===s&&(a=n.util.encodeUtf8(a));var u=a.length;i.messageLength+=u,u=[u/4294967296>>>0,u>>>0];for(var c=i.fullMessageLength.length-1;c>=0;--c)i.fullMessageLength[c]+=u[1],u[1]=u[0]+(i.fullMessageLength[c]/4294967296>>>0),i.fullMessageLength[c]=i.fullMessageLength[c]>>>0,u[0]=u[1]/4294967296>>>0;return t.putBytes(a),o(e,r,t),(t.read>2048||0===t.length())&&t.compact(),i},i.digest=function(){var s=n.util.createBuffer();s.putBytes(t.bytes());var u,c=i.fullMessageLength[i.fullMessageLength.length-1]+i.messageLengthSize&i.blockLength-1;s.putBytes(a.substr(0,i.blockLength-c));for(var l=8*i.fullMessageLength[0],f=0;f<i.fullMessageLength.length-1;++f)l+=(u=8*i.fullMessageLength[f+1])/4294967296>>>0,s.putInt32(l>>>0),l=u>>>0;s.putInt32(l);var h={h0:e.h0,h1:e.h1,h2:e.h2,h3:e.h3,h4:e.h4};o(h,r,s);var p=n.util.createBuffer();return p.putInt32(h.h0),p.putInt32(h.h1),p.putInt32(h.h2),p.putInt32(h.h3),p.putInt32(h.h4),p},i};var a=null,s=!1;function o(e,t,r){for(var n,i,a,s,o,u,c,l=r.length();l>=64;){for(i=e.h0,a=e.h1,s=e.h2,o=e.h3,u=e.h4,c=0;c<16;++c)n=r.getInt32(),t[c]=n,n=(i<<5|i>>>27)+(o^a&(s^o))+u+1518500249+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;for(;c<20;++c)n=(n=t[c-3]^t[c-8]^t[c-14]^t[c-16])<<1|n>>>31,t[c]=n,n=(i<<5|i>>>27)+(o^a&(s^o))+u+1518500249+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;for(;c<32;++c)n=(n=t[c-3]^t[c-8]^t[c-14]^t[c-16])<<1|n>>>31,t[c]=n,n=(i<<5|i>>>27)+(a^s^o)+u+1859775393+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;for(;c<40;++c)n=(n=t[c-6]^t[c-16]^t[c-28]^t[c-32])<<2|n>>>30,t[c]=n,n=(i<<5|i>>>27)+(a^s^o)+u+1859775393+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;for(;c<60;++c)n=(n=t[c-6]^t[c-16]^t[c-28]^t[c-32])<<2|n>>>30,t[c]=n,n=(i<<5|i>>>27)+(a&s|o&(a^s))+u+2400959708+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;for(;c<80;++c)n=(n=t[c-6]^t[c-16]^t[c-28]^t[c-32])<<2|n>>>30,t[c]=n,n=(i<<5|i>>>27)+(a^s^o)+u+3395469782+n,u=o,o=s,s=(a<<30|a>>>2)>>>0,a=i,i=n;e.h0=e.h0+i|0,e.h1=e.h1+a|0,e.h2=e.h2+s|0,e.h3=e.h3+o|0,e.h4=e.h4+u|0,l-=64}}},function(e,t,r){var n=r(1);r(29),r(15),r(58),r(9),r(105),r(16),r(35),r(63),r(25),r(2);var i=n.asn1,a=e.exports=n.pki=n.pki||{},s=a.oids,o={};o.CN=s.commonName,o.commonName="CN",o.C=s.countryName,o.countryName="C",o.L=s.localityName,o.localityName="L",o.ST=s.stateOrProvinceName,o.stateOrProvinceName="ST",o.O=s.organizationName,o.organizationName="O",o.OU=s.organizationalUnitName,o.organizationalUnitName="OU",o.E=s.emailAddress,o.emailAddress="E";var u=n.pki.rsa.publicKeyValidator,c={name:"Certificate",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"tbsCertificate",value:[{name:"Certificate.TBSCertificate.version",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.version.integer",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"certVersion"}]},{name:"Certificate.TBSCertificate.serialNumber",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"certSerialNumber"},{name:"Certificate.TBSCertificate.signature",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.signature.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"certinfoSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:i.Class.UNIVERSAL,optional:!0,captureAsn1:"certinfoSignatureParams"}]},{name:"Certificate.TBSCertificate.issuer",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"certIssuer"},{name:"Certificate.TBSCertificate.validity",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.TBSCertificate.validity.notBefore (utc)",tagClass:i.Class.UNIVERSAL,type:i.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity1UTCTime"},{name:"Certificate.TBSCertificate.validity.notBefore (generalized)",tagClass:i.Class.UNIVERSAL,type:i.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity2GeneralizedTime"},{name:"Certificate.TBSCertificate.validity.notAfter (utc)",tagClass:i.Class.UNIVERSAL,type:i.Type.UTCTIME,constructed:!1,optional:!0,capture:"certValidity3UTCTime"},{name:"Certificate.TBSCertificate.validity.notAfter (generalized)",tagClass:i.Class.UNIVERSAL,type:i.Type.GENERALIZEDTIME,constructed:!1,optional:!0,capture:"certValidity4GeneralizedTime"}]},{name:"Certificate.TBSCertificate.subject",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"certSubject"},u,{name:"Certificate.TBSCertificate.issuerUniqueID",tagClass:i.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.issuerUniqueID.id",tagClass:i.Class.UNIVERSAL,type:i.Type.BITSTRING,constructed:!1,captureBitStringValue:"certIssuerUniqueId"}]},{name:"Certificate.TBSCertificate.subjectUniqueID",tagClass:i.Class.CONTEXT_SPECIFIC,type:2,constructed:!0,optional:!0,value:[{name:"Certificate.TBSCertificate.subjectUniqueID.id",tagClass:i.Class.UNIVERSAL,type:i.Type.BITSTRING,constructed:!1,captureBitStringValue:"certSubjectUniqueId"}]},{name:"Certificate.TBSCertificate.extensions",tagClass:i.Class.CONTEXT_SPECIFIC,type:3,constructed:!0,captureAsn1:"certExtensions",optional:!0}]},{name:"Certificate.signatureAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"Certificate.signatureAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"certSignatureOid"},{name:"Certificate.TBSCertificate.signature.parameters",tagClass:i.Class.UNIVERSAL,optional:!0,captureAsn1:"certSignatureParams"}]},{name:"Certificate.signatureValue",tagClass:i.Class.UNIVERSAL,type:i.Type.BITSTRING,constructed:!1,captureBitStringValue:"certSignature"}]},l={name:"rsapss",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.hashAlgorithm",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier",tagClass:i.Class.UNIVERSAL,type:i.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"hashOid"}]}]},{name:"rsapss.maskGenAlgorithm",tagClass:i.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier",tagClass:i.Class.UNIVERSAL,type:i.Class.SEQUENCE,constructed:!0,optional:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"maskGenOid"},{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"maskGenHashOid"}]}]}]},{name:"rsapss.saltLength",tagClass:i.Class.CONTEXT_SPECIFIC,type:2,optional:!0,value:[{name:"rsapss.saltLength.saltLength",tagClass:i.Class.UNIVERSAL,type:i.Class.INTEGER,constructed:!1,capture:"saltLength"}]},{name:"rsapss.trailerField",tagClass:i.Class.CONTEXT_SPECIFIC,type:3,optional:!0,value:[{name:"rsapss.trailer.trailer",tagClass:i.Class.UNIVERSAL,type:i.Class.INTEGER,constructed:!1,capture:"trailer"}]}]},f={name:"CertificationRequestInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfo",value:[{name:"CertificationRequestInfo.integer",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"certificationRequestInfoVersion"},{name:"CertificationRequestInfo.subject",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"certificationRequestInfoSubject"},u,{name:"CertificationRequestInfo.attributes",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"certificationRequestInfoAttributes",value:[{name:"CertificationRequestInfo.attributes",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequestInfo.attributes.type",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1},{name:"CertificationRequestInfo.attributes.value",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,constructed:!0}]}]}]},h={name:"CertificationRequest",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"csr",value:[f,{name:"CertificationRequest.signatureAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"CertificationRequest.signatureAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"csrSignatureOid"},{name:"CertificationRequest.signatureAlgorithm.parameters",tagClass:i.Class.UNIVERSAL,optional:!0,captureAsn1:"csrSignatureParams"}]},{name:"CertificationRequest.signature",tagClass:i.Class.UNIVERSAL,type:i.Type.BITSTRING,constructed:!1,captureBitStringValue:"csrSignature"}]};function p(e,t){"string"==typeof t&&(t={shortName:t});for(var r,n=null,i=0;null===n&&i<e.attributes.length;++i)r=e.attributes[i],t.type&&t.type===r.type?n=r:t.name&&t.name===r.name?n=r:t.shortName&&t.shortName===r.shortName&&(n=r);return n}a.RDNAttributesAsArray=function(e,t){for(var r,n,a,u=[],c=0;c<e.value.length;++c){r=e.value[c];for(var l=0;l<r.value.length;++l)a={},n=r.value[l],a.type=i.derToOid(n.value[0].value),a.value=n.value[1].value,a.valueTagClass=n.value[1].type,a.type in s&&(a.name=s[a.type],a.name in o&&(a.shortName=o[a.name])),t&&(t.update(a.type),t.update(a.value)),u.push(a)}return u},a.CRIAttributesAsArray=function(e){for(var t=[],r=0;r<e.length;++r)for(var n=e[r],u=i.derToOid(n.value[0].value),c=n.value[1].value,l=0;l<c.length;++l){var f={};if(f.type=u,f.value=c[l].value,f.valueTagClass=c[l].type,f.type in s&&(f.name=s[f.type],f.name in o&&(f.shortName=o[f.name])),f.type===s.extensionRequest){f.extensions=[];for(var h=0;h<f.value.length;++h)f.extensions.push(a.certificateExtensionFromAsn1(f.value[h]))}t.push(f)}return t};var d=function(e,t,r){var n={};if(e!==s["RSASSA-PSS"])return n;r&&(n={hash:{algorithmOid:s.sha1},mgf:{algorithmOid:s.mgf1,hash:{algorithmOid:s.sha1}},saltLength:20});var a={},o=[];if(!i.validate(t,l,a,o)){var u=new Error("Cannot read RSASSA-PSS parameter block.");throw u.errors=o,u}return void 0!==a.hashOid&&(n.hash=n.hash||{},n.hash.algorithmOid=i.derToOid(a.hashOid)),void 0!==a.maskGenOid&&(n.mgf=n.mgf||{},n.mgf.algorithmOid=i.derToOid(a.maskGenOid),n.mgf.hash=n.mgf.hash||{},n.mgf.hash.algorithmOid=i.derToOid(a.maskGenHashOid)),void 0!==a.saltLength&&(n.saltLength=a.saltLength.charCodeAt(0)),n};function y(e){for(var t,r,a=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]),s=e.attributes,o=0;o<s.length;++o){var u=(t=s[o]).value,c=i.Type.PRINTABLESTRING;"valueTagClass"in t&&(c=t.valueTagClass)===i.Type.UTF8&&(u=n.util.encodeUtf8(u)),r=i.create(i.Class.UNIVERSAL,i.Type.SET,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(t.type).getBytes()),i.create(i.Class.UNIVERSAL,c,!1,u)])]),a.value.push(r)}return a}function g(e){for(var t,r=0;r<e.length;++r){if(void 0===(t=e[r]).name&&(t.type&&t.type in a.oids?t.name=a.oids[t.type]:t.shortName&&t.shortName in o&&(t.name=a.oids[o[t.shortName]])),void 0===t.type){if(!(t.name&&t.name in a.oids))throw(u=new Error("Attribute type not specified.")).attribute=t,u;t.type=a.oids[t.name]}if(void 0===t.shortName&&t.name&&t.name in o&&(t.shortName=o[t.name]),t.type===s.extensionRequest&&(t.valueConstructed=!0,t.valueTagClass=i.Type.SEQUENCE,!t.value&&t.extensions)){t.value=[];for(var n=0;n<t.extensions.length;++n)t.value.push(a.certificateExtensionToAsn1(m(t.extensions[n])))}var u;if(void 0===t.value)throw(u=new Error("Attribute value not specified.")).attribute=t,u}}function m(e,t){if(t=t||{},void 0===e.name&&e.id&&e.id in a.oids&&(e.name=a.oids[e.id]),void 0===e.id){if(!(e.name&&e.name in a.oids))throw(S=new Error("Extension ID not specified.")).extension=e,S;e.id=a.oids[e.name]}if(void 0!==e.value)return e;if("keyUsage"===e.name){var r=0,o=0,u=0;e.digitalSignature&&(o|=128,r=7),e.nonRepudiation&&(o|=64,r=6),e.keyEncipherment&&(o|=32,r=5),e.dataEncipherment&&(o|=16,r=4),e.keyAgreement&&(o|=8,r=3),e.keyCertSign&&(o|=4,r=2),e.cRLSign&&(o|=2,r=1),e.encipherOnly&&(o|=1,r=0),e.decipherOnly&&(u|=128,r=7);var c=String.fromCharCode(r);0!==u?c+=String.fromCharCode(o)+String.fromCharCode(u):0!==o&&(c+=String.fromCharCode(o)),e.value=i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,c)}else if("basicConstraints"===e.name)e.value=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]),e.cA&&e.value.value.push(i.create(i.Class.UNIVERSAL,i.Type.BOOLEAN,!1,String.fromCharCode(255))),"pathLenConstraint"in e&&e.value.value.push(i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(e.pathLenConstraint).getBytes()));else if("extKeyUsage"===e.name){e.value=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);var l=e.value.value;for(var f in e)!0===e[f]&&(f in s?l.push(i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(s[f]).getBytes())):-1!==f.indexOf(".")&&l.push(i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(f).getBytes())))}else if("nsCertType"===e.name){r=0,o=0;e.client&&(o|=128,r=7),e.server&&(o|=64,r=6),e.email&&(o|=32,r=5),e.objsign&&(o|=16,r=4),e.reserved&&(o|=8,r=3),e.sslCA&&(o|=4,r=2),e.emailCA&&(o|=2,r=1),e.objCA&&(o|=1,r=0);c=String.fromCharCode(r);0!==o&&(c+=String.fromCharCode(o)),e.value=i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,c)}else if("subjectAltName"===e.name||"issuerAltName"===e.name){e.value=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);for(var h=0;h<e.altNames.length;++h){c=(v=e.altNames[h]).value;if(7===v.type&&v.ip){if(null===(c=n.util.bytesFromIP(v.ip)))throw(S=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension=e,S}else 8===v.type&&(c=v.oid?i.oidToDer(i.oidToDer(v.oid)):i.oidToDer(c));e.value.value.push(i.create(i.Class.CONTEXT_SPECIFIC,v.type,!1,c))}}else if("nsComment"===e.name&&t.cert){if(!/^[\x00-\x7F]*$/.test(e.comment)||e.comment.length<1||e.comment.length>128)throw new Error('Invalid "nsComment" content.');e.value=i.create(i.Class.UNIVERSAL,i.Type.IA5STRING,!1,e.comment)}else if("subjectKeyIdentifier"===e.name&&t.cert){var p=t.cert.generateSubjectKeyIdentifier();e.subjectKeyIdentifier=p.toHex(),e.value=i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,p.getBytes())}else if("authorityKeyIdentifier"===e.name&&t.cert){e.value=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);l=e.value.value;if(e.keyIdentifier){var d=!0===e.keyIdentifier?t.cert.generateSubjectKeyIdentifier().getBytes():e.keyIdentifier;l.push(i.create(i.Class.CONTEXT_SPECIFIC,0,!1,d))}if(e.authorityCertIssuer){var g=[i.create(i.Class.CONTEXT_SPECIFIC,4,!0,[y(!0===e.authorityCertIssuer?t.cert.issuer:e.authorityCertIssuer)])];l.push(i.create(i.Class.CONTEXT_SPECIFIC,1,!0,g))}if(e.serialNumber){var m=n.util.hexToBytes(!0===e.serialNumber?t.cert.serialNumber:e.serialNumber);l.push(i.create(i.Class.CONTEXT_SPECIFIC,2,!1,m))}}else if("cRLDistributionPoints"===e.name){e.value=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);l=e.value.value;var v,b=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]),E=i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[]);for(h=0;h<e.altNames.length;++h){c=(v=e.altNames[h]).value;if(7===v.type&&v.ip){if(null===(c=n.util.bytesFromIP(v.ip)))throw(S=new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension=e,S}else 8===v.type&&(c=v.oid?i.oidToDer(i.oidToDer(v.oid)):i.oidToDer(c));E.value.push(i.create(i.Class.CONTEXT_SPECIFIC,v.type,!1,c))}b.value.push(i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[E])),l.push(b)}var S;if(void 0===e.value)throw(S=new Error("Extension value not specified.")).extension=e,S;return e}function v(e,t){switch(e){case s["RSASSA-PSS"]:var r=[];return void 0!==t.hash.algorithmOid&&r.push(i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(t.hash.algorithmOid).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.NULL,!1,"")])])),void 0!==t.mgf.algorithmOid&&r.push(i.create(i.Class.CONTEXT_SPECIFIC,1,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(t.mgf.algorithmOid).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(t.mgf.hash.algorithmOid).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.NULL,!1,"")])])])),void 0!==t.saltLength&&r.push(i.create(i.Class.CONTEXT_SPECIFIC,2,!0,[i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(t.saltLength).getBytes())])),i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,r);default:return i.create(i.Class.UNIVERSAL,i.Type.NULL,!1,"")}}function b(e){var t=i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[]);if(0===e.attributes.length)return t;for(var r=e.attributes,a=0;a<r.length;++a){var s=r[a],o=s.value,u=i.Type.UTF8;"valueTagClass"in s&&(u=s.valueTagClass),u===i.Type.UTF8&&(o=n.util.encodeUtf8(o));var c=!1;"valueConstructed"in s&&(c=s.valueConstructed);var l=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(s.type).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.SET,!0,[i.create(i.Class.UNIVERSAL,u,c,o)])]);t.value.push(l)}return t}a.certificateFromPem=function(e,t,r){var s=n.pem.decode(e)[0];if("CERTIFICATE"!==s.type&&"X509 CERTIFICATE"!==s.type&&"TRUSTED CERTIFICATE"!==s.type){var o=new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');throw o.headerType=s.type,o}if(s.procType&&"ENCRYPTED"===s.procType.type)throw new Error("Could not convert certificate from PEM; PEM is encrypted.");var u=i.fromDer(s.body,r);return a.certificateFromAsn1(u,t)},a.certificateToPem=function(e,t){var r={type:"CERTIFICATE",body:i.toDer(a.certificateToAsn1(e)).getBytes()};return n.pem.encode(r,{maxline:t})},a.publicKeyFromPem=function(e){var t=n.pem.decode(e)[0];if("PUBLIC KEY"!==t.type&&"RSA PUBLIC KEY"!==t.type){var r=new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');throw r.headerType=t.type,r}if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert public key from PEM; PEM is encrypted.");var s=i.fromDer(t.body);return a.publicKeyFromAsn1(s)},a.publicKeyToPem=function(e,t){var r={type:"PUBLIC KEY",body:i.toDer(a.publicKeyToAsn1(e)).getBytes()};return n.pem.encode(r,{maxline:t})},a.publicKeyToRSAPublicKeyPem=function(e,t){var r={type:"RSA PUBLIC KEY",body:i.toDer(a.publicKeyToRSAPublicKey(e)).getBytes()};return n.pem.encode(r,{maxline:t})},a.getPublicKeyFingerprint=function(e,t){var r,s=(t=t||{}).md||n.md.sha1.create();switch(t.type||"RSAPublicKey"){case"RSAPublicKey":r=i.toDer(a.publicKeyToRSAPublicKey(e)).getBytes();break;case"SubjectPublicKeyInfo":r=i.toDer(a.publicKeyToAsn1(e)).getBytes();break;default:throw new Error('Unknown fingerprint type "'+t.type+'".')}s.start(),s.update(r);var o=s.digest();if("hex"===t.encoding){var u=o.toHex();return t.delimiter?u.match(/.{2}/g).join(t.delimiter):u}if("binary"===t.encoding)return o.getBytes();if(t.encoding)throw new Error('Unknown encoding "'+t.encoding+'".');return o},a.certificationRequestFromPem=function(e,t,r){var s=n.pem.decode(e)[0];if("CERTIFICATE REQUEST"!==s.type){var o=new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');throw o.headerType=s.type,o}if(s.procType&&"ENCRYPTED"===s.procType.type)throw new Error("Could not convert certification request from PEM; PEM is encrypted.");var u=i.fromDer(s.body,r);return a.certificationRequestFromAsn1(u,t)},a.certificationRequestToPem=function(e,t){var r={type:"CERTIFICATE REQUEST",body:i.toDer(a.certificationRequestToAsn1(e)).getBytes()};return n.pem.encode(r,{maxline:t})},a.createCertificate=function(){var e={version:2,serialNumber:"00",signatureOid:null,signature:null,siginfo:{}};return e.siginfo.algorithmOid=null,e.validity={},e.validity.notBefore=new Date,e.validity.notAfter=new Date,e.issuer={},e.issuer.getField=function(t){return p(e.issuer,t)},e.issuer.addField=function(t){g([t]),e.issuer.attributes.push(t)},e.issuer.attributes=[],e.issuer.hash=null,e.subject={},e.subject.getField=function(t){return p(e.subject,t)},e.subject.addField=function(t){g([t]),e.subject.attributes.push(t)},e.subject.attributes=[],e.subject.hash=null,e.extensions=[],e.publicKey=null,e.md=null,e.setSubject=function(t,r){g(t),e.subject.attributes=t,delete e.subject.uniqueId,r&&(e.subject.uniqueId=r),e.subject.hash=null},e.setIssuer=function(t,r){g(t),e.issuer.attributes=t,delete e.issuer.uniqueId,r&&(e.issuer.uniqueId=r),e.issuer.hash=null},e.setExtensions=function(t){for(var r=0;r<t.length;++r)m(t[r],{cert:e});e.extensions=t},e.getExtension=function(t){"string"==typeof t&&(t={name:t});for(var r,n=null,i=0;null===n&&i<e.extensions.length;++i)r=e.extensions[i],t.id&&r.id===t.id?n=r:t.name&&r.name===t.name&&(n=r);return n},e.sign=function(t,r){e.md=r||n.md.sha1.create();var o=s[e.md.algorithm+"WithRSAEncryption"];if(!o){var u=new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");throw u.algorithm=e.md.algorithm,u}e.signatureOid=e.siginfo.algorithmOid=o,e.tbsCertificate=a.getTBSCertificate(e);var c=i.toDer(e.tbsCertificate);e.md.update(c.getBytes()),e.signature=t.sign(e.md)},e.verify=function(t){var r=!1;if(!e.issued(t)){var o=t.issuer,u=e.subject;throw(y=new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.")).expectedIssuer=o.attributes,y.actualIssuer=u.attributes,y}var c=t.md;if(null===c){if(t.signatureOid in s)switch(s[t.signatureOid]){case"sha1WithRSAEncryption":c=n.md.sha1.create();break;case"md5WithRSAEncryption":c=n.md.md5.create();break;case"sha256WithRSAEncryption":c=n.md.sha256.create();break;case"sha384WithRSAEncryption":c=n.md.sha384.create();break;case"sha512WithRSAEncryption":c=n.md.sha512.create();break;case"RSASSA-PSS":c=n.md.sha256.create()}if(null===c)throw(y=new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid=t.signatureOid,y;var l=t.tbsCertificate||a.getTBSCertificate(t),f=i.toDer(l);c.update(f.getBytes())}if(null!==c){var h;switch(t.signatureOid){case s.sha1WithRSAEncryption:h=void 0;break;case s["RSASSA-PSS"]:var p,d,y;if(void 0===(p=s[t.signatureParameters.mgf.hash.algorithmOid])||void 0===n.md[p])throw(y=new Error("Unsupported MGF hash function.")).oid=t.signatureParameters.mgf.hash.algorithmOid,y.name=p,y;if(void 0===(d=s[t.signatureParameters.mgf.algorithmOid])||void 0===n.mgf[d])throw(y=new Error("Unsupported MGF function.")).oid=t.signatureParameters.mgf.algorithmOid,y.name=d,y;if(d=n.mgf[d].create(n.md[p].create()),void 0===(p=s[t.signatureParameters.hash.algorithmOid])||void 0===n.md[p])throw{message:"Unsupported RSASSA-PSS hash function.",oid:t.signatureParameters.hash.algorithmOid,name:p};h=n.pss.create(n.md[p].create(),d,t.signatureParameters.saltLength)}r=e.publicKey.verify(c.digest().getBytes(),t.signature,h)}return r},e.isIssuer=function(t){var r=!1,n=e.issuer,i=t.subject;if(n.hash&&i.hash)r=n.hash===i.hash;else if(n.attributes.length===i.attributes.length){var a,s;r=!0;for(var o=0;r&&o<n.attributes.length;++o)a=n.attributes[o],s=i.attributes[o],a.type===s.type&&a.value===s.value||(r=!1)}return r},e.issued=function(t){return t.isIssuer(e)},e.generateSubjectKeyIdentifier=function(){return a.getPublicKeyFingerprint(e.publicKey,{type:"RSAPublicKey"})},e.verifySubjectKeyIdentifier=function(){for(var t=s.subjectKeyIdentifier,r=0;r<e.extensions.length;++r){var i=e.extensions[r];if(i.id===t){var a=e.generateSubjectKeyIdentifier().getBytes();return n.util.hexToBytes(i.subjectKeyIdentifier)===a}}return!1},e},a.certificateFromAsn1=function(e,t){var r={},o=[];if(!i.validate(e,c,r,o))throw(h=new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")).errors=o,h;if(i.derToOid(r.publicKeyOid)!==a.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var u=a.createCertificate();u.version=r.certVersion?r.certVersion.charCodeAt(0):0;var l=n.util.createBuffer(r.certSerialNumber);u.serialNumber=l.toHex(),u.signatureOid=n.asn1.derToOid(r.certSignatureOid),u.signatureParameters=d(u.signatureOid,r.certSignatureParams,!0),u.siginfo.algorithmOid=n.asn1.derToOid(r.certinfoSignatureOid),u.siginfo.parameters=d(u.siginfo.algorithmOid,r.certinfoSignatureParams,!1),u.signature=r.certSignature;var f=[];if(void 0!==r.certValidity1UTCTime&&f.push(i.utcTimeToDate(r.certValidity1UTCTime)),void 0!==r.certValidity2GeneralizedTime&&f.push(i.generalizedTimeToDate(r.certValidity2GeneralizedTime)),void 0!==r.certValidity3UTCTime&&f.push(i.utcTimeToDate(r.certValidity3UTCTime)),void 0!==r.certValidity4GeneralizedTime&&f.push(i.generalizedTimeToDate(r.certValidity4GeneralizedTime)),f.length>2)throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");if(f.length<2)throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");if(u.validity.notBefore=f[0],u.validity.notAfter=f[1],u.tbsCertificate=r.tbsCertificate,t){var h;if(u.md=null,u.signatureOid in s)switch(s[u.signatureOid]){case"sha1WithRSAEncryption":u.md=n.md.sha1.create();break;case"md5WithRSAEncryption":u.md=n.md.md5.create();break;case"sha256WithRSAEncryption":u.md=n.md.sha256.create();break;case"sha384WithRSAEncryption":u.md=n.md.sha384.create();break;case"sha512WithRSAEncryption":u.md=n.md.sha512.create();break;case"RSASSA-PSS":u.md=n.md.sha256.create()}if(null===u.md)throw(h=new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid=u.signatureOid,h;var y=i.toDer(u.tbsCertificate);u.md.update(y.getBytes())}var m=n.md.sha1.create();u.issuer.getField=function(e){return p(u.issuer,e)},u.issuer.addField=function(e){g([e]),u.issuer.attributes.push(e)},u.issuer.attributes=a.RDNAttributesAsArray(r.certIssuer,m),r.certIssuerUniqueId&&(u.issuer.uniqueId=r.certIssuerUniqueId),u.issuer.hash=m.digest().toHex();var v=n.md.sha1.create();return u.subject.getField=function(e){return p(u.subject,e)},u.subject.addField=function(e){g([e]),u.subject.attributes.push(e)},u.subject.attributes=a.RDNAttributesAsArray(r.certSubject,v),r.certSubjectUniqueId&&(u.subject.uniqueId=r.certSubjectUniqueId),u.subject.hash=v.digest().toHex(),r.certExtensions?u.extensions=a.certificateExtensionsFromAsn1(r.certExtensions):u.extensions=[],u.publicKey=a.publicKeyFromAsn1(r.subjectPublicKeyInfo),u},a.certificateExtensionsFromAsn1=function(e){for(var t=[],r=0;r<e.value.length;++r)for(var n=e.value[r],i=0;i<n.value.length;++i)t.push(a.certificateExtensionFromAsn1(n.value[i]));return t},a.certificateExtensionFromAsn1=function(e){var t={};if(t.id=i.derToOid(e.value[0].value),t.critical=!1,e.value[1].type===i.Type.BOOLEAN?(t.critical=0!==e.value[1].value.charCodeAt(0),t.value=e.value[2].value):t.value=e.value[1].value,t.id in s)if(t.name=s[t.id],"keyUsage"===t.name){var r=0,a=0;(u=i.fromDer(t.value)).value.length>1&&(r=u.value.charCodeAt(1),a=u.value.length>2?u.value.charCodeAt(2):0),t.digitalSignature=128==(128&r),t.nonRepudiation=64==(64&r),t.keyEncipherment=32==(32&r),t.dataEncipherment=16==(16&r),t.keyAgreement=8==(8&r),t.keyCertSign=4==(4&r),t.cRLSign=2==(2&r),t.encipherOnly=1==(1&r),t.decipherOnly=128==(128&a)}else if("basicConstraints"===t.name){(u=i.fromDer(t.value)).value.length>0&&u.value[0].type===i.Type.BOOLEAN?t.cA=0!==u.value[0].value.charCodeAt(0):t.cA=!1;var o=null;u.value.length>0&&u.value[0].type===i.Type.INTEGER?o=u.value[0].value:u.value.length>1&&(o=u.value[1].value),null!==o&&(t.pathLenConstraint=i.derToInteger(o))}else if("extKeyUsage"===t.name)for(var u=i.fromDer(t.value),c=0;c<u.value.length;++c){var l=i.derToOid(u.value[c].value);l in s?t[s[l]]=!0:t[l]=!0}else if("nsCertType"===t.name){r=0;(u=i.fromDer(t.value)).value.length>1&&(r=u.value.charCodeAt(1)),t.client=128==(128&r),t.server=64==(64&r),t.email=32==(32&r),t.objsign=16==(16&r),t.reserved=8==(8&r),t.sslCA=4==(4&r),t.emailCA=2==(2&r),t.objCA=1==(1&r)}else if("subjectAltName"===t.name||"issuerAltName"===t.name){var f;t.altNames=[];u=i.fromDer(t.value);for(var h=0;h<u.value.length;++h){var p={type:(f=u.value[h]).type,value:f.value};switch(t.altNames.push(p),f.type){case 1:case 2:case 6:break;case 7:p.ip=n.util.bytesToIP(f.value);break;case 8:p.oid=i.derToOid(f.value)}}}else if("subjectKeyIdentifier"===t.name){u=i.fromDer(t.value);t.subjectKeyIdentifier=n.util.bytesToHex(u.value)}return t},a.certificationRequestFromAsn1=function(e,t){var r={},o=[];if(!i.validate(e,h,r,o))throw(c=new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.")).errors=o,c;if(i.derToOid(r.publicKeyOid)!==a.oids.rsaEncryption)throw new Error("Cannot read public key. OID is not RSA.");var u=a.createCertificationRequest();if(u.version=r.csrVersion?r.csrVersion.charCodeAt(0):0,u.signatureOid=n.asn1.derToOid(r.csrSignatureOid),u.signatureParameters=d(u.signatureOid,r.csrSignatureParams,!0),u.siginfo.algorithmOid=n.asn1.derToOid(r.csrSignatureOid),u.siginfo.parameters=d(u.siginfo.algorithmOid,r.csrSignatureParams,!1),u.signature=r.csrSignature,u.certificationRequestInfo=r.certificationRequestInfo,t){var c;if(u.md=null,u.signatureOid in s)switch(s[u.signatureOid]){case"sha1WithRSAEncryption":u.md=n.md.sha1.create();break;case"md5WithRSAEncryption":u.md=n.md.md5.create();break;case"sha256WithRSAEncryption":u.md=n.md.sha256.create();break;case"sha384WithRSAEncryption":u.md=n.md.sha384.create();break;case"sha512WithRSAEncryption":u.md=n.md.sha512.create();break;case"RSASSA-PSS":u.md=n.md.sha256.create()}if(null===u.md)throw(c=new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid=u.signatureOid,c;var l=i.toDer(u.certificationRequestInfo);u.md.update(l.getBytes())}var f=n.md.sha1.create();return u.subject.getField=function(e){return p(u.subject,e)},u.subject.addField=function(e){g([e]),u.subject.attributes.push(e)},u.subject.attributes=a.RDNAttributesAsArray(r.certificationRequestInfoSubject,f),u.subject.hash=f.digest().toHex(),u.publicKey=a.publicKeyFromAsn1(r.subjectPublicKeyInfo),u.getAttribute=function(e){return p(u,e)},u.addAttribute=function(e){g([e]),u.attributes.push(e)},u.attributes=a.CRIAttributesAsArray(r.certificationRequestInfoAttributes||[]),u},a.createCertificationRequest=function(){var e={version:0,signatureOid:null,signature:null,siginfo:{}};return e.siginfo.algorithmOid=null,e.subject={},e.subject.getField=function(t){return p(e.subject,t)},e.subject.addField=function(t){g([t]),e.subject.attributes.push(t)},e.subject.attributes=[],e.subject.hash=null,e.publicKey=null,e.attributes=[],e.getAttribute=function(t){return p(e,t)},e.addAttribute=function(t){g([t]),e.attributes.push(t)},e.md=null,e.setSubject=function(t){g(t),e.subject.attributes=t,e.subject.hash=null},e.setAttributes=function(t){g(t),e.attributes=t},e.sign=function(t,r){e.md=r||n.md.sha1.create();var o=s[e.md.algorithm+"WithRSAEncryption"];if(!o){var u=new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");throw u.algorithm=e.md.algorithm,u}e.signatureOid=e.siginfo.algorithmOid=o,e.certificationRequestInfo=a.getCertificationRequestInfo(e);var c=i.toDer(e.certificationRequestInfo);e.md.update(c.getBytes()),e.signature=t.sign(e.md)},e.verify=function(){var t=!1,r=e.md;if(null===r){if(e.signatureOid in s)switch(s[e.signatureOid]){case"sha1WithRSAEncryption":r=n.md.sha1.create();break;case"md5WithRSAEncryption":r=n.md.md5.create();break;case"sha256WithRSAEncryption":r=n.md.sha256.create();break;case"sha384WithRSAEncryption":r=n.md.sha384.create();break;case"sha512WithRSAEncryption":r=n.md.sha512.create();break;case"RSASSA-PSS":r=n.md.sha256.create()}if(null===r)throw(h=new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid=e.signatureOid,h;var o=e.certificationRequestInfo||a.getCertificationRequestInfo(e),u=i.toDer(o);r.update(u.getBytes())}if(null!==r){var c;switch(e.signatureOid){case s.sha1WithRSAEncryption:break;case s["RSASSA-PSS"]:var l,f,h;if(void 0===(l=s[e.signatureParameters.mgf.hash.algorithmOid])||void 0===n.md[l])throw(h=new Error("Unsupported MGF hash function.")).oid=e.signatureParameters.mgf.hash.algorithmOid,h.name=l,h;if(void 0===(f=s[e.signatureParameters.mgf.algorithmOid])||void 0===n.mgf[f])throw(h=new Error("Unsupported MGF function.")).oid=e.signatureParameters.mgf.algorithmOid,h.name=f,h;if(f=n.mgf[f].create(n.md[l].create()),void 0===(l=s[e.signatureParameters.hash.algorithmOid])||void 0===n.md[l])throw(h=new Error("Unsupported RSASSA-PSS hash function.")).oid=e.signatureParameters.hash.algorithmOid,h.name=l,h;c=n.pss.create(n.md[l].create(),f,e.signatureParameters.saltLength)}t=e.publicKey.verify(r.digest().getBytes(),e.signature,c)}return t},e};var E=new Date("1950-01-01T00:00:00Z"),S=new Date("2050-01-01T00:00:00Z");function T(e){return e>=E&&e<S?i.create(i.Class.UNIVERSAL,i.Type.UTCTIME,!1,i.dateToUtcTime(e)):i.create(i.Class.UNIVERSAL,i.Type.GENERALIZEDTIME,!1,i.dateToGeneralizedTime(e))}a.getTBSCertificate=function(e){var t=T(e.validity.notBefore),r=T(e.validity.notAfter),s=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(e.version).getBytes())]),i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,n.util.hexToBytes(e.serialNumber)),i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(e.siginfo.algorithmOid).getBytes()),v(e.siginfo.algorithmOid,e.siginfo.parameters)]),y(e.issuer),i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[t,r]),y(e.subject),a.publicKeyToAsn1(e.publicKey)]);return e.issuer.uniqueId&&s.value.push(i.create(i.Class.CONTEXT_SPECIFIC,1,!0,[i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,String.fromCharCode(0)+e.issuer.uniqueId)])),e.subject.uniqueId&&s.value.push(i.create(i.Class.CONTEXT_SPECIFIC,2,!0,[i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,String.fromCharCode(0)+e.subject.uniqueId)])),e.extensions.length>0&&s.value.push(a.certificateExtensionsToAsn1(e.extensions)),s},a.getCertificationRequestInfo=function(e){return i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(e.version).getBytes()),y(e.subject),a.publicKeyToAsn1(e.publicKey),b(e)])},a.distinguishedNameToAsn1=function(e){return y(e)},a.certificateToAsn1=function(e){var t=e.tbsCertificate||a.getTBSCertificate(e);return i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[t,i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(e.signatureOid).getBytes()),v(e.signatureOid,e.signatureParameters)]),i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},a.certificateExtensionsToAsn1=function(e){var t=i.create(i.Class.CONTEXT_SPECIFIC,3,!0,[]),r=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);t.value.push(r);for(var n=0;n<e.length;++n)r.value.push(a.certificateExtensionToAsn1(e[n]));return t},a.certificateExtensionToAsn1=function(e){var t=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[]);t.value.push(i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(e.id).getBytes())),e.critical&&t.value.push(i.create(i.Class.UNIVERSAL,i.Type.BOOLEAN,!1,String.fromCharCode(255)));var r=e.value;return"string"!=typeof e.value&&(r=i.toDer(r).getBytes()),t.value.push(i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,r)),t},a.certificationRequestToAsn1=function(e){var t=e.certificationRequestInfo||a.getCertificationRequestInfo(e);return i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[t,i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(e.signatureOid).getBytes()),v(e.signatureOid,e.signatureParameters)]),i.create(i.Class.UNIVERSAL,i.Type.BITSTRING,!1,String.fromCharCode(0)+e.signature)])},a.createCaStore=function(e){var t={certs:{}};function r(e){return s(e),t.certs[e.hash]||null}function s(e){if(!e.hash){var t=n.md.sha1.create();e.attributes=a.RDNAttributesAsArray(y(e),t),e.hash=t.digest().toHex()}}if(t.getIssuer=function(e){return r(e.issuer)},t.addCertificate=function(e){if("string"==typeof e&&(e=n.pki.certificateFromPem(e)),s(e.subject),!t.hasCertificate(e))if(e.subject.hash in t.certs){var r=t.certs[e.subject.hash];n.util.isArray(r)||(r=[r]),r.push(e),t.certs[e.subject.hash]=r}else t.certs[e.subject.hash]=e},t.hasCertificate=function(e){"string"==typeof e&&(e=n.pki.certificateFromPem(e));var t=r(e.subject);if(!t)return!1;n.util.isArray(t)||(t=[t]);for(var s=i.toDer(a.certificateToAsn1(e)).getBytes(),o=0;o<t.length;++o){if(s===i.toDer(a.certificateToAsn1(t[o])).getBytes())return!0}return!1},t.listAllCertificates=function(){var e=[];for(var r in t.certs)if(t.certs.hasOwnProperty(r)){var i=t.certs[r];if(n.util.isArray(i))for(var a=0;a<i.length;++a)e.push(i[a]);else e.push(i)}return e},t.removeCertificate=function(e){var o;if("string"==typeof e&&(e=n.pki.certificateFromPem(e)),s(e.subject),!t.hasCertificate(e))return null;var u=r(e.subject);if(!n.util.isArray(u))return o=t.certs[e.subject.hash],delete t.certs[e.subject.hash],o;for(var c=i.toDer(a.certificateToAsn1(e)).getBytes(),l=0;l<u.length;++l){c===i.toDer(a.certificateToAsn1(u[l])).getBytes()&&(o=u[l],u.splice(l,1))}return 0===u.length&&delete t.certs[e.subject.hash],o},e)for(var o=0;o<e.length;++o){var u=e[o];t.addCertificate(u)}return t},a.certificateError={bad_certificate:"forge.pki.BadCertificate",unsupported_certificate:"forge.pki.UnsupportedCertificate",certificate_revoked:"forge.pki.CertificateRevoked",certificate_expired:"forge.pki.CertificateExpired",certificate_unknown:"forge.pki.CertificateUnknown",unknown_ca:"forge.pki.UnknownCertificateAuthority"},a.verifyCertificateChain=function(e,t,r){"function"==typeof r&&(r={verify:r}),r=r||{};var i=(t=t.slice(0)).slice(0),s=r.validityCheckDate;void 0===s&&(s=new Date);var o=!0,u=null,c=0;do{var l=t.shift(),f=null,h=!1;if(s&&(s<l.validity.notBefore||s>l.validity.notAfter)&&(u={message:"Certificate is not valid yet or has expired.",error:a.certificateError.certificate_expired,notBefore:l.validity.notBefore,notAfter:l.validity.notAfter,now:s}),null===u){if(null===(f=t[0]||e.getIssuer(l))&&l.isIssuer(l)&&(h=!0,f=l),f){var p=f;n.util.isArray(p)||(p=[p]);for(var d=!1;!d&&p.length>0;){f=p.shift();try{d=f.verify(l)}catch(e){}}d||(u={message:"Certificate signature is invalid.",error:a.certificateError.bad_certificate})}null!==u||f&&!h||e.hasCertificate(l)||(u={message:"Certificate is not trusted.",error:a.certificateError.unknown_ca})}if(null===u&&f&&!l.isIssuer(f)&&(u={message:"Certificate issuer is invalid.",error:a.certificateError.bad_certificate}),null===u)for(var y={keyUsage:!0,basicConstraints:!0},g=0;null===u&&g<l.extensions.length;++g){var m=l.extensions[g];!m.critical||m.name in y||(u={message:"Certificate has an unsupported critical extension.",error:a.certificateError.unsupported_certificate})}if(null===u&&(!o||0===t.length&&(!f||h))){var v=l.getExtension("basicConstraints"),b=l.getExtension("keyUsage");if(null!==b&&(b.keyCertSign&&null!==v||(u={message:"Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",error:a.certificateError.bad_certificate})),null!==u||null===v||v.cA||(u={message:"Certificate basicConstraints indicates the certificate is not a CA.",error:a.certificateError.bad_certificate}),null===u&&null!==b&&"pathLenConstraint"in v)c-1>v.pathLenConstraint&&(u={message:"Certificate basicConstraints pathLenConstraint violated.",error:a.certificateError.bad_certificate})}var E=null===u||u.error,S=r.verify?r.verify(E,c,i):E;if(!0!==S)throw!0===E&&(u={message:"The application rejected the certificate.",error:a.certificateError.bad_certificate}),(S||0===S)&&("object"!=typeof S||n.util.isArray(S)?"string"==typeof S&&(u.error=S):(S.message&&(u.message=S.message),S.error&&(u.error=S.error))),u;u=null,o=!1,++c}while(t.length>0);return!0}},function(e,t,r){var n=r(1);r(12),r(2),(e.exports=n.pss=n.pss||{}).create=function(e){3===arguments.length&&(e={md:arguments[0],mgf:arguments[1],saltLength:arguments[2]});var t,r=e.md,i=e.mgf,a=r.digestLength,s=e.salt||null;if("string"==typeof s&&(s=n.util.createBuffer(s)),"saltLength"in e)t=e.saltLength;else{if(null===s)throw new Error("Salt length not specified or specific salt not given.");t=s.length()}if(null!==s&&s.length()!==t)throw new Error("Given salt length does not match length of given salt.");var o=e.prng||n.random,u={encode:function(e,u){var c,l,f=u-1,h=Math.ceil(f/8),p=e.digest().getBytes();if(h<a+t+2)throw new Error("Message is too long to encrypt.");l=null===s?o.getBytesSync(t):s.bytes();var d=new n.util.ByteBuffer;d.fillWithByte(0,8),d.putBytes(p),d.putBytes(l),r.start(),r.update(d.getBytes());var y=r.digest().getBytes(),g=new n.util.ByteBuffer;g.fillWithByte(0,h-t-a-2),g.putByte(1),g.putBytes(l);var m=g.getBytes(),v=h-a-1,b=i.generate(y,v),E="";for(c=0;c<v;c++)E+=String.fromCharCode(m.charCodeAt(c)^b.charCodeAt(c));var S=65280>>8*h-f&255;return(E=String.fromCharCode(E.charCodeAt(0)&~S)+E.substr(1))+y+String.fromCharCode(188)},verify:function(e,s,o){var u,c=o-1,l=Math.ceil(c/8);if(s=s.substr(-l),l<a+t+2)throw new Error("Inconsistent parameters to PSS signature verification.");if(188!==s.charCodeAt(l-1))throw new Error("Encoded message does not end in 0xBC.");var f=l-a-1,h=s.substr(0,f),p=s.substr(f,a),d=65280>>8*l-c&255;if(0!=(h.charCodeAt(0)&d))throw new Error("Bits beyond keysize not zero as expected.");var y=i.generate(p,f),g="";for(u=0;u<f;u++)g+=String.fromCharCode(h.charCodeAt(u)^y.charCodeAt(u));g=String.fromCharCode(g.charCodeAt(0)&~d)+g.substr(1);var m=l-a-t-2;for(u=0;u<m;u++)if(0!==g.charCodeAt(u))throw new Error("Leftmost octets not zero as expected");if(1!==g.charCodeAt(m))throw new Error("Inconsistent PSS signature, 0x01 marker not found");var v=g.substr(-t),b=new n.util.ByteBuffer;return b.fillWithByte(0,8),b.putBytes(e),b.putBytes(v),r.start(),r.update(b.getBytes()),p===r.digest().getBytes()}};return u}},function(e,t,r){var n=r(1);r(9),r(2);var i=e.exports=n.md5=n.md5||{};n.md.md5=n.md.algorithms.md5=i,i.create=function(){c||function(){a=String.fromCharCode(128),a+=n.util.fillString(String.fromCharCode(0),64),s=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,6,11,0,5,10,15,4,9,14,3,8,13,2,7,12,5,8,11,14,1,4,7,10,13,0,3,6,9,12,15,2,0,7,14,5,12,3,10,1,8,15,6,13,4,11,2,9],o=[7,12,17,22,7,12,17,22,7,12,17,22,7,12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20,4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10,15,21,6,10,15,21,6,10,15,21,6,10,15,21],u=new Array(64);for(var e=0;e<64;++e)u[e]=Math.floor(4294967296*Math.abs(Math.sin(e+1)));c=!0}();var e=null,t=n.util.createBuffer(),r=new Array(16),i={algorithm:"md5",blockLength:64,digestLength:16,messageLength:0,fullMessageLength:null,messageLengthSize:8,start:function(){i.messageLength=0,i.fullMessageLength=i.messageLength64=[];for(var r=i.messageLengthSize/4,a=0;a<r;++a)i.fullMessageLength.push(0);return t=n.util.createBuffer(),e={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878},i}};return i.start(),i.update=function(a,s){"utf8"===s&&(a=n.util.encodeUtf8(a));var o=a.length;i.messageLength+=o,o=[o/4294967296>>>0,o>>>0];for(var u=i.fullMessageLength.length-1;u>=0;--u)i.fullMessageLength[u]+=o[1],o[1]=o[0]+(i.fullMessageLength[u]/4294967296>>>0),i.fullMessageLength[u]=i.fullMessageLength[u]>>>0,o[0]=o[1]/4294967296>>>0;return t.putBytes(a),l(e,r,t),(t.read>2048||0===t.length())&&t.compact(),i},i.digest=function(){var s=n.util.createBuffer();s.putBytes(t.bytes());var o=i.fullMessageLength[i.fullMessageLength.length-1]+i.messageLengthSize&i.blockLength-1;s.putBytes(a.substr(0,i.blockLength-o));for(var u,c=0,f=i.fullMessageLength.length-1;f>=0;--f)c=(u=8*i.fullMessageLength[f]+c)/4294967296>>>0,s.putInt32Le(u>>>0);var h={h0:e.h0,h1:e.h1,h2:e.h2,h3:e.h3};l(h,r,s);var p=n.util.createBuffer();return p.putInt32Le(h.h0),p.putInt32Le(h.h1),p.putInt32Le(h.h2),p.putInt32Le(h.h3),p},i};var a=null,s=null,o=null,u=null,c=!1;function l(e,t,r){for(var n,i,a,c,l,f,h,p=r.length();p>=64;){for(i=e.h0,a=e.h1,c=e.h2,l=e.h3,h=0;h<16;++h)t[h]=r.getInt32Le(),n=i+(l^a&(c^l))+u[h]+t[h],i=l,l=c,c=a,a+=n<<(f=o[h])|n>>>32-f;for(;h<32;++h)n=i+(c^l&(a^c))+u[h]+t[s[h]],i=l,l=c,c=a,a+=n<<(f=o[h])|n>>>32-f;for(;h<48;++h)n=i+(a^c^l)+u[h]+t[s[h]],i=l,l=c,c=a,a+=n<<(f=o[h])|n>>>32-f;for(;h<64;++h)n=i+(c^(a|~l))+u[h]+t[s[h]],i=l,l=c,c=a,a+=n<<(f=o[h])|n>>>32-f;e.h0=e.h0+i|0,e.h1=e.h1+a|0,e.h2=e.h2+c|0,e.h3=e.h3+l|0,p-=64}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",i=n.split("").reduce((e,t,r)=>(e[t]=r,e),{});t.default={encode(e){if(!e.length)return"";const t=[0];for(let r=0;r<e.length;r++){for(let e=0;e<t.length;e++)t[e]<<=8;t[0]+=e[r];let n=0;for(let e=0;e<t.length;e++)t[e]+=n,n=t[e]/58|0,t[e]%=58;for(;n;)t.push(n%58),n=n/58|0}for(let r=0;0===e[r]&&r<e.length-1;r++)t.push(0);return t.reverse().map((function(e){return n[e]})).join("")},decode(e){if(!e.length)return new Uint8Array(0);const t=[0];for(let r=0;r<e.length;r++){const n=e[r];if(!(n in i))throw new Error(`There is no character "${n}" in the Base58 sequence!`);for(let e=0;e<t.length;e++)t[e]*=58;t[0]+=i[n];let a=0;for(let e=0;e<t.length;e++)t[e]+=a,a=t[e]>>8,t[e]&=255;for(;a;)t.push(255&a),a>>=8}for(let r=0;"1"===e[r]&&r<e.length-1;r++)t.push(0);return new Uint8Array(t.reverse())}}},function(e,t,r){!function(e){"use strict";var t=/^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,r=Math.ceil,n=Math.floor,i="[BigNumber Error] ",a=i+"Number primitive has more than 15 significant digits: ",s=1e14,o=14,u=9007199254740991,c=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],l=1e7,f=1e9;function h(e){var t=0|e;return e>0||e===t?t:t-1}function p(e){for(var t,r,n=1,i=e.length,a=e[0]+"";n<i;){for(t=e[n++]+"",r=o-t.length;r--;t="0"+t);a+=t}for(i=a.length;48===a.charCodeAt(--i););return a.slice(0,i+1||1)}function d(e,t){var r,n,i=e.c,a=t.c,s=e.s,o=t.s,u=e.e,c=t.e;if(!s||!o)return null;if(r=i&&!i[0],n=a&&!a[0],r||n)return r?n?0:-o:s;if(s!=o)return s;if(r=s<0,n=u==c,!i||!a)return n?0:!i^r?1:-1;if(!n)return u>c^r?1:-1;for(o=(u=i.length)<(c=a.length)?u:c,s=0;s<o;s++)if(i[s]!=a[s])return i[s]>a[s]^r?1:-1;return u==c?0:u>c^r?1:-1}function y(e,t,r,a){if(e<t||e>r||e!==n(e))throw Error(i+(a||"Argument")+("number"==typeof e?e<t||e>r?" out of range: ":" not an integer: ":" not a primitive number: ")+String(e))}function g(e){var t=e.c.length-1;return h(e.e/o)==t&&e.c[t]%2!=0}function m(e,t){return(e.length>1?e.charAt(0)+"."+e.slice(1):e)+(t<0?"e":"e+")+t}function v(e,t,r){var n,i;if(t<0){for(i=r+".";++t;i+=r);e=i+e}else if(++t>(n=e.length)){for(i=r,t-=n;--t;i+=r);e+=i}else t<n&&(e=e.slice(0,t)+"."+e.slice(t));return e}var b=function e(b){var E,S,T,C,A,I,w,B,N,R=F.prototype={constructor:F,toString:null,valueOf:null},_=new F(1),P=20,O=4,k=-7,U=21,L=-1e7,D=1e7,V=!1,x=1,K=0,M={prefix:"",groupSize:3,secondaryGroupSize:0,groupSeparator:",",decimalSeparator:".",fractionGroupSize:0,fractionGroupSeparator:" ",suffix:""},j="0123456789abcdefghijklmnopqrstuvwxyz";function F(e,r){var i,s,c,l,f,h,p,d,g=this;if(!(g instanceof F))return new F(e,r);if(null==r){if(e&&!0===e._isBigNumber)return g.s=e.s,void(!e.c||e.e>D?g.c=g.e=null:e.e<L?g.c=[g.e=0]:(g.e=e.e,g.c=e.c.slice()));if((h="number"==typeof e)&&0*e==0){if(g.s=1/e<0?(e=-e,-1):1,e===~~e){for(l=0,f=e;f>=10;f/=10,l++);return void(l>D?g.c=g.e=null:(g.e=l,g.c=[e]))}d=String(e)}else{if(!t.test(d=String(e)))return T(g,d,h);g.s=45==d.charCodeAt(0)?(d=d.slice(1),-1):1}(l=d.indexOf("."))>-1&&(d=d.replace(".","")),(f=d.search(/e/i))>0?(l<0&&(l=f),l+=+d.slice(f+1),d=d.substring(0,f)):l<0&&(l=d.length)}else{if(y(r,2,j.length,"Base"),10==r)return H(g=new F(e),P+g.e+1,O);if(d=String(e),h="number"==typeof e){if(0*e!=0)return T(g,d,h,r);if(g.s=1/e<0?(d=d.slice(1),-1):1,F.DEBUG&&d.replace(/^0\.0*|\./,"").length>15)throw Error(a+e)}else g.s=45===d.charCodeAt(0)?(d=d.slice(1),-1):1;for(i=j.slice(0,r),l=f=0,p=d.length;f<p;f++)if(i.indexOf(s=d.charAt(f))<0){if("."==s){if(f>l){l=p;continue}}else if(!c&&(d==d.toUpperCase()&&(d=d.toLowerCase())||d==d.toLowerCase()&&(d=d.toUpperCase()))){c=!0,f=-1,l=0;continue}return T(g,String(e),h,r)}h=!1,(l=(d=S(d,r,10,g.s)).indexOf("."))>-1?d=d.replace(".",""):l=d.length}for(f=0;48===d.charCodeAt(f);f++);for(p=d.length;48===d.charCodeAt(--p););if(d=d.slice(f,++p)){if(p-=f,h&&F.DEBUG&&p>15&&(e>u||e!==n(e)))throw Error(a+g.s*e);if((l=l-f-1)>D)g.c=g.e=null;else if(l<L)g.c=[g.e=0];else{if(g.e=l,g.c=[],f=(l+1)%o,l<0&&(f+=o),f<p){for(f&&g.c.push(+d.slice(0,f)),p-=o;f<p;)g.c.push(+d.slice(f,f+=o));f=o-(d=d.slice(f)).length}else f-=p;for(;f--;d+="0");g.c.push(+d)}}else g.c=[g.e=0]}function q(e,t,r,n){var i,a,s,o,u;if(null==r?r=O:y(r,0,8),!e.c)return e.toString();if(i=e.c[0],s=e.e,null==t)u=p(e.c),u=1==n||2==n&&(s<=k||s>=U)?m(u,s):v(u,s,"0");else if(a=(e=H(new F(e),t,r)).e,o=(u=p(e.c)).length,1==n||2==n&&(t<=a||a<=k)){for(;o<t;u+="0",o++);u=m(u,a)}else if(t-=s,u=v(u,a,"0"),a+1>o){if(--t>0)for(u+=".";t--;u+="0");}else if((t+=a-o)>0)for(a+1==o&&(u+=".");t--;u+="0");return e.s<0&&i?"-"+u:u}function z(e,t){for(var r,n=1,i=new F(e[0]);n<e.length;n++){if(!(r=new F(e[n])).s){i=r;break}t.call(i,r)&&(i=r)}return i}function G(e,t,r){for(var n=1,i=t.length;!t[--i];t.pop());for(i=t[0];i>=10;i/=10,n++);return(r=n+r*o-1)>D?e.c=e.e=null:r<L?e.c=[e.e=0]:(e.e=r,e.c=t),e}function H(e,t,i,a){var u,l,f,h,p,d,y,g=e.c,m=c;if(g){e:{for(u=1,h=g[0];h>=10;h/=10,u++);if((l=t-u)<0)l+=o,f=t,y=(p=g[d=0])/m[u-f-1]%10|0;else if((d=r((l+1)/o))>=g.length){if(!a)break e;for(;g.length<=d;g.push(0));p=y=0,u=1,f=(l%=o)-o+1}else{for(p=h=g[d],u=1;h>=10;h/=10,u++);y=(f=(l%=o)-o+u)<0?0:p/m[u-f-1]%10|0}if(a=a||t<0||null!=g[d+1]||(f<0?p:p%m[u-f-1]),a=i<4?(y||a)&&(0==i||i==(e.s<0?3:2)):y>5||5==y&&(4==i||a||6==i&&(l>0?f>0?p/m[u-f]:0:g[d-1])%10&1||i==(e.s<0?8:7)),t<1||!g[0])return g.length=0,a?(t-=e.e+1,g[0]=m[(o-t%o)%o],e.e=-t||0):g[0]=e.e=0,e;if(0==l?(g.length=d,h=1,d--):(g.length=d+1,h=m[o-l],g[d]=f>0?n(p/m[u-f]%m[f])*h:0),a)for(;;){if(0==d){for(l=1,f=g[0];f>=10;f/=10,l++);for(f=g[0]+=h,h=1;f>=10;f/=10,h++);l!=h&&(e.e++,g[0]==s&&(g[0]=1));break}if(g[d]+=h,g[d]!=s)break;g[d--]=0,h=1}for(l=g.length;0===g[--l];g.pop());}e.e>D?e.c=e.e=null:e.e<L&&(e.c=[e.e=0])}return e}function Y(e){var t,r=e.e;return null===r?e.toString():(t=p(e.c),t=r<=k||r>=U?m(t,r):v(t,r,"0"),e.s<0?"-"+t:t)}return F.clone=e,F.ROUND_UP=0,F.ROUND_DOWN=1,F.ROUND_CEIL=2,F.ROUND_FLOOR=3,F.ROUND_HALF_UP=4,F.ROUND_HALF_DOWN=5,F.ROUND_HALF_EVEN=6,F.ROUND_HALF_CEIL=7,F.ROUND_HALF_FLOOR=8,F.EUCLID=9,F.config=F.set=function(e){var t,r;if(null!=e){if("object"!=typeof e)throw Error(i+"Object expected: "+e);if(e.hasOwnProperty(t="DECIMAL_PLACES")&&(y(r=e[t],0,f,t),P=r),e.hasOwnProperty(t="ROUNDING_MODE")&&(y(r=e[t],0,8,t),O=r),e.hasOwnProperty(t="EXPONENTIAL_AT")&&((r=e[t])&&r.pop?(y(r[0],-f,0,t),y(r[1],0,f,t),k=r[0],U=r[1]):(y(r,-f,f,t),k=-(U=r<0?-r:r))),e.hasOwnProperty(t="RANGE"))if((r=e[t])&&r.pop)y(r[0],-f,-1,t),y(r[1],1,f,t),L=r[0],D=r[1];else{if(y(r,-f,f,t),!r)throw Error(i+t+" cannot be zero: "+r);L=-(D=r<0?-r:r)}if(e.hasOwnProperty(t="CRYPTO")){if((r=e[t])!==!!r)throw Error(i+t+" not true or false: "+r);if(r){if("undefined"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw V=!r,Error(i+"crypto unavailable");V=r}else V=r}if(e.hasOwnProperty(t="MODULO_MODE")&&(y(r=e[t],0,9,t),x=r),e.hasOwnProperty(t="POW_PRECISION")&&(y(r=e[t],0,f,t),K=r),e.hasOwnProperty(t="FORMAT")){if("object"!=typeof(r=e[t]))throw Error(i+t+" not an object: "+r);M=r}if(e.hasOwnProperty(t="ALPHABET")){if("string"!=typeof(r=e[t])||/^.$|[+-.\s]|(.).*\1/.test(r))throw Error(i+t+" invalid: "+r);j=r}}return{DECIMAL_PLACES:P,ROUNDING_MODE:O,EXPONENTIAL_AT:[k,U],RANGE:[L,D],CRYPTO:V,MODULO_MODE:x,POW_PRECISION:K,FORMAT:M,ALPHABET:j}},F.isBigNumber=function(e){if(!e||!0!==e._isBigNumber)return!1;if(!F.DEBUG)return!0;var t,r,a=e.c,u=e.e,c=e.s;e:if("[object Array]"=={}.toString.call(a)){if((1===c||-1===c)&&u>=-f&&u<=f&&u===n(u)){if(0===a[0]){if(0===u&&1===a.length)return!0;break e}if((t=(u+1)%o)<1&&(t+=o),String(a[0]).length==t){for(t=0;t<a.length;t++)if((r=a[t])<0||r>=s||r!==n(r))break e;if(0!==r)return!0}}}else if(null===a&&null===u&&(null===c||1===c||-1===c))return!0;throw Error(i+"Invalid BigNumber: "+e)},F.maximum=F.max=function(){return z(arguments,R.lt)},F.minimum=F.min=function(){return z(arguments,R.gt)},F.random=(C=9007199254740992*Math.random()&2097151?function(){return n(9007199254740992*Math.random())}:function(){return 8388608*(1073741824*Math.random()|0)+(8388608*Math.random()|0)},function(e){var t,a,s,u,l,h=0,p=[],d=new F(_);if(null==e?e=P:y(e,0,f),u=r(e/o),V)if(crypto.getRandomValues){for(t=crypto.getRandomValues(new Uint32Array(u*=2));h<u;)(l=131072*t[h]+(t[h+1]>>>11))>=9e15?(a=crypto.getRandomValues(new Uint32Array(2)),t[h]=a[0],t[h+1]=a[1]):(p.push(l%1e14),h+=2);h=u/2}else{if(!crypto.randomBytes)throw V=!1,Error(i+"crypto unavailable");for(t=crypto.randomBytes(u*=7);h<u;)(l=281474976710656*(31&t[h])+1099511627776*t[h+1]+4294967296*t[h+2]+16777216*t[h+3]+(t[h+4]<<16)+(t[h+5]<<8)+t[h+6])>=9e15?crypto.randomBytes(7).copy(t,h):(p.push(l%1e14),h+=7);h=u/7}if(!V)for(;h<u;)(l=C())<9e15&&(p[h++]=l%1e14);for(u=p[--h],e%=o,u&&e&&(l=c[o-e],p[h]=n(u/l)*l);0===p[h];p.pop(),h--);if(h<0)p=[s=0];else{for(s=-1;0===p[0];p.splice(0,1),s-=o);for(h=1,l=p[0];l>=10;l/=10,h++);h<o&&(s-=o-h)}return d.e=s,d.c=p,d}),F.sum=function(){for(var e=1,t=arguments,r=new F(t[0]);e<t.length;)r=r.plus(t[e++]);return r},S=function(){function e(e,t,r,n){for(var i,a,s=[0],o=0,u=e.length;o<u;){for(a=s.length;a--;s[a]*=t);for(s[0]+=n.indexOf(e.charAt(o++)),i=0;i<s.length;i++)s[i]>r-1&&(null==s[i+1]&&(s[i+1]=0),s[i+1]+=s[i]/r|0,s[i]%=r)}return s.reverse()}return function(t,r,n,i,a){var s,o,u,c,l,f,h,d,y=t.indexOf("."),g=P,m=O;for(y>=0&&(c=K,K=0,t=t.replace(".",""),f=(d=new F(r)).pow(t.length-y),K=c,d.c=e(v(p(f.c),f.e,"0"),10,n,"0123456789"),d.e=d.c.length),u=c=(h=e(t,r,n,a?(s=j,"0123456789"):(s="0123456789",j))).length;0==h[--c];h.pop());if(!h[0])return s.charAt(0);if(y<0?--u:(f.c=h,f.e=u,f.s=i,h=(f=E(f,d,g,m,n)).c,l=f.r,u=f.e),y=h[o=u+g+1],c=n/2,l=l||o<0||null!=h[o+1],l=m<4?(null!=y||l)&&(0==m||m==(f.s<0?3:2)):y>c||y==c&&(4==m||l||6==m&&1&h[o-1]||m==(f.s<0?8:7)),o<1||!h[0])t=l?v(s.charAt(1),-g,s.charAt(0)):s.charAt(0);else{if(h.length=o,l)for(--n;++h[--o]>n;)h[o]=0,o||(++u,h=[1].concat(h));for(c=h.length;!h[--c];);for(y=0,t="";y<=c;t+=s.charAt(h[y++]));t=v(t,u,s.charAt(0))}return t}}(),E=function(){function e(e,t,r){var n,i,a,s,o=0,u=e.length,c=t%l,f=t/l|0;for(e=e.slice();u--;)o=((i=c*(a=e[u]%l)+(n=f*a+(s=e[u]/l|0)*c)%l*l+o)/r|0)+(n/l|0)+f*s,e[u]=i%r;return o&&(e=[o].concat(e)),e}function t(e,t,r,n){var i,a;if(r!=n)a=r>n?1:-1;else for(i=a=0;i<r;i++)if(e[i]!=t[i]){a=e[i]>t[i]?1:-1;break}return a}function r(e,t,r,n){for(var i=0;r--;)e[r]-=i,i=e[r]<t[r]?1:0,e[r]=i*n+e[r]-t[r];for(;!e[0]&&e.length>1;e.splice(0,1));}return function(i,a,u,c,l){var f,p,d,y,g,m,v,b,E,S,T,C,A,I,w,B,N,R=i.s==a.s?1:-1,_=i.c,P=a.c;if(!(_&&_[0]&&P&&P[0]))return new F(i.s&&a.s&&(_?!P||_[0]!=P[0]:P)?_&&0==_[0]||!P?0*R:R/0:NaN);for(E=(b=new F(R)).c=[],R=u+(p=i.e-a.e)+1,l||(l=s,p=h(i.e/o)-h(a.e/o),R=R/o|0),d=0;P[d]==(_[d]||0);d++);if(P[d]>(_[d]||0)&&p--,R<0)E.push(1),y=!0;else{for(I=_.length,B=P.length,d=0,R+=2,(g=n(l/(P[0]+1)))>1&&(P=e(P,g,l),_=e(_,g,l),B=P.length,I=_.length),A=B,T=(S=_.slice(0,B)).length;T<B;S[T++]=0);N=P.slice(),N=[0].concat(N),w=P[0],P[1]>=l/2&&w++;do{if(g=0,(f=t(P,S,B,T))<0){if(C=S[0],B!=T&&(C=C*l+(S[1]||0)),(g=n(C/w))>1)for(g>=l&&(g=l-1),v=(m=e(P,g,l)).length,T=S.length;1==t(m,S,v,T);)g--,r(m,B<v?N:P,v,l),v=m.length,f=1;else 0==g&&(f=g=1),v=(m=P.slice()).length;if(v<T&&(m=[0].concat(m)),r(S,m,T,l),T=S.length,-1==f)for(;t(P,S,B,T)<1;)g++,r(S,B<T?N:P,T,l),T=S.length}else 0===f&&(g++,S=[0]);E[d++]=g,S[0]?S[T++]=_[A]||0:(S=[_[A]],T=1)}while((A++<I||null!=S[0])&&R--);y=null!=S[0],E[0]||E.splice(0,1)}if(l==s){for(d=1,R=E[0];R>=10;R/=10,d++);H(b,u+(b.e=d+p*o-1)+1,c,y)}else b.e=p,b.r=+y;return b}}(),A=/^(-?)0([xbo])(?=\w[\w.]*$)/i,I=/^([^.]+)\.$/,w=/^\.([^.]+)$/,B=/^-?(Infinity|NaN)$/,N=/^\s*\+(?=[\w.])|^\s+|\s+$/g,T=function(e,t,r,n){var a,s=r?t:t.replace(N,"");if(B.test(s))e.s=isNaN(s)?null:s<0?-1:1;else{if(!r&&(s=s.replace(A,(function(e,t,r){return a="x"==(r=r.toLowerCase())?16:"b"==r?2:8,n&&n!=a?e:t})),n&&(a=n,s=s.replace(I,"$1").replace(w,"0.$1")),t!=s))return new F(s,a);if(F.DEBUG)throw Error(i+"Not a"+(n?" base "+n:"")+" number: "+t);e.s=null}e.c=e.e=null},R.absoluteValue=R.abs=function(){var e=new F(this);return e.s<0&&(e.s=1),e},R.comparedTo=function(e,t){return d(this,new F(e,t))},R.decimalPlaces=R.dp=function(e,t){var r,n,i,a=this;if(null!=e)return y(e,0,f),null==t?t=O:y(t,0,8),H(new F(a),e+a.e+1,t);if(!(r=a.c))return null;if(n=((i=r.length-1)-h(this.e/o))*o,i=r[i])for(;i%10==0;i/=10,n--);return n<0&&(n=0),n},R.dividedBy=R.div=function(e,t){return E(this,new F(e,t),P,O)},R.dividedToIntegerBy=R.idiv=function(e,t){return E(this,new F(e,t),0,1)},R.exponentiatedBy=R.pow=function(e,t){var a,s,u,c,l,f,h,p,d=this;if((e=new F(e)).c&&!e.isInteger())throw Error(i+"Exponent not an integer: "+Y(e));if(null!=t&&(t=new F(t)),l=e.e>14,!d.c||!d.c[0]||1==d.c[0]&&!d.e&&1==d.c.length||!e.c||!e.c[0])return p=new F(Math.pow(+Y(d),l?2-g(e):+Y(e))),t?p.mod(t):p;if(f=e.s<0,t){if(t.c?!t.c[0]:!t.s)return new F(NaN);(s=!f&&d.isInteger()&&t.isInteger())&&(d=d.mod(t))}else{if(e.e>9&&(d.e>0||d.e<-1||(0==d.e?d.c[0]>1||l&&d.c[1]>=24e7:d.c[0]<8e13||l&&d.c[0]<=9999975e7)))return c=d.s<0&&g(e)?-0:0,d.e>-1&&(c=1/c),new F(f?1/c:c);K&&(c=r(K/o+2))}for(l?(a=new F(.5),f&&(e.s=1),h=g(e)):h=(u=Math.abs(+Y(e)))%2,p=new F(_);;){if(h){if(!(p=p.times(d)).c)break;c?p.c.length>c&&(p.c.length=c):s&&(p=p.mod(t))}if(u){if(0===(u=n(u/2)))break;h=u%2}else if(H(e=e.times(a),e.e+1,1),e.e>14)h=g(e);else{if(0==(u=+Y(e)))break;h=u%2}d=d.times(d),c?d.c&&d.c.length>c&&(d.c.length=c):s&&(d=d.mod(t))}return s?p:(f&&(p=_.div(p)),t?p.mod(t):c?H(p,K,O,void 0):p)},R.integerValue=function(e){var t=new F(this);return null==e?e=O:y(e,0,8),H(t,t.e+1,e)},R.isEqualTo=R.eq=function(e,t){return 0===d(this,new F(e,t))},R.isFinite=function(){return!!this.c},R.isGreaterThan=R.gt=function(e,t){return d(this,new F(e,t))>0},R.isGreaterThanOrEqualTo=R.gte=function(e,t){return 1===(t=d(this,new F(e,t)))||0===t},R.isInteger=function(){return!!this.c&&h(this.e/o)>this.c.length-2},R.isLessThan=R.lt=function(e,t){return d(this,new F(e,t))<0},R.isLessThanOrEqualTo=R.lte=function(e,t){return-1===(t=d(this,new F(e,t)))||0===t},R.isNaN=function(){return!this.s},R.isNegative=function(){return this.s<0},R.isPositive=function(){return this.s>0},R.isZero=function(){return!!this.c&&0==this.c[0]},R.minus=function(e,t){var r,n,i,a,u=this,c=u.s;if(t=(e=new F(e,t)).s,!c||!t)return new F(NaN);if(c!=t)return e.s=-t,u.plus(e);var l=u.e/o,f=e.e/o,p=u.c,d=e.c;if(!l||!f){if(!p||!d)return p?(e.s=-t,e):new F(d?u:NaN);if(!p[0]||!d[0])return d[0]?(e.s=-t,e):new F(p[0]?u:3==O?-0:0)}if(l=h(l),f=h(f),p=p.slice(),c=l-f){for((a=c<0)?(c=-c,i=p):(f=l,i=d),i.reverse(),t=c;t--;i.push(0));i.reverse()}else for(n=(a=(c=p.length)<(t=d.length))?c:t,c=t=0;t<n;t++)if(p[t]!=d[t]){a=p[t]<d[t];break}if(a&&(i=p,p=d,d=i,e.s=-e.s),(t=(n=d.length)-(r=p.length))>0)for(;t--;p[r++]=0);for(t=s-1;n>c;){if(p[--n]<d[n]){for(r=n;r&&!p[--r];p[r]=t);--p[r],p[n]+=s}p[n]-=d[n]}for(;0==p[0];p.splice(0,1),--f);return p[0]?G(e,p,f):(e.s=3==O?-1:1,e.c=[e.e=0],e)},R.modulo=R.mod=function(e,t){var r,n,i=this;return e=new F(e,t),!i.c||!e.s||e.c&&!e.c[0]?new F(NaN):!e.c||i.c&&!i.c[0]?new F(i):(9==x?(n=e.s,e.s=1,r=E(i,e,0,3),e.s=n,r.s*=n):r=E(i,e,0,x),(e=i.minus(r.times(e))).c[0]||1!=x||(e.s=i.s),e)},R.multipliedBy=R.times=function(e,t){var r,n,i,a,u,c,f,p,d,y,g,m,v,b,E,S=this,T=S.c,C=(e=new F(e,t)).c;if(!(T&&C&&T[0]&&C[0]))return!S.s||!e.s||T&&!T[0]&&!C||C&&!C[0]&&!T?e.c=e.e=e.s=null:(e.s*=S.s,T&&C?(e.c=[0],e.e=0):e.c=e.e=null),e;for(n=h(S.e/o)+h(e.e/o),e.s*=S.s,(f=T.length)<(y=C.length)&&(v=T,T=C,C=v,i=f,f=y,y=i),i=f+y,v=[];i--;v.push(0));for(b=s,E=l,i=y;--i>=0;){for(r=0,g=C[i]%E,m=C[i]/E|0,a=i+(u=f);a>i;)r=((p=g*(p=T[--u]%E)+(c=m*p+(d=T[u]/E|0)*g)%E*E+v[a]+r)/b|0)+(c/E|0)+m*d,v[a--]=p%b;v[a]=r}return r?++n:v.splice(0,1),G(e,v,n)},R.negated=function(){var e=new F(this);return e.s=-e.s||null,e},R.plus=function(e,t){var r,n=this,i=n.s;if(t=(e=new F(e,t)).s,!i||!t)return new F(NaN);if(i!=t)return e.s=-t,n.minus(e);var a=n.e/o,u=e.e/o,c=n.c,l=e.c;if(!a||!u){if(!c||!l)return new F(i/0);if(!c[0]||!l[0])return l[0]?e:new F(c[0]?n:0*i)}if(a=h(a),u=h(u),c=c.slice(),i=a-u){for(i>0?(u=a,r=l):(i=-i,r=c),r.reverse();i--;r.push(0));r.reverse()}for((i=c.length)-(t=l.length)<0&&(r=l,l=c,c=r,t=i),i=0;t;)i=(c[--t]=c[t]+l[t]+i)/s|0,c[t]=s===c[t]?0:c[t]%s;return i&&(c=[i].concat(c),++u),G(e,c,u)},R.precision=R.sd=function(e,t){var r,n,i,a=this;if(null!=e&&e!==!!e)return y(e,1,f),null==t?t=O:y(t,0,8),H(new F(a),e,t);if(!(r=a.c))return null;if(n=(i=r.length-1)*o+1,i=r[i]){for(;i%10==0;i/=10,n--);for(i=r[0];i>=10;i/=10,n++);}return e&&a.e+1>n&&(n=a.e+1),n},R.shiftedBy=function(e){return y(e,-u,u),this.times("1e"+e)},R.squareRoot=R.sqrt=function(){var e,t,r,n,i,a=this,s=a.c,o=a.s,u=a.e,c=P+4,l=new F("0.5");if(1!==o||!s||!s[0])return new F(!o||o<0&&(!s||s[0])?NaN:s?a:1/0);if(0==(o=Math.sqrt(+Y(a)))||o==1/0?(((t=p(s)).length+u)%2==0&&(t+="0"),o=Math.sqrt(+t),u=h((u+1)/2)-(u<0||u%2),r=new F(t=o==1/0?"1e"+u:(t=o.toExponential()).slice(0,t.indexOf("e")+1)+u)):r=new F(o+""),r.c[0])for((o=(u=r.e)+c)<3&&(o=0);;)if(i=r,r=l.times(i.plus(E(a,i,c,1))),p(i.c).slice(0,o)===(t=p(r.c)).slice(0,o)){if(r.e<u&&--o,"9999"!=(t=t.slice(o-3,o+1))&&(n||"4999"!=t)){+t&&(+t.slice(1)||"5"!=t.charAt(0))||(H(r,r.e+P+2,1),e=!r.times(r).eq(a));break}if(!n&&(H(i,i.e+P+2,0),i.times(i).eq(a))){r=i;break}c+=4,o+=4,n=1}return H(r,r.e+P+1,O,e)},R.toExponential=function(e,t){return null!=e&&(y(e,0,f),e++),q(this,e,t,1)},R.toFixed=function(e,t){return null!=e&&(y(e,0,f),e=e+this.e+1),q(this,e,t)},R.toFormat=function(e,t,r){var n,a=this;if(null==r)null!=e&&t&&"object"==typeof t?(r=t,t=null):e&&"object"==typeof e?(r=e,e=t=null):r=M;else if("object"!=typeof r)throw Error(i+"Argument not an object: "+r);if(n=a.toFixed(e,t),a.c){var s,o=n.split("."),u=+r.groupSize,c=+r.secondaryGroupSize,l=r.groupSeparator||"",f=o[0],h=o[1],p=a.s<0,d=p?f.slice(1):f,y=d.length;if(c&&(s=u,u=c,c=s,y-=s),u>0&&y>0){for(s=y%u||u,f=d.substr(0,s);s<y;s+=u)f+=l+d.substr(s,u);c>0&&(f+=l+d.slice(s)),p&&(f="-"+f)}n=h?f+(r.decimalSeparator||"")+((c=+r.fractionGroupSize)?h.replace(new RegExp("\\d{"+c+"}\\B","g"),"$&"+(r.fractionGroupSeparator||"")):h):f}return(r.prefix||"")+n+(r.suffix||"")},R.toFraction=function(e){var t,r,n,a,s,u,l,f,h,d,y,g,m=this,v=m.c;if(null!=e&&(!(l=new F(e)).isInteger()&&(l.c||1!==l.s)||l.lt(_)))throw Error(i+"Argument "+(l.isInteger()?"out of range: ":"not an integer: ")+Y(l));if(!v)return new F(m);for(t=new F(_),h=r=new F(_),n=f=new F(_),g=p(v),s=t.e=g.length-m.e-1,t.c[0]=c[(u=s%o)<0?o+u:u],e=!e||l.comparedTo(t)>0?s>0?t:h:l,u=D,D=1/0,l=new F(g),f.c[0]=0;d=E(l,t,0,1),1!=(a=r.plus(d.times(n))).comparedTo(e);)r=n,n=a,h=f.plus(d.times(a=h)),f=a,t=l.minus(d.times(a=t)),l=a;return a=E(e.minus(r),n,0,1),f=f.plus(a.times(h)),r=r.plus(a.times(n)),f.s=h.s=m.s,y=E(h,n,s*=2,O).minus(m).abs().comparedTo(E(f,r,s,O).minus(m).abs())<1?[h,n]:[f,r],D=u,y},R.toNumber=function(){return+Y(this)},R.toPrecision=function(e,t){return null!=e&&y(e,1,f),q(this,e,t,2)},R.toString=function(e){var t,r=this,n=r.s,i=r.e;return null===i?n?(t="Infinity",n<0&&(t="-"+t)):t="NaN":(null==e?t=i<=k||i>=U?m(p(r.c),i):v(p(r.c),i,"0"):10===e?t=v(p((r=H(new F(r),P+i+1,O)).c),r.e,"0"):(y(e,2,j.length,"Base"),t=S(v(p(r.c),i,"0"),10,e,n,!0)),n<0&&r.c[0]&&(t="-"+t)),t},R.valueOf=R.toJSON=function(){return Y(this)},R._isBigNumber=!0,R[Symbol.toStringTag]="BigNumber",R[Symbol.for("nodejs.util.inspect.custom")]=R.valueOf,null!=b&&F.set(b),F}(),E=function(){return(E=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var i in t=arguments[r])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)},S=function(){function e(){this.format=e.DEFAULT_FORMAT,b.config({FORMAT:this.format})}return e.prototype.set=function(e){"FORMAT"in e&&(this.format=E({},this.format,e.FORMAT),e.FORMAT=this.format),b.config(e)},e.DEFAULT_FORMAT={prefix:"",decimalSeparator:".",groupSeparator:",",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:" ",fractionGroupSize:0,suffix:""},e}();e.BigNumber=function(){function e(t){"object"==typeof t&&e.isBigNumber(t)?this.bn=t.bn.plus(0):this.bn=e.toBigNumberJs(t)}return e.prototype.clone=function(){return new e(this)},e.prototype.add=function(t){return new e(this.bn.plus(e.toBigNumberJs(t)))},e.prototype.sub=function(t){return new e(this.bn.minus(e.toBigNumberJs(t)))},e.prototype.mul=function(t){return new e(this.bn.times(e.toBigNumberJs(t)))},e.prototype.div=function(t){return new e(this.bn.div(e.toBigNumberJs(t)))},e.prototype.pow=function(t){return new e(this.bn.pow(e.toBigNumberJs(t)))},e.prototype.abs=function(){return new e(this.bn.abs())},e.prototype.mod=function(t){return new e(this.bn.mod(e.toBigNumberJs(t)))},e.prototype.roundTo=function(t,r){return void 0===t&&(t=0),void 0===r&&(r=4),new e(this.bn.dp(t||0,r))},e.prototype.eq=function(t){return this.bn.eq(e.toBigNumberJs(t))},e.prototype.lt=function(t){return this.bn.lt(e.toBigNumberJs(t))},e.prototype.gt=function(t){return this.bn.gt(e.toBigNumberJs(t))},e.prototype.lte=function(t){return this.bn.lte(e.toBigNumberJs(t))},e.prototype.gte=function(t){return this.bn.gte(e.toBigNumberJs(t))},e.prototype.isNaN=function(){return this.bn.isNaN()},e.prototype.isFinite=function(){return this.bn.isFinite()},e.prototype.isZero=function(){return this.eq(0)},e.prototype.isPositive=function(){return this.gt(0)},e.prototype.isNegative=function(){return this.lt(0)},e.prototype.isInt=function(){return this.bn.isInteger()},e.prototype.getDecimalsCount=function(){return this.bn.dp()},e.prototype.isEven=function(){return this.mod(2).eq(0)},e.prototype.isOdd=function(){return!this.isEven()},e.prototype.toBytes=function(){if(!this.isInt())throw new Error("Cant create bytes from number with decimals!");var t=this.isNegative(),r=t?"1":"0",n=e._toLength(64,this.bn.plus(r).abs().toString(2).replace("-","")).split(""),i=[];do{i.push(parseInt(n.splice(0,8).join(""),2))}while(n.length);return t?Uint8Array.from(i.map((function(e){return 255-e}))):Uint8Array.from(i)},e.prototype.toFormat=function(e,t,r){return this.bn.toFormat(e,t,r)},e.prototype.toFixed=function(e,t){return null==e?this.bn.toFixed():this.bn.toFixed(e,t)},e.prototype.toString=function(){return this.toFixed()},e.prototype.toNumber=function(){return this.bn.toNumber()},e.prototype.toJSON=function(){return this.bn.toFixed()},e.prototype.valueOf=function(){return this.bn.valueOf()},e.fromBytes=function(t){if(8!==t.length)throw new Error("Wrong bytes length! Need 8 bytes!");var r=t[0]>127,n=Array.from(t).map((function(e){return r?255-e:e})).map((function(t){return e._toLength(8,t.toString(2))})).join(""),i=new e(new b(n,2));return r?i.mul(-1).sub(1):i},e.max=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return e.toBigNumber(t).reduce((function(e,t){return e.gte(t)?e:t}))},e.min=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return e.toBigNumber(t).reduce((function(e,t){return e.lte(t)?e:t}))},e.sum=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return e.toBigNumber(t).reduce((function(e,t){return e.add(t)}))},e.isBigNumber=function(t){return t&&"object"==typeof t&&(t instanceof e||Object.entries(e.prototype).filter((function(e){return"_"!==e[0].charAt(0)})).every((function(e){var r=e[0],n=e[1];return r in t&&typeof n==typeof t[r]})))},e.toBigNumber=function(t){return Array.isArray(t)?t.map((function(t){return new e(t)})):new e(t)},e.toBigNumberJs=function(t){return b.isBigNumber(t)?t:t instanceof e?t.bn:new b(t)},e._toLength=function(e,t){return new Array(e).fill("0",0,e).concat(t.split("")).slice(-e).join("")},e.MAX_VALUE=new e("9223372036854775807"),e.MIN_VALUE=new e("-9223372036854775808"),e.MAX_UNSIGNED_VALUE=new e("18446744073709551615"),e.config=new S,e}(),function(e){!function(e){e[e.ROUND_UP=0]="ROUND_UP",e[e.ROUND_DOWN=1]="ROUND_DOWN",e[e.ROUND_CEIL=2]="ROUND_CEIL",e[e.ROUND_FLOOR=3]="ROUND_FLOOR",e[e.ROUND_HALF_UP=4]="ROUND_HALF_UP",e[e.ROUND_HALF_DOWN=5]="ROUND_HALF_DOWN",e[e.ROUND_HALF_EVEN=6]="ROUND_HALF_EVEN",e[e.ROUND_HALF_CEIL=7]="ROUND_HALF_CEIL",e[e.ROUND_HALF_FLOOR=8]="ROUND_HALF_FLOOR"}(e.ROUND_MODE||(e.ROUND_MODE={}))}(e.BigNumber||(e.BigNumber={}));var T=e.BigNumber;e.default=T,Object.defineProperty(e,"__esModule",{value:!0})}(t)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(26),i=r(36),a=r(21);t.serializerFromSchema=(e,r)=>a=>{let s,o;if("array"===e.type)return s=t.serializerFromSchema(e.items,r),o=i.concat(...a.map(e=>s(e))),i.concat((e.toBytes||n.SHORT)(a.length),o);if("object"===e.type){let n=Uint8Array.from([]);if(e.optional&&null==a)return Uint8Array.from([0]);if(e.schema.forEach(e=>{const[u,c]=e;let l;l=Array.isArray(u)?u.reduce((e,t)=>Object.assign({},e,{[t]:a[t]}),{}):a[u],s=t.serializerFromSchema(c,r),o=s(l),n=i.concat(n,o)}),e.withLength){const t=e.withLength.toBytes(n.length);n=i.concat(t,n)}return e.optional&&(n=i.concat([1],n)),n}if("anyOf"===e.type){const u=a[e.discriminatorField],c=e.itemByKey(u);if(null==c)throw new Error(`Serializer Error: Unknown anyOf type: ${u}`);return"boolean"===c.strKey&&6===c.key&&!1===a.value&&(c.key=7),s=t.serializerFromSchema(c.schema,r),null==e.valueField?s(a):(o=s(a[e.valueField]),i.concat((e.toBytes||n.BYTE)(c.key),o))}if("primitive"===e.type||void 0===e.type)return e.toBytes(a);if("dataTxField"===e.type){const u=n.LEN(n.SHORT)(n.STRING)(a.key),c=a.type,l=e.items.get(c);if(null==l)throw new Error(`Serializer Error: Unknown dataTxField type: ${c}`);const f=[...e.items.values()].findIndex(e=>e===l);return s=t.serializerFromSchema(l,r),o=s(a.value),i.concat(u,n.BYTE(f),o)}throw new Error(`Serializer Error: Unknown schema type: ${e.type}`)},t.serializeTx=function(e,r){const{type:n,version:i}=e,s=a.getTransactionSchema(n,i);return t.serializerFromSchema(s,r)(e)},t.serializeOrder=function(e,r){const n=e.version||1,i=a.orderVersionMap[n];if(null==i)throw new Error(`Unknown order version: ${n}`);return t.serializerFromSchema(i,r)(e)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),i={orderType:n.orEq(["sell","buy"]),senderPublicKey:n.isPublicKey,matcherPublicKey:n.isPublicKey,version:n.orEq([void 0,0,1,2,3]),assetPair:n.validatePipe(n.isRequired(!0),n.pipe(n.prop("amountAsset"),n.isAssetId),n.pipe(n.prop("priceAsset"),n.isAssetId)),price:n.isNumberLike,amount:n.isNumberLike,matcherFee:n.isNumberLike,expiration:n.isNumberLike,timestamp:n.isNumber,proofs:n.ifElse(n.isArray,n.defaultValue(!0),n.orEq([void 0]))},a={matcherFeeAssetId:n.orEq([void 0,null,"WAVES"])},s={matcherFeeAssetId:n.isAssetId},o=n.validateByShema(i,n.getError),u=n.validateByShema(a,n.getError),c=n.validateByShema(s,n.getError);t.orderValidator=n.validatePipe(o,n.ifElse(n.pipe(n.prop("version"),n.isEq(3)),c,u))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=r(3),a=r(3),s=r(5);function o(e){if(1===e.version)return n.concat([255,255,255,1],i.serializePrimitives.BASE64_STRING(e.binary));if(2===e.version){const t=a.binary.serializerFromSchema(i.schemas.txFields.data[1]);return n.concat([255,255,255,2],t(e.data))}throw new Error(`Invalid CustomData version: ${e.version}`)}t.customData=function(e,t){s.validate.customData(e);let r=o(e);const i=n.base58Encode(n.blake2b(r)),a=e.publicKey?e.publicKey:t&&n.publicKey(t),u=t&&n.signBytes(t,r);return Object.assign({},e,{hash:i,publicKey:a,signature:u})},t.serializeCustomData=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=r(3),{STRING:a,LEN:s,SHORT:o}=i.serializePrimitives,u=r(7),c=r(5);t.serializeAuthData=e=>n.concat(s(o)(a)("WavesWalletAuthentication"),s(o)(a)(e.host||""),s(o)(a)(e.data||"")),t.auth=function(e,r,i){const a=u.convertToPairs(r),s=e.publicKey||u.getSenderPublicKey(a,{senderPublicKey:void 0});c.validate.auth(e);const o={hash:"",signature:"",host:e.host,data:e.data,publicKey:s,address:n.address({publicKey:s},i)},l=t.serializeAuthData(o);return o.signature=null!=r&&n.signBytes(r,l)||"",o.hash=n.base58Encode(n.blake2b(Uint8Array.from(l))),o}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=r(3),{LONG:a,BASE58_STRING:s}=i.serializePrimitives,o=r(7),u=r(5);t.serializeWavesAuthData=e=>n.concat(s(e.publicKey),a(e.timestamp)),t.wavesAuth=function(e,r,i){const a=o.convertToPairs(r),s=e.publicKey||o.getSenderPublicKey(a,{senderPublicKey:void 0}),c=e.timestamp||Date.now();u.validate.wavesAuth({publicKey:s,timestamp:c});const l={hash:"",signature:"",timestamp:c,publicKey:s,address:n.address({publicKey:s},i)},f=t.serializeWavesAuthData(l);return l.signature=a.map(([e])=>n.signBytes(e,f))[0]||"",l.hash=n.base58Encode(n.blake2b(Uint8Array.from(f))),l}},function(e,t,r){e.exports=r(137)},function(e,t,r){"use strict";e.exports=function(e,t){return function(){for(var r=new Array(arguments.length),n=0;n<r.length;n++)r[n]=arguments[n];return e.apply(t,r)}}},function(e,t,r){"use strict";var n=r(8);function i(e){return encodeURIComponent(e).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}e.exports=function(e,t,r){if(!t)return e;var a;if(r)a=r(t);else if(n.isURLSearchParams(t))a=t.toString();else{var s=[];n.forEach(t,(function(e,t){null!=e&&(n.isArray(e)?t+="[]":e=[e],n.forEach(e,(function(e){n.isDate(e)?e=e.toISOString():n.isObject(e)&&(e=JSON.stringify(e)),s.push(i(t)+"="+i(e))})))})),a=s.join("&")}if(a){var o=e.indexOf("#");-1!==o&&(e=e.slice(0,o)),e+=(-1===e.indexOf("?")?"?":"&")+a}return e}},function(e,t,r){"use strict";e.exports=function(e){return!(!e||!e.__CANCEL__)}},function(e,t,r){"use strict";(function(t){var n=r(8),i=r(143),a={"Content-Type":"application/x-www-form-urlencoded"};function s(e,t){!n.isUndefined(e)&&n.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t)}var o,u={adapter:(void 0!==t&&"[object process]"===Object.prototype.toString.call(t)?o=r(77):"undefined"!=typeof XMLHttpRequest&&(o=r(77)),o),transformRequest:[function(e,t){return i(t,"Accept"),i(t,"Content-Type"),n.isFormData(e)||n.isArrayBuffer(e)||n.isBuffer(e)||n.isStream(e)||n.isFile(e)||n.isBlob(e)?e:n.isArrayBufferView(e)?e.buffer:n.isURLSearchParams(e)?(s(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString()):n.isObject(e)?(s(t,"application/json;charset=utf-8"),JSON.stringify(e)):e}],transformResponse:[function(e){if("string"==typeof e)try{e=JSON.parse(e)}catch(e){}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(e){return e>=200&&e<300}};u.headers={common:{Accept:"application/json, text/plain, */*"}},n.forEach(["delete","get","head"],(function(e){u.headers[e]={}})),n.forEach(["post","put","patch"],(function(e){u.headers[e]=n.merge(a)})),e.exports=u}).call(this,r(18))},function(e,t,r){"use strict";var n=r(8),i=r(144),a=r(74),s=r(146),o=r(147),u=r(78);e.exports=function(e){return new Promise((function(t,c){var l=e.data,f=e.headers;n.isFormData(l)&&delete f["Content-Type"];var h=new XMLHttpRequest;if(e.auth){var p=e.auth.username||"",d=e.auth.password||"";f.Authorization="Basic "+btoa(p+":"+d)}if(h.open(e.method.toUpperCase(),a(e.url,e.params,e.paramsSerializer),!0),h.timeout=e.timeout,h.onreadystatechange=function(){if(h&&4===h.readyState&&(0!==h.status||h.responseURL&&0===h.responseURL.indexOf("file:"))){var r="getAllResponseHeaders"in h?s(h.getAllResponseHeaders()):null,n={data:e.responseType&&"text"!==e.responseType?h.response:h.responseText,status:h.status,statusText:h.statusText,headers:r,config:e,request:h};i(t,c,n),h=null}},h.onabort=function(){h&&(c(u("Request aborted",e,"ECONNABORTED",h)),h=null)},h.onerror=function(){c(u("Network Error",e,null,h)),h=null},h.ontimeout=function(){c(u("timeout of "+e.timeout+"ms exceeded",e,"ECONNABORTED",h)),h=null},n.isStandardBrowserEnv()){var y=r(148),g=(e.withCredentials||o(e.url))&&e.xsrfCookieName?y.read(e.xsrfCookieName):void 0;g&&(f[e.xsrfHeaderName]=g)}if("setRequestHeader"in h&&n.forEach(f,(function(e,t){void 0===l&&"content-type"===t.toLowerCase()?delete f[t]:h.setRequestHeader(t,e)})),e.withCredentials&&(h.withCredentials=!0),e.responseType)try{h.responseType=e.responseType}catch(t){if("json"!==e.responseType)throw t}"function"==typeof e.onDownloadProgress&&h.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&h.upload&&h.upload.addEventListener("progress",e.onUploadProgress),e.cancelToken&&e.cancelToken.promise.then((function(e){h&&(h.abort(),c(e),h=null)})),void 0===l&&(l=null),h.send(l)}))}},function(e,t,r){"use strict";var n=r(145);e.exports=function(e,t,r,i,a){var s=new Error(e);return n(s,t,r,i,a)}},function(e,t,r){"use strict";var n=r(8);e.exports=function(e,t){t=t||{};var r={};return n.forEach(["url","method","params","data"],(function(e){void 0!==t[e]&&(r[e]=t[e])})),n.forEach(["headers","auth","proxy"],(function(i){n.isObject(t[i])?r[i]=n.deepMerge(e[i],t[i]):void 0!==t[i]?r[i]=t[i]:n.isObject(e[i])?r[i]=n.deepMerge(e[i]):void 0!==e[i]&&(r[i]=e[i])})),n.forEach(["baseURL","transformRequest","transformResponse","paramsSerializer","timeout","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","maxContentLength","validateStatus","maxRedirects","httpAgent","httpsAgent","cancelToken","socketPath"],(function(n){void 0!==t[n]?r[n]=t[n]:void 0!==e[n]&&(r[n]=e[n])})),r}},function(e,t,r){"use strict";function n(e){this.message=e}n.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},n.prototype.__CANCEL__=!0,e.exports=n},function(e,t,r){"use strict";var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(i,a){function s(e){try{u(n.next(e))}catch(e){a(e)}}function o(e){try{u(n.throw(e))}catch(e){a(e)}}function u(e){e.done?i(e.value):new r((function(t){t(e.value)})).then(s,o)}u((n=n.apply(e,t||[])).next())}))},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=i(r(72)),s=r(3),o=e=>{const t={},r=new Promise((r,n)=>{t.resolve=r,t.id=setTimeout(()=>r(),e)});return r.cancel=()=>{t.resolve(),clearTimeout(t.id)},r},u=(e,t,r=1e3)=>o(r).then(r=>t?Promise.reject(new Error("Tx wait stopped: timeout")):e()),c={timeout:12e4,apiBase:"https://nodes.wavesplatform.com"};function l(e,r){return n(this,void 0,void 0,(function*(){const{timeout:n,apiBase:i}=Object.assign({},c,r);let a=!1;const s=o(n);s.then(()=>a=!0);const l=()=>t.currentHeight(i).then(t=>t>=e?(s.cancel(),t):u(l,a,1e4)).catch(e=>u(l,a));return l()}))}function f(e,t){return n(this,void 0,void 0,(function*(){const{timeout:r,apiBase:n}=Object.assign({},c,t);let i=!1;const s=o(r);s.then(()=>i=!0);const u=()=>a.default.get(`transactions/info/${e}`,{baseURL:n}).then(e=>(s.cancel(),e.data)).catch(e=>o(1e3).then(e=>i?Promise.reject(new Error("Tx wait stopped: timeout")):u()));return u()}))}t.currentHeight=e=>n(this,void 0,void 0,(function*(){return yield a.default.get("/blocks/height",{baseURL:e}).then(e=>e.data&&e.data.height)})),t.waitForHeight=l,t.waitForTx=f;const h=e=>400===e.status?Promise.reject(Object.assign(new Error,e.data)):e,p=e=>400===e||e>=200&&e<300;t.waitForTxWithNConfirmations=function(e,t,r){return n(this,void 0,void 0,(function*(){const{timeout:n}=Object.assign({},c,r);let i=!1;o(n).then(()=>i=!0);let a=yield f(e,r),s=a.height,u=a.height;for(;s+t>u;){if(i)throw new Error("Tx wait stopped: timeout");yield l(s+t,r),a=yield f(e,r),s=a.height}return a}))},t.waitNBlocks=function(e,r=c){return n(this,void 0,void 0,(function*(){const{apiBase:n}=Object.assign({},c,r),i=(yield t.currentHeight(n))+e;return yield l(i,r)}))},t.transactionById=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`transactions/info/${e}`,{baseURL:t,validateStatus:e=>404===e||p(e)}).then(e=>311===e.data.error?null:e.data)}))},t.balance=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`addresses/balance/${e}`,{baseURL:t,validateStatus:p}).then(h).then(e=>e.data.balance)}))},t.balanceDetails=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`addresses/balance/details/${e}`,{baseURL:t,validateStatus:p}).then(h).then(e=>e.data)}))},t.assetBalance=function(e,t,r){return n(this,void 0,void 0,(function*(){return a.default.get(`assets/balance/${t}/${e}`,{baseURL:r,validateStatus:p}).then(h).then(e=>e.data.balance)}))},t.accountData=function(e,t){return n(this,void 0,void 0,(function*(){let r,n;"string"==typeof e?(r=e,n=void 0):(r=e.address,n=e.match&&encodeURIComponent("string"==typeof e.match?e.match:e.match.source));const i=`addresses/data/${r}`,s={baseURL:t,params:{matches:n},validateStatus:p};return(yield a.default.get(i,s).then(h).then(e=>e.data)).reduce((e,t)=>Object.assign({},e,{[t.key]:t}),{})}))},t.accountDataByKey=function(e,t,r){return n(this,void 0,void 0,(function*(){return a.default.get(`addresses/data/${t}/${e}`,{baseURL:r,validateStatus:e=>404===e||p(e)}).then(h).then(e=>404===e.status?null:e.data)}))},t.scriptInfo=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`addresses/scriptInfo/${e}`,{baseURL:t,validateStatus:e=>p(e)}).then(h).then(e=>e.data)}))},t.scriptMeta=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`addresses/scriptInfo/${e}/meta`,{baseURL:t,validateStatus:e=>p(e)}).then(h).then(e=>e.data)}))},t.rewards=function(...e){return n(this,void 0,void 0,(function*(){let t,r="blockchain/rewards/";return void 0!==e[1]?(r+=e[0].toString(),t=e[1]):t=e[0],a.default.get(r,{baseURL:t,validateStatus:e=>p(e)}).then(h).then(e=>e.data)}))},t.stateChanges=function(e,t){return n(this,void 0,void 0,(function*(){return a.default.get(`debug/stateChanges/info/${e}`,{baseURL:t,validateStatus:e=>p(e)}).then(h).then(e=>e.data&&e.data.stateChanges)}))},t.broadcast=function(e,t){return a.default.post("transactions/broadcast",s.json.stringifyTx(e),{baseURL:t,headers:{"content-type":"application/json"},validateStatus:p}).then(h).then(e=>e.data)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(83);t.ProviderSeed=n.ProviderSeed,t.default=n.ProviderSeed},function(e,t,r){"use strict";var n=this&&this.__assign||function(){return(n=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var i in t=arguments[r])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};Object.defineProperty(t,"__esModule",{value:!0});var i=r(84),a=function(){function e(e){this._options={NETWORK_BYTE:"W".charCodeAt(0),NODE_URL:"https://nodes.wavesplatform.com"},this._seed=e||i.libs.crypto.randomSeed()}return e.prototype.connect=function(e){return this._options=e,Promise.resolve()},e.prototype.sign=function(e){var t=this;return Promise.resolve(e.map((function(e){return i.signTx(n({chainId:t._options.NETWORK_BYTE},e),t._seed)})))},e.prototype.login=function(){return Promise.resolve({address:i.libs.crypto.address(this._seed,this._options.NETWORK_BYTE),publicKey:i.libs.crypto.publicKey(this._seed)})},e.prototype.logout=function(){return Promise.resolve()},e.prototype.signTypedData=function(e){return Promise.resolve("// TODO")},e.prototype.signMessage=function(e){return Promise.resolve("// TODO")},e}();t.ProviderSeed=a},function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});var i=r(27);t.massTransfer=i.massTransfer;var a=r(38);t.reissue=a.reissue;var s=r(39);t.burn=s.burn;var o=r(40);t.exchange=o.exchange;var u=r(41);t.lease=u.lease;var c=r(42);t.cancelLease=c.cancelLease;var l=r(43);t.data=l.data;var f=r(44);t.issue=f.issue;var h=r(45);t.transfer=h.transfer;var p=r(46);t.alias=p.alias;var d=r(47);t.setScript=d.setScript;var y=r(48);t.setAssetScript=y.setAssetScript;var g=r(49);t.sponsorship=g.sponsorship;var m=r(134);t.order=m.order;var v=r(135);t.cancelOrder=v.cancelOrder;var b=r(69);t.customData=b.customData,t.serializeCustomData=b.serializeCustomData;var E=r(70);t.auth=E.auth;var S=r(71);t.wavesAuth=S.wavesAuth;var T=r(50);t.invokeScript=T.invokeScript;var C=r(136);t.signTx=C.signTx,t.verify=C.verify,t.serialize=C.serialize,t.submitOrder=C.submitOrder,t.cancelSubmittedOrder=C.cancelSubmittedOrder,t.verifyAuthData=C.verifyAuthData,t.verifyCustomData=C.verifyCustomData,t.verifyWavesAuthData=C.verifyWavesAuthData;var A=r(81);t.waitForTx=A.waitForTx,t.broadcast=A.broadcast;var I=r(153);t.makeTx=I.makeTx;const w={crypto:n(r(4)),marshall:n(r(3))};t.libs=w;const B=n(r(154));t.seedUtils=B;const N=n(r(81));t.nodeInteraction=N;const R=n(r(5));t.validators=R},function(e,t){t.read=function(e,t,r,n,i){var a,s,o=8*i-n-1,u=(1<<o)-1,c=u>>1,l=-7,f=r?i-1:0,h=r?-1:1,p=e[t+f];for(f+=h,a=p&(1<<-l)-1,p>>=-l,l+=o;l>0;a=256*a+e[t+f],f+=h,l-=8);for(s=a&(1<<-l)-1,a>>=-l,l+=n;l>0;s=256*s+e[t+f],f+=h,l-=8);if(0===a)a=1-c;else{if(a===u)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,n),a-=c}return(p?-1:1)*s*Math.pow(2,a-n)},t.write=function(e,t,r,n,i,a){var s,o,u,c=8*a-i-1,l=(1<<c)-1,f=l>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:a-1,d=n?1:-1,y=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,s=l):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+f>=1?h/u:h*Math.pow(2,1-f))*u>=2&&(s++,u/=2),s+f>=l?(o=0,s=l):s+f>=1?(o=(t*u-1)*Math.pow(2,i),s+=f):(o=t*Math.pow(2,f-1)*Math.pow(2,i),s=0));i>=8;e[r+p]=255&o,p+=d,o/=256,i-=8);for(s=s<<i|o,c+=i;c>0;e[r+p]=255&s,p+=d,s/=256,c-=8);e[r+p-d]|=128*y}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){(function(e){var n=void 0!==e&&e||"undefined"!=typeof self&&self||window,i=Function.prototype.apply;function a(e,t){this._id=e,this._clearFn=t}t.setTimeout=function(){return new a(i.call(setTimeout,n,arguments),clearTimeout)},t.setInterval=function(){return new a(i.call(setInterval,n,arguments),clearInterval)},t.clearTimeout=t.clearInterval=function(e){e&&e.close()},a.prototype.unref=a.prototype.ref=function(){},a.prototype.close=function(){this._clearFn.call(n,this._id)},t.enroll=function(e,t){clearTimeout(e._idleTimeoutId),e._idleTimeout=t},t.unenroll=function(e){clearTimeout(e._idleTimeoutId),e._idleTimeout=-1},t._unrefActive=t.active=function(e){clearTimeout(e._idleTimeoutId);var t=e._idleTimeout;t>=0&&(e._idleTimeoutId=setTimeout((function(){e._onTimeout&&e._onTimeout()}),t))},r(88),t.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==e&&e.setImmediate||this&&this.setImmediate,t.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==e&&e.clearImmediate||this&&this.clearImmediate}).call(this,r(17))},function(e,t,r){(function(e,t){!function(e,r){"use strict";if(!e.setImmediate){var n,i,a,s,o,u=1,c={},l=!1,f=e.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(e);h=h&&h.setTimeout?h:e,"[object process]"==={}.toString.call(e.process)?n=function(e){t.nextTick((function(){d(e)}))}:!function(){if(e.postMessage&&!e.importScripts){var t=!0,r=e.onmessage;return e.onmessage=function(){t=!1},e.postMessage("","*"),e.onmessage=r,t}}()?e.MessageChannel?((a=new MessageChannel).port1.onmessage=function(e){d(e.data)},n=function(e){a.port2.postMessage(e)}):f&&"onreadystatechange"in f.createElement("script")?(i=f.documentElement,n=function(e){var t=f.createElement("script");t.onreadystatechange=function(){d(e),t.onreadystatechange=null,i.removeChild(t),t=null},i.appendChild(t)}):n=function(e){setTimeout(d,0,e)}:(s="setImmediate$"+Math.random()+"$",o=function(t){t.source===e&&"string"==typeof t.data&&0===t.data.indexOf(s)&&d(+t.data.slice(s.length))},e.addEventListener?e.addEventListener("message",o,!1):e.attachEvent("onmessage",o),n=function(t){e.postMessage(s+t,"*")}),h.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var i={callback:e,args:t};return c[u]=i,n(u),u++},h.clearImmediate=p}function p(e){delete c[e]}function d(e){if(l)setTimeout(d,0,e);else{var t=c[e];if(t){l=!0;try{!function(e){var t=e.callback,n=e.args;switch(n.length){case 0:t();break;case 1:t(n[0]);break;case 2:t(n[0],n[1]);break;case 3:t(n[0],n[1],n[2]);break;default:t.apply(r,n)}}(t)}finally{p(e),l=!1}}}}}("undefined"==typeof self?void 0===e?this:e:self)}).call(this,r(17),r(18))},function(e,t,r){(function(t){var r={};e.exports=r;var n={};r.encode=function(e,t,r){if("string"!=typeof t)throw new TypeError('"alphabet" must be a string.');if(void 0!==r&&"number"!=typeof r)throw new TypeError('"maxline" must be a number.');var n="";if(e instanceof Uint8Array){var i=0,a=t.length,s=t.charAt(0),o=[0];for(i=0;i<e.length;++i){for(var u=0,c=e[i];u<o.length;++u)c+=o[u]<<8,o[u]=c%a,c=c/a|0;for(;c>0;)o.push(c%a),c=c/a|0}for(i=0;0===e[i]&&i<e.length-1;++i)n+=s;for(i=o.length-1;i>=0;--i)n+=t[o[i]]}else n=function(e,t){var r=0,n=t.length,i=t.charAt(0),a=[0];for(r=0;r<e.length();++r){for(var s=0,o=e.at(r);s<a.length;++s)o+=a[s]<<8,a[s]=o%n,o=o/n|0;for(;o>0;)a.push(o%n),o=o/n|0}var u="";for(r=0;0===e.at(r)&&r<e.length()-1;++r)u+=i;for(r=a.length-1;r>=0;--r)u+=t[a[r]];return u}(e,t);if(r){var l=new RegExp(".{1,"+r+"}","g");n=n.match(l).join("\r\n")}return n},r.decode=function(e,r){if("string"!=typeof e)throw new TypeError('"input" must be a string.');if("string"!=typeof r)throw new TypeError('"alphabet" must be a string.');var i=n[r];if(!i){i=n[r]=[];for(var a=0;a<r.length;++a)i[r.charCodeAt(a)]=a}e=e.replace(/\s/g,"");var s=r.length,o=r.charAt(0),u=[0];for(a=0;a<e.length;a++){var c=i[e.charCodeAt(a)];if(void 0===c)return;for(var l=0,f=c;l<u.length;++l)f+=u[l]*s,u[l]=255&f,f>>=8;for(;f>0;)u.push(255&f),f>>=8}for(var h=0;e[h]===o&&h<e.length-1;++h)u.push(0);return void 0!==t?t.from(u.reverse()):new Uint8Array(u.reverse())}}).call(this,r(13).Buffer)},function(e,t,r){var n=r(1);r(9),r(2);var i=e.exports=n.sha256=n.sha256||{};n.md.sha256=n.md.algorithms.sha256=i,i.create=function(){s||(a=String.fromCharCode(128),a+=n.util.fillString(String.fromCharCode(0),64),o=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],s=!0);var e=null,t=n.util.createBuffer(),r=new Array(64),i={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0,fullMessageLength:null,messageLengthSize:8,start:function(){i.messageLength=0,i.fullMessageLength=i.messageLength64=[];for(var r=i.messageLengthSize/4,a=0;a<r;++a)i.fullMessageLength.push(0);return t=n.util.createBuffer(),e={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},i}};return i.start(),i.update=function(a,s){"utf8"===s&&(a=n.util.encodeUtf8(a));var o=a.length;i.messageLength+=o,o=[o/4294967296>>>0,o>>>0];for(var c=i.fullMessageLength.length-1;c>=0;--c)i.fullMessageLength[c]+=o[1],o[1]=o[0]+(i.fullMessageLength[c]/4294967296>>>0),i.fullMessageLength[c]=i.fullMessageLength[c]>>>0,o[0]=o[1]/4294967296>>>0;return t.putBytes(a),u(e,r,t),(t.read>2048||0===t.length())&&t.compact(),i},i.digest=function(){var s=n.util.createBuffer();s.putBytes(t.bytes());var o,c=i.fullMessageLength[i.fullMessageLength.length-1]+i.messageLengthSize&i.blockLength-1;s.putBytes(a.substr(0,i.blockLength-c));for(var l=8*i.fullMessageLength[0],f=0;f<i.fullMessageLength.length-1;++f)l+=(o=8*i.fullMessageLength[f+1])/4294967296>>>0,s.putInt32(l>>>0),l=o>>>0;s.putInt32(l);var h={h0:e.h0,h1:e.h1,h2:e.h2,h3:e.h3,h4:e.h4,h5:e.h5,h6:e.h6,h7:e.h7};u(h,r,s);var p=n.util.createBuffer();return p.putInt32(h.h0),p.putInt32(h.h1),p.putInt32(h.h2),p.putInt32(h.h3),p.putInt32(h.h4),p.putInt32(h.h5),p.putInt32(h.h6),p.putInt32(h.h7),p},i};var a=null,s=!1,o=null;function u(e,t,r){for(var n,i,a,s,u,c,l,f,h,p,d,y,g,m=r.length();m>=64;){for(u=0;u<16;++u)t[u]=r.getInt32();for(;u<64;++u)n=((n=t[u-2])>>>17|n<<15)^(n>>>19|n<<13)^n>>>10,i=((i=t[u-15])>>>7|i<<25)^(i>>>18|i<<14)^i>>>3,t[u]=n+t[u-7]+i+t[u-16]|0;for(c=e.h0,l=e.h1,f=e.h2,h=e.h3,p=e.h4,d=e.h5,y=e.h6,g=e.h7,u=0;u<64;++u)a=(c>>>2|c<<30)^(c>>>13|c<<19)^(c>>>22|c<<10),s=c&l|f&(c^l),n=g+((p>>>6|p<<26)^(p>>>11|p<<21)^(p>>>25|p<<7))+(y^p&(d^y))+o[u]+t[u],g=y,y=d,d=p,p=h+n>>>0,h=f,f=l,l=c,c=n+(i=a+s)>>>0;e.h0=e.h0+c|0,e.h1=e.h1+l|0,e.h2=e.h2+f|0,e.h3=e.h3+h|0,e.h4=e.h4+p|0,e.h5=e.h5+d|0,e.h6=e.h6+y|0,e.h7=e.h7+g|0,m-=64}}},function(e,t,r){(function(t){var n=r(1);r(2);var i=null;!n.util.isNodejs||n.options.usePureJavaScript||t.versions["node-webkit"]||(i=r(31)),(e.exports=n.prng=n.prng||{}).create=function(e){for(var t={plugin:e,key:null,seed:null,time:null,reseeds:0,generated:0,keyBytes:""},r=e.md,a=new Array(32),s=0;s<32;++s)a[s]=r.create();function o(){if(t.pools[0].messageLength>=32)return u();var e=32-t.pools[0].messageLength<<5;t.collect(t.seedFileSync(e)),u()}function u(){t.reseeds=4294967295===t.reseeds?0:t.reseeds+1;var e=t.plugin.md.create();e.update(t.keyBytes);for(var r=1,n=0;n<32;++n)t.reseeds%r==0&&(e.update(t.pools[n].digest().getBytes()),t.pools[n].start()),r<<=1;t.keyBytes=e.digest().getBytes(),e.start(),e.update(t.keyBytes);var i=e.digest().getBytes();t.key=t.plugin.formatKey(t.keyBytes),t.seed=t.plugin.formatSeed(i),t.generated=0}function c(e){var t=null,r=n.util.globalScope,i=r.crypto||r.msCrypto;i&&i.getRandomValues&&(t=function(e){return i.getRandomValues(e)});var a=n.util.createBuffer();if(t)for(;a.length()<e;){var s=Math.max(1,Math.min(e-a.length(),65536)/4),o=new Uint32Array(Math.floor(s));try{t(o);for(var u=0;u<o.length;++u)a.putInt32(o[u])}catch(e){if(!("undefined"!=typeof QuotaExceededError&&e instanceof QuotaExceededError))throw e}}if(a.length()<e)for(var c,l,f,h=Math.floor(65536*Math.random());a.length()<e;){l=16807*(65535&h),l+=(32767&(c=16807*(h>>16)))<<16,h=4294967295&(l=(2147483647&(l+=c>>15))+(l>>31));for(u=0;u<3;++u)f=h>>>(u<<3),f^=Math.floor(256*Math.random()),a.putByte(String.fromCharCode(255&f))}return a.getBytes(e)}return t.pools=a,t.pool=0,t.generate=function(e,r){if(!r)return t.generateSync(e);var i=t.plugin.cipher,a=t.plugin.increment,s=t.plugin.formatKey,o=t.plugin.formatSeed,c=n.util.createBuffer();t.key=null,function l(f){if(f)return r(f);if(c.length()>=e)return r(null,c.getBytes(e));t.generated>1048575&&(t.key=null);if(null===t.key)return n.util.nextTick((function(){!function(e){if(t.pools[0].messageLength>=32)return u(),e();var r=32-t.pools[0].messageLength<<5;t.seedFile(r,(function(r,n){if(r)return e(r);t.collect(n),u(),e()}))}(l)}));var h=i(t.key,t.seed);t.generated+=h.length,c.putBytes(h),t.key=s(i(t.key,a(t.seed))),t.seed=o(i(t.key,t.seed)),n.util.setImmediate(l)}()},t.generateSync=function(e){var r=t.plugin.cipher,i=t.plugin.increment,a=t.plugin.formatKey,s=t.plugin.formatSeed;t.key=null;for(var u=n.util.createBuffer();u.length()<e;){t.generated>1048575&&(t.key=null),null===t.key&&o();var c=r(t.key,t.seed);t.generated+=c.length,u.putBytes(c),t.key=a(r(t.key,i(t.seed))),t.seed=s(r(t.key,t.seed))}return u.getBytes(e)},i?(t.seedFile=function(e,t){i.randomBytes(e,(function(e,r){if(e)return t(e);t(null,r.toString())}))},t.seedFileSync=function(e){return i.randomBytes(e).toString()}):(t.seedFile=function(e,t){try{t(null,c(e))}catch(e){t(e)}},t.seedFileSync=c),t.collect=function(e){for(var r=e.length,n=0;n<r;++n)t.pools[t.pool].update(e.substr(n,1)),t.pool=31===t.pool?0:t.pool+1},t.collectInt=function(e,r){for(var n="",i=0;i<r;i+=8)n+=String.fromCharCode(e>>i&255);t.collect(n)},t.registerWorker=function(e){if(e===self)t.seedFile=function(e,t){self.addEventListener("message",(function e(r){var n=r.data;n.forge&&n.forge.prng&&(self.removeEventListener("message",e),t(n.forge.prng.err,n.forge.prng.bytes))})),self.postMessage({forge:{prng:{needed:e}}})};else{e.addEventListener("message",(function(r){var n=r.data;n.forge&&n.forge.prng&&t.seedFile(n.forge.prng.needed,(function(t,r){e.postMessage({forge:{prng:{err:t,bytes:r}}})}))}))}},t}}).call(this,r(18))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",i=n.split("").reduce((function(e,t,r){return e[t]=r,e}),{});t.default={encode:function(e){if(!e.length)return"";for(var t=[0],r=0;r<e.length;r++){for(var i=0;i<t.length;i++)t[i]<<=8;t[0]+=e[r];for(var a=0,s=0;s<t.length;s++)t[s]+=a,a=t[s]/58|0,t[s]%=58;for(;a;)t.push(a%58),a=a/58|0}for(r=0;0===e[r]&&r<e.length-1;r++)t.push(0);return t.reverse().map((function(e){return n[e]})).join("")},decode:function(e){if(!e.length)return new Uint8Array(0);for(var t=[0],r=0;r<e.length;r++){var n=e[r];if(!(n in i))throw'There is no character "'+n+'" in the Base58 sequence!';for(var a=0;a<t.length;a++)t[a]*=58;t[0]+=i[n];var s=0;for(a=0;a<t.length;a++)t[a]+=s,s=t[a]>>8,t[a]&=255;for(;s;)t.push(255&s),s>>=8}for(r=0;"1"===e[r]&&r<e.length-1;r++)t.push(0);return new Uint8Array(t.reverse())}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,i,a;t.utf8ArrayToStr=(n=new Array(128),i=String.fromCodePoint||String.fromCharCode,a=[],function(e){var t,r,s=e.length;a.length=0;for(var o=0;o<s;)(r=e[o++])<=127?t=r:r<=223?t=(31&r)<<6|63&e[o++]:r<=239?t=(15&r)<<12|(63&e[o++])<<6|63&e[o++]:String.fromCodePoint?t=(7&r)<<18|(63&e[o++])<<12|(63&e[o++])<<6|63&e[o++]:(t=63,o+=3),a.push(n[t]||(n[t]=i(t)));return a.join("")}),t.strToUtf8Array=function(e){for(var t=[],r=0;r<e.length;r++){var n=e.charCodeAt(r);n<128?t.push(n):n<2048?t.push(192|n>>6,128|63&n):n<55296||n>=57344?t.push(224|n>>12,128|n>>6&63,128|63&n):(r++,n=65536+((1023&n)<<10|1023&e.charCodeAt(r)),t.push(240|n>>18,128|n>>12&63,128|n>>6&63,128|63&n))}return Uint8Array.from(t)}},function(e,t,r){"use strict";
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.7
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */t.__esModule=!0;for(var n="0123456789abcdef".split(""),i=[0,8,16,24],a=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],s=[224,256,384,512],o=["hex","buffer","arrayBuffer","array"],u=function(e,t,r){return function(n){return new b(e,t,e).update(n)[r]()}},c=function(e,t,r){return function(n,i){return new b(e,t,i).update(n)[r]()}},l=function(e,t){var r=u(e,t,"hex");r.create=function(){return new b(e,t,e)},r.update=function(e){return r.create().update(e)};for(var n=0;n<o.length;++n){var i=o[n];r[i]=u(e,t,i)}return r},f=[{name:"keccak",padding:[1,256,65536,16777216],bits:s,createMethod:l},{name:"sha3",padding:[6,1536,393216,100663296],bits:s,createMethod:l},{name:"shake",padding:[31,7936,2031616,520093696],bits:[128,256],createMethod:function(e,t){var r=c(e,t,"hex");r.create=function(r){return new b(e,t,r)},r.update=function(e,t){return r.create(t).update(e)};for(var n=0;n<o.length;++n){var i=o[n];r[i]=c(e,t,i)}return r}}],h={},p=[],d=0;d<f.length;++d)for(var y=f[d],g=y.bits,m=0;m<g.length;++m){var v=y.name+"_"+g[m];p.push(v),h[v]=y.createMethod(g[m],y.padding)}function b(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}b.prototype.update=function(e){var t="string"!=typeof e;t&&e.constructor===ArrayBuffer&&(e=new Uint8Array(e));for(var r,n,a=e.length,s=this.blocks,o=this.byteCount,u=this.blockCount,c=0,l=this.s;c<a;){if(this.reset)for(this.reset=!1,s[0]=this.block,r=1;r<u+1;++r)s[r]=0;if(t)for(r=this.start;c<a&&r<o;++c)s[r>>2]|=e[c]<<i[3&r++];else for(r=this.start;c<a&&r<o;++c)(n=e.charCodeAt(c))<128?s[r>>2]|=n<<i[3&r++]:n<2048?(s[r>>2]|=(192|n>>6)<<i[3&r++],s[r>>2]|=(128|63&n)<<i[3&r++]):n<55296||n>=57344?(s[r>>2]|=(224|n>>12)<<i[3&r++],s[r>>2]|=(128|n>>6&63)<<i[3&r++],s[r>>2]|=(128|63&n)<<i[3&r++]):(n=65536+((1023&n)<<10|1023&e.charCodeAt(++c)),s[r>>2]|=(240|n>>18)<<i[3&r++],s[r>>2]|=(128|n>>12&63)<<i[3&r++],s[r>>2]|=(128|n>>6&63)<<i[3&r++],s[r>>2]|=(128|63&n)<<i[3&r++]);if(this.lastByteIndex=r,r>=o){for(this.start=r-o,this.block=s[u],r=0;r<u;++r)l[r]^=s[r];E(l),this.reset=!0}else this.start=r}return this},b.prototype.finalize=function(){var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];E(n)},b.prototype.toString=b.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,i=this.outputBlocks,a=this.extraBytes,s=0,o=0,u="";o<i;){for(s=0;s<t&&o<i;++s,++o)e=r[s],u+=n[e>>4&15]+n[15&e]+n[e>>12&15]+n[e>>8&15]+n[e>>20&15]+n[e>>16&15]+n[e>>28&15]+n[e>>24&15];o%t==0&&(E(r),s=0)}return a&&(e=r[s],a>0&&(u+=n[e>>4&15]+n[15&e]),a>1&&(u+=n[e>>12&15]+n[e>>8&15]),a>2&&(u+=n[e>>20&15]+n[e>>16&15])),u},b.prototype.arrayBuffer=function(){this.finalize();var e,t=this.blockCount,r=this.s,n=this.outputBlocks,i=this.extraBytes,a=0,s=0,o=this.outputBits>>3;e=i?new ArrayBuffer(n+1<<2):new ArrayBuffer(o);for(var u=new Uint32Array(e);s<n;){for(a=0;a<t&&s<n;++a,++s)u[s]=r[a];s%t==0&&E(r)}return i&&(u[a]=r[a],e=e.slice(0,o)),e},b.prototype.buffer=b.prototype.arrayBuffer,b.prototype.digest=b.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,i=this.outputBlocks,a=this.extraBytes,s=0,o=0,u=[];o<i;){for(s=0;s<r&&o<i;++s,++o)e=o<<2,t=n[s],u[e]=255&t,u[e+1]=t>>8&255,u[e+2]=t>>16&255,u[e+3]=t>>24&255;o%r==0&&E(n)}return a&&(e=o<<2,t=n[s],a>0&&(u[e]=255&t),a>1&&(u[e+1]=t>>8&255),a>2&&(u[e+2]=t>>16&255)),u};var E=function(e){var t,r,n,i,s,o,u,c,l,f,h,p,d,y,g,m,v,b,E,S,T,C,A,I,w,B,N,R,_,P,O,k,U,L,D,V,x,K,M,j,F,q,z,G,H,Y,Q,W,X,$,J,Z,ee,te,re,ne,ie,ae,se,oe,ue,ce,le;for(n=0;n<48;n+=2)i=e[0]^e[10]^e[20]^e[30]^e[40],s=e[1]^e[11]^e[21]^e[31]^e[41],o=e[2]^e[12]^e[22]^e[32]^e[42],u=e[3]^e[13]^e[23]^e[33]^e[43],c=e[4]^e[14]^e[24]^e[34]^e[44],l=e[5]^e[15]^e[25]^e[35]^e[45],f=e[6]^e[16]^e[26]^e[36]^e[46],h=e[7]^e[17]^e[27]^e[37]^e[47],t=(p=e[8]^e[18]^e[28]^e[38]^e[48])^(o<<1|u>>>31),r=(d=e[9]^e[19]^e[29]^e[39]^e[49])^(u<<1|o>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=i^(c<<1|l>>>31),r=s^(l<<1|c>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=o^(f<<1|h>>>31),r=u^(h<<1|f>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=c^(p<<1|d>>>31),r=l^(d<<1|p>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=f^(i<<1|s>>>31),r=h^(s<<1|i>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,y=e[0],g=e[1],Y=e[11]<<4|e[10]>>>28,Q=e[10]<<4|e[11]>>>28,R=e[20]<<3|e[21]>>>29,_=e[21]<<3|e[20]>>>29,oe=e[31]<<9|e[30]>>>23,ue=e[30]<<9|e[31]>>>23,q=e[40]<<18|e[41]>>>14,z=e[41]<<18|e[40]>>>14,L=e[2]<<1|e[3]>>>31,D=e[3]<<1|e[2]>>>31,m=e[13]<<12|e[12]>>>20,v=e[12]<<12|e[13]>>>20,W=e[22]<<10|e[23]>>>22,X=e[23]<<10|e[22]>>>22,P=e[33]<<13|e[32]>>>19,O=e[32]<<13|e[33]>>>19,ce=e[42]<<2|e[43]>>>30,le=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,re=e[4]<<30|e[5]>>>2,V=e[14]<<6|e[15]>>>26,x=e[15]<<6|e[14]>>>26,b=e[25]<<11|e[24]>>>21,E=e[24]<<11|e[25]>>>21,$=e[34]<<15|e[35]>>>17,J=e[35]<<15|e[34]>>>17,k=e[45]<<29|e[44]>>>3,U=e[44]<<29|e[45]>>>3,I=e[6]<<28|e[7]>>>4,w=e[7]<<28|e[6]>>>4,ne=e[17]<<23|e[16]>>>9,ie=e[16]<<23|e[17]>>>9,K=e[26]<<25|e[27]>>>7,M=e[27]<<25|e[26]>>>7,S=e[36]<<21|e[37]>>>11,T=e[37]<<21|e[36]>>>11,Z=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,G=e[8]<<27|e[9]>>>5,H=e[9]<<27|e[8]>>>5,B=e[18]<<20|e[19]>>>12,N=e[19]<<20|e[18]>>>12,ae=e[29]<<7|e[28]>>>25,se=e[28]<<7|e[29]>>>25,j=e[38]<<8|e[39]>>>24,F=e[39]<<8|e[38]>>>24,C=e[48]<<14|e[49]>>>18,A=e[49]<<14|e[48]>>>18,e[0]=y^~m&b,e[1]=g^~v&E,e[10]=I^~B&R,e[11]=w^~N&_,e[20]=L^~V&K,e[21]=D^~x&M,e[30]=G^~Y&W,e[31]=H^~Q&X,e[40]=te^~ne&ae,e[41]=re^~ie&se,e[2]=m^~b&S,e[3]=v^~E&T,e[12]=B^~R&P,e[13]=N^~_&O,e[22]=V^~K&j,e[23]=x^~M&F,e[32]=Y^~W&$,e[33]=Q^~X&J,e[42]=ne^~ae&oe,e[43]=ie^~se&ue,e[4]=b^~S&C,e[5]=E^~T&A,e[14]=R^~P&k,e[15]=_^~O&U,e[24]=K^~j&q,e[25]=M^~F&z,e[34]=W^~$&Z,e[35]=X^~J&ee,e[44]=ae^~oe&ce,e[45]=se^~ue&le,e[6]=S^~C&y,e[7]=T^~A&g,e[16]=P^~k&I,e[17]=O^~U&w,e[26]=j^~q&L,e[27]=F^~z&D,e[36]=$^~Z&G,e[37]=J^~ee&H,e[46]=oe^~ce&te,e[47]=ue^~le&re,e[8]=C^~y&m,e[9]=A^~g&v,e[18]=k^~I&B,e[19]=U^~w&N,e[28]=q^~L&V,e[29]=z^~D&x,e[38]=Z^~G&Y,e[39]=ee^~H&Q,e[48]=ce^~te&ne,e[49]=le^~re&ie,e[0]^=a[n],e[1]^=a[n+1]};t.keccak256=h.keccak_256},function(e,t,r){"use strict";(function(e){t.__esModule=!0;var r="Input must be an string, Buffer or Uint8Array";function n(e,t,r){var n=e[t]+e[r],i=e[t+1]+e[r+1];n>=4294967296&&i++,e[t]=n,e[t+1]=i}function i(e,t,r,n){var i=e[t]+r;r<0&&(i+=4294967296);var a=e[t+1]+n;i>=4294967296&&a++,e[t]=i,e[t+1]=a}function a(e,t){return e[t]^e[t+1]<<8^e[t+2]<<16^e[t+3]<<24}function s(e,t,r,a,s,o){var u=l[s],f=l[s+1],h=l[o],p=l[o+1];n(c,e,t),i(c,e,u,f);var d=c[a]^c[e],y=c[a+1]^c[e+1];c[a]=y,c[a+1]=d,n(c,r,a),d=c[t]^c[r],y=c[t+1]^c[r+1],c[t]=d>>>24^y<<8,c[t+1]=y>>>24^d<<8,n(c,e,t),i(c,e,h,p),d=c[a]^c[e],y=c[a+1]^c[e+1],c[a]=d>>>16^y<<16,c[a+1]=y>>>16^d<<16,n(c,r,a),d=c[t]^c[r],y=c[t+1]^c[r+1],c[t]=y>>>31^d<<1,c[t+1]=d>>>31^y<<1}var o=new Uint32Array([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),u=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3].map((function(e){return 2*e}))),c=new Uint32Array(32),l=new Uint32Array(32);function f(e,t){var r=0;for(r=0;r<16;r++)c[r]=e.h[r],c[r+16]=o[r];for(c[24]=c[24]^e.t,c[25]=c[25]^e.t/4294967296,t&&(c[28]=~c[28],c[29]=~c[29]),r=0;r<32;r++)l[r]=a(e.b,4*r);for(r=0;r<12;r++)s(0,8,16,24,u[16*r+0],u[16*r+1]),s(2,10,18,26,u[16*r+2],u[16*r+3]),s(4,12,20,28,u[16*r+4],u[16*r+5]),s(6,14,22,30,u[16*r+6],u[16*r+7]),s(0,10,20,30,u[16*r+8],u[16*r+9]),s(2,12,22,24,u[16*r+10],u[16*r+11]),s(4,14,16,26,u[16*r+12],u[16*r+13]),s(6,8,18,28,u[16*r+14],u[16*r+15]);for(r=0;r<16;r++)e.h[r]=e.h[r]^c[r]^c[r+16]}function h(e,t){if(0===e||e>64)throw new Error("Illegal output length, expected 0 < length <= 64");if(t&&t.length>64)throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");for(var r={b:new Uint8Array(128),h:new Uint32Array(16),t:0,c:0,outlen:e},n=0;n<16;n++)r.h[n]=o[n];var i=t?t.length:0;return r.h[0]^=16842752^i<<8^e,t&&(p(r,t),r.c=128),r}function p(e,t){for(var r=0;r<t.length;r++)128===e.c&&(e.t+=e.c,f(e,!1),e.c=0),e.b[e.c++]=t[r]}function d(e){for(e.t+=e.c;e.c<128;)e.b[e.c++]=0;f(e,!0);for(var t=new Uint8Array(e.outlen),r=0;r<e.outlen;r++)t[r]=e.h[r>>2]>>8*(3&r);return t}function y(t,n,i){i=i||64,t=function(t){var n;if(t instanceof Uint8Array)n=t;else if(t instanceof e)n=new Uint8Array(t);else{if("string"!=typeof t)throw new Error(r);n=new Uint8Array(e.from(t,"utf8"))}return n}(t);var a=h(i,n);return p(a,t),d(a)}t.blake2bInit=h,t.blake2bUpdate=p,t.blake2bFinal=d,t.blake2b=y,t.blake2bHex=function(e,t,r){var n,i=y(e,t,r);return n=i,Array.prototype.map.call(n,(function(e){return(e<16?"0":"")+e.toString(16)})).join("")}}).call(this,r(13).Buffer)},function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var i=n(r(24)),a=r(11),s=r(34),o=r(33),u=r(22);t.signBytes=function(e,t,r){return i.default.sign(a._fromIn(s.isPrivateKey(e)?e.privateKey:o.privateKey(e)),a._fromIn(t),a._fromIn(r||u.randomBytes(64)))}},function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});var i=r(20),a=r(56),s=r(11),o=r(14),u=r(33),c=n(r(24));t.verifyAddress=function(e,t){var r=t?t.chainId:void 0;try{var n=s._fromIn(e);if(1!=n[0]||r&&n[1]!=a.ChaidId.toNumber(r))return!1;for(var i=n.slice(0,22),c=n.slice(22,26),l=o._hashChain(i).slice(0,4),f=0;f<4;f++)if(c[f]!=l[f])return!1;if(t&&t.publicKey){var h=u.address({publicKey:t.publicKey},r);if(n.length!==h.length)return!1;for(f=0;f<h.length;f++)if(h[f]!==n[f])return!1}}catch(e){return!1}return!0},t.verifySignature=function(e,t,r){try{return c.default.verify(s._fromIn(e),s._fromIn(t),s._fromIn(r))}catch(e){return!1}},t.verifyPublicKey=function(e){return s._fromIn(e).length===i.PUBLIC_KEY_LENGTH}},function(e,t,r){"use strict";var n=this&&this.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(i,a){function s(e){try{u(n.next(e))}catch(e){a(e)}}function o(e){try{u(n.throw(e))}catch(e){a(e)}}function u(e){e.done?i(e.value):new r((function(t){t(e.value)})).then(s,o)}u((n=n.apply(e,t||[])).next())}))},i=this&&this.__generator||function(e,t){var r,n,i,a,s={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(r)throw new TypeError("Generator is already executing.");for(;s;)try{if(r=1,n&&(i=2&a[0]?n.return:a[0]?n.throw||((i=n.return)&&i.call(n),0):n.next)&&!(i=i.call(n,a[1])).done)return i;switch(n=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return s.label++,{value:a[1],done:!1};case 5:s.label++,n=a[1],a=[0];continue;case 7:a=s.ops.pop(),s.trys.pop();continue;default:if(!(i=(i=s.trys).length>0&&i[i.length-1])&&(6===a[0]||2===a[0])){s=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){s.label=a[1];break}if(6===a[0]&&s.label<i[1]){s.label=i[1],i=a;break}if(i&&s.label<i[2]){s.label=i[2],s.ops.push(a);break}i[2]&&s.ops.pop(),s.trys.pop();continue}a=t.call(e,s)}catch(e){a=[6,e],n=0}finally{r=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}},a=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t},s=this;Object.defineProperty(t,"__esModule",{value:!0});var o=a(r(99)),u=a(r(9)),c=a(r(64)),l=a(r(2)),f=r(23),h=r(10),p=a(r(107));o.oids.sha224="2.16.840.1.101.3.4.2.4",o.oids["2.16.840.1.101.3.4.2.4"]="sha224",o.oids["sha3-224"]="2.16.840.1.101.3.4.2.7",o.oids["2.16.840.1.101.3.4.2.7"]="sha3-224",o.oids["sha3-256"]="2.16.840.1.101.3.4.2.8",o.oids["2.16.840.1.101.3.4.2.8"]="sha3-256",o.oids["sha3-384"]="2.16.840.1.101.3.4.2.9",o.oids["2.16.840.1.101.3.4.2.9"]="sha3-384",o.oids["sha3-512"]="2.16.840.1.101.3.4.2.10",o.oids["2.16.840.1.101.3.4.2.10"]="sha3-512",t.pemToBytes=function(e){return f.base64Decode(e.trim().split(/\r\n|\n/).slice(1,-1).join("").trim())};var d={rsaPrivateNonEncrypted:"RSA PRIVATE KEY",rsaPublic:"PUBLIC KEY"};t.bytesToPem=function(e,t){var r="-----BEGIN "+d[t]+"-----\n",n="-----END "+d[t]+"-----\n",i=f.base64Encode(e);i.length%64!=0&&(i+=" ".repeat(64-i.length%64));for(var a=r,s=0;s<i.length/64;s++)a+=i.slice(64*s,64*(s+1))+"\n";return a+=n},t.rsaKeyPairSync=function(e,r){var n=o.rsa.generateKeyPair(e,r);return{rsaPrivate:t.pemToBytes(o.privateKeyToPem(n.privateKey)),rsaPublic:t.pemToBytes(o.publicKeyToPem(n.publicKey))}},t.rsaKeyPair=function(e,r){return n(s,void 0,void 0,(function(){return i(this,(function(n){return[2,new Promise((function(n,i){o.rsa.generateKeyPair(e,r,(function(e,r){e&&i(e),n({rsaPrivate:t.pemToBytes(o.privateKeyToPem(r.privateKey)),rsaPublic:t.pemToBytes(o.publicKeyToPem(r.publicKey))})}))}))]}))}))};var y,g=function(){function e(e,t){this.sha3Digest=e,this.algorithm=t}return e.makeCreator=function(t,r){return{create:function(){return new e(t.create(),r)}}},e.prototype.update=function(e,t){return this.sha3Digest.update(h.stringToBytes(e,null==t?"raw":t)),this},e.prototype.digest=function(){var e=Uint8Array.from(this.sha3Digest.digest());return l.createBuffer(h.bytesToString(e,"raw"))},e}(),m={MD5:c,SHA1:u.algorithms.sha1,SHA224:(y="SHA224",function(){throw new Error("Digest "+y+" is unsupported")}),SHA256:u.algorithms.sha256,SHA384:u.algorithms.sha384,SHA512:u.algorithms.sha512,"SHA3-224":g.makeCreator(p.sha3_224,"sha3-224"),"SHA3-256":g.makeCreator(p.sha3_256,"sha3-256"),"SHA3-384":g.makeCreator(p.sha3_384,"sha3-384"),"SHA3-512":g.makeCreator(p.sha3_512,"sha3-512")};t.rsaSign=function(e,r,n){void 0===n&&(n="SHA256");var i=t.bytesToPem(e,"rsaPrivateNonEncrypted"),a=o.privateKeyFromPem(i),s=m[n].create();return s.update(h.bytesToString(r,"raw")),h.stringToBytes(a.sign(s),"raw")},t.rsaVerify=function(e,r,n,i){void 0===i&&(i="SHA256");var a=o.publicKeyFromPem(t.bytesToPem(e,"rsaPublic")),s=m[i].create();return s.update(h.bytesToString(r),"raw"),a.verify(s.digest().getBytes(),h.bytesToString(n,"raw"))}},function(e,t,r){var n=r(1);r(15),r(16),r(57),r(35),r(59),r(103),r(63),r(25),r(2),r(62);var i=n.asn1,a=e.exports=n.pki=n.pki||{};a.pemToDer=function(e){var t=n.pem.decode(e)[0];if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert PEM to DER; PEM is encrypted.");return n.util.createBuffer(t.body)},a.privateKeyFromPem=function(e){var t=n.pem.decode(e)[0];if("PRIVATE KEY"!==t.type&&"RSA PRIVATE KEY"!==t.type){var r=new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');throw r.headerType=t.type,r}if(t.procType&&"ENCRYPTED"===t.procType.type)throw new Error("Could not convert private key from PEM; PEM is encrypted.");var s=i.fromDer(t.body);return a.privateKeyFromAsn1(s)},a.privateKeyToPem=function(e,t){var r={type:"RSA PRIVATE KEY",body:i.toDer(a.privateKeyToAsn1(e)).getBytes()};return n.pem.encode(r,{maxline:t})},a.privateKeyInfoToPem=function(e,t){var r={type:"PRIVATE KEY",body:i.toDer(e).getBytes()};return n.pem.encode(r,{maxline:t})}},function(e,t,r){var n=r(1);r(2);var i=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],a=[1,2,3,5],s=function(e,t){return e<<t&65535|(65535&e)>>16-t},o=function(e,t){return(65535&e)>>t|e<<16-t&65535};e.exports=n.rc2=n.rc2||{},n.rc2.expandKey=function(e,t){"string"==typeof e&&(e=n.util.createBuffer(e)),t=t||128;var r,a=e,s=e.length(),o=t,u=Math.ceil(o/8),c=255>>(7&o);for(r=s;r<128;r++)a.putByte(i[a.at(r-1)+a.at(r-s)&255]);for(a.setAt(128-u,i[a.at(128-u)&c]),r=127-u;r>=0;r--)a.setAt(r,i[a.at(r+1)^a.at(r+u)]);return a};var u=function(e,t,r){var i,u,c,l,f=!1,h=null,p=null,d=null,y=[];for(e=n.rc2.expandKey(e,t),c=0;c<64;c++)y.push(e.getInt16Le());r?(i=function(e){for(c=0;c<4;c++)e[c]+=y[l]+(e[(c+3)%4]&e[(c+2)%4])+(~e[(c+3)%4]&e[(c+1)%4]),e[c]=s(e[c],a[c]),l++},u=function(e){for(c=0;c<4;c++)e[c]+=y[63&e[(c+3)%4]]}):(i=function(e){for(c=3;c>=0;c--)e[c]=o(e[c],a[c]),e[c]-=y[l]+(e[(c+3)%4]&e[(c+2)%4])+(~e[(c+3)%4]&e[(c+1)%4]),l--},u=function(e){for(c=3;c>=0;c--)e[c]-=y[63&e[(c+3)%4]]});var g=function(e){var t=[];for(c=0;c<4;c++){var n=h.getInt16Le();null!==d&&(r?n^=d.getInt16Le():d.putInt16Le(n)),t.push(65535&n)}l=r?0:63;for(var i=0;i<e.length;i++)for(var a=0;a<e[i][0];a++)e[i][1](t);for(c=0;c<4;c++)null!==d&&(r?d.putInt16Le(t[c]):t[c]^=d.getInt16Le()),p.putInt16Le(t[c])},m=null;return m={start:function(e,t){e&&"string"==typeof e&&(e=n.util.createBuffer(e)),f=!1,h=n.util.createBuffer(),p=t||new n.util.createBuffer,d=e,m.output=p},update:function(e){for(f||h.putBuffer(e);h.length()>=8;)g([[5,i],[1,u],[6,i],[1,u],[5,i]])},finish:function(e){var t=!0;if(r)if(e)t=e(8,h,!r);else{var n=8===h.length()?8:8-h.length();h.fillWithByte(n,n)}if(t&&(f=!0,m.update()),!r&&(t=0===h.length()))if(e)t=e(8,p,!r);else{var i=p.length(),a=p.at(i-1);a>i?t=!1:p.truncate(a)}return t}}};n.rc2.startEncrypting=function(e,t,r){var i=n.rc2.createEncryptionCipher(e,128);return i.start(t,r),i},n.rc2.createEncryptionCipher=function(e,t){return u(e,t,!0)},n.rc2.startDecrypting=function(e,t,r){var i=n.rc2.createDecryptionCipher(e,128);return i.start(t,r),i},n.rc2.createDecryptionCipher=function(e,t){return u(e,t,!1)}},function(e,t,r){var n=r(1);r(2),r(12),r(61);var i=e.exports=n.pkcs1=n.pkcs1||{};function a(e,t,r){r||(r=n.md.sha1.create());for(var i="",a=Math.ceil(t/r.digestLength),s=0;s<a;++s){var o=String.fromCharCode(s>>24&255,s>>16&255,s>>8&255,255&s);r.start(),r.update(e+o),i+=r.digest().getBytes()}return i.substring(0,t)}i.encode_rsa_oaep=function(e,t,r){var i,s,o,u;"string"==typeof r?(i=r,s=arguments[3]||void 0,o=arguments[4]||void 0):r&&(i=r.label||void 0,s=r.seed||void 0,o=r.md||void 0,r.mgf1&&r.mgf1.md&&(u=r.mgf1.md)),o?o.start():o=n.md.sha1.create(),u||(u=o);var c=Math.ceil(e.n.bitLength()/8),l=c-2*o.digestLength-2;if(t.length>l)throw(g=new Error("RSAES-OAEP input message length is too long.")).length=t.length,g.maxLength=l,g;i||(i=""),o.update(i,"raw");for(var f=o.digest(),h="",p=l-t.length,d=0;d<p;d++)h+="\0";var y=f.getBytes()+h+""+t;if(s){if(s.length!==o.digestLength){var g;throw(g=new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.")).seedLength=s.length,g.digestLength=o.digestLength,g}}else s=n.random.getBytes(o.digestLength);var m=a(s,c-o.digestLength-1,u),v=n.util.xorBytes(y,m,y.length),b=a(v,o.digestLength,u),E=n.util.xorBytes(s,b,s.length);return"\0"+E+v},i.decode_rsa_oaep=function(e,t,r){var i,s,o;"string"==typeof r?(i=r,s=arguments[3]||void 0):r&&(i=r.label||void 0,s=r.md||void 0,r.mgf1&&r.mgf1.md&&(o=r.mgf1.md));var u=Math.ceil(e.n.bitLength()/8);if(t.length!==u)throw(v=new Error("RSAES-OAEP encoded message length is invalid.")).length=t.length,v.expectedLength=u,v;if(void 0===s?s=n.md.sha1.create():s.start(),o||(o=s),u<2*s.digestLength+2)throw new Error("RSAES-OAEP key is too short for the hash function.");i||(i=""),s.update(i,"raw");for(var c=s.digest().getBytes(),l=t.charAt(0),f=t.substring(1,s.digestLength+1),h=t.substring(1+s.digestLength),p=a(h,s.digestLength,o),d=n.util.xorBytes(f,p,f.length),y=a(d,u-s.digestLength-1,o),g=n.util.xorBytes(h,y,h.length),m=g.substring(0,s.digestLength),v="\0"!==l,b=0;b<s.digestLength;++b)v|=c.charAt(b)!==m.charAt(b);for(var E=1,S=s.digestLength,T=s.digestLength;T<g.length;T++){var C=g.charCodeAt(T),A=1&C^1,I=E?65534:0;v|=C&I,S+=E&=A}if(v||1!==g.charCodeAt(S))throw new Error("Invalid RSAES-OAEP padding.");return g.substring(S+1)}},function(e,t,r){var n=r(1);r(2),r(60),r(12),function(){if(n.prime)e.exports=n.prime;else{var t=e.exports=n.prime=n.prime||{},r=n.jsbn.BigInteger,i=[6,4,2,4,2,4,6,2],a=new r(null);a.fromInt(30);var s=function(e,t){return e|t};t.generateProbablePrime=function(e,t,i){"function"==typeof t&&(i=t,t={});var a=(t=t||{}).algorithm||"PRIMEINC";"string"==typeof a&&(a={name:a}),a.options=a.options||{};var s=t.prng||n.random,c={nextBytes:function(e){for(var t=s.getBytesSync(e.length),r=0;r<e.length;++r)e[r]=t.charCodeAt(r)}};if("PRIMEINC"===a.name)return function(e,t,i,a){if("workers"in i)return function(e,t,i,a){if("undefined"==typeof Worker)return o(e,t,i,a);var s=u(e,t),c=i.workers,l=i.workLoad||100,f=30*l/8,h=i.workerScript||"forge/prime.worker.js";if(-1===c)return n.util.estimateCores((function(e,t){e&&(t=2),c=t-1,p()}));function p(){c=Math.max(1,c);for(var n=[],i=0;i<c;++i)n[i]=new Worker(h);for(i=0;i<c;++i)n[i].addEventListener("message",p);var o=!1;function p(i){if(!o){0;var c=i.data;if(c.found){for(var h=0;h<n.length;++h)n[h].terminate();return o=!0,a(null,new r(c.prime,16))}s.bitLength()>e&&(s=u(e,t));var p=s.toString(16);i.target.postMessage({hex:p,workLoad:l}),s.dAddOffset(f,0)}}}p()}(e,t,i,a);return o(e,t,i,a)}(e,c,a.options,i);throw new Error("Invalid prime generation algorithm: "+a.name)}}function o(e,t,r,a){var s=u(e,t),o=function(e){return e<=100?27:e<=150?18:e<=200?15:e<=250?12:e<=300?9:e<=350?8:e<=400?7:e<=500?6:e<=600?5:e<=800?4:e<=1250?3:2}(s.bitLength());"millerRabinTests"in r&&(o=r.millerRabinTests);var c=10;"maxBlockTime"in r&&(c=r.maxBlockTime),function e(t,r,a,s,o,c,l){var f=+new Date;do{if(t.bitLength()>r&&(t=u(r,a)),t.isProbablePrime(o))return l(null,t);t.dAddOffset(i[s++%8],0)}while(c<0||+new Date-f<c);n.util.setImmediate((function(){e(t,r,a,s,o,c,l)}))}(s,e,t,0,o,c,a)}function u(e,t){var n=new r(e,t),i=e-1;return n.testBit(i)||n.bitwiseTo(r.ONE.shiftLeft(i),s,n),n.dAddOffset(31-n.mod(a).byteValue(),0),n}}()},function(e,t,r){var n=r(1);r(15),r(32),r(16),r(104),r(57),r(12),r(25),r(61),r(2),r(62);var i=n.asn1,a=n.pki,s=e.exports=n.pkcs12=n.pkcs12||{},o={name:"ContentInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.contentType",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:i.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"content"}]},u={name:"PFX",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"version"},o,{name:"PFX.macData",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"mac",value:[{name:"PFX.macData.mac",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"PFX.macData.mac.digestAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"macAlgorithm"},{name:"PFX.macData.mac.digestAlgorithm.parameters",tagClass:i.Class.UNIVERSAL,captureAsn1:"macAlgorithmParameters"}]},{name:"PFX.macData.mac.digest",tagClass:i.Class.UNIVERSAL,type:i.Type.OCTETSTRING,constructed:!1,capture:"macDigest"}]},{name:"PFX.macData.macSalt",tagClass:i.Class.UNIVERSAL,type:i.Type.OCTETSTRING,constructed:!1,capture:"macSalt"},{name:"PFX.macData.iterations",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,optional:!0,capture:"macIterations"}]}]},c={name:"SafeBag",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"SafeBag.bagId",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"bagId"},{name:"SafeBag.bagValue",tagClass:i.Class.CONTEXT_SPECIFIC,constructed:!0,captureAsn1:"bagValue"},{name:"SafeBag.bagAttributes",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,constructed:!0,optional:!0,capture:"bagAttributes"}]},l={name:"Attribute",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"Attribute.attrId",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"oid"},{name:"Attribute.attrValues",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,constructed:!0,capture:"values"}]},f={name:"CertBag",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"CertBag.certId",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"certId"},{name:"CertBag.certValue",tagClass:i.Class.CONTEXT_SPECIFIC,constructed:!0,value:[{name:"CertBag.certValue[0]",tagClass:i.Class.UNIVERSAL,type:i.Class.OCTETSTRING,constructed:!1,capture:"cert"}]}]};function h(e,t,r,n){for(var i=[],a=0;a<e.length;a++)for(var s=0;s<e[a].safeBags.length;s++){var o=e[a].safeBags[s];void 0!==n&&o.type!==n||(null!==t?void 0!==o.attributes[t]&&o.attributes[t].indexOf(r)>=0&&i.push(o):i.push(o))}return i}function p(e){if(e.composed||e.constructed){for(var t=n.util.createBuffer(),r=0;r<e.value.length;++r)t.putBytes(e.value[r].value);e.composed=e.constructed=!1,e.value=t.getBytes()}return e}function d(e,t){var r={},s=[];if(!i.validate(e,n.pkcs7.asn1.encryptedDataValidator,r,s))throw(o=new Error("Cannot read EncryptedContentInfo.")).errors=s,o;var o,u=i.derToOid(r.contentType);if(u!==a.oids.data)throw(o=new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.")).oid=u,o;u=i.derToOid(r.encAlgorithm);var c=a.pbe.getCipher(u,r.encParameter,t),l=p(r.encryptedContentAsn1),f=n.util.createBuffer(l.value);if(c.update(f),!c.finish())throw new Error("Failed to decrypt PKCS#12 SafeContents.");return c.output.getBytes()}function y(e,t,r){if(!t&&0===e.length)return[];if((e=i.fromDer(e,t)).tagClass!==i.Class.UNIVERSAL||e.type!==i.Type.SEQUENCE||!0!==e.constructed)throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");for(var n=[],s=0;s<e.value.length;s++){var o=e.value[s],u={},l=[];if(!i.validate(o,c,u,l))throw(m=new Error("Cannot read SafeBag.")).errors=l,m;var h,p,d={type:i.derToOid(u.bagId),attributes:g(u.bagAttributes)};n.push(d);var y=u.bagValue.value[0];switch(d.type){case a.oids.pkcs8ShroudedKeyBag:if(null===(y=a.decryptPrivateKeyInfo(y,r)))throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");case a.oids.keyBag:try{d.key=a.privateKeyFromAsn1(y)}catch(e){d.key=null,d.asn1=y}continue;case a.oids.certBag:h=f,p=function(){if(i.derToOid(u.certId)!==a.oids.x509Certificate){var e=new Error("Unsupported certificate type, only X.509 supported.");throw e.oid=i.derToOid(u.certId),e}var r=i.fromDer(u.cert,t);try{d.cert=a.certificateFromAsn1(r,!0)}catch(e){d.cert=null,d.asn1=r}};break;default:var m;throw(m=new Error("Unsupported PKCS#12 SafeBag type.")).oid=d.type,m}if(void 0!==h&&!i.validate(y,h,u,l))throw(m=new Error("Cannot read PKCS#12 "+h.name)).errors=l,m;p()}return n}function g(e){var t={};if(void 0!==e)for(var r=0;r<e.length;++r){var n={},s=[];if(!i.validate(e[r],l,n,s)){var o=new Error("Cannot read PKCS#12 BagAttribute.");throw o.errors=s,o}var u=i.derToOid(n.oid);if(void 0!==a.oids[u]){t[a.oids[u]]=[];for(var c=0;c<n.values.length;++c)t[a.oids[u]].push(n.values[c].value)}}return t}s.pkcs12FromAsn1=function(e,t,r){"string"==typeof t?(r=t,t=!0):void 0===t&&(t=!0);var c={};if(!i.validate(e,u,c,[]))throw(l=new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.")).errors=l,l;var l,f={version:c.version.charCodeAt(0),safeContents:[],getBags:function(e){var t,r={};return"localKeyId"in e?t=e.localKeyId:"localKeyIdHex"in e&&(t=n.util.hexToBytes(e.localKeyIdHex)),void 0===t&&!("friendlyName"in e)&&"bagType"in e&&(r[e.bagType]=h(f.safeContents,null,null,e.bagType)),void 0!==t&&(r.localKeyId=h(f.safeContents,"localKeyId",t,e.bagType)),"friendlyName"in e&&(r.friendlyName=h(f.safeContents,"friendlyName",e.friendlyName,e.bagType)),r},getBagsByFriendlyName:function(e,t){return h(f.safeContents,"friendlyName",e,t)},getBagsByLocalKeyId:function(e,t){return h(f.safeContents,"localKeyId",e,t)}};if(3!==c.version.charCodeAt(0))throw(l=new Error("PKCS#12 PFX of version other than 3 not supported.")).version=c.version.charCodeAt(0),l;if(i.derToOid(c.contentType)!==a.oids.data)throw(l=new Error("Only PKCS#12 PFX in password integrity mode supported.")).oid=i.derToOid(c.contentType),l;var g=c.content.value[0];if(g.tagClass!==i.Class.UNIVERSAL||g.type!==i.Type.OCTETSTRING)throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");if(g=p(g),c.mac){var m=null,v=0,b=i.derToOid(c.macAlgorithm);switch(b){case a.oids.sha1:m=n.md.sha1.create(),v=20;break;case a.oids.sha256:m=n.md.sha256.create(),v=32;break;case a.oids.sha384:m=n.md.sha384.create(),v=48;break;case a.oids.sha512:m=n.md.sha512.create(),v=64;break;case a.oids.md5:m=n.md.md5.create(),v=16}if(null===m)throw new Error("PKCS#12 uses unsupported MAC algorithm: "+b);var E=new n.util.ByteBuffer(c.macSalt),S="macIterations"in c?parseInt(n.util.bytesToHex(c.macIterations),16):1,T=s.generateKey(r,E,3,S,v,m),C=n.hmac.create();if(C.start(m,T),C.update(g.value),C.getMac().getBytes()!==c.macDigest)throw new Error("PKCS#12 MAC could not be verified. Invalid password?")}return function(e,t,r,n){if((t=i.fromDer(t,r)).tagClass!==i.Class.UNIVERSAL||t.type!==i.Type.SEQUENCE||!0!==t.constructed)throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");for(var s=0;s<t.value.length;s++){var u=t.value[s],c={},l=[];if(!i.validate(u,o,c,l))throw(m=new Error("Cannot read ContentInfo.")).errors=l,m;var f={encrypted:!1},h=null,g=c.content.value[0];switch(i.derToOid(c.contentType)){case a.oids.data:if(g.tagClass!==i.Class.UNIVERSAL||g.type!==i.Type.OCTETSTRING)throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");h=p(g).value;break;case a.oids.encryptedData:h=d(g,n),f.encrypted=!0;break;default:var m;throw(m=new Error("Unsupported PKCS#12 contentType.")).contentType=i.derToOid(c.contentType),m}f.safeBags=y(h,r,n),e.safeContents.push(f)}}(f,g.value,t,r),f},s.toPkcs12Asn1=function(e,t,r,o){(o=o||{}).saltSize=o.saltSize||8,o.count=o.count||2048,o.algorithm=o.algorithm||o.encAlgorithm||"aes128","useMac"in o||(o.useMac=!0),"localKeyId"in o||(o.localKeyId=null),"generateLocalKeyId"in o||(o.generateLocalKeyId=!0);var u,c=o.localKeyId;if(null!==c)c=n.util.hexToBytes(c);else if(o.generateLocalKeyId)if(t){var l=n.util.isArray(t)?t[0]:t;"string"==typeof l&&(l=a.certificateFromPem(l)),(B=n.md.sha1.create()).update(i.toDer(a.certificateToAsn1(l)).getBytes()),c=B.digest().getBytes()}else c=n.random.getBytes(20);var f=[];null!==c&&f.push(i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.localKeyId).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.SET,!0,[i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,c)])])),"friendlyName"in o&&f.push(i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.friendlyName).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.SET,!0,[i.create(i.Class.UNIVERSAL,i.Type.BMPSTRING,!1,o.friendlyName)])])),f.length>0&&(u=i.create(i.Class.UNIVERSAL,i.Type.SET,!0,f));var h=[],p=[];null!==t&&(p=n.util.isArray(t)?t:[t]);for(var d=[],y=0;y<p.length;++y){"string"==typeof(t=p[y])&&(t=a.certificateFromPem(t));var g=0===y?u:void 0,m=a.certificateToAsn1(t),v=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.certBag).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.x509Certificate).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,i.toDer(m).getBytes())])])]),g]);d.push(v)}if(d.length>0){var b=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,d),E=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.data).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,i.toDer(b).getBytes())])]);h.push(E)}var S=null;if(null!==e){var T=a.wrapRsaPrivateKey(a.privateKeyToAsn1(e));S=null===r?i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.keyBag).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[T]),u]):i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.pkcs8ShroudedKeyBag).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[a.encryptPrivateKeyInfo(T,r,o)]),u]);var C=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[S]),A=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.data).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,i.toDer(C).getBytes())])]);h.push(A)}var I,w=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,h);if(o.useMac){var B=n.md.sha1.create(),N=new n.util.ByteBuffer(n.random.getBytes(o.saltSize)),R=o.count,_=(e=s.generateKey(r,N,3,R,20),n.hmac.create());_.start(B,e),_.update(i.toDer(w).getBytes());var P=_.getMac();I=i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.sha1).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.NULL,!1,"")]),i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,P.getBytes())]),i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,N.getBytes()),i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(R).getBytes())])}return i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.INTEGER,!1,i.integerToDer(3).getBytes()),i.create(i.Class.UNIVERSAL,i.Type.SEQUENCE,!0,[i.create(i.Class.UNIVERSAL,i.Type.OID,!1,i.oidToDer(a.oids.data).getBytes()),i.create(i.Class.CONTEXT_SPECIFIC,0,!0,[i.create(i.Class.UNIVERSAL,i.Type.OCTETSTRING,!1,i.toDer(w).getBytes())])]),I])},s.generateKey=n.pbe.generatePkcs12Key},function(e,t,r){var n=r(1);r(15),r(2);var i=n.asn1,a=e.exports=n.pkcs7asn1=n.pkcs7asn1||{};n.pkcs7=n.pkcs7||{},n.pkcs7.asn1=a;var s={name:"ContentInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"ContentInfo.ContentType",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"contentType"},{name:"ContentInfo.content",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,captureAsn1:"content"}]};a.contentInfoValidator=s;var o={name:"EncryptedContentInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentType",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"contentType"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"EncryptedContentInfo.contentEncryptionAlgorithm.parameter",tagClass:i.Class.UNIVERSAL,captureAsn1:"encParameter"}]},{name:"EncryptedContentInfo.encryptedContent",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,capture:"encryptedContent",captureAsn1:"encryptedContentAsn1"}]};a.envelopedDataValidator={name:"EnvelopedData",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"EnvelopedData.Version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"version"},{name:"EnvelopedData.RecipientInfos",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,constructed:!0,captureAsn1:"recipientInfos"}].concat(o)},a.encryptedDataValidator={name:"EncryptedData",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedData.Version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"version"}].concat(o)};var u={name:"SignerInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1},{name:"SignerInfo.issuerAndSerialNumber",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.issuerAndSerialNumber.issuer",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"SignerInfo.issuerAndSerialNumber.serialNumber",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"SignerInfo.digestAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"SignerInfo.digestAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"digestAlgorithm"},{name:"SignerInfo.digestAlgorithm.parameter",tagClass:i.Class.UNIVERSAL,constructed:!1,captureAsn1:"digestParameter",optional:!0}]},{name:"SignerInfo.authenticatedAttributes",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,constructed:!0,optional:!0,capture:"authenticatedAttributes"},{name:"SignerInfo.digestEncryptionAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,capture:"signatureAlgorithm"},{name:"SignerInfo.encryptedDigest",tagClass:i.Class.UNIVERSAL,type:i.Type.OCTETSTRING,constructed:!1,capture:"signature"},{name:"SignerInfo.unauthenticatedAttributes",tagClass:i.Class.CONTEXT_SPECIFIC,type:1,constructed:!0,optional:!0,capture:"unauthenticatedAttributes"}]};a.signedDataValidator={name:"SignedData",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"SignedData.Version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"version"},{name:"SignedData.DigestAlgorithms",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,constructed:!0,captureAsn1:"digestAlgorithms"},s,{name:"SignedData.Certificates",tagClass:i.Class.CONTEXT_SPECIFIC,type:0,optional:!0,captureAsn1:"certificates"},{name:"SignedData.CertificateRevocationLists",tagClass:i.Class.CONTEXT_SPECIFIC,type:1,optional:!0,captureAsn1:"crls"},{name:"SignedData.SignerInfos",tagClass:i.Class.UNIVERSAL,type:i.Type.SET,capture:"signerInfos",optional:!0,value:[u]}]},a.recipientInfoValidator={name:"RecipientInfo",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.version",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"version"},{name:"RecipientInfo.issuerAndSerial",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.issuerAndSerial.issuer",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,captureAsn1:"issuer"},{name:"RecipientInfo.issuerAndSerial.serialNumber",tagClass:i.Class.UNIVERSAL,type:i.Type.INTEGER,constructed:!1,capture:"serial"}]},{name:"RecipientInfo.keyEncryptionAlgorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.SEQUENCE,constructed:!0,value:[{name:"RecipientInfo.keyEncryptionAlgorithm.algorithm",tagClass:i.Class.UNIVERSAL,type:i.Type.OID,constructed:!1,capture:"encAlgorithm"},{name:"RecipientInfo.keyEncryptionAlgorithm.parameter",tagClass:i.Class.UNIVERSAL,constructed:!1,captureAsn1:"encParameter"}]},{name:"RecipientInfo.encryptedKey",tagClass:i.Class.UNIVERSAL,type:i.Type.OCTETSTRING,constructed:!1,capture:"encKey"}]}},function(e,t,r){var n=r(1);r(106),e.exports=n.mgf=n.mgf||{},n.mgf.mgf1=n.mgf1},function(e,t,r){var n=r(1);r(2),n.mgf=n.mgf||{},(e.exports=n.mgf.mgf1=n.mgf1=n.mgf1||{}).create=function(e){return{generate:function(t,r){for(var i=new n.util.ByteBuffer,a=Math.ceil(r/e.digestLength),s=0;s<a;s++){var o=new n.util.ByteBuffer;o.putInt32(s),e.start(),e.update(t+o.getBytes()),i.putBuffer(e.digest())}return i.truncate(i.length()-r),i.getBytes()}}}},function(e,t,r){(function(n,i){var a;
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */!function(){"use strict";var s="input is invalid type",o="object"==typeof window,u=o?window:{};u.JS_SHA3_NO_WINDOW&&(o=!1);var c=!o&&"object"==typeof self;!u.JS_SHA3_NO_NODE_JS&&"object"==typeof n&&n.versions&&n.versions.node?u=i:c&&(u=self);var l=!u.JS_SHA3_NO_COMMON_JS&&"object"==typeof e&&e.exports,f=r(108),h=!u.JS_SHA3_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,p="0123456789abcdef".split(""),d=[4,1024,262144,67108864],y=[0,8,16,24],g=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],m=[224,256,384,512],v=[128,256],b=["hex","buffer","arrayBuffer","array","digest"],E={128:168,256:136};!u.JS_SHA3_NO_NODE_JS&&Array.isArray||(Array.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)}),!h||!u.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW&&ArrayBuffer.isView||(ArrayBuffer.isView=function(e){return"object"==typeof e&&e.buffer&&e.buffer.constructor===ArrayBuffer});for(var S=function(e,t,r){return function(n){return new D(e,t,e).update(n)[r]()}},T=function(e,t,r){return function(n,i){return new D(e,t,i).update(n)[r]()}},C=function(e,t,r){return function(t,n,i,a){return N["cshake"+e].update(t,n,i,a)[r]()}},A=function(e,t,r){return function(t,n,i,a){return N["kmac"+e].update(t,n,i,a)[r]()}},I=function(e,t,r,n){for(var i=0;i<b.length;++i){var a=b[i];e[a]=t(r,n,a)}return e},w=function(e,t){var r=S(e,t,"hex");return r.create=function(){return new D(e,t,e)},r.update=function(e){return r.create().update(e)},I(r,S,e,t)},B=[{name:"keccak",padding:[1,256,65536,16777216],bits:m,createMethod:w},{name:"sha3",padding:[6,1536,393216,100663296],bits:m,createMethod:w},{name:"shake",padding:[31,7936,2031616,520093696],bits:v,createMethod:function(e,t){var r=T(e,t,"hex");return r.create=function(r){return new D(e,t,r)},r.update=function(e,t){return r.create(t).update(e)},I(r,T,e,t)}},{name:"cshake",padding:d,bits:v,createMethod:function(e,t){var r=E[e],n=C(e,0,"hex");return n.create=function(n,i,a){return i||a?new D(e,t,n).bytepad([i,a],r):N["shake"+e].create(n)},n.update=function(e,t,r,i){return n.create(t,r,i).update(e)},I(n,C,e,t)}},{name:"kmac",padding:d,bits:v,createMethod:function(e,t){var r=E[e],n=A(e,0,"hex");return n.create=function(n,i,a){return new V(e,t,i).bytepad(["KMAC",a],r).bytepad([n],r)},n.update=function(e,t,r,i){return n.create(e,r,i).update(t)},I(n,A,e,t)}}],N={},R=[],_=0;_<B.length;++_)for(var P=B[_],O=P.bits,k=0;k<O.length;++k){var U=P.name+"_"+O[k];if(R.push(U),N[U]=P.createMethod(O[k],P.padding),"sha3"!==P.name){var L=P.name+O[k];R.push(L),N[L]=N[U]}}function D(e,t,r){this.blocks=[],this.s=[],this.padding=t,this.outputBits=r,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(e<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=r>>5,this.extraBytes=(31&r)>>3;for(var n=0;n<50;++n)this.s[n]=0}function V(e,t,r){D.call(this,e,t,r)}D.prototype.update=function(e){if(this.finalized)throw new Error("finalize already called");var t,r=typeof e;if("string"!==r){if("object"!==r)throw new Error(s);if(null===e)throw new Error(s);if(h&&e.constructor===ArrayBuffer)e=new Uint8Array(e);else if(!(Array.isArray(e)||h&&ArrayBuffer.isView(e)))throw new Error(s);t=!0}for(var n,i,a=this.blocks,o=this.byteCount,u=e.length,c=this.blockCount,l=0,f=this.s;l<u;){if(this.reset)for(this.reset=!1,a[0]=this.block,n=1;n<c+1;++n)a[n]=0;if(t)for(n=this.start;l<u&&n<o;++l)a[n>>2]|=e[l]<<y[3&n++];else for(n=this.start;l<u&&n<o;++l)(i=e.charCodeAt(l))<128?a[n>>2]|=i<<y[3&n++]:i<2048?(a[n>>2]|=(192|i>>6)<<y[3&n++],a[n>>2]|=(128|63&i)<<y[3&n++]):i<55296||i>=57344?(a[n>>2]|=(224|i>>12)<<y[3&n++],a[n>>2]|=(128|i>>6&63)<<y[3&n++],a[n>>2]|=(128|63&i)<<y[3&n++]):(i=65536+((1023&i)<<10|1023&e.charCodeAt(++l)),a[n>>2]|=(240|i>>18)<<y[3&n++],a[n>>2]|=(128|i>>12&63)<<y[3&n++],a[n>>2]|=(128|i>>6&63)<<y[3&n++],a[n>>2]|=(128|63&i)<<y[3&n++]);if(this.lastByteIndex=n,n>=o){for(this.start=n-o,this.block=a[c],n=0;n<c;++n)f[n]^=a[n];x(f),this.reset=!0}else this.start=n}return this},D.prototype.encode=function(e,t){var r=255&e,n=1,i=[r];for(r=255&(e>>=8);r>0;)i.unshift(r),r=255&(e>>=8),++n;return t?i.push(n):i.unshift(n),this.update(i),i.length},D.prototype.encodeString=function(e){var t,r=typeof e;if("string"!==r){if("object"!==r)throw new Error(s);if(null===e)throw new Error(s);if(h&&e.constructor===ArrayBuffer)e=new Uint8Array(e);else if(!(Array.isArray(e)||h&&ArrayBuffer.isView(e)))throw new Error(s);t=!0}var n=0,i=e.length;if(t)n=i;else for(var a=0;a<e.length;++a){var o=e.charCodeAt(a);o<128?n+=1:o<2048?n+=2:o<55296||o>=57344?n+=3:(o=65536+((1023&o)<<10|1023&e.charCodeAt(++a)),n+=4)}return n+=this.encode(8*n),this.update(e),n},D.prototype.bytepad=function(e,t){for(var r=this.encode(t),n=0;n<e.length;++n)r+=this.encodeString(e[n]);var i=t-r%t,a=[];return a.length=i,this.update(a),this},D.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var e=this.blocks,t=this.lastByteIndex,r=this.blockCount,n=this.s;if(e[t>>2]|=this.padding[3&t],this.lastByteIndex===this.byteCount)for(e[0]=e[r],t=1;t<r+1;++t)e[t]=0;for(e[r-1]|=2147483648,t=0;t<r;++t)n[t]^=e[t];x(n)}},D.prototype.toString=D.prototype.hex=function(){this.finalize();for(var e,t=this.blockCount,r=this.s,n=this.outputBlocks,i=this.extraBytes,a=0,s=0,o="";s<n;){for(a=0;a<t&&s<n;++a,++s)e=r[a],o+=p[e>>4&15]+p[15&e]+p[e>>12&15]+p[e>>8&15]+p[e>>20&15]+p[e>>16&15]+p[e>>28&15]+p[e>>24&15];s%t==0&&(x(r),a=0)}return i&&(e=r[a],o+=p[e>>4&15]+p[15&e],i>1&&(o+=p[e>>12&15]+p[e>>8&15]),i>2&&(o+=p[e>>20&15]+p[e>>16&15])),o},D.prototype.arrayBuffer=function(){this.finalize();var e,t=this.blockCount,r=this.s,n=this.outputBlocks,i=this.extraBytes,a=0,s=0,o=this.outputBits>>3;e=i?new ArrayBuffer(n+1<<2):new ArrayBuffer(o);for(var u=new Uint32Array(e);s<n;){for(a=0;a<t&&s<n;++a,++s)u[s]=r[a];s%t==0&&x(r)}return i&&(u[a]=r[a],e=e.slice(0,o)),e},D.prototype.buffer=D.prototype.arrayBuffer,D.prototype.digest=D.prototype.array=function(){this.finalize();for(var e,t,r=this.blockCount,n=this.s,i=this.outputBlocks,a=this.extraBytes,s=0,o=0,u=[];o<i;){for(s=0;s<r&&o<i;++s,++o)e=o<<2,t=n[s],u[e]=255&t,u[e+1]=t>>8&255,u[e+2]=t>>16&255,u[e+3]=t>>24&255;o%r==0&&x(n)}return a&&(e=o<<2,t=n[s],u[e]=255&t,a>1&&(u[e+1]=t>>8&255),a>2&&(u[e+2]=t>>16&255)),u},V.prototype=new D,V.prototype.finalize=function(){return this.encode(this.outputBits,!0),D.prototype.finalize.call(this)};var x=function(e){var t,r,n,i,a,s,o,u,c,l,f,h,p,d,y,m,v,b,E,S,T,C,A,I,w,B,N,R,_,P,O,k,U,L,D,V,x,K,M,j,F,q,z,G,H,Y,Q,W,X,$,J,Z,ee,te,re,ne,ie,ae,se,oe,ue,ce,le;for(n=0;n<48;n+=2)i=e[0]^e[10]^e[20]^e[30]^e[40],a=e[1]^e[11]^e[21]^e[31]^e[41],s=e[2]^e[12]^e[22]^e[32]^e[42],o=e[3]^e[13]^e[23]^e[33]^e[43],u=e[4]^e[14]^e[24]^e[34]^e[44],c=e[5]^e[15]^e[25]^e[35]^e[45],l=e[6]^e[16]^e[26]^e[36]^e[46],f=e[7]^e[17]^e[27]^e[37]^e[47],t=(h=e[8]^e[18]^e[28]^e[38]^e[48])^(s<<1|o>>>31),r=(p=e[9]^e[19]^e[29]^e[39]^e[49])^(o<<1|s>>>31),e[0]^=t,e[1]^=r,e[10]^=t,e[11]^=r,e[20]^=t,e[21]^=r,e[30]^=t,e[31]^=r,e[40]^=t,e[41]^=r,t=i^(u<<1|c>>>31),r=a^(c<<1|u>>>31),e[2]^=t,e[3]^=r,e[12]^=t,e[13]^=r,e[22]^=t,e[23]^=r,e[32]^=t,e[33]^=r,e[42]^=t,e[43]^=r,t=s^(l<<1|f>>>31),r=o^(f<<1|l>>>31),e[4]^=t,e[5]^=r,e[14]^=t,e[15]^=r,e[24]^=t,e[25]^=r,e[34]^=t,e[35]^=r,e[44]^=t,e[45]^=r,t=u^(h<<1|p>>>31),r=c^(p<<1|h>>>31),e[6]^=t,e[7]^=r,e[16]^=t,e[17]^=r,e[26]^=t,e[27]^=r,e[36]^=t,e[37]^=r,e[46]^=t,e[47]^=r,t=l^(i<<1|a>>>31),r=f^(a<<1|i>>>31),e[8]^=t,e[9]^=r,e[18]^=t,e[19]^=r,e[28]^=t,e[29]^=r,e[38]^=t,e[39]^=r,e[48]^=t,e[49]^=r,d=e[0],y=e[1],Y=e[11]<<4|e[10]>>>28,Q=e[10]<<4|e[11]>>>28,R=e[20]<<3|e[21]>>>29,_=e[21]<<3|e[20]>>>29,oe=e[31]<<9|e[30]>>>23,ue=e[30]<<9|e[31]>>>23,q=e[40]<<18|e[41]>>>14,z=e[41]<<18|e[40]>>>14,L=e[2]<<1|e[3]>>>31,D=e[3]<<1|e[2]>>>31,m=e[13]<<12|e[12]>>>20,v=e[12]<<12|e[13]>>>20,W=e[22]<<10|e[23]>>>22,X=e[23]<<10|e[22]>>>22,P=e[33]<<13|e[32]>>>19,O=e[32]<<13|e[33]>>>19,ce=e[42]<<2|e[43]>>>30,le=e[43]<<2|e[42]>>>30,te=e[5]<<30|e[4]>>>2,re=e[4]<<30|e[5]>>>2,V=e[14]<<6|e[15]>>>26,x=e[15]<<6|e[14]>>>26,b=e[25]<<11|e[24]>>>21,E=e[24]<<11|e[25]>>>21,$=e[34]<<15|e[35]>>>17,J=e[35]<<15|e[34]>>>17,k=e[45]<<29|e[44]>>>3,U=e[44]<<29|e[45]>>>3,I=e[6]<<28|e[7]>>>4,w=e[7]<<28|e[6]>>>4,ne=e[17]<<23|e[16]>>>9,ie=e[16]<<23|e[17]>>>9,K=e[26]<<25|e[27]>>>7,M=e[27]<<25|e[26]>>>7,S=e[36]<<21|e[37]>>>11,T=e[37]<<21|e[36]>>>11,Z=e[47]<<24|e[46]>>>8,ee=e[46]<<24|e[47]>>>8,G=e[8]<<27|e[9]>>>5,H=e[9]<<27|e[8]>>>5,B=e[18]<<20|e[19]>>>12,N=e[19]<<20|e[18]>>>12,ae=e[29]<<7|e[28]>>>25,se=e[28]<<7|e[29]>>>25,j=e[38]<<8|e[39]>>>24,F=e[39]<<8|e[38]>>>24,C=e[48]<<14|e[49]>>>18,A=e[49]<<14|e[48]>>>18,e[0]=d^~m&b,e[1]=y^~v&E,e[10]=I^~B&R,e[11]=w^~N&_,e[20]=L^~V&K,e[21]=D^~x&M,e[30]=G^~Y&W,e[31]=H^~Q&X,e[40]=te^~ne&ae,e[41]=re^~ie&se,e[2]=m^~b&S,e[3]=v^~E&T,e[12]=B^~R&P,e[13]=N^~_&O,e[22]=V^~K&j,e[23]=x^~M&F,e[32]=Y^~W&$,e[33]=Q^~X&J,e[42]=ne^~ae&oe,e[43]=ie^~se&ue,e[4]=b^~S&C,e[5]=E^~T&A,e[14]=R^~P&k,e[15]=_^~O&U,e[24]=K^~j&q,e[25]=M^~F&z,e[34]=W^~$&Z,e[35]=X^~J&ee,e[44]=ae^~oe&ce,e[45]=se^~ue&le,e[6]=S^~C&d,e[7]=T^~A&y,e[16]=P^~k&I,e[17]=O^~U&w,e[26]=j^~q&L,e[27]=F^~z&D,e[36]=$^~Z&G,e[37]=J^~ee&H,e[46]=oe^~ce&te,e[47]=ue^~le&re,e[8]=C^~d&m,e[9]=A^~y&v,e[18]=k^~I&B,e[19]=U^~w&N,e[28]=q^~L&V,e[29]=z^~D&x,e[38]=Z^~G&Y,e[39]=ee^~H&Q,e[48]=ce^~te&ne,e[49]=le^~re&ie,e[0]^=g[n],e[1]^=g[n+1]};if(l)e.exports=N;else{for(_=0;_<R.length;++_)u[R[_]]=N[R[_]];f&&(void 0===(a=function(){return N}.call(t,r,t,e))||(e.exports=a))}}()}).call(this,r(18),r(17))},function(e,t){(function(t){e.exports=t}).call(this,{})},function(e,t,r){"use strict";var n=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t};Object.defineProperty(t,"__esModule",{value:!0});var i=r(10),a=n(r(64)),s=r(19),o=r(54),u=r(23),c=r(14),l=r(22);function f(e,t){for(void 0===t&&(t=5e3);t--;){var r=i.stringToBytes(e);e=u.base16Encode(c.sha256(r))}return e}function h(e,t,r){void 0===r&&(r=48);for(var n=i.bytesToString(s.concat(e,t),"raw"),o="",u=o;u.length<r;)u+=o=a.create().update(o+n).digest().getBytes();return u}t.encryptSeed=function(e,t,r){var n=f(t,r),a=l.randomBytes(8),c=h(i.stringToBytes(n,"raw"),a),p=i.stringToBytes(c.slice(0,32),"raw"),d=i.stringToBytes(c.slice(32),"raw"),y=o.aesEncrypt(i.stringToBytes(e),p,"CBC",d);return u.base64Encode(s.concat(i.stringToBytes("Salted__"),a,y))},t.decryptSeed=function(e,t,r){var n=f(t,r),a=u.base64Decode(e),s=a.slice(8,16),c=h(i.stringToBytes(n,"raw"),s),l=i.stringToBytes(c.slice(0,32),"raw"),p=i.stringToBytes(c.slice(32),"raw");return i.bytesToString(o.aesDecrypt(a.slice(16),l,"CBC",p))}},function(e,t,r){"use strict";var n=this&&this.__read||function(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,i,a=r.call(e),s=[];try{for(;(void 0===t||t-- >0)&&!(n=a.next()).done;)s.push(n.value)}catch(e){i={error:e}}finally{try{n&&!n.done&&(r=a.return)&&r.call(a)}finally{if(i)throw i.error}}return s};Object.defineProperty(t,"__esModule",{value:!0});var i=r(14),a=r(19);t.merkleVerify=function(e,t,r){var s=Uint8Array.from([0]),o=Uint8Array.from([1]);if(32!==e.length)throw new Error("Failed to parse merkleProof: Invalid rootHash length");for(var u=i.blake2b(a.concat(s,r)),c=[],l=t.map((function(e){return e}));l.length>0;){var f=0===l[0]?"L":"R",h=l[1];if(h<1)throw new Error("Failed to parse merkleProof: Wrong hash size");var p=l.slice(2,2+h);c.push([f,p]),l=l.slice(2+h)}return c.reduce((function(e,t){var r=n(t,2),s=r[0],u=r[1];return i.blake2b(a.concat(o,"R"===s?a.concat(u,e):a.concat(e,u)))}),u).every((function(t,r){return t===e[r]}))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,i,a;t.Utf8ArrayToStr=(n=new Array(128),i=String.fromCodePoint||String.fromCharCode,a=[],function(e){var t,r,s=e.length;a.length=0;for(var o=0;o<s;)(r=e[o++])<=127?t=r:r<=223?t=(31&r)<<6|63&e[o++]:r<=239?t=(15&r)<<12|(63&e[o++])<<6|63&e[o++]:String.fromCodePoint?t=(7&r)<<18|(63&e[o++])<<12|(63&e[o++])<<6|63&e[o++]:(t=63,o+=3),a.push(n[t]||(n[t]=i(t)));return a.join("")})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e.INTEGER="integer",e.BOOLEAN="boolean",e.STRING="string",e.BINARY="binary"}(t.DATA_FIELD_TYPE||(t.DATA_FIELD_TYPE={})),t.anyOf=function(e,t){return new n(e,t)};class n{constructor(e,t){this._items=e,this.type="anyOf",this.discriminatorField="type",this.discriminatorBytePos=0,Object.assign(this,t)}itemByKey(e){const t=this._items.find(([t,r,n])=>n===e||t==e);return t&&{schema:t[1],key:t[0],strKey:t[2]}}itemByByteKey(e){const t=this._items.find(([t,r])=>t===e);return t&&{schema:t[1],key:t[0],strKey:t[2]||t[0].toString(10)}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(37),i=r(36),a=r(21);t.parserFromSchema=(e,r)=>(a,s=0)=>{let o=s;if("array"===e.type){const u=[],{value:c,shift:l}=(e.fromBytes||n.P_SHORT)(a,s);return o+=l,i.range(0,c).forEach(n=>{const i=t.parserFromSchema(e.items,r),{value:s,shift:c}=i(a,o);u.push(s),o+=c}),{value:u,shift:o-s}}if("object"===e.type){if(e.optional){const e=1===a[o];if(o+=1,!e)return{value:void 0,shift:1}}if(e.withLength){const t=e.withLength.fromBytes(a,o);o+=t.shift}const n={};return e.schema.forEach(e=>{const[i,s]=e,u=t.parserFromSchema(s,r),{value:c,shift:l}=u(a,o);o+=l,void 0!==c&&(Array.isArray(i)?Object.assign(n,c):n[i]=c)}),{value:n,shift:o-s}}if("anyOf"===e.type){const i=(e.fromBytes||n.P_BYTE)(a,o+e.discriminatorBytePos);e.valueField&&0===e.discriminatorBytePos&&(o+=i.shift);const u=e.itemByByteKey(i.value);if(null==u)throw new Error(`Failed to get schema for item with bytecode: ${i.value}`);const c=t.parserFromSchema(u.schema,r),{value:l,shift:f}=c(a,o);return o+=f,{value:e.valueField?{[e.discriminatorField]:u.strKey,[e.valueField]:l}:l,shift:o-s}}if("dataTxField"===e.type){const i=n.byteToStringWithLength(a,o);o+=i.shift;let s=n.P_BYTE(a,o);o+=s.shift;const u=[...e.items].find((e,t)=>t===s.value);if(!u)throw new Error(`Parser Error: Unknown dataTxField type: ${s.value}`);const c=t.parserFromSchema(u[1],r)(a,o);return{value:{value:c.value,key:i.value,type:u[0]},shift:c.shift+i.shift+s.shift}}if("primitive"===e.type||void 0===e.type){const t=e.fromBytes;let{value:i,shift:o}=t(a,s);return t===n.P_LONG&&r&&(i=r(i)),{value:i,shift:o}}throw new Error(`Parser Error: Unknown schema type: ${e.type}`)},t.parseHeader=e=>{let t=0,r=n.P_BYTE(e,t);t+=r.shift,0===r.value&&(r=n.P_BYTE(e,t),t+=r.shift);let i=n.P_BYTE(e,t);return{type:r.value,version:i.value}},t.parseTx=function(e,r){const{type:n,version:i}=t.parseHeader(e),s=a.getTransactionSchema(n,i);return t.parserFromSchema(s,r)(e).value},t.parseOrder=function(e,r){return t.parserFromSchema(a.orderSchemaV2,r)(e).value}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(115),{parse:i,stringify:a}=n(),s=r(21),o=r(26),u=r(3);function c(e,t){return 0===e.length?t:"object"==typeof t?c(e.slice(1),t[e[0]]):void 0}const l=(e,t,r)=>{return function t(n,i){if(null==i)return!1;if(0===n.length&&("primitive"===i.type||void 0===i.type))return i.toBytes===o.LONG;if("object"===i.type){const e=i.schema.find(([e,t])=>e===n[0]);return t(n.slice(1),e&&e[1])}if("array"===i.type)return t(n.slice(1),i.items);if("dataTxField"===i.type){if("value"!==n[0])return!1;const a=c(e.slice(0,e.length-1),r),s=i.items.get(a.type);return t(n.slice(1),s)}if("anyOf"===i.type){const a=c(e.slice(0,e.length-1),r)[i.discriminatorField],s=i.itemByKey(a);return!!s&&(null!=i.valueField&&e[e.length-1]===i.valueField?t(n.slice(1),s.schema):t(n,s.schema))}return!1}(e,t)};function f(e,t){const r=[],n=[];function i(s){return"string"==typeof s&&l(r,t,e)?s:"boolean"==typeof s||s instanceof Boolean||null===s||"number"==typeof s||s instanceof Number||"string"==typeof s||s instanceof String||s instanceof Date?JSON.stringify(s):Array.isArray(s)?function(e){let t="[";const a=n.length;n[a]=e;for(let n=0;n<e.length;n++){let s=n+"",o=e[n];void 0!==o&&"function"!=typeof o?(r[a]=s,t+=i(o)):t+="null",n<e.length-1&&(t+=",")}return n.length=a,r.length=a,t+="]",t}(s):s&&"object"==typeof s?function(e){let t=!0,s="{";const o=n.length;n[o]=e;for(let n in e)if(e.hasOwnProperty(n)){let u=e[n];a(u)&&(t?t=!1:s+=",",s+='"'+n+'":',r[o]=n,s+=i(u))}return n.length=o,r.length=o,s+="}",s}(s):void 0}function a(e){return void 0!==e&&"function"!=typeof e}return i(e)||""}t.stringifyWithSchema=f,t.parseTx=function(e,t){const r=i(e);return t?u.convertTxLongFields(r,t):r},t.stringifyTx=function(e,t){const{type:r,version:n}=e,i=s.getTransactionSchema(r,n);return f(u.convertLongFields(e,i,void 0,t),i)},t.parseOrder=function(e,t){const r=i(e),n=2===r.version?s.orderSchemaV2:s.orderSchemaV1;return t?u.convertLongFields(r,n,t):r},t.stringifyOrder=function(e,t){const r=2===e.version?s.orderSchemaV2:s.orderSchemaV1;return f(u.convertLongFields(e,r,void 0,t),r)}},function(e,t,r){"use strict";e.exports=function(e){var t={strict:!1};null!=e&&!0===e.strict&&(t.strict=!0);var r,n,i,a,s={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"},o=function(e){throw{name:"SyntaxError",message:e,at:r,text:i}},u=function(e){return e&&e!==n&&o("Expected '"+e+"' instead of '"+n+"'"),n=i.charAt(r),r+=1,n},c=function(){var t,r="";for("-"===n&&(r="-",u("-"));n>="0"&&n<="9";)r+=n,u();if("."===n)for(r+=".";u()&&n>="0"&&n<="9";)r+=n;if("e"===n||"E"===n)for(r+=n,u(),"-"!==n&&"+"!==n||(r+=n,u());n>="0"&&n<="9";)r+=n,u();return t=+r,e&&e.parse?e.parse(r):isFinite(t)?r.length>15?r:t:void o("Bad number")},l=function(){var e,t,r,i="";if('"'===n)for(;u();){if('"'===n)return u(),i;if("\\"===n)if(u(),"u"===n){for(r=0,t=0;t<4&&(e=parseInt(u(),16),isFinite(e));t+=1)r=16*r+e;i+=String.fromCharCode(r)}else{if("string"!=typeof s[n])break;i+=s[n]}else i+=n}o("Bad string")},f=function(){for(;n&&n<=" ";)u()};a=function(){switch(f(),n){case"{":return function(){var e,r={};if("{"===n){if(u("{"),f(),"}"===n)return u("}"),r;for(;n;){if(e=l(),f(),u(":"),!0===t.strict&&Object.hasOwnProperty.call(r,e)&&o('Duplicate key "'+e+'"'),r[e]=a(),f(),"}"===n)return u("}"),r;u(","),f()}}o("Bad object")}();case"[":return function(){var e=[];if("["===n){if(u("["),f(),"]"===n)return u("]"),e;for(;n;){if(e.push(a()),f(),"]"===n)return u("]"),e;u(","),f()}}o("Bad array")}();case'"':return l();case"-":return c();default:return n>="0"&&n<="9"?c():function(){switch(n){case"t":return u("t"),u("r"),u("u"),u("e"),!0;case"f":return u("f"),u("a"),u("l"),u("s"),u("e"),!1;case"n":return u("n"),u("u"),u("l"),u("l"),null}o("Unexpected '"+n+"'")}()}};var h,p,d,y=/[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,g={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};function m(e){return y.lastIndex=0,y.test(e)?'"'+e.replace(y,(function(e){var t=g[e];return"string"==typeof t?t:"\\u"+("0000"+e.charCodeAt(0).toString(16)).slice(-4)}))+'"':'"'+e+'"'}return{parse:function(e,t){var s;return i=e+"",r=0,n=" ",s=a(),f(),n&&o("Syntax error"),"function"==typeof t?function e(r,n){var i,a=r[n];return a&&"object"==typeof a&&Object.keys(a).forEach((function(t){void 0!==(i=e(a,t))?a[t]=i:delete a[t]})),t.call(r,n,a)}({"":s},""):s},stringify:function(t,r,n){var i;if(h="",p="","number"==typeof n)for(i=0;i<n;i+=1)p+=" ";else"string"==typeof n&&(p=n);if(d=r,r&&"function"!=typeof r&&("object"!=typeof r||"number"!=typeof r.length))throw new Error("JSON.stringify");return function t(r,n){var i,a,s,o,u,c=h,l=n[r],f=e&&e.isInstance&&e.isInstance(l);switch(f&&!l.isFinite()&&(l=null),f?l=e.stringify(l):l&&"object"==typeof l&&"function"==typeof l.toJSON&&(l=l.toJSON(r)),"function"==typeof d&&(l=d.call(n,r,l)),typeof l){case"string":return f?l:m(l);case"number":return isFinite(l)?String(l):"null";case"boolean":return String(l);case"object":if(!l)return"null";if(h+=p,u=[],"[object Array]"===Object.prototype.toString.apply(l)){for(o=l.length,i=0;i<o;i+=1)u[i]=t(i,l)||"null";return s=0===u.length?"[]":h?"[\n"+h+u.join(",\n"+h)+"\n"+c+"]":"["+u.join(",")+"]",h=c,s}if(d&&"object"==typeof d)for(o=d.length,i=0;i<o;i+=1)"string"==typeof d[i]&&(s=t(a=d[i],l))&&u.push(m(a)+(h?": ":":")+s);else for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(s=t(a,l))&&u.push(m(a)+(h?": ":":")+s);return s=0===u.length?"{}":h?"{\n"+h+u.join(",\n"+h)+"\n"+c+"}":"{"+u.join(",")+"}",h=c,s}}("",{"":t})}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.TRANSFER),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,2]),assetId:i.isAssetId,feeAssetId:i.isAssetId,recipient:i.isRecipient,amount:i.isNumberLike,attachment:i.isAttachment,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.transferValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.MASS_TRANSFER),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),transfers:i.validatePipe(i.isArray,i.pipe(i.prop("length"),i.gte(0)),e=>e.every(i.validatePipe(i.isRequired(!0),i.pipe(i.prop("recipient"),i.isRecipient),i.pipe(i.prop("amount"),i.isNumberLike)))),assetId:i.isAssetId,attachment:i.isAttachment,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.massTransferValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.ALIAS),version:i.orEq([void 0,2]),senderPublicKey:i.isPublicKey,alias:i.isValidAliasName,fee:i.isNumberLike,chainId:i.isNumber,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.aliasValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.BURN),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,2]),assetId:i.isAssetId,quantity:i.isNumberLike,chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.burnValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.CANCEL_LEASE),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,2]),leaseId:i.isAssetId,chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.cancelLeaseValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.DATA),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),data:e=>i.isArray(e)&&e.every(e=>i.isValidData(e)),fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.dataValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.SPONSORSHIP),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),assetId:i.isAssetId,minSponsoredAssetFee:i.isNumberLike,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.sponsorshipValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.SET_ASSET_SCRIPT),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),assetId:i.isAssetId,chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,script:i.isBase64,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.setAssetScriptValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.SET_SCRIPT),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,script:i.ifElse(i.isEq(null),i.defaultValue(!0),i.isBase64),proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.setScriptValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.REISSUE),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,2]),assetId:i.isAssetId,quantity:i.isNumberLike,reissuable:i.isBoolean,chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.reissueValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.ISSUE),version:i.orEq([void 0,2]),senderPublicKey:i.isPublicKey,name:i.isValidAssetName,description:i.isValidAssetDescription,quantity:i.isNumberLike,decimals:i.isNumber,reissuable:i.isBoolean,script:i.ifElse(i.isRequired(!0),i.isBase64,i.defaultValue(!0)),chainId:i.isNumber,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.issueValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.LEASE),version:i.orEq([void 0,2]),senderPublicKey:i.isPublicKey,recipient:i.isRecipient,amount:i.isNumberLike,fee:i.isNumberLike,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.leaseValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(6),a={type:i.isEq(n.TRANSACTION_TYPE.INVOKE_SCRIPT),senderPublicKey:i.isPublicKey,version:i.orEq([void 0,0,1]),dApp:i.isRecipient,call:i.ifElse(i.isRequired(!1),i.defaultValue(!0),i.validatePipe(i.pipe(i.prop("function"),i.isString),i.pipe(i.prop("function"),i.prop("length"),i.gte(0)),i.pipe(i.prop("args"),i.isArray),e=>e.every(i.validatePipe(i.isRequired(!0),i.isValidDataPair)))),payment:i.validatePipe(i.isArray,e=>e.every(i.validatePipe(i.pipe(i.prop("amount"),i.isNumberLike),i.pipe(i.prop("assetId"),i.isAssetId)))),fee:i.isNumberLike,feeAssetId:i.isAssetId,chainId:i.isNumber,timestamp:i.isNumber,proofs:i.ifElse(i.isArray,i.defaultValue(!0),i.orEq([void 0]))};t.invokeValidator=i.validateByShema(a,i.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(68),a=r(6),s={type:a.isEq(n.TRANSACTION_TYPE.EXCHANGE),senderPublicKey:a.isPublicKey,version:a.orEq([void 0,0,1,2]),order1:a.validatePipe(a.isRequired(!0),i.orderValidator),order2:a.validatePipe(a.isRequired(!0),i.orderValidator),amount:a.isNumberLike,price:a.isNumberLike,buyMatcherFee:a.isNumberLike,sellMatcherFee:a.isNumberLike,fee:a.isNumberLike,timestamp:a.isNumber,proofs:a.ifElse(a.isArray,a.defaultValue(!0),a.orEq([void 0]))};t.exchangeValidator=a.validateByShema(s,a.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),i={sender:n.isPublicKey,orderId:n.isHash,signature:n.isBase58,hash:n.isBase58};t.cancelOrderValidator=n.validateByShema(i,n.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),i={version:n.isEq(1),binary:n.isBase64},a={version:n.isEq(2),data:n.validatePipe(n.isArray,e=>e.every(n.validatePipe(n.isRequired(!0),n.isValidDataPair)))},s=n.validateByShema(i,n.getError),o=n.validateByShema(a,n.getError);t.customDataValidator=n.ifElse(n.pipe(n.prop("version"),n.isEq(1)),s,o)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),i={data:n.isString,host:n.isString};t.authValidator=n.validateByShema(i,n.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6),i={publicKey:n.isPublicKey,timestamp:n.isNumber};t.authValidator=n.validateByShema(i,n.getError)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=r(7),a=r(3),s=r(5);t.order=function(e,t){const r=i.isOrder(e)?e.assetPair.amountAsset:e.amountAsset,o=i.isOrder(e)?e.assetPair.priceAsset:e.priceAsset,u=i.isOrder(e)?e.proofs:[],{matcherFee:c,matcherPublicKey:l,price:f,amount:h,orderType:p,expiration:d,timestamp:y}=e,g=y||Date.now(),m=i.convertToPairs(t),v=e.senderPublicKey||i.getSenderPublicKey(m,e),b={orderType:p,version:null===e.version?void 0:e.version||2,assetPair:{amountAsset:r,priceAsset:o},price:f,amount:h,timestamp:g,expiration:d||g+25056e5,matcherFee:c||3e5,matcherPublicKey:l,senderPublicKey:v,proofs:u,id:""};3===b.version&&(b.matcherFeeAssetId="WAVES"===e.matcherFeeAssetId?null:e.matcherFeeAssetId);const E=a.binary.serializeOrder(b);return m.forEach(([e,t])=>i.addProof(b,n.signBytes(e,E),t)),s.validate.order(b),b.id=n.base58Encode(n.blake2b(E)),void 0!==b.version&&1!==b.version||(b.signature=b.proofs&&b.proofs[0]),b}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4),i=r(3),{BASE58_STRING:a}=i.serializePrimitives,s=r(7),o=r(5);t.cancelOrderParamsToBytes=e=>n.concat(a(e.sender),a(e.orderId)),t.cancelOrder=function(e,t){const r=s.convertToPairs(t),i=e.senderPublicKey||s.getSenderPublicKey(r,{senderPublicKey:void 0}),u=n.concat(a(i),a(e.orderId)),c=e.signature||null!=t&&n.signBytes(t,u)||"",l=n.base58Encode(n.blake2b(Uint8Array.from(u))),f={sender:i,orderId:e.orderId,signature:c,hash:l};return o.validate.cancelOrder(f),f}},function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const i=n(r(72)),a=r(3),s=r(4),o=r(0),u=r(44),c=r(45),l=r(38),f=r(39),h=r(41),p=r(42),d=r(43),y=r(27),g=r(46),m=r(47),v=r(7),b=r(48),E=r(40),S=r(49),T=r(50),C=r(69),A=r(70),I=r(71);function w(e){return v.isOrder(e)?a.binary.serializeOrder(e):a.binary.serializeTx(e)}t.txTypeMap={[o.TRANSACTION_TYPE.ISSUE]:{sign:(e,t)=>u.issue(e,t)},[o.TRANSACTION_TYPE.TRANSFER]:{sign:(e,t)=>c.transfer(e,t)},[o.TRANSACTION_TYPE.REISSUE]:{sign:(e,t)=>l.reissue(e,t)},[o.TRANSACTION_TYPE.BURN]:{sign:(e,t)=>f.burn(e,t)},[o.TRANSACTION_TYPE.LEASE]:{sign:(e,t)=>h.lease(e,t)},[o.TRANSACTION_TYPE.CANCEL_LEASE]:{sign:(e,t)=>p.cancelLease(e,t)},[o.TRANSACTION_TYPE.ALIAS]:{sign:(e,t)=>g.alias(e,t)},[o.TRANSACTION_TYPE.MASS_TRANSFER]:{sign:(e,t)=>y.massTransfer(e,t)},[o.TRANSACTION_TYPE.DATA]:{sign:(e,t)=>d.data(e,t)},[o.TRANSACTION_TYPE.SET_SCRIPT]:{sign:(e,t)=>m.setScript(e,t)},[o.TRANSACTION_TYPE.SET_ASSET_SCRIPT]:{sign:(e,t)=>b.setAssetScript(e,t)},[o.TRANSACTION_TYPE.SPONSORSHIP]:{sign:(e,t)=>S.sponsorship(e,t)},[o.TRANSACTION_TYPE.EXCHANGE]:{sign:(e,t)=>E.exchange(e,t)},[o.TRANSACTION_TYPE.INVOKE_SCRIPT]:{sign:(e,t)=>T.invokeScript(e,t)}},t.signTx=function(e,r){if(!t.txTypeMap[e.type])throw new Error(`Unknown tx type: ${e.type}`);return t.txTypeMap[e.type].sign(e,r)},t.serialize=w,t.verify=function(e,t=0,r){r=r||e.senderPublicKey;const n=w(e),i=null==e.version?e.signature:e.proofs[t];return s.verifySignature(r,n,i)},t.verifyCustomData=function(e){const t=C.serializeCustomData(e);return s.verifySignature(e.publicKey,t,e.signature)},t.verifyAuthData=function(e,t,r){r=r||"W";const n=A.serializeAuthData(t);return s.address({publicKey:e.publicKey},r)===e.address&&s.verifySignature(e.publicKey,n,e.signature)},t.verifyWavesAuthData=function(e,t,r){r=r||"W";const n=I.serializeWavesAuthData(t);return s.address({publicKey:e.publicKey},r)===e.address&&s.verifySignature(e.publicKey,n,e.signature)},t.submitOrder=function(e,t){let r,n;return"string"==typeof t?(n=t,r="matcher/orderbook"):(n=t.matcherUrl,r=t.market?"matcher/orderbook/market":"matcher/orderbook"),i.default.post(r,a.json.stringifyOrder(e),{baseURL:n,headers:{"content-type":"application/json"}}).then(e=>e.data).catch(e=>Promise.reject(e.response&&400===e.response.status?new Error(e.response.data.message):e))},t.cancelSubmittedOrder=function(e,t,r,n){return i.default.post(`matcher/orderbook/${t||"WAVES"}/${r||"WAVES"}/cancel`,JSON.stringify(e),{baseURL:n,headers:{"content-type":"application/json"}}).then(e=>e.data).catch(e=>Promise.reject(e.response&&400===e.response.status?new Error(e.response.data.message):e))}},function(e,t,r){"use strict";var n=r(8),i=r(73),a=r(139),s=r(79);function o(e){var t=new a(e),r=i(a.prototype.request,t);return n.extend(r,a.prototype,t),n.extend(r,t),r}var u=o(r(76));u.Axios=a,u.create=function(e){return o(s(u.defaults,e))},u.Cancel=r(80),u.CancelToken=r(151),u.isCancel=r(75),u.all=function(e){return Promise.all(e)},u.spread=r(152),e.exports=u,e.exports.default=u},function(e,t){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
e.exports=function(e){return null!=e&&null!=e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}},function(e,t,r){"use strict";var n=r(8),i=r(74),a=r(140),s=r(141),o=r(79);function u(e){this.defaults=e,this.interceptors={request:new a,response:new a}}u.prototype.request=function(e){"string"==typeof e?(e=arguments[1]||{}).url=arguments[0]:e=e||{},(e=o(this.defaults,e)).method=e.method?e.method.toLowerCase():"get";var t=[s,void 0],r=Promise.resolve(e);for(this.interceptors.request.forEach((function(e){t.unshift(e.fulfilled,e.rejected)})),this.interceptors.response.forEach((function(e){t.push(e.fulfilled,e.rejected)}));t.length;)r=r.then(t.shift(),t.shift());return r},u.prototype.getUri=function(e){return e=o(this.defaults,e),i(e.url,e.params,e.paramsSerializer).replace(/^\?/,"")},n.forEach(["delete","get","head","options"],(function(e){u.prototype[e]=function(t,r){return this.request(n.merge(r||{},{method:e,url:t}))}})),n.forEach(["post","put","patch"],(function(e){u.prototype[e]=function(t,r,i){return this.request(n.merge(i||{},{method:e,url:t,data:r}))}})),e.exports=u},function(e,t,r){"use strict";var n=r(8);function i(){this.handlers=[]}i.prototype.use=function(e,t){return this.handlers.push({fulfilled:e,rejected:t}),this.handlers.length-1},i.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)},i.prototype.forEach=function(e){n.forEach(this.handlers,(function(t){null!==t&&e(t)}))},e.exports=i},function(e,t,r){"use strict";var n=r(8),i=r(142),a=r(75),s=r(76),o=r(149),u=r(150);function c(e){e.cancelToken&&e.cancelToken.throwIfRequested()}e.exports=function(e){return c(e),e.baseURL&&!o(e.url)&&(e.url=u(e.baseURL,e.url)),e.headers=e.headers||{},e.data=i(e.data,e.headers,e.transformRequest),e.headers=n.merge(e.headers.common||{},e.headers[e.method]||{},e.headers||{}),n.forEach(["delete","get","head","post","put","patch","common"],(function(t){delete e.headers[t]})),(e.adapter||s.adapter)(e).then((function(t){return c(e),t.data=i(t.data,t.headers,e.transformResponse),t}),(function(t){return a(t)||(c(e),t&&t.response&&(t.response.data=i(t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)}))}},function(e,t,r){"use strict";var n=r(8);e.exports=function(e,t,r){return n.forEach(r,(function(r){e=r(e,t)})),e}},function(e,t,r){"use strict";var n=r(8);e.exports=function(e,t){n.forEach(e,(function(r,n){n!==t&&n.toUpperCase()===t.toUpperCase()&&(e[t]=r,delete e[n])}))}},function(e,t,r){"use strict";var n=r(78);e.exports=function(e,t,r){var i=r.config.validateStatus;!i||i(r.status)?e(r):t(n("Request failed with status code "+r.status,r.config,null,r.request,r))}},function(e,t,r){"use strict";e.exports=function(e,t,r,n,i){return e.config=t,r&&(e.code=r),e.request=n,e.response=i,e.isAxiosError=!0,e.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code}},e}},function(e,t,r){"use strict";var n=r(8),i=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];e.exports=function(e){var t,r,a,s={};return e?(n.forEach(e.split("\n"),(function(e){if(a=e.indexOf(":"),t=n.trim(e.substr(0,a)).toLowerCase(),r=n.trim(e.substr(a+1)),t){if(s[t]&&i.indexOf(t)>=0)return;s[t]="set-cookie"===t?(s[t]?s[t]:[]).concat([r]):s[t]?s[t]+", "+r:r}})),s):s}},function(e,t,r){"use strict";var n=r(8);e.exports=n.isStandardBrowserEnv()?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a");function i(e){var n=e;return t&&(r.setAttribute("href",n),n=r.href),r.setAttribute("href",n),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:"/"===r.pathname.charAt(0)?r.pathname:"/"+r.pathname}}return e=i(window.location.href),function(t){var r=n.isString(t)?i(t):t;return r.protocol===e.protocol&&r.host===e.host}}():function(){return!0}},function(e,t,r){"use strict";var n=r(8);e.exports=n.isStandardBrowserEnv()?{write:function(e,t,r,i,a,s){var o=[];o.push(e+"="+encodeURIComponent(t)),n.isNumber(r)&&o.push("expires="+new Date(r).toGMTString()),n.isString(i)&&o.push("path="+i),n.isString(a)&&o.push("domain="+a),!0===s&&o.push("secure"),document.cookie=o.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(e,t,r){"use strict";e.exports=function(e){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)}},function(e,t,r){"use strict";e.exports=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}},function(e,t,r){"use strict";var n=r(80);function i(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise((function(e){t=e}));var r=this;e((function(e){r.reason||(r.reason=new n(e),t(r.reason))}))}i.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},i.source=function(){var e;return{token:new i((function(t){e=t})),cancel:e}},e.exports=i},function(e,t,r){"use strict";e.exports=function(e){return function(t){return e.apply(null,t)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(0),i=r(44),a=r(45),s=r(38),o=r(39),u=r(41),c=r(42),l=r(46),f=r(27),h=r(43),p=r(47),d=r(48),y=r(49),g=r(40),m=r(50);t.makeTx=function(e){switch(e.type){case n.TRANSACTION_TYPE.ISSUE:return i.issue(e);case n.TRANSACTION_TYPE.TRANSFER:return a.transfer(e);case n.TRANSACTION_TYPE.REISSUE:return s.reissue(e);case n.TRANSACTION_TYPE.BURN:return o.burn(e);case n.TRANSACTION_TYPE.LEASE:return u.lease(e);case n.TRANSACTION_TYPE.CANCEL_LEASE:return c.cancelLease(e);case n.TRANSACTION_TYPE.ALIAS:return l.alias(e);case n.TRANSACTION_TYPE.MASS_TRANSFER:return f.massTransfer(e);case n.TRANSACTION_TYPE.DATA:return h.data(e);case n.TRANSACTION_TYPE.SET_SCRIPT:return p.setScript(e);case n.TRANSACTION_TYPE.SET_ASSET_SCRIPT:return d.setAssetScript(e);case n.TRANSACTION_TYPE.SPONSORSHIP:return y.sponsorship(e);case n.TRANSACTION_TYPE.EXCHANGE:return g.exchange(e);case n.TRANSACTION_TYPE.INVOKE_SCRIPT:return m.invokeScript(e);default:throw new Error(`Unknown tx type: ${e.type}`)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(4);t.encryptSeed=n.encryptSeed,t.decryptSeed=n.decryptSeed;const i=r(3);class a{constructor(e,t){if(e.length<12)throw new Error("Your seed length is less than allowed in config");this.phrase=e,this.address=n.address(e,t),this.keyPair={privateKey:n.privateKey(e),publicKey:n.publicKey(e)},Object.freeze(this),Object.freeze(this.keyPair)}encrypt(e,t){return a.encryptSeedPhrase(this.phrase,e,t)}static encryptSeedPhrase(e,t,r=5e3){if(t&&t.length,e.length<12)throw new Error("The seed phrase you are trying to encrypt is too short");return n.encryptSeed(e,t,r)}static decryptSeedPhrase(e,t,r=5e3){let i;try{i=n.decryptSeed(e,t,r)}catch(e){throw new Error("The password is wrong")}if(""===i||i.length<12)throw new Error("The password is wrong");return i}static create(e=15){const t=s(e);if(t.length<12)throw new Error("The resulted seed length is less than the minimum length (12)");return new a(t)}static fromExistingPhrase(e){if(e.length<12)throw new Error("The resulted seed length is less than the minimum length (12)");return new a(e)}}function s(e=15){return n.randomSeed(e)}t.Seed=a,t.generateNewSeed=s,t.strengthenPassword=function(e,t=5e3){for(;t--;){const t=i.serializePrimitives.STRING(e);e=n.base16Encode(n.sha256(t))}return e}}])}));

/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/Signer.js":
/*!******************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/Signer.js ***!
  \******************************************************/
/*! no static exports found */
/*! exports used: Signer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Signer", function() { return Signer; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@waves/signer/dist/es/constants.js");
/* harmony import */ var _waves_client_logs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @waves/client-logs */ "./node_modules/@waves/client-logs/dist/client-logs.min.js");
/* harmony import */ var _waves_client_logs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_waves_client_logs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _waves_node_api_js_cjs_api_node_addresses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @waves/node-api-js/cjs/api-node/addresses */ "./node_modules/@waves/node-api-js/cjs/api-node/addresses/index.js");
/* harmony import */ var _waves_node_api_js_cjs_api_node_addresses__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_waves_node_api_js_cjs_api_node_addresses__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _waves_node_api_js_cjs_api_node_assets__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @waves/node-api-js/cjs/api-node/assets */ "./node_modules/@waves/node-api-js/cjs/api-node/assets/index.js");
/* harmony import */ var _waves_node_api_js_cjs_api_node_assets__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_waves_node_api_js_cjs_api_node_assets__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _waves_node_api_js_cjs_tools_transactions_wait__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @waves/node-api-js/cjs/tools/transactions/wait */ "./node_modules/@waves/node-api-js/cjs/tools/transactions/wait.js");
/* harmony import */ var _waves_node_api_js_cjs_tools_transactions_wait__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_waves_node_api_js_cjs_tools_transactions_wait__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _waves_node_api_js_cjs_tools_transactions_broadcast__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @waves/node-api-js/cjs/tools/transactions/broadcast */ "./node_modules/@waves/node-api-js/cjs/tools/transactions/broadcast.js");
/* harmony import */ var _waves_node_api_js_cjs_tools_transactions_broadcast__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_waves_node_api_js_cjs_tools_transactions_broadcast__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _waves_node_api_js_cjs_tools_blocks_getNetworkByte__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @waves/node-api-js/cjs/tools/blocks/getNetworkByte */ "./node_modules/@waves/node-api-js/cjs/tools/blocks/getNetworkByte.js");
/* harmony import */ var _waves_node_api_js_cjs_tools_blocks_getNetworkByte__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_waves_node_api_js_cjs_tools_blocks_getNetworkByte__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @waves/ts-types */ "./node_modules/@waves/ts-types/dist/src/index.js");
/* harmony import */ var _waves_ts_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_waves_ts_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _validation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./validation */ "./node_modules/@waves/signer/dist/es/validation.js");
/* harmony import */ var _SignerError__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SignerError */ "./node_modules/@waves/signer/dist/es/SignerError.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers */ "./node_modules/@waves/signer/dist/es/helpers.js");
/* harmony import */ var _decorators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./decorators */ "./node_modules/@waves/signer/dist/es/decorators.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./types */ "./node_modules/@waves/signer/dist/es/types/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_13__);














var Signer = /** @class */ (function () {
    function Signer(options) {
        var _this_1 = this;
        var _a;
        this._issue = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].ISSUE }));
        }; };
        this._transfer = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].TRANSFER }));
        }; };
        this._reissue = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].REISSUE }));
        }; };
        this._burn = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].BURN }));
        }; };
        this._lease = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].LEASE }));
        }; };
        this._exchange = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].EXCHANGE }));
        }; };
        this._cancelLease = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].CANCEL_LEASE }));
        }; };
        this._alias = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].ALIAS }));
        }; };
        this._massTransfer = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].MASS_TRANSFER }));
        }; };
        this._data = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].DATA }));
        }; };
        this._sponsorship = function (txList) { return function (sponsorship) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, sponsorship), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].SPONSORSHIP }));
        }; };
        this._setScript = function (txList) { return function (setScript) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, setScript), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].SET_SCRIPT }));
        }; };
        this._setAssetScript = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].SET_ASSET_SCRIPT }));
        }; };
        this._invoke = function (txList) { return function (data) {
            return _this_1._createPipelineAPI(txList, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, data), { type: _waves_ts_types__WEBPACK_IMPORTED_MODULE_8__["TRANSACTION_TYPE"].INVOKE_SCRIPT }));
        }; };
        this._logger = Object(_waves_client_logs__WEBPACK_IMPORTED_MODULE_2__["makeConsole"])(Object(_waves_client_logs__WEBPACK_IMPORTED_MODULE_2__["makeOptions"])((_a = options === null || options === void 0 ? void 0 : options.LOG_LEVEL) !== null && _a !== void 0 ? _a : 'production', 'Signer'));
        this._handleError = Object(_helpers__WEBPACK_IMPORTED_MODULE_11__[/* errorHandlerFactory */ "a"])(this._logger);
        this._options = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, _constants__WEBPACK_IMPORTED_MODULE_1__[/* DEFAULT_OPTIONS */ "a"]), (options || {}));
        var _b = Object(_validation__WEBPACK_IMPORTED_MODULE_9__[/* validateSignerOptions */ "c"])(this._options), isValid = _b.isValid, invalidOptions = _b.invalidOptions;
        if (!isValid) {
            var error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].SIGNER_OPTIONS, [
                invalidOptions,
            ]);
            throw error;
        }
        var makeNetworkByteError = function (e) {
            var error = _this_1._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].NETWORK_BYTE, [
                {
                    error: e.message,
                    node: _this_1._options.NODE_URL,
                },
            ]);
            _this_1._logger.error(error);
            return error;
        };
        try {
            this._networkBytePromise = _waves_node_api_js_cjs_tools_blocks_getNetworkByte__WEBPACK_IMPORTED_MODULE_7___default()(this._options.NODE_URL).catch(function (e) { return Promise.reject(makeNetworkByteError(e)); });
        }
        catch (e) {
            throw makeNetworkByteError(e);
        }
        this._logger.info('Signer instance has been successfully created. Options: ', options);
    }
    Object.defineProperty(Signer.prototype, "_connectPromise", {
        get: function () {
            return this.__connectPromise || Promise.reject('Has no provider!');
        },
        set: function (promise) {
            this.__connectPromise = promise;
        },
        enumerable: false,
        configurable: true
    });
    Signer.prototype.on = function (event, handler) {
        this.currentProvider.on(event, handler);
        this._logger.info("Handler for \"" + event + "\" has been added.");
        return this;
    };
    Signer.prototype.once = function (event, handler) {
        this.currentProvider.once(event, handler);
        this._logger.info("One-Time handler for \"" + event + "\" has been added.");
        return this;
    };
    Signer.prototype.off = function (event, handler) {
        this.currentProvider.off(event, handler);
        this._logger.info("Handler for \"" + event + "\" has been removed.");
        return this;
    };
    Signer.prototype.broadcast = function (toBroadcast, options) {
        // @ts-ignore
        return _waves_node_api_js_cjs_tools_transactions_broadcast__WEBPACK_IMPORTED_MODULE_6___default()(this._options.NODE_URL, toBroadcast, options); // TODO поправить тип в broadcast
    };
    /**
     * Запросить байт сети
     */
    Signer.prototype.getNetworkByte = function () {
        return this._networkBytePromise;
    };
    /**
     * Устанавливаем провайдер отвечающий за подпись
     * @param provider
     *
     * ```ts
     * import Signer from '@waves/signer';
     * import Provider from '@waves/seed-provider';
     *
     * const waves = new Signer();
     * waves.setProvider(new Provider('SEED'));
     * ```
     */
    Signer.prototype.setProvider = function (provider) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "b"])(this, void 0, void 0, function () {
            var providerValidation, error;
            var _this_1 = this;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ "e"])(this, function (_a) {
                providerValidation = Object(_validation__WEBPACK_IMPORTED_MODULE_9__[/* validateProviderInterface */ "b"])(provider);
                if (!providerValidation.isValid) {
                    error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].PROVIDER_INTERFACE, [
                        providerValidation.invalidProperties,
                    ]);
                    throw error;
                }
                this.currentProvider = provider;
                this._logger.info('Provider has been set.');
                this._connectPromise = this._networkBytePromise.then(function (byte) {
                    return provider
                        .connect({
                        NETWORK_BYTE: byte,
                        NODE_URL: _this_1._options.NODE_URL,
                    })
                        .then(function () {
                        _this_1._logger.info('Provider has conneced to node.');
                        return provider;
                    })
                        .catch(function (e) {
                        var error = _this_1._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].PROVIDER_CONNECT, [
                            {
                                error: e.message,
                                node: _this_1._options.NODE_URL,
                            },
                        ]);
                        _this_1._logger.error(error);
                        return Promise.reject(error);
                    });
                });
                return [2 /*return*/];
            });
        });
    };
    /**
     * Получаем список балансов пользователя (необходимо выполнить login перед использованием)
     * Basic usage example:
     *
     * ```ts
     * await waves.getBalance(); // Возвращает балансы пользователя
     * ```
     */
    Signer.prototype.getBalance = function () {
        var _this_1 = this;
        return Promise.all([
            Object(_waves_node_api_js_cjs_api_node_addresses__WEBPACK_IMPORTED_MODULE_3__["fetchBalanceDetails"])(this._options.NODE_URL, this._userData.address).then(function (data) { return ({
                assetId: 'WAVES',
                assetName: 'Waves',
                decimals: 8,
                amount: String(data.available),
                isMyAsset: false,
                tokens: Number(data.available) * Math.pow(10, 8),
                sponsorship: null,
                isSmart: false,
            }); }),
            Object(_waves_node_api_js_cjs_api_node_assets__WEBPACK_IMPORTED_MODULE_4__["fetchAssetsBalance"])(this._options.NODE_URL, this._userData.address).then(function (data) {
                return data.balances.map(function (item) { return ({
                    assetId: item.assetId,
                    assetName: item.issueTransaction.name,
                    decimals: item.issueTransaction.decimals,
                    amount: String(item.balance),
                    isMyAsset: item.issueTransaction.sender ===
                        _this_1._userData.address,
                    tokens: item.balance *
                        Math.pow(10, item.issueTransaction.decimals),
                    isSmart: !!item.issueTransaction.script,
                    sponsorship: item.sponsorBalance != null &&
                        item.sponsorBalance > Math.pow(10, 8) &&
                        (item.minSponsoredAssetFee || 0) < item.balance
                        ? item.minSponsoredAssetFee
                        : null,
                }); });
            }),
        ]).then(function (_a) {
            var waves = _a[0], assets = _a[1];
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "f"])([waves], assets);
        });
    };
    /**
     * Получаем информацию о пользователе
     *
     * ```ts
     * await waves.login(); // Авторизуемся. Возвращает адрес и публичный ключ
     * ```
     */
    Signer.prototype.login = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "b"])(this, void 0, void 0, function () {
            var _a, err_1, error;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ "e"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._connectPromise];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        _a = this;
                        return [4 /*yield*/, this.currentProvider.login()];
                    case 3:
                        _a._userData = _b.sent();
                        this._logger.info('Logged in.');
                        return [2 /*return*/, this._userData];
                    case 4:
                        err_1 = _b.sent();
                        if (err_1 === 'Error: User rejection!') {
                            throw err_1;
                        }
                        error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].PROVIDER_INTERNAL, [
                            err_1.message,
                        ]);
                        throw error;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Вылогиниваемся из юзера
     */
    Signer.prototype.logout = function () {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __awaiter */ "b"])(this, void 0, void 0, function () {
            var _a, message, error;
            return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __generator */ "e"])(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._connectPromise];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.currentProvider.logout()];
                    case 3:
                        _b.sent();
                        this._userData = undefined;
                        this._logger.info('Logged out.');
                        return [3 /*break*/, 5];
                    case 4:
                        _a = _b.sent();
                        message = _a.message;
                        error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].PROVIDER_INTERNAL, message);
                        throw error;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Подписываем сообщение пользователя (провайдер может устанавливать префикс)
     * @param message
     */
    Signer.prototype.signMessage = function (message) {
        return this._connectPromise.then(function (provider) {
            return provider.signMessage(message);
        });
    };
    /**
     * Подписываем типизированные данные
     * @param data
     */
    Signer.prototype.signTypedData = function (data) {
        return this._connectPromise.then(function (provider) {
            return provider.signTypedData(data);
        });
    };
    /**
     * Получаем список балансов в кторых можно платить комиссию
     */
    Signer.prototype.getSponsoredBalances = function () {
        return this.getBalance().then(function (balance) {
            return balance.filter(function (item) { return !!item.sponsorship; });
        });
    };
    Signer.prototype.batch = function (tsx) {
        var _this_1 = this;
        var sign = function () {
            return _this_1._sign(tsx).then(function (result) { return result; });
        };
        return {
            sign: sign,
            broadcast: function (opt) {
                return sign().then(function (transactions) {
                    return _this_1.broadcast(transactions, opt);
                });
            },
        };
    };
    Signer.prototype.issue = function (data) {
        return this._issue([])(data);
    };
    Signer.prototype.transfer = function (data) {
        return this._transfer([])(data);
    };
    Signer.prototype.reissue = function (data) {
        return this._reissue([])(data);
    };
    Signer.prototype.burn = function (data) {
        return this._burn([])(data);
    };
    Signer.prototype.lease = function (data) {
        return this._lease([])(data);
    };
    Signer.prototype.exchange = function (data) {
        return this._exchange([])(data);
    };
    Signer.prototype.cancelLease = function (data) {
        return this._cancelLease([])(data);
    };
    Signer.prototype.alias = function (data) {
        return this._alias([])(data);
    };
    Signer.prototype.massTransfer = function (data) {
        return this._massTransfer([])(data);
    };
    Signer.prototype.data = function (data) {
        return this._data([])(data);
    };
    Signer.prototype.sponsorship = function (data) {
        return this._sponsorship([])(data);
    };
    Signer.prototype.setScript = function (data) {
        return this._setScript([])(data);
    };
    Signer.prototype.setAssetScript = function (data) {
        return this._setAssetScript([])(data);
    };
    Signer.prototype.invoke = function (data) {
        return this._invoke([])(data);
    };
    Signer.prototype.waitTxConfirm = function (tx, confirmations) {
        return _waves_node_api_js_cjs_tools_transactions_wait__WEBPACK_IMPORTED_MODULE_5___default()(this._options.NODE_URL, tx, { confirmations: confirmations }); // TODO Fix types
    };
    Signer.prototype._createPipelineAPI = function (prevCallTxList, signerTx) {
        var _this_1 = this;
        var _this = this;
        var txs = prevCallTxList.length
            ? Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "f"])(prevCallTxList, [signerTx]) : [signerTx];
        var chainArgs = Array.isArray(txs) ? txs : [txs];
        return Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, {
            issue: this._issue(chainArgs),
            transfer: this._transfer(chainArgs),
            reissue: this._reissue(chainArgs),
            burn: this._burn(chainArgs),
            lease: this._lease(chainArgs),
            exchange: this._exchange(chainArgs),
            cancelLease: this._cancelLease(chainArgs),
            alias: this._alias(chainArgs),
            massTransfer: this._massTransfer(chainArgs),
            data: this._data(chainArgs),
            sponsorship: this._sponsorship(chainArgs),
            setScript: this._setScript(chainArgs),
            setAssetScript: this._setAssetScript(chainArgs),
            invoke: this._invoke(chainArgs),
        }), { sign: function () { return _this_1._sign(txs); }, broadcast: function (options) {
                var _a;
                if (((_a = _this.currentProvider) === null || _a === void 0 ? void 0 : _a.isSignAndBroadcastByProvider) === true) {
                    return _this.currentProvider
                        .sign(txs);
                }
                else {
                    return this.sign()
                        // @ts-ignore
                        .then(function (txs) { return _this.broadcast(txs, options); });
                }
            } });
    };
    Signer.prototype._validate = function (toSign) {
        var signerTxs = Array.isArray(toSign) ? toSign : [toSign];
        var validateTx = function (tx) { return _validation__WEBPACK_IMPORTED_MODULE_9__[/* argsValidators */ "a"][tx.type](tx); };
        var knownTxPredicate = function (type) {
            return Object.keys(_validation__WEBPACK_IMPORTED_MODULE_9__[/* argsValidators */ "a"]).includes(String(type));
        };
        var unknownTxs = signerTxs.filter(function (_a) {
            var type = _a.type;
            return !knownTxPredicate(type);
        });
        var knownTxs = signerTxs.filter(function (_a) {
            var type = _a.type;
            return knownTxPredicate(type);
        });
        var invalidTxs = knownTxs
            .map(validateTx)
            .filter(function (_a) {
            var isValid = _a.isValid;
            return !isValid;
        });
        if (invalidTxs.length === 0 && unknownTxs.length === 0) {
            return { isValid: true, errors: [] };
        }
        else {
            return {
                isValid: false,
                errors: Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "f"])(invalidTxs.map(function (_a) {
                    var transaction = _a.transaction, scope = _a.method, invalidFields = _a.invalidFields;
                    return "Validation error for " + scope + " transaction: " + JSON.stringify(transaction) + ". Invalid arguments: " + (invalidFields === null || invalidFields === void 0 ? void 0 : invalidFields.join(', '));
                }), unknownTxs.map(function (tx) {
                    return "Validation error for transaction " + JSON.stringify(tx) + ". Unknown transaction type: " + tx.type;
                })),
            };
        }
    };
    Signer.prototype._sign = function (toSign) {
        var _a;
        var validation = this._validate(toSign);
        if (((_a = this.currentProvider) === null || _a === void 0 ? void 0 : _a.isSignAndBroadcastByProvider) === true) {
            var error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].PROVIDER_SIGN_NOT_SUPPORTED, [{
                    error: 'PROVIDER_SIGN_NOT_SUPPORTED',
                    node: this._options.NODE_URL,
                }]);
            throw error;
        }
        if (validation.isValid) {
            return this._connectPromise.then(function (provider) { return provider.sign(toSign); }
            // any fixes "Expression produces a union type that is too complex to
            );
        }
        else {
            var error = this._handleError(_SignerError__WEBPACK_IMPORTED_MODULE_10__[/* ERRORS */ "a"].API_ARGUMENTS, [
                validation.errors,
            ]);
            throw error;
        }
    };
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "on", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "once", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "off", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"],
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* checkAuth */ "b"]
    ], Signer.prototype, "getBalance", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "login", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "logout", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "signMessage", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* ensureProvider */ "c"]
    ], Signer.prototype, "signTypedData", null);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "c"])([
        _decorators__WEBPACK_IMPORTED_MODULE_12__[/* catchProviderError */ "a"]
    ], Signer.prototype, "_sign", null);
    return Signer;
}());

// eslint-disable-next-line import/no-default-export
/* unused harmony default export */ var _unused_webpack_default_export = (Signer);


/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/SignerError.js":
/*!***********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/SignerError.js ***!
  \***********************************************************/
/*! exports provided: ERRORS, SignerError, SignerOptionsError, SignerApiArgumentsError, SignerNetworkByteError, SignerProviderInterfaceError, SignerProviderConnectError, SignerProviderSignIsNotSupport, SignerEnsureProviderError, SignerProviderInternalError, SignerAuthError, SignerNetworkError */
/*! exports used: ERRORS, SignerApiArgumentsError, SignerAuthError, SignerEnsureProviderError, SignerError, SignerNetworkByteError, SignerNetworkError, SignerOptionsError, SignerProviderConnectError, SignerProviderInterfaceError, SignerProviderInternalError, SignerProviderSignIsNotSupport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ERRORS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return SignerError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return SignerOptionsError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SignerApiArgumentsError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return SignerNetworkByteError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return SignerProviderInterfaceError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return SignerProviderConnectError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return SignerProviderSignIsNotSupport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return SignerEnsureProviderError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SignerProviderInternalError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SignerAuthError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return SignerNetworkError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");

var REPOSITORY_URL = 'http://github.com/wavesplatform/signer';
var ERRORS = {
    SIGNER_OPTIONS: 1000,
    NETWORK_BYTE: 1001,
    NOT_AUTHORIZED: 1002,
    PROVIDER_CONNECT: 1003,
    ENSURE_PROVIDER: 1004,
    PROVIDER_INTERFACE: 1005,
    PROVIDER_INTERNAL: 1006,
    API_ARGUMENTS: 1007,
    NETWORK_ERROR: 1008,
    PROVIDER_SIGN_NOT_SUPPORTED: 1009,
};
var errorTemplate = function (error) {
    var details = error.details ? "    Details: " + error.details : undefined;
    var errorArgs = error.errorArgs
        ? "    ErrorArgs: " + error.errorArgs
        : undefined;
    return [
        "Signer error:",
        "    Title: " + error.title,
        "    Type: " + error.type,
        "    Code: " + error.code,
        errorArgs,
        details,
        "    More info: " + REPOSITORY_URL + "/README.md#error-codes",
    ]
        .filter(Boolean)
        .join('\n');
};
var SignerError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerError, _super);
    function SignerError(details) {
        var _this = _super.call(this, errorTemplate(details)) || this;
        _this.code = details.code;
        _this.type = details.type;
        // Set the prototype explicitly.
        Object.setPrototypeOf(_this, SignerError.prototype);
        return _this;
    }
    return SignerError;
}(Error));

var SignerOptionsError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerOptionsError, _super);
    function SignerOptionsError(args) {
        var _this = _super.call(this, {
            code: ERRORS.SIGNER_OPTIONS,
            title: 'Invalid signer options',
            type: 'validation',
            details: "\n        Invalid signer options: " + args.join(', '),
            errorArgs: args,
        }) || this;
        Object.setPrototypeOf(_this, SignerOptionsError.prototype);
        return _this;
    }
    return SignerOptionsError;
}(SignerError));

var SignerApiArgumentsError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerApiArgumentsError, _super);
    function SignerApiArgumentsError(args) {
        var _this = _super.call(this, {
            code: ERRORS.API_ARGUMENTS,
            title: 'Invalid api method arguments',
            type: 'validation',
            details: "\n        " + args.join('\n        '),
            errorArgs: args,
        }) || this;
        Object.setPrototypeOf(_this, SignerApiArgumentsError.prototype);
        return _this;
    }
    return SignerApiArgumentsError;
}(SignerError));

var SignerNetworkByteError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerNetworkByteError, _super);
    function SignerNetworkByteError(_a) {
        var error = _a.error, node = _a.node;
        var _this = _super.call(this, {
            code: ERRORS.NETWORK_BYTE,
            title: 'Network byte fetching has failed',
            type: 'network',
            details: "\n        Could not fetch network from " + node + ": " + error,
            errorArgs: { error: error, node: node },
        }) || this;
        Object.setPrototypeOf(_this, SignerNetworkByteError.prototype);
        return _this;
    }
    return SignerNetworkByteError;
}(SignerError));

var SignerProviderInterfaceError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerProviderInterfaceError, _super);
    function SignerProviderInterfaceError(invalidProperties) {
        var _this = _super.call(this, {
            code: ERRORS.NETWORK_BYTE,
            title: 'Invalid Provider interface',
            type: 'validation',
            details: "\n        Invalid provider properties: " + invalidProperties.join(', '),
            errorArgs: invalidProperties,
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderInterfaceError.prototype);
        return _this;
    }
    return SignerProviderInterfaceError;
}(SignerError));

var SignerProviderConnectError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerProviderConnectError, _super);
    function SignerProviderConnectError(_a) {
        var error = _a.error, node = _a.node;
        var _this = _super.call(this, {
            code: ERRORS.PROVIDER_CONNECT,
            title: 'Could not connect the Provider',
            type: 'network',
            errorArgs: { error: error, node: node },
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderConnectError.prototype);
        return _this;
    }
    return SignerProviderConnectError;
}(SignerError));

var SignerProviderSignIsNotSupport = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerProviderSignIsNotSupport, _super);
    function SignerProviderSignIsNotSupport(_a) {
        var error = _a.error, node = _a.node;
        var _this = _super.call(this, {
            code: ERRORS.PROVIDER_SIGN_NOT_SUPPORTED,
            title: 'Method sign is not support for this provider. Use broadcats instead',
            type: 'validation',
            errorArgs: { error: error, node: node },
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderSignIsNotSupport.prototype);
        return _this;
    }
    return SignerProviderSignIsNotSupport;
}(SignerError));

var SignerEnsureProviderError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerEnsureProviderError, _super);
    function SignerEnsureProviderError(method) {
        var _this = _super.call(this, {
            code: ERRORS.ENSURE_PROVIDER,
            title: 'Provider instance is missing',
            type: 'provider',
            details: "Can't use method: " + method + ". Provider instance is missing",
            errorArgs: { failedMethod: method },
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderConnectError.prototype);
        return _this;
    }
    return SignerEnsureProviderError;
}(SignerError));

var SignerProviderInternalError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerProviderInternalError, _super);
    function SignerProviderInternalError(message) {
        var _this = _super.call(this, {
            code: ERRORS.ENSURE_PROVIDER,
            title: 'Provider internal error',
            type: 'provider',
            details: "Provider internal error: " + message + ". This is not error of signer.",
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderConnectError.prototype);
        return _this;
    }
    return SignerProviderInternalError;
}(SignerError));

var SignerAuthError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerAuthError, _super);
    function SignerAuthError(method) {
        var _this = _super.call(this, {
            code: ERRORS.NOT_AUTHORIZED,
            title: 'Authorization error',
            type: 'authorization',
            details: "Can't use method: " + method + ". User must be logged in",
            errorArgs: { failedMethod: method },
        }) || this;
        Object.setPrototypeOf(_this, SignerProviderConnectError.prototype);
        return _this;
    }
    return SignerAuthError;
}(SignerError));

var SignerNetworkError = /** @class */ (function (_super) {
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(SignerNetworkError, _super);
    // TODO REMOVE ANY, ADD MORE DETAILS
    function SignerNetworkError(params) {
        return _super.call(this, {
            code: ERRORS.NETWORK_ERROR,
            title: 'Network Error',
            type: 'network',
            details: "Error connect to " + '',
            errorArgs: {},
        }) || this;
    }
    return SignerNetworkError;
}(SignerError));



/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/constants.js ***!
  \*********************************************************/
/*! exports provided: DEFAULT_OPTIONS, DEFAULT_BROADCAST_OPTIONS, MAX_ALIAS_LENGTH, SMART_ASSET_EXTRA_FEE */
/*! exports used: DEFAULT_OPTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_OPTIONS; });
/* unused harmony export DEFAULT_BROADCAST_OPTIONS */
/* unused harmony export MAX_ALIAS_LENGTH */
/* unused harmony export SMART_ASSET_EXTRA_FEE */
var DEFAULT_OPTIONS = {
    NODE_URL: 'https://nodes.wavesplatform.com',
    LOG_LEVEL: 'production',
};
var DEFAULT_BROADCAST_OPTIONS = {
    chain: false,
    confirmations: -1,
};
var MAX_ALIAS_LENGTH = 30;
var SMART_ASSET_EXTRA_FEE = 0.004 * Math.pow(10, 8);


/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/decorators.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/decorators.js ***!
  \**********************************************************/
/*! exports provided: ensureProvider, catchProviderError, checkAuth, catchNetworkErrors */
/*! exports used: catchProviderError, checkAuth, ensureProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ensureProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return catchProviderError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return checkAuth; });
/* unused harmony export catchNetworkErrors */
/* harmony import */ var _SignerError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignerError */ "./node_modules/@waves/signer/dist/es/SignerError.js");

var getErrorHandler = function (signer) {
    return signer._handleError;
};
var ensureProvider = function (target, propertyKey, descriptor) {
    var origin = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var provider = this.currentProvider;
        if (!provider) {
            var handler = getErrorHandler(this);
            var error = handler(_SignerError__WEBPACK_IMPORTED_MODULE_0__[/* ERRORS */ "a"].ENSURE_PROVIDER, [propertyKey]);
            throw error;
        }
        return origin.apply(this, args);
    };
};
var catchProviderError = function (target, propertyKey, descriptor) {
    var origin = descriptor.value;
    descriptor.value = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return origin.apply(this, args).catch(function (e) {
            if (e === 'Error: User rejection!') {
                return Promise.reject(e);
            }
            if (e instanceof _SignerError__WEBPACK_IMPORTED_MODULE_0__[/* SignerError */ "e"]) {
                return Promise.reject(e);
            }
            var handler = getErrorHandler(_this);
            var error = handler(_SignerError__WEBPACK_IMPORTED_MODULE_0__[/* ERRORS */ "a"].PROVIDER_INTERNAL, [e.message]);
            _this._console.error(error);
            return Promise.reject(e);
        });
    };
};
var checkAuth = function (target, propertyKey, descriptor) {
    var origin = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.currentProvider.user == null) {
            var handler = getErrorHandler(this);
            var error = handler(_SignerError__WEBPACK_IMPORTED_MODULE_0__[/* ERRORS */ "a"].NOT_AUTHORIZED, [propertyKey]);
            throw error;
        }
        return origin.apply(this, args);
    };
};
var catchNetworkErrors = function (checkData) { return function (target, propertyKey, descriptor) {
    var origin = descriptor.value;
    descriptor.value = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (checkData.isMatcher) {
            // TODO
            // if (!this._options.MATCHER_URL) {
            //     const error = new SignerError(
            //         ERROR_CODE_MAP.NO_MATCHER_URL_PROVIDED,
            //         void 0
            //     );
            //
            //     this._console.error(error);
            //
            //     return Promise.reject(error);
            // }
        }
        return origin.apply(this, args).catch(function (e) {
            if (e instanceof _SignerError__WEBPACK_IMPORTED_MODULE_0__[/* SignerError */ "e"]) {
                return Promise.reject(e);
            }
            var handler = getErrorHandler(_this);
            // TODO Provide more details for request error!
            var error = handler(_SignerError__WEBPACK_IMPORTED_MODULE_0__[/* ERRORS */ "a"].NETWORK_ERROR, [{}]);
            _this._console.error(error);
            return Promise.reject(error);
        });
    };
}; };


/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/helpers.js ***!
  \*******************************************************/
/*! exports provided: errorHandlerFactory */
/*! exports used: errorHandlerFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return errorHandlerFactory; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _SignerError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SignerError */ "./node_modules/@waves/signer/dist/es/SignerError.js");
var _a;


var ERRORS_MAP = (_a = {},
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].SIGNER_OPTIONS] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerOptionsError */ "h"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].NETWORK_BYTE] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerNetworkByteError */ "f"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].PROVIDER_INTERFACE] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerProviderInterfaceError */ "j"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].API_ARGUMENTS] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerApiArgumentsError */ "b"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].PROVIDER_CONNECT] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerProviderConnectError */ "i"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].PROVIDER_SIGN_NOT_SUPPORTED] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerProviderSignIsNotSupport */ "l"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].ENSURE_PROVIDER] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerEnsureProviderError */ "d"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].PROVIDER_INTERNAL] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerProviderInternalError */ "k"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].NOT_AUTHORIZED] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerAuthError */ "c"],
    _a[_SignerError__WEBPACK_IMPORTED_MODULE_1__[/* ERRORS */ "a"].NETWORK_ERROR] = _SignerError__WEBPACK_IMPORTED_MODULE_1__[/* SignerNetworkError */ "g"],
    _a);
var errorHandlerFactory = function (logger) { return function (errorCode, parameters) {
    var _a;
    var error = new ((_a = ERRORS_MAP[errorCode]).bind.apply(_a, Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __spreadArrays */ "f"])([void 0], (parameters || []))))();
    logger.log(error.toString());
    throw error;
}; };


/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/index.js ***!
  \*****************************************************/
/*! no static exports found */
/*! exports used: Signer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _types_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types/api */ "./node_modules/@waves/signer/dist/es/types/api.js");
/* harmony import */ var _types_api__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_types_api__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_types_api__WEBPACK_IMPORTED_MODULE_0__, "Signer")) __webpack_require__.d(__webpack_exports__, "Signer", function() { return _types_api__WEBPACK_IMPORTED_MODULE_0__["Signer"]; });

/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/index */ "./node_modules/@waves/signer/dist/es/types/index.js");
/* harmony import */ var _types_index__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_types_index__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (checked) */ if(__webpack_require__.o(_types_index__WEBPACK_IMPORTED_MODULE_1__, "Signer")) __webpack_require__.d(__webpack_exports__, "Signer", function() { return _types_index__WEBPACK_IMPORTED_MODULE_1__["Signer"]; });

/* harmony import */ var _Signer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Signer */ "./node_modules/@waves/signer/dist/es/Signer.js");
/* harmony reexport (checked) */ if(__webpack_require__.o(_Signer__WEBPACK_IMPORTED_MODULE_2__, "Signer")) __webpack_require__.d(__webpack_exports__, "Signer", function() { return _Signer__WEBPACK_IMPORTED_MODULE_2__["Signer"]; });

/* harmony reexport (checked) */ if(__webpack_require__.o(_types_api__WEBPACK_IMPORTED_MODULE_0__, "Signer")) __webpack_require__.d(__webpack_exports__, "Signer", function() { return _types_api__WEBPACK_IMPORTED_MODULE_0__["Signer"]; });

/* harmony reexport (checked) */ if(__webpack_require__.o(_types_index__WEBPACK_IMPORTED_MODULE_1__, "Signer")) __webpack_require__.d(__webpack_exports__, "Signer", function() { return _types_index__WEBPACK_IMPORTED_MODULE_1__["Signer"]; });








/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/types/api.js":
/*!*********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/types/api.js ***!
  \*********************************************************/
/*! no static exports found */
/*! exports used: Signer */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/types/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/types/index.js ***!
  \***********************************************************/
/*! no static exports found */
/*! exports used: Signer */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/validation.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/validation.js ***!
  \**********************************************************/
/*! exports provided: validator, issueArgsScheme, issueArgsValidator, transferArgsScheme, transferArgsValidator, reissueArgsScheme, reissueArgsValidator, burnArgsScheme, burnArgsValidator, leaseArgsScheme, leaseArgsValidator, cancelLeaseArgsScheme, cancelLeaseArgsValidator, aliasArgsScheme, aliasArgsValidator, massTransferArgsScheme, massTransferArgsValidator, dataArgsScheme, dataArgsValidator, setScriptArgsScheme, setScriptArgsValidator, sponsorshipArgsScheme, sponsorshipArgsValidator, exchangeArgsScheme, exchangeArgsValidator, setAssetScriptArgsScheme, setAssetScriptArgsValidator, invokeArgsScheme, invokeArgsValidator, argsValidators, validateSignerOptions, validateProviderInterface */
/*! exports used: argsValidators, validateProviderInterface, validateSignerOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export validator */
/* unused harmony export issueArgsScheme */
/* unused harmony export issueArgsValidator */
/* unused harmony export transferArgsScheme */
/* unused harmony export transferArgsValidator */
/* unused harmony export reissueArgsScheme */
/* unused harmony export reissueArgsValidator */
/* unused harmony export burnArgsScheme */
/* unused harmony export burnArgsValidator */
/* unused harmony export leaseArgsScheme */
/* unused harmony export leaseArgsValidator */
/* unused harmony export cancelLeaseArgsScheme */
/* unused harmony export cancelLeaseArgsValidator */
/* unused harmony export aliasArgsScheme */
/* unused harmony export aliasArgsValidator */
/* unused harmony export massTransferArgsScheme */
/* unused harmony export massTransferArgsValidator */
/* unused harmony export dataArgsScheme */
/* unused harmony export dataArgsValidator */
/* unused harmony export setScriptArgsScheme */
/* unused harmony export setScriptArgsValidator */
/* unused harmony export sponsorshipArgsScheme */
/* unused harmony export sponsorshipArgsValidator */
/* unused harmony export exchangeArgsScheme */
/* unused harmony export exchangeArgsValidator */
/* unused harmony export setAssetScriptArgsScheme */
/* unused harmony export setAssetScriptArgsValidator */
/* unused harmony export invokeArgsScheme */
/* unused harmony export invokeArgsValidator */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return argsValidators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validateSignerOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return validateProviderInterface; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ramda/src/defaultTo */ "./node_modules/ramda/src/defaultTo.js");
/* harmony import */ var ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ramda_src_prop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ramda/src/prop */ "./node_modules/ramda/src/prop.js");
/* harmony import */ var ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ramda/src/ifElse */ "./node_modules/ramda/src/ifElse.js");
/* harmony import */ var ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ramda/src/pipe */ "./node_modules/ramda/src/pipe.js");
/* harmony import */ var ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ramda_src_equals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ramda/src/equals */ "./node_modules/ramda/src/equals.js");
/* harmony import */ var ramda_src_equals__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ramda_src_equals__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ramda_src_lte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ramda/src/lte */ "./node_modules/ramda/src/lte.js");
/* harmony import */ var ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ramda_src_lte__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ramda_src_not__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ramda/src/not */ "./node_modules/ramda/src/not.js");
/* harmony import */ var ramda_src_not__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ramda_src_not__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _validators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./validators */ "./node_modules/@waves/signer/dist/es/validators.js");
/* harmony import */ var _waves_ts_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @waves/ts-types */ "./node_modules/@waves/ts-types/dist/src/index.js");
/* harmony import */ var _waves_ts_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__);
var _a;










var shouldValidate = ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_equals__WEBPACK_IMPORTED_MODULE_5___default()(undefined), ramda_src_not__WEBPACK_IMPORTED_MODULE_7___default.a);
var validateOptional = function (validator) {
    return ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_3___default()(shouldValidate, validator, ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_1___default()(true));
};
// waves-transaction validator can't collect errors for each invalid field.
// This method does.
var validator = function (scheme, method) { return function (transaction) {
    var _a;
    var invalidFields = [];
    for (var _i = 0, _b = Object.entries(scheme); _i < _b.length; _i++) {
        var _c = _b[_i], fieldName = _c[0], validationScheme = _c[1];
        try {
            Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validateBySchema */ "s"])((_a = {}, _a[fieldName] = validationScheme, _a), 
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            _validators__WEBPACK_IMPORTED_MODULE_8__[/* noop */ "p"])(transaction);
        }
        catch (error) {
            invalidFields.push(fieldName);
        }
    }
    return {
        isValid: invalidFields.length === 0,
        transaction: transaction,
        method: method,
        invalidFields: invalidFields,
    };
}; };
var getCommonValidators = function (transactionType) { return ({
    type: ramda_src_equals__WEBPACK_IMPORTED_MODULE_5___default()(transactionType),
    version: validateOptional(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* orEq */ "q"])([undefined, 1, 2, 3])),
    senderPublicKey: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isPublicKey */ "h"]),
    fee: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"]),
    proofs: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"]),
}); };
var issueArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].ISSUE)), { name: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isValidAssetName */ "n"], description: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isValidAssetDescription */ "m"]), quantity: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], decimals: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"], reissuable: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isBoolean */ "e"]), script: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isBase64 */ "d"]), chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var issueArgsValidator = validator(issueArgsScheme, 'issue');
var transferArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].TRANSFER)), { amount: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], recipient: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isRecipient */ "i"], assetId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"]), feeAssetId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"]), attachment: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAttachment */ "c"]) });
var transferArgsValidator = validator(transferArgsScheme, 'transfer');
var reissueArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].REISSUE)), { assetId: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"], quantity: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], reissuable: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isBoolean */ "e"], chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var reissueArgsValidator = validator(reissueArgsScheme, 'reissue');
var burnArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].BURN)), { 
    // TODO isAssetId (not WAVES)
    assetId: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "k"], amount: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var burnArgsValidator = validator(burnArgsScheme, 'burn');
var leaseArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].LEASE)), { amount: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], recipient: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isRecipient */ "i"] });
var leaseArgsValidator = validator(leaseArgsScheme, 'lease');
var cancelLeaseArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].CANCEL_LEASE)), { leaseId: ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "k"]), chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var cancelLeaseArgsValidator = validator(cancelLeaseArgsScheme, 'cancel lease');
var aliasArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].ALIAS)), { alias: function (value) {
        return typeof value === 'string' ? Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isValidAliasName */ "l"])(value) : false;
    } });
var aliasArgsValidator = validator(aliasArgsScheme, 'alias');
var massTransferArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].MASS_TRANSFER)), { transfers: Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"], ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('length'), ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default()(0)), function (data) {
        return data.every(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isRequired */ "j"])(true), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('recipient'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isRecipient */ "i"]), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('amount'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"])));
    }), assetId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"]), attachment: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAttachment */ "c"]) });
var massTransferArgsValidator = validator(massTransferArgsScheme, 'mass transfer');
var dataArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].DATA)), { data: function (data) {
        return Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"])(data) && data.every(function (item) { return Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isValidData */ "o"])(item); });
    } });
var dataArgsValidator = validator(dataArgsScheme, 'data'); // TODO fix any
var setScriptArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SET_SCRIPT)), { script: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isBase64 */ "d"], chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var setScriptArgsValidator = validator(setScriptArgsScheme, 'set script');
var sponsorshipArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SPONSORSHIP)), { 
    // TODO Add not WAVES ASSET ID
    assetId: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "k"], minSponsoredAssetFee: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"] });
var sponsorshipArgsValidator = validator(sponsorshipArgsScheme, 'sponsorship');
var exchangeArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].EXCHANGE)), { order1: Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isRequired */ "j"])(true), _validators__WEBPACK_IMPORTED_MODULE_8__[/* orderValidator */ "r"]), order2: Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isRequired */ "j"])(true), _validators__WEBPACK_IMPORTED_MODULE_8__[/* orderValidator */ "r"]), amount: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], price: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], buyMatcherFee: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"], sellMatcherFee: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"] });
var exchangeArgsValidator = validator(exchangeArgsScheme, 'exchange');
var setAssetScriptArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SET_ASSET_SCRIPT)), { script: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isBase64 */ "d"], assetId: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"], chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var setAssetScriptArgsValidator = validator(setAssetScriptArgsScheme, 'set asset script');
var invokeArgsScheme = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __assign */ "a"])({}, getCommonValidators(_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].INVOKE_SCRIPT)), { dApp: _validators__WEBPACK_IMPORTED_MODULE_8__[/* isRecipient */ "i"], call: validateOptional(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('function'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "k"]), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('function'), ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('length'), ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default()(0)), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('args'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"]))), payment: validateOptional(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isArray */ "a"], function (data) {
        return data.every(Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* validatePipe */ "t"])(ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('amount'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumberLike */ "g"]), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_4___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_2___default()('assetId'), _validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"])));
    })), feeAssetId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isAssetId */ "b"]), chainId: validateOptional(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isNumber */ "f"]) });
var invokeArgsValidator = validator(invokeArgsScheme, 'invoke');
var argsValidators = (_a = {},
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].ISSUE] = issueArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].TRANSFER] = transferArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].REISSUE] = reissueArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].BURN] = burnArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].LEASE] = leaseArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].CANCEL_LEASE] = cancelLeaseArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].ALIAS] = aliasArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].MASS_TRANSFER] = massTransferArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].DATA] = dataArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SET_SCRIPT] = setScriptArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SPONSORSHIP] = sponsorshipArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].EXCHANGE] = exchangeArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].SET_ASSET_SCRIPT] = setAssetScriptArgsValidator,
    _a[_waves_ts_types__WEBPACK_IMPORTED_MODULE_9__["TRANSACTION_TYPE"].INVOKE_SCRIPT] = invokeArgsValidator,
    _a);
var validateSignerOptions = function (options) {
    var res = {
        isValid: true,
        invalidOptions: [],
    };
    var isValidLogLevel = function (level) {
        return ['verbose', 'production', 'error'].includes(String(level));
    };
    if (!Object(_validators__WEBPACK_IMPORTED_MODULE_8__[/* isString */ "k"])(options.NODE_URL)) {
        res.isValid = false;
        res.invalidOptions.push('NODE_URL');
    }
    if (!validateOptional(isValidLogLevel)(options.LOG_LEVEL)) {
        res.isValid = false;
        res.invalidOptions.push('debug');
    }
    return res;
};
var validateProviderInterface = function (provider) {
    var isFunction = function (value) { return typeof value === 'function'; };
    var scheme = {
        connect: isFunction,
        login: isFunction,
        logout: isFunction,
        signMessage: isFunction,
        signTypedData: isFunction,
        sign: isFunction,
    };
    var invalidProperties = [];
    for (var _i = 0, _a = Object.entries(scheme); _i < _a.length; _i++) {
        var _b = _a[_i], fieldName = _b[0], validator_1 = _b[1];
        if (!validator_1(provider[fieldName])) {
            invalidProperties.push(fieldName);
        }
    }
    return {
        isValid: invalidProperties.length === 0,
        invalidProperties: invalidProperties,
    };
};


/***/ }),

/***/ "./node_modules/@waves/signer/dist/es/validators.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/signer/dist/es/validators.js ***!
  \**********************************************************/
/*! exports provided: isArray, validatePipe, isRequired, isString, isNumber, isNumberLike, isBoolean, orEq, exception, validateBySchema, isAttachment, isValidAliasName, ASSETS, isBase64, validateType, isValidDataPair, isValidData, isPublicKey, isValidAssetName, isValidAssetDescription, isAssetId, isAlias, isValidAddress, isValidAlias, isRecipient, noop, orderValidator */
/*! exports used: isArray, isAssetId, isAttachment, isBase64, isBoolean, isNumber, isNumberLike, isPublicKey, isRecipient, isRequired, isString, isValidAliasName, isValidAssetDescription, isValidAssetName, isValidData, noop, orEq, orderValidator, validateBySchema, validatePipe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return validatePipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isRequired; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isNumberLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return orEq; });
/* unused harmony export exception */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return validateBySchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isAttachment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return isValidAliasName; });
/* unused harmony export ASSETS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isBase64; });
/* unused harmony export validateType */
/* unused harmony export isValidDataPair */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return isValidData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isPublicKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return isValidAssetName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return isValidAssetDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isAssetId; });
/* unused harmony export isAlias */
/* unused harmony export isValidAddress */
/* unused harmony export isValidAlias */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return isRecipient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return noop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return orderValidator; });
/* harmony import */ var ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ramda/src/defaultTo */ "./node_modules/ramda/src/defaultTo.js");
/* harmony import */ var ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ramda_src_prop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ramda/src/prop */ "./node_modules/ramda/src/prop.js");
/* harmony import */ var ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ramda/src/ifElse */ "./node_modules/ramda/src/ifElse.js");
/* harmony import */ var ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ramda/src/pipe */ "./node_modules/ramda/src/pipe.js");
/* harmony import */ var ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ramda_src_equals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ramda/src/equals */ "./node_modules/ramda/src/equals.js");
/* harmony import */ var ramda_src_equals__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ramda_src_equals__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ramda_src_gte__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ramda/src/gte */ "./node_modules/ramda/src/gte.js");
/* harmony import */ var ramda_src_gte__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ramda_src_gte__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ramda_src_lte__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ramda/src/lte */ "./node_modules/ramda/src/lte.js");
/* harmony import */ var ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ramda_src_lte__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ramda_src_startsWith__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ramda/src/startsWith */ "./node_modules/ramda/src/startsWith.js");
/* harmony import */ var ramda_src_startsWith__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ramda_src_startsWith__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ramda_src_isNil__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ramda/src/isNil */ "./node_modules/ramda/src/isNil.js");
/* harmony import */ var ramda_src_isNil__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ramda_src_isNil__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ramda_src_includes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ramda/src/includes */ "./node_modules/ramda/src/includes.js");
/* harmony import */ var ramda_src_includes__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ramda_src_includes__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ramda_src_flip__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ramda/src/flip */ "./node_modules/ramda/src/flip.js");
/* harmony import */ var ramda_src_flip__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ramda_src_flip__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ramda_src_always__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ramda/src/always */ "./node_modules/ramda/src/always.js");
/* harmony import */ var ramda_src_always__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ramda_src_always__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var ramda_src_tryCatch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ramda/src/tryCatch */ "./node_modules/ramda/src/tryCatch.js");
/* harmony import */ var ramda_src_tryCatch__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ramda_src_tryCatch__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _waves_ts_lib_crypto__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @waves/ts-lib-crypto */ "./node_modules/@waves/ts-lib-crypto/index.js");
/* harmony import */ var _waves_ts_lib_crypto__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_waves_ts_lib_crypto__WEBPACK_IMPORTED_MODULE_13__);














var TX_DEFAULTS = {
    MAX_ATTACHMENT: 140,
    ALIAS: {
        AVAILABLE_CHARS: '-.0123456789@_abcdefghijklmnopqrstuvwxyz',
        MAX_ALIAS_LENGTH: 30,
        MIN_ALIAS_LENGTH: 4,
    },
};
var isArray = function (value) { return Array.isArray(value); };
var validatePipe = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (value) {
        var isValid = true;
        for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
            var cb = args_1[_i];
            isValid = !!cb(value);
            if (!isValid) {
                return false;
            }
        }
        return isValid;
    };
};
var isRequired = function (required) { return function (value) {
    return !required || value != null;
}; };
var isString = function (value) {
    return typeof value === 'string' || value instanceof String;
};
var isNumber = function (value) {
    return (typeof value === 'number' || value instanceof Number) &&
        !isNaN(Number(value));
};
var isNumberLike = function (value) {
    return value != null && !isNaN(Number(value)) && !!(value || value === 0);
};
var isBoolean = function (value) {
    return value != null && (typeof value === 'boolean' || value instanceof Boolean);
};
var orEq = ramda_src_flip__WEBPACK_IMPORTED_MODULE_10___default()(ramda_src_includes__WEBPACK_IMPORTED_MODULE_9___default.a);
var exception = function (msg) {
    throw new Error(msg);
};
var validateBySchema = function (schema, errorTpl) { return function (tx) {
    Object.entries(schema).forEach(function (_a) {
        var key = _a[0], cb = _a[1];
        var value = ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()(key, tx || {});
        if (!cb(value)) {
            exception(errorTpl(key, value));
        }
    });
    return true;
}; };
var isAttachment = ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(orEq([null, undefined]), ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(true), ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(isString, 
// TODO Fix attachment gte(TX_DEFAULTS.MAX_ATTACHMENT)
ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('length'), ramda_src_always__WEBPACK_IMPORTED_MODULE_11___default()(true)), ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(false)));
var validateChars = function (chars) { return function (value) {
    return value.split('').every(function (char) { return chars.includes(char); });
}; };
var isValidAliasName = ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(validateChars(TX_DEFAULTS.ALIAS.AVAILABLE_CHARS), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('length'), validatePipe(ramda_src_gte__WEBPACK_IMPORTED_MODULE_5___default()(TX_DEFAULTS.ALIAS.MAX_ALIAS_LENGTH), ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default()(TX_DEFAULTS.ALIAS.MIN_ALIAS_LENGTH))), ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(false));
var ASSETS = {
    NAME_MIN_BYTES: 4,
    NAME_MAX_BYTES: 16,
    DESCRIPTION_MAX_BYTES: 1000,
};
var isBase64 = validatePipe(ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(isString, ramda_src_startsWith__WEBPACK_IMPORTED_MODULE_7___default()('base64:'), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_isNil__WEBPACK_IMPORTED_MODULE_8___default.a)));
var validateType = {
    integer: isNumberLike,
    boolean: isBoolean,
    string: isString,
    binary: isBase64,
};
var isValidDataPair = function (data) { return !!(validateType[data.type] && validateType[data.type](data.value)); };
var isValidData = validatePipe(isRequired(true), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('key'), validatePipe(isString, function (key) { return !!key; })), isValidDataPair);
var isPublicKey = validatePipe(isString, ramda_src_tryCatch__WEBPACK_IMPORTED_MODULE_12___default()(function (v) { return Object(_waves_ts_lib_crypto__WEBPACK_IMPORTED_MODULE_13__["base58Decode"])(v).length === 32; }, ramda_src_always__WEBPACK_IMPORTED_MODULE_11___default()(false)));
var isValidAssetName = validatePipe(isString, ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('length'), ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(ramda_src_lte__WEBPACK_IMPORTED_MODULE_6___default()(ASSETS.NAME_MIN_BYTES), ramda_src_gte__WEBPACK_IMPORTED_MODULE_5___default()(ASSETS.NAME_MAX_BYTES), ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(false))));
var isValidAssetDescription = validatePipe(isString, ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('length'), ramda_src_gte__WEBPACK_IMPORTED_MODULE_5___default()(ASSETS.DESCRIPTION_MAX_BYTES)));
var isAssetId = validatePipe(ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(orEq(['', null, undefined, 'WAVES']), ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(true), isString));
var isAlias = function (value) { return value.startsWith('alias:'); };
// TODO fix validator!!!
var isValidAddress = isString;
var isValidAlias = ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(function (value) { return value.split(':')[2]; }, isValidAliasName);
var isRecipient = validatePipe(isString, ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(isAlias, isValidAlias, isValidAddress));
var orderScheme = {
    orderType: orEq(['sell', 'buy']),
    senderPublicKey: isPublicKey,
    matcherPublicKey: isPublicKey,
    version: orEq([undefined, 0, 1, 2, 3]),
    assetPair: validatePipe(isRequired(true), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('amountAsset'), isAssetId), ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('priceAsset'), isAssetId)),
    price: isNumberLike,
    amount: isNumberLike,
    matcherFee: isNumberLike,
    expiration: isNumberLike,
    timestamp: isNumber,
    proofs: ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(isArray, ramda_src_defaultTo__WEBPACK_IMPORTED_MODULE_0___default()(true), orEq([undefined])),
};
var v12OrderScheme = {
    matcherFeeAssetId: orEq([undefined, null, 'WAVES']),
};
var v3OrderScheme = {
    matcherFeeAssetId: isAssetId,
};
// eslint-disable-next-line @typescript-eslint/no-empty-function
var noop = function () {
};
// TODO!!!
var validateOrder = validateBySchema(orderScheme, noop);
var validateOrderV2 = validateBySchema(v12OrderScheme, noop);
var validateOrderV3 = validateBySchema(v3OrderScheme, noop);
var orderValidator = validatePipe(validateOrder, ramda_src_ifElse__WEBPACK_IMPORTED_MODULE_2___default()(ramda_src_pipe__WEBPACK_IMPORTED_MODULE_3___default()(ramda_src_prop__WEBPACK_IMPORTED_MODULE_1___default()('version'), ramda_src_equals__WEBPACK_IMPORTED_MODULE_4___default()(3)), validateOrderV3, validateOrderV2));


/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js":
/*!******************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
var util_1 = __webpack_require__(/*! node-forge/lib/util */ "./node_modules/node-forge/lib/util.js");
var base58_1 = __importDefault(__webpack_require__(/*! ../libs/base58 */ "./node_modules/@waves/ts-lib-crypto/libs/base58.js"));
var param_1 = __webpack_require__(/*! ./param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var string_bytes_1 = __webpack_require__(/*! ./string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
exports.base64Decode = function (input) {
    return string_bytes_1.stringToBytes(util_1.decode64(input), 'raw');
};
exports.base64Encode = function (input) {
    return util_1.encode64(string_bytes_1.bytesToString(param_1._fromIn(input), 'raw'));
};
exports.base58Decode = function (input) {
    return base58_1.default.decode(input);
};
exports.base58Encode = function (input) {
    return base58_1.default.encode(param_1._fromIn(input));
};
exports.base16Decode = function (input) {
    return string_bytes_1.stringToBytes(util_1.hexToBytes(input), 'raw');
};
exports.base16Encode = function (input) { return util_1.bytesToHex(string_bytes_1.bytesToString(param_1._fromIn(input), 'raw')); };
//# sourceMappingURL=base-xx.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/conversions/param.js":
/*!****************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/conversions/param.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var base_xx_1 = __webpack_require__(/*! ./base-xx */ "./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js");
var string_bytes_1 = __webpack_require__(/*! ./string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
var isString = function (val) { return typeof val === 'string' || val instanceof String; };
var isUint8Array = function (val) { return val instanceof Uint8Array; };
var isTRawStringInDiscriminator = function (_) { return false; };
exports._fromIn = function (inValue) {
    if (isString(inValue))
        return base_xx_1.base58Decode(inValue);
    if (isUint8Array(inValue))
        return inValue;
    return Uint8Array.from(inValue);
};
exports._fromRawIn = function (inValue) {
    if (isTRawStringInDiscriminator(inValue))
        throw new Error('');
    if (isString(inValue))
        return string_bytes_1.stringToBytes(inValue);
    if (isUint8Array(inValue))
        return inValue;
    return Uint8Array.from(inValue);
};
//# sourceMappingURL=param.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var param_1 = __webpack_require__(/*! ./param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var Utf8_1 = __webpack_require__(/*! ../libs/Utf8 */ "./node_modules/@waves/ts-lib-crypto/libs/Utf8.js");
exports.stringToBytes = function (str, encoding) {
    if (encoding === void 0) { encoding = 'utf8'; }
    if (encoding === 'utf8') {
        return Utf8_1.strToUtf8Array(str);
    }
    else if (encoding === 'raw') {
        return Uint8Array.from(__spread(str).map(function (c) { return c.charCodeAt(0); }));
    }
    else {
        throw new Error("Unsupported encoding " + encoding);
    }
};
exports.bytesToString = function (bytes, encoding) {
    if (encoding === void 0) { encoding = 'utf8'; }
    if (encoding === 'utf8') {
        return Utf8_1.utf8ArrayToStr(Array.from(param_1._fromIn(bytes)));
    }
    else if (encoding === 'raw') {
        return Array.from(param_1._fromIn(bytes))
            .map(function (byte) { return String.fromCharCode(byte); })
            .join('');
    }
    else {
        throw new Error("Unsupported encoding " + encoding);
    }
};
/**
 * Converts each character to byte
 */
exports.binaryStringToBytes = function (str) {
    return Uint8Array.from(__spread(str).map(function (c) { return c.charCodeAt(0); }));
};
/**
 * Reads each byte as individual character
 */
exports.bytesToBinaryString = function (bytes) {
    return Array.from(param_1._fromIn(bytes))
        .map(function (byte) { return String.fromCharCode(byte); })
        .join('');
};
//# sourceMappingURL=string-bytes.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/address-keys-seed.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/address-keys-seed.js ***!
  \***********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js");
var seed_1 = __webpack_require__(/*! ../extensions/seed */ "./node_modules/@waves/ts-lib-crypto/extensions/seed.js");
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var concat_split_1 = __webpack_require__(/*! ./concat-split */ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js");
var util_1 = __webpack_require__(/*! ./util */ "./node_modules/@waves/ts-lib-crypto/crypto/util.js");
var axlsign_1 = __importDefault(__webpack_require__(/*! ../libs/axlsign */ "./node_modules/@waves/ts-lib-crypto/libs/axlsign.js"));
exports.seedWithNonce = function (seed, nonce) { return ({ seed: seed_1.Seed.toBinary(seed).seed, nonce: nonce }); };
exports.buildAddress = function (publicKeyBytes, chainId) {
    if (chainId === void 0) { chainId = interface_1.MAIN_NET_CHAIN_ID; }
    var prefix = [1, typeof chainId === 'string' ? chainId.charCodeAt(0) : chainId];
    var publicKeyHashPart = hashing_1._hashChain(publicKeyBytes).slice(0, 20);
    var rawAddress = concat_split_1.concat(prefix, publicKeyHashPart);
    var addressHash = hashing_1._hashChain(rawAddress).slice(0, 4);
    return concat_split_1.concat(rawAddress, addressHash);
};
var buildSeedHash = function (seedBytes, nonce) {
    var nonceArray = [0, 0, 0, 0];
    if (nonce && nonce > 0) {
        var remainder = nonce;
        for (var i = 3; i >= 0; i--) {
            nonceArray[3 - i] = Math.floor(remainder / Math.pow(2, (i * 8)));
            remainder = remainder % Math.pow(2, (i * 8));
        }
    }
    var seedBytesWithNonce = concat_split_1.concat(nonceArray, seedBytes);
    var seedHash = hashing_1._hashChain(seedBytesWithNonce);
    return hashing_1.sha256(seedHash);
};
exports.keyPair = function (seed) {
    var _a = seed_1.Seed.toBinary(seed), seedBytes = _a.seed, nonce = _a.nonce;
    var seedHash = buildSeedHash(seedBytes, nonce);
    var keys = axlsign_1.default.generateKeyPair(seedHash);
    return {
        privateKey: keys.private,
        publicKey: keys.public,
    };
};
exports.address = function (seedOrPublicKey, chainId) {
    if (chainId === void 0) { chainId = interface_1.MAIN_NET_CHAIN_ID; }
    return util_1.isPublicKey(seedOrPublicKey) ?
        exports.buildAddress(param_1._fromIn(seedOrPublicKey.publicKey), chainId) :
        exports.address(exports.keyPair(seedOrPublicKey), chainId);
};
exports.publicKey = function (seedOrPrivateKey) {
    return util_1.isPrivateKey(seedOrPrivateKey) ?
        axlsign_1.default.generateKeyPair(param_1._fromIn(seedOrPrivateKey.privateKey)).public :
        exports.keyPair(seedOrPrivateKey).publicKey;
};
exports.privateKey = function (seed) {
    return exports.keyPair(seed).privateKey;
};
//# sourceMappingURL=address-keys-seed.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js":
/*!******************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
exports.concat = function () {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    return arrays.reduce(function (a, b) { return Uint8Array.from(__spread(a, param_1._fromIn(b))); }, new Uint8Array(0));
};
exports.split = function (binary) {
    var sizes = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sizes[_i - 1] = arguments[_i];
    }
    var _a = sizes.reduce(function (a, s) { return ({ arr: a.arr.slice(s), r: __spread(a.r, [a.arr.slice(0, s)]) }); }, { arr: param_1._fromIn(binary), r: [] }), r = _a.r, arr = _a.arr;
    return __spread(r, [arr]);
};
//# sourceMappingURL=concat-split.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/crypto.js":
/*!************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/crypto.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var random_1 = __webpack_require__(/*! ./random */ "./node_modules/@waves/ts-lib-crypto/crypto/random.js");
var encryption_1 = __webpack_require__(/*! ./encryption */ "./node_modules/@waves/ts-lib-crypto/crypto/encryption.js");
var base_xx_1 = __webpack_require__(/*! ../conversions/base-xx */ "./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js");
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
var concat_split_1 = __webpack_require__(/*! ./concat-split */ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js");
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var address_keys_seed_1 = __webpack_require__(/*! ./address-keys-seed */ "./node_modules/@waves/ts-lib-crypto/crypto/address-keys-seed.js");
var sign_1 = __webpack_require__(/*! ./sign */ "./node_modules/@waves/ts-lib-crypto/crypto/sign.js");
var verification_1 = __webpack_require__(/*! ./verification */ "./node_modules/@waves/ts-lib-crypto/crypto/verification.js");
var rsa_1 = __webpack_require__(/*! ./rsa */ "./node_modules/@waves/ts-lib-crypto/crypto/rsa.js");
var seed_ecryption_1 = __webpack_require__(/*! ./seed-ecryption */ "./node_modules/@waves/ts-lib-crypto/crypto/seed-ecryption.js");
var merkle_verify_1 = __webpack_require__(/*! ./merkle-verify */ "./node_modules/@waves/ts-lib-crypto/crypto/merkle-verify.js");
exports.crypto = function (options) {
    if (options && options.seed == '')
        throw new Error('Empty seed is not allowed.');
    var c = function (f, first) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return f.apply(void 0, __spread([first], args));
        };
    };
    var toOut = function (f) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var r = f.apply(void 0, __spread(args));
        return (!options || options && options.output === 'Base58') ? base_xx_1.base58Encode(r) : r;
    }; };
    var toOutKey = function (f) { return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var r = f.apply(void 0, __spread(args));
        return ((!options || options && options.output === 'Base58') ?
            ({ privateKey: base_xx_1.base58Encode(r.privateKey), publicKey: base_xx_1.base58Encode(r.publicKey) }) :
            r);
    }; };
    var s = (options && options.seed) ? options.seed : undefined;
    var seedPart = {
        seedWithNonce: s ? c(address_keys_seed_1.seedWithNonce, s) : address_keys_seed_1.seedWithNonce,
        signBytes: toOut(s ? c(sign_1.signBytes, s) : sign_1.signBytes),
        keyPair: toOutKey(s ? c(address_keys_seed_1.keyPair, s) : address_keys_seed_1.keyPair),
        publicKey: toOut(s ? c(address_keys_seed_1.publicKey, s) : address_keys_seed_1.publicKey),
        privateKey: toOut(s ? c(address_keys_seed_1.privateKey, s) : address_keys_seed_1.privateKey),
        address: toOut(s ? c(address_keys_seed_1.address, s) : address_keys_seed_1.address),
    };
    return __assign({}, seedPart, { sharedKey: toOut(encryption_1.sharedKey), buildAddress: address_keys_seed_1.buildAddress,
        blake2b: hashing_1.blake2b,
        keccak: hashing_1.keccak,
        sha256: hashing_1.sha256,
        base64Encode: base_xx_1.base64Encode,
        base64Decode: base_xx_1.base64Decode,
        base58Encode: base_xx_1.base58Encode,
        base58Decode: base_xx_1.base58Decode,
        base16Encode: base_xx_1.base16Encode,
        base16Decode: base_xx_1.base16Decode,
        stringToBytes: string_bytes_1.stringToBytes,
        bytesToString: string_bytes_1.bytesToString,
        random: random_1.random,
        randomSeed: random_1.randomSeed,
        randomBytes: random_1.randomBytes,
        verifySignature: verification_1.verifySignature,
        verifyPublicKey: verification_1.verifyPublicKey,
        verifyAddress: verification_1.verifyAddress,
        messageDecrypt: encryption_1.messageDecrypt,
        messageEncrypt: encryption_1.messageEncrypt,
        aesDecrypt: encryption_1.aesDecrypt,
        aesEncrypt: encryption_1.aesEncrypt,
        encryptSeed: seed_ecryption_1.encryptSeed,
        decryptSeed: seed_ecryption_1.decryptSeed,
        rsaKeyPair: rsa_1.rsaKeyPair,
        rsaKeyPairSync: rsa_1.rsaKeyPairSync,
        rsaSign: rsa_1.rsaSign,
        rsaVerify: rsa_1.rsaVerify,
        merkleVerify: merkle_verify_1.merkleVerify,
        split: concat_split_1.split,
        concat: concat_split_1.concat });
};
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/encryption.js":
/*!****************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/encryption.js ***!
  \****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
var forgeCipher = __importStar(__webpack_require__(/*! node-forge/lib/cipher */ "./node_modules/node-forge/lib/cipher.js"));
// @ts-ignore
var util = __importStar(__webpack_require__(/*! node-forge/lib/util */ "./node_modules/node-forge/lib/util.js"));
var random_1 = __webpack_require__(/*! ./random */ "./node_modules/@waves/ts-lib-crypto/crypto/random.js");
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var concat_split_1 = __webpack_require__(/*! ./concat-split */ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js");
var axlsign_1 = __importDefault(__webpack_require__(/*! ../libs/axlsign */ "./node_modules/@waves/ts-lib-crypto/libs/axlsign.js"));
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
exports.aesEncrypt = function (data, key, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    var cipher = forgeCipher.createCipher("AES-" + mode, string_bytes_1.bytesToString(param_1._fromIn(key), 'raw'));
    cipher.start({ iv: iv && util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(iv), 'raw')) });
    cipher.update(util.createBuffer(string_bytes_1.bytesToString(data, 'raw')));
    cipher.finish();
    return string_bytes_1.stringToBytes(cipher.output.getBytes(), 'raw');
};
exports.aesDecrypt = function (encryptedData, key, mode, iv) {
    if (mode === void 0) { mode = 'CBC'; }
    var decipher = forgeCipher.createDecipher("AES-" + mode, string_bytes_1.bytesToString(param_1._fromIn(key), 'raw'));
    decipher.start({ iv: iv && util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(iv), 'raw')) });
    var encbuf = util.createBuffer(string_bytes_1.bytesToString(param_1._fromIn(encryptedData), 'raw'));
    decipher.update(encbuf);
    if (!decipher.finish()) {
        throw new Error('Failed to decrypt data with provided key');
    }
    return string_bytes_1.stringToBytes(decipher.output.getBytes(), 'raw');
};
exports.messageEncrypt = function (sharedKey, message) {
    var version = Uint8Array.from([1]);
    var CEK = random_1.randomBytes(32);
    var IV = random_1.randomBytes(16);
    var m = string_bytes_1.stringToBytes(message);
    var Cc = exports.aesEncrypt(m, CEK, 'CTR', IV);
    var Ccek = exports.aesEncrypt(CEK, sharedKey, 'ECB');
    var Mhmac = hashing_1.hmacSHA256(m, CEK);
    var CEKhmac = hashing_1.hmacSHA256(concat_split_1.concat(CEK, IV), sharedKey);
    var packageBytes = concat_split_1.concat(version, Ccek, CEKhmac, Mhmac, IV, Cc);
    return packageBytes;
};
exports.messageDecrypt = function (sharedKey, encryptedMessage) {
    var _a = __read(concat_split_1.split(encryptedMessage, 1, 48, 32, 32, 16), 6), version = _a[0], Ccek = _a[1], _CEKhmac = _a[2], _Mhmac = _a[3], iv = _a[4], Cc = _a[5];
    var CEK = exports.aesDecrypt(Ccek, sharedKey, 'ECB');
    var CEKhmac = param_1._fromIn(hashing_1.hmacSHA256(concat_split_1.concat(CEK, iv), param_1._fromIn(sharedKey)));
    var isValidKey = CEKhmac.every(function (v, i) { return v === _CEKhmac[i]; });
    if (!isValidKey)
        throw new Error('Invalid key');
    var M = exports.aesDecrypt(Cc, CEK, 'CTR', iv);
    var Mhmac = param_1._fromIn(hashing_1.hmacSHA256(M, CEK));
    var isValidMessage = Mhmac.every(function (v, i) { return v === _Mhmac[i]; });
    if (!isValidMessage)
        throw new Error('Invalid message');
    return string_bytes_1.bytesToString(M);
};
exports.sharedKey = function (privateKeyFrom, publicKeyTo, prefix) {
    var sharedKey = axlsign_1.default.sharedKey(param_1._fromIn(privateKeyFrom), param_1._fromIn(publicKeyTo));
    var prefixHash = hashing_1.sha256(param_1._fromRawIn(prefix));
    return hashing_1.hmacSHA256(sharedKey, prefixHash);
};
//# sourceMappingURL=encryption.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js":
/*!*************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/hashing.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var sha3_1 = __webpack_require__(/*! ../libs/sha3 */ "./node_modules/@waves/ts-lib-crypto/libs/sha3.js");
// @ts-ignore
var forgeHmac = __importStar(__webpack_require__(/*! node-forge/lib/hmac */ "./node_modules/node-forge/lib/hmac.js"));
// @ts-ignore
var forgeMd = __importStar(__webpack_require__(/*! node-forge/lib/md */ "./node_modules/node-forge/lib/md.js"));
__webpack_require__(/*! node-forge/lib/sha256 */ "./node_modules/node-forge/lib/sha256.js");
var blake = __importStar(__webpack_require__(/*! ../libs/blake2b */ "./node_modules/@waves/ts-lib-crypto/libs/blake2b.js"));
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
exports._hashChain = function (input) {
    return param_1._fromIn(exports.keccak(exports.blake2b(param_1._fromIn(input))));
};
exports.sha256 = function (input) {
    var md = forgeMd.algorithms.sha256.create();
    md.update(string_bytes_1.bytesToString(input, 'raw'));
    return string_bytes_1.stringToBytes(md.digest().getBytes(), 'raw');
};
exports.blake2b = function (input) {
    return blake.blake2b(param_1._fromIn(input), null, 32);
};
exports.keccak = function (input) {
    return param_1._fromIn(sha3_1.keccak256.array(param_1._fromIn(input)));
};
exports.hmacSHA256 = function (message, key) {
    var hmac = forgeHmac.create();
    hmac.start('sha256', string_bytes_1.bytesToString(param_1._fromIn(key), 'raw'));
    hmac.update(string_bytes_1.bytesToString(param_1._fromIn(message), 'raw'));
    return string_bytes_1.stringToBytes(hmac.digest().getBytes(), 'raw');
};
//# sourceMappingURL=hashing.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js":
/*!***************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/interface.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PUBLIC_KEY_LENGTH = 32;
exports.PRIVATE_KEY_LENGTH = 32;
exports.SIGNATURE_LENGTH = 64;
exports.ADDRESS_LENGTH = 26;
exports.MAIN_NET_CHAIN_ID = 87; // W
exports.TEST_NET_CHAIN_ID = 84; // T
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/merkle-verify.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/merkle-verify.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var concat_split_1 = __webpack_require__(/*! ./concat-split */ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js");
/**
 *
 * @param rootHash
 * @param merkleProof
 * @param leafData
 */
function merkleVerify(rootHash, merkleProof, leafData) {
    var LEAF_PREFIX = Uint8Array.from([0]);
    var INTERNAL_NODE_PREFIX = Uint8Array.from([1]);
    if (rootHash.length !== 32)
        throw new Error('Failed to parse merkleProof: Invalid rootHash length');
    var leafHash = hashing_1.blake2b(concat_split_1.concat(LEAF_PREFIX, leafData));
    var proofsWithSide = [];
    var proofBytes = merkleProof.map(function (x) { return x; });
    while (proofBytes.length > 0) {
        var side = proofBytes[0] === 0 ? 'L' : 'R';
        var size = proofBytes[1];
        if (size < 1)
            throw new Error('Failed to parse merkleProof: Wrong hash size');
        var hash = proofBytes.slice(2, 2 + size);
        proofsWithSide.push([side, hash]);
        proofBytes = proofBytes.slice(2 + size);
    }
    var rootHashFromProof = proofsWithSide.reduce(function (acc, _a) {
        var _b = __read(_a, 2), side = _b[0], hash = _b[1];
        return hashing_1.blake2b(concat_split_1.concat(INTERNAL_NODE_PREFIX, side === 'R' ? concat_split_1.concat(hash, acc) : concat_split_1.concat(acc, hash)));
    }, leafHash);
    return rootHashFromProof.every(function (v, i) { return v === rootHash[i]; });
}
exports.merkleVerify = merkleVerify;
//# sourceMappingURL=merkle-verify.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/random.js":
/*!************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/random.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
var random_1 = __importDefault(__webpack_require__(/*! node-forge/lib/random */ "./node_modules/node-forge/lib/random.js"));
var seed_words_list_1 = __webpack_require__(/*! ./seed-words-list */ "./node_modules/@waves/ts-lib-crypto/crypto/seed-words-list.js");
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
var _random = function (count) { return string_bytes_1.stringToBytes(random_1.default.getBytesSync(count), 'raw'); };
var ensureBuffer = function () {
    try {
        var b = new Buffer(1);
    }
    catch (e) {
        throw new Error('Buffer not supported in this environment. Use Node.js or Browserify for browser support.');
    }
};
exports.random = function (count, type) {
    switch (type) {
        case 'Array8':
            return Array.from(_random(count));
        case 'Array16':
            return Array.from(exports.random(count, 'Uint16Array'));
        case 'Array32':
            return Array.from(exports.random(count, 'Uint32Array'));
        case 'Buffer':
            ensureBuffer();
            return Buffer.from(_random(count));
        case 'Uint8Array':
            return _random(count);
        case 'Uint16Array':
            return new Uint16Array(count)
                .map(function (_) { return _random(2).reduce(function (a, b, i) { return a | b << 8 * (1 - i); }, 0); });
        case 'Uint32Array':
            return new Uint32Array(count)
                .map(function (_) { return _random(4).reduce(function (a, b, i) { return a | b << 8 * (1 - i); }, 0); });
        default:
            throw new Error(type + ' is unsupported.');
    }
};
exports.randomBytes = function (length) {
    return exports.random(length, 'Uint8Array');
};
exports.randomSeed = function (wordsCount) {
    if (wordsCount === void 0) { wordsCount = 15; }
    return exports.random(wordsCount, 'Array32')
        .map(function (x) { return seed_words_list_1.seedWordsList[x % seed_words_list_1.seedWordsList.length]; })
        .join(' ');
};
//# sourceMappingURL=random.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/rsa.js":
/*!*********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/rsa.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-ignore
var pki = __importStar(__webpack_require__(/*! node-forge/lib/pki */ "./node_modules/node-forge/lib/pki.js"));
// @ts-ignore
var md = __importStar(__webpack_require__(/*! node-forge/lib/md */ "./node_modules/node-forge/lib/md.js"));
// @ts-ignore
var md5 = __importStar(__webpack_require__(/*! node-forge/lib/md5 */ "./node_modules/node-forge/lib/md5.js"));
// @ts-ignore
var util = __importStar(__webpack_require__(/*! node-forge/lib/util */ "./node_modules/node-forge/lib/util.js"));
var base_xx_1 = __webpack_require__(/*! ../conversions/base-xx */ "./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js");
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
var sha3 = __importStar(__webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js"));
// HACK. Monkey patch node-forge library to provide oids for missing hash algorithms
pki.oids['sha224'] = '2.16.840.1.101.3.4.2.4';
pki.oids['2.16.840.1.101.3.4.2.4'] = 'sha224';
pki.oids['sha3-224'] = '2.16.840.1.101.3.4.2.7';
pki.oids['2.16.840.1.101.3.4.2.7'] = 'sha3-224';
pki.oids['sha3-256'] = '2.16.840.1.101.3.4.2.8';
pki.oids['2.16.840.1.101.3.4.2.8'] = 'sha3-256';
pki.oids['sha3-384'] = '2.16.840.1.101.3.4.2.9';
pki.oids['2.16.840.1.101.3.4.2.9'] = 'sha3-384';
pki.oids['sha3-512'] = '2.16.840.1.101.3.4.2.10';
pki.oids['2.16.840.1.101.3.4.2.10'] = 'sha3-512';
exports.pemToBytes = function (pem) { return base_xx_1.base64Decode(pem.trim()
    .split(/\r\n|\n/)
    .slice(1, -1).join('')
    .trim()); };
var pemTypeMap = {
    rsaPrivateNonEncrypted: 'RSA PRIVATE KEY',
    rsaPublic: 'PUBLIC KEY',
};
exports.bytesToPem = function (bytes, type) {
    var header = "-----BEGIN " + pemTypeMap[type] + "-----\n";
    var footer = "-----END " + pemTypeMap[type] + "-----\n";
    var b64characters = base_xx_1.base64Encode(bytes);
    if (b64characters.length % 64 !== 0) {
        b64characters += ' '.repeat(64 - b64characters.length % 64);
    }
    var result = header;
    for (var i = 0; i < (b64characters.length / 64); i++) {
        result += b64characters.slice(i * 64, (i + 1) * 64) + '\n';
    }
    result += footer;
    return result;
};
exports.rsaKeyPairSync = function (bits, e) {
    var kp = pki.rsa.generateKeyPair(bits, e);
    return {
        rsaPrivate: exports.pemToBytes(pki.privateKeyToPem(kp.privateKey)),
        rsaPublic: exports.pemToBytes(pki.publicKeyToPem(kp.publicKey)),
    };
};
exports.rsaKeyPair = function (bits, e) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve, reject) {
                pki.rsa.generateKeyPair(bits, e, function (err, kp) {
                    if (err)
                        reject(err);
                    resolve({
                        rsaPrivate: exports.pemToBytes(pki.privateKeyToPem(kp.privateKey)),
                        rsaPublic: exports.pemToBytes(pki.publicKeyToPem(kp.publicKey)),
                    });
                });
            })];
    });
}); };
var digestCreatorPlaceHolder = function (type) { return function () {
    throw new Error("Digest " + type + " is unsupported");
}; };
var MessageDigestAdapter = /** @class */ (function () {
    function MessageDigestAdapter(sha3Digest, algorithm) {
        this.sha3Digest = sha3Digest;
        this.algorithm = algorithm;
    }
    MessageDigestAdapter.makeCreator = function (sha3Hash, algorithmName) {
        return { create: function () { return new MessageDigestAdapter(sha3Hash.create(), algorithmName); } };
    };
    MessageDigestAdapter.prototype.update = function (msg, encoding) {
        this.sha3Digest.update(string_bytes_1.stringToBytes(msg, encoding == null ? 'raw' : encoding));
        return this;
    };
    MessageDigestAdapter.prototype.digest = function () {
        var bytes = Uint8Array.from(this.sha3Digest.digest());
        return util.createBuffer(string_bytes_1.bytesToString(bytes, 'raw'));
    };
    return MessageDigestAdapter;
}());
var digestMap = {
    'MD5': md5,
    'SHA1': md.algorithms.sha1,
    'SHA224': digestCreatorPlaceHolder('SHA224'),
    'SHA256': md.algorithms.sha256,
    'SHA384': md.algorithms.sha384,
    'SHA512': md.algorithms.sha512,
    'SHA3-224': MessageDigestAdapter.makeCreator(sha3.sha3_224, 'sha3-224'),
    'SHA3-256': MessageDigestAdapter.makeCreator(sha3.sha3_256, 'sha3-256'),
    'SHA3-384': MessageDigestAdapter.makeCreator(sha3.sha3_384, 'sha3-384'),
    'SHA3-512': MessageDigestAdapter.makeCreator(sha3.sha3_512, 'sha3-512'),
};
exports.rsaSign = function (rsaPrivateKey, message, digest) {
    if (digest === void 0) { digest = 'SHA256'; }
    var s = exports.bytesToPem(rsaPrivateKey, 'rsaPrivateNonEncrypted');
    var sk = pki.privateKeyFromPem(s);
    var _digest = digestMap[digest].create();
    _digest.update(string_bytes_1.bytesToString(message, 'raw'));
    return string_bytes_1.stringToBytes(sk.sign(_digest), 'raw');
};
exports.rsaVerify = function (rsaPublicKey, message, signature, digest) {
    if (digest === void 0) { digest = 'SHA256'; }
    var pk = pki.publicKeyFromPem(exports.bytesToPem(rsaPublicKey, 'rsaPublic'));
    var _digest = digestMap[digest].create();
    _digest.update(string_bytes_1.bytesToString(message), 'raw');
    return pk.verify(_digest.digest().getBytes(), string_bytes_1.bytesToString(signature, 'raw'));
};
//# sourceMappingURL=rsa.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/seed-ecryption.js":
/*!********************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/seed-ecryption.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
// @ts-ignore
var forgeMd5 = __importStar(__webpack_require__(/*! node-forge/lib/md5 */ "./node_modules/node-forge/lib/md5.js"));
var concat_split_1 = __webpack_require__(/*! ./concat-split */ "./node_modules/@waves/ts-lib-crypto/crypto/concat-split.js");
var encryption_1 = __webpack_require__(/*! ./encryption */ "./node_modules/@waves/ts-lib-crypto/crypto/encryption.js");
var base_xx_1 = __webpack_require__(/*! ../conversions/base-xx */ "./node_modules/@waves/ts-lib-crypto/conversions/base-xx.js");
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var random_1 = __webpack_require__(/*! ./random */ "./node_modules/@waves/ts-lib-crypto/crypto/random.js");
function strengthenPassword(password, rounds) {
    if (rounds === void 0) { rounds = 5000; }
    while (rounds--) {
        var bytes = string_bytes_1.stringToBytes(password);
        password = base_xx_1.base16Encode(hashing_1.sha256(bytes));
    }
    return password;
}
function evpKdf(passphrase, salt, output) {
    if (output === void 0) { output = 48; }
    var passPlusSalt = string_bytes_1.bytesToString(concat_split_1.concat(passphrase, salt), 'raw');
    var key = '';
    var final_key = key;
    while (final_key.length < output) {
        key = forgeMd5.create().update(key + passPlusSalt).digest().getBytes();
        final_key += key;
    }
    return final_key;
}
/**
 * Encrypts arbitrary utf8 string with utf8 password. Evp key deriving function is used to get encryption key and IV from
 * password. AES-CBC algorithm is used for encryption. Output format is base64 encoded OpenSSL
 * @param seed - utf8 string to encrypt
 * @param password - utf8 password
 * @param encryptionRounds - how many times password will be hashed. Default = 5000
 */
exports.encryptSeed = function (seed, password, encryptionRounds) {
    var passphrase = strengthenPassword(password, encryptionRounds);
    var salt = random_1.randomBytes(8);
    var key_iv = evpKdf(string_bytes_1.stringToBytes(passphrase, 'raw'), salt);
    var key = string_bytes_1.stringToBytes(key_iv.slice(0, 32), 'raw');
    var iv = string_bytes_1.stringToBytes(key_iv.slice(32), 'raw');
    var encrypted = encryption_1.aesEncrypt(string_bytes_1.stringToBytes(seed), key, 'CBC', iv);
    return base_xx_1.base64Encode(concat_split_1.concat(string_bytes_1.stringToBytes('Salted__'), salt, encrypted));
};
exports.decryptSeed = function (encryptedSeed, password, encryptionRounds) {
    var passphrase = strengthenPassword(password, encryptionRounds);
    var encBytes = base_xx_1.base64Decode(encryptedSeed);
    var salt = encBytes.slice(8, 16);
    var key_iv = evpKdf(string_bytes_1.stringToBytes(passphrase, 'raw'), salt);
    var key = string_bytes_1.stringToBytes(key_iv.slice(0, 32), 'raw');
    var iv = string_bytes_1.stringToBytes(key_iv.slice(32), 'raw');
    return string_bytes_1.bytesToString(encryption_1.aesDecrypt(encBytes.slice(16), key, 'CBC', iv));
};
//# sourceMappingURL=seed-ecryption.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/seed-words-list.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/seed-words-list.js ***!
  \*********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.seedWordsList = [
    'abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access',
    'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action',
    'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance',
    'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air',
    'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost',
    'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused',
    'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual',
    'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple',
    'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around',
    'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault',
    'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract',
    'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake',
    'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag',
    'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base',
    'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin',
    'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between',
    'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame',
    'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush',
    'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow',
    'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze',
    'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother',
    'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle',
    'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage',
    'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel',
    'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card',
    'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch',
    'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census',
    'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge',
    'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child',
    'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle',
    'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click',
    'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club',
    'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect',
    'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct',
    'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy',
    'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin',
    'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy',
    'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch',
    'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture',
    'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad',
    'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate',
    'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define',
    'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend',
    'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy',
    'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel',
    'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree',
    'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce',
    'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door',
    'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill',
    'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty',
    'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology',
    'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric',
    'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge',
    'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy',
    'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure',
    'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion',
    'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke',
    'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise',
    'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose',
    'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith',
    'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal',
    'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female',
    'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film',
    'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit',
    'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock',
    'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food',
    'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found',
    'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown',
    'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy',
    'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate',
    'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant',
    'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide',
    'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose',
    'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass',
    'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess',
    'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy',
    'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy',
    'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip',
    'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope',
    'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble',
    'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea',
    'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune',
    'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate',
    'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury',
    'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install',
    'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item',
    'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke',
    'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep',
    'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten',
    'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp',
    'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit',
    'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure',
    'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library',
    'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little',
    'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery',
    'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics',
    'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage',
    'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market',
    'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze',
    'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory',
    'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle',
    'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery',
    'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor',
    'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor',
    'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom',
    'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty',
    'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest',
    'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee',
    'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear',
    'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious',
    'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive',
    'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose',
    'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan',
    'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner',
    'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic',
    'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient',
    'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen',
    'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase',
    'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer',
    'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge',
    'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool',
    'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power',
    'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride',
    'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit',
    'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public',
    'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose',
    'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit',
    'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally',
    'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready',
    'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce',
    'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief',
    'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat',
    'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire',
    'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich',
    'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river',
    'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate',
    'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad',
    'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand',
    'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene',
    'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea',
    'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select',
    'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup',
    'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine',
    'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug',
    'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver',
    'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski',
    'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim',
    'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap',
    'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid',
    'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south',
    'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice',
    'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray',
    'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs',
    'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still',
    'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong',
    'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such',
    'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply',
    'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow',
    'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol',
    'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target',
    'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term',
    'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought',
    'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny',
    'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet',
    'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple',
    'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track',
    'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree',
    'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true',
    'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey',
    'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly',
    'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy',
    'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update',
    'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless',
    'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor',
    'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version',
    'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village',
    'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice',
    'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want',
    'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear',
    'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what',
    'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win',
    'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf',
    'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle',
    'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo',
];
//# sourceMappingURL=seed-words-list.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/sign.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/sign.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var axlsign_1 = __importDefault(__webpack_require__(/*! ../libs/axlsign */ "./node_modules/@waves/ts-lib-crypto/libs/axlsign.js"));
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var util_1 = __webpack_require__(/*! ./util */ "./node_modules/@waves/ts-lib-crypto/crypto/util.js");
var address_keys_seed_1 = __webpack_require__(/*! ./address-keys-seed */ "./node_modules/@waves/ts-lib-crypto/crypto/address-keys-seed.js");
var random_1 = __webpack_require__(/*! ./random */ "./node_modules/@waves/ts-lib-crypto/crypto/random.js");
exports.signBytes = function (seedOrPrivateKey, bytes, random) {
    return axlsign_1.default.sign(param_1._fromIn(util_1.isPrivateKey(seedOrPrivateKey)
        ? seedOrPrivateKey.privateKey
        : address_keys_seed_1.privateKey(seedOrPrivateKey)), param_1._fromIn(bytes), param_1._fromIn(random || random_1.randomBytes(64)));
};
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/util.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isPublicKey = function (val) {
    return val.publicKey !== undefined;
};
exports.isPrivateKey = function (val) {
    return val.privateKey !== undefined;
};
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/crypto/verification.js":
/*!******************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/crypto/verification.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js");
var chain_id_1 = __webpack_require__(/*! ../extensions/chain-id */ "./node_modules/@waves/ts-lib-crypto/extensions/chain-id.js");
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var hashing_1 = __webpack_require__(/*! ./hashing */ "./node_modules/@waves/ts-lib-crypto/crypto/hashing.js");
var address_keys_seed_1 = __webpack_require__(/*! ./address-keys-seed */ "./node_modules/@waves/ts-lib-crypto/crypto/address-keys-seed.js");
var axlsign_1 = __importDefault(__webpack_require__(/*! ../libs/axlsign */ "./node_modules/@waves/ts-lib-crypto/libs/axlsign.js"));
exports.verifyAddress = function (addr, optional) {
    var chainId = optional ? optional.chainId : undefined;
    try {
        var addressBytes = param_1._fromIn(addr);
        if (addressBytes[0] != 1 || (chainId ? addressBytes[1] != chain_id_1.ChaidId.toNumber(chainId) : false))
            return false;
        var key = addressBytes.slice(0, 22);
        var check = addressBytes.slice(22, 26);
        var keyHash = hashing_1._hashChain(key).slice(0, 4);
        for (var i = 0; i < 4; i++) {
            if (check[i] != keyHash[i])
                return false;
        }
        if (optional && optional.publicKey) {
            var a = address_keys_seed_1.address({ publicKey: optional.publicKey }, chainId);
            if (addressBytes.length !== a.length)
                return false;
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== addressBytes[i])
                    return false;
            }
        }
    }
    catch (ex) {
        return false;
    }
    return true;
};
exports.verifySignature = function (publicKey, bytes, signature) {
    try {
        return axlsign_1.default.verify(param_1._fromIn(publicKey), param_1._fromIn(bytes), param_1._fromIn(signature));
    }
    catch (error) {
        return false;
    }
};
exports.verifyPublicKey = function (publicKey) { return param_1._fromIn(publicKey).length === interface_1.PUBLIC_KEY_LENGTH; };
//# sourceMappingURL=verification.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/extensions/chain-id.js":
/*!******************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/extensions/chain-id.js ***!
  \******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var interface_1 = __webpack_require__(/*! ../crypto/interface */ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js");
var interface_2 = __webpack_require__(/*! ../crypto/interface */ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js");
exports.ChaidId = {
    toNumber: function (chainId) {
        return (typeof chainId === 'string' ? chainId.charCodeAt(0) : chainId);
    },
    isMainnet: function (chainId) {
        return exports.ChaidId.toNumber(chainId) === interface_1.MAIN_NET_CHAIN_ID;
    },
    isTestnet: function (chainId) {
        return exports.ChaidId.toNumber(chainId) === interface_2.TEST_NET_CHAIN_ID;
    },
};
//# sourceMappingURL=chain-id.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/extensions/seed.js":
/*!**************************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/extensions/seed.js ***!
  \**************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var param_1 = __webpack_require__(/*! ../conversions/param */ "./node_modules/@waves/ts-lib-crypto/conversions/param.js");
var string_bytes_1 = __webpack_require__(/*! ../conversions/string-bytes */ "./node_modules/@waves/ts-lib-crypto/conversions/string-bytes.js");
exports.Seed = {
    isSeedWithNonce: function (val) {
        return val.nonce !== undefined;
    },
    toBinary: function (seed) {
        return exports.Seed.isSeedWithNonce(seed) ?
            { seed: exports.Seed.toBinary(seed.seed).seed, nonce: seed.nonce } :
            { seed: param_1._fromRawIn(seed), nonce: undefined };
    },
    toString: function (seed) {
        return string_bytes_1.bytesToString(exports.Seed.toBinary(seed).seed);
    },
};
//# sourceMappingURL=seed.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/index.js ***!
  \****************************************************/
/*! no static exports found */
/*! exports used: base58Decode */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = __webpack_require__(/*! ./crypto/crypto */ "./node_modules/@waves/ts-lib-crypto/crypto/crypto.js");
var seed_words_list_1 = __webpack_require__(/*! ./crypto/seed-words-list */ "./node_modules/@waves/ts-lib-crypto/crypto/seed-words-list.js");
exports.seedWordsList = seed_words_list_1.seedWordsList;
var chain_id_1 = __webpack_require__(/*! ./extensions/chain-id */ "./node_modules/@waves/ts-lib-crypto/extensions/chain-id.js");
exports.ChaidId = chain_id_1.ChaidId;
var seed_1 = __webpack_require__(/*! ./extensions/seed */ "./node_modules/@waves/ts-lib-crypto/extensions/seed.js");
exports.Seed = seed_1.Seed;
var util_1 = __webpack_require__(/*! ./crypto/util */ "./node_modules/@waves/ts-lib-crypto/crypto/util.js");
exports.isPrivateKey = util_1.isPrivateKey;
exports.isPublicKey = util_1.isPublicKey;
var crypto_2 = __webpack_require__(/*! ./crypto/crypto */ "./node_modules/@waves/ts-lib-crypto/crypto/crypto.js");
exports.crypto = crypto_2.crypto;
__export(__webpack_require__(/*! ./crypto/interface */ "./node_modules/@waves/ts-lib-crypto/crypto/interface.js"));
exports.signBytes = (_a = crypto_1.crypto({ output: 'Base58' }), _a.signBytes), exports.keyPair = _a.keyPair, exports.publicKey = _a.publicKey, exports.privateKey = _a.privateKey, exports.address = _a.address, exports.buildAddress = _a.buildAddress, exports.blake2b = _a.blake2b, exports.keccak = _a.keccak, exports.sha256 = _a.sha256, exports.sharedKey = _a.sharedKey, exports.seedWithNonce = _a.seedWithNonce, exports.base64Encode = _a.base64Encode, exports.base64Decode = _a.base64Decode, exports.base58Encode = _a.base58Encode, exports.base58Decode = _a.base58Decode, exports.base16Encode = _a.base16Encode, exports.base16Decode = _a.base16Decode, exports.stringToBytes = _a.stringToBytes, exports.bytesToString = _a.bytesToString, exports.random = _a.random, exports.randomSeed = _a.randomSeed, exports.randomBytes = _a.randomBytes, exports.verifySignature = _a.verifySignature, exports.verifyPublicKey = _a.verifyPublicKey, exports.verifyAddress = _a.verifyAddress, exports.messageDecrypt = _a.messageDecrypt, exports.messageEncrypt = _a.messageEncrypt, exports.aesDecrypt = _a.aesDecrypt, exports.aesEncrypt = _a.aesEncrypt, exports.encryptSeed = _a.encryptSeed, exports.decryptSeed = _a.decryptSeed, exports.rsaKeyPair = _a.rsaKeyPair, exports.rsaKeyPairSync = _a.rsaKeyPairSync, exports.rsaSign = _a.rsaSign, exports.rsaVerify = _a.rsaVerify, exports.merkleVerify = _a.merkleVerify, exports.split = _a.split, exports.concat = _a.concat;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/libs/Utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/libs/Utf8.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Utf8ArrayToStr = (function () {
    var charCache = new Array(128); // Preallocate the cache for the common single byte chars
    var charFromCodePt = String.fromCodePoint || String.fromCharCode;
    var result = [];
    return function (array) {
        var codePt, byte1;
        var buffLen = array.length;
        result.length = 0;
        for (var i = 0; i < buffLen;) {
            byte1 = array[i++];
            if (byte1 <= 0x7F) {
                codePt = byte1;
            }
            else if (byte1 <= 0xDF) {
                codePt = ((byte1 & 0x1F) << 6) | (array[i++] & 0x3F);
            }
            else if (byte1 <= 0xEF) {
                codePt = ((byte1 & 0x0F) << 12) | ((array[i++] & 0x3F) << 6) | (array[i++] & 0x3F);
            }
            else if (String.fromCodePoint) {
                codePt = ((byte1 & 0x07) << 18) | ((array[i++] & 0x3F) << 12) | ((array[i++] & 0x3F) << 6) | (array[i++] & 0x3F);
            }
            else {
                codePt = 63; // Cannot convertLongFields four byte code points, so use "?" instead
                i += 3;
            }
            result.push(charCache[codePt] || (charCache[codePt] = charFromCodePt(codePt)));
        }
        return result.join('');
    };
});
exports.utf8ArrayToStr = Utf8ArrayToStr();
function strToUtf8Array(str) {
    var utf8 = [];
    for (var i = 0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80)
            utf8.push(charcode);
        else if (charcode < 0x800) {
            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
            i++;
            // UTF-16 encodes 0x10000-0x10FFFF by
            // subtracting 0x10000 and splitting the
            // 20 bits of 0x0-0xFFFFF into two halves
            charcode = 0x10000 + (((charcode & 0x3ff) << 10)
                | (str.charCodeAt(i) & 0x3ff));
            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
        }
    }
    return Uint8Array.from(utf8);
}
exports.strToUtf8Array = strToUtf8Array;
//# sourceMappingURL=Utf8.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/libs/axlsign.js":
/*!***********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/libs/axlsign.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Curve25519 signatures (and also key agreement)
// like in the early Axolotl.
//
// Written by Dmitry Chestnykh.
// You can use it under MIT or CC0 license.
exports.__esModule = true
// Curve25519 signatures idea and math by Trevor Perrin
// https://moderncrypto.org/mail-archive/curves/2014/000205.html
// Derived from TweetNaCl.js (https://tweetnacl.js.org/)
// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/
var axlsign = Object.create(null)
var gf = function (init) {
  var i, r = new Float64Array(16)
  if (init)
    for (i = 0; i < init.length; i++)
      r[i] = init[i]
  return r
}
var _0 = new Uint8Array(16)
var _9 = new Uint8Array(32)
_9[0] = 9
var gf0 = gf(), gf1 = gf([1]), _121665 = gf([0xdb41, 1]), D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]), D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]), X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]), Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]), I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83])
function ts64(x, i, h, l) {
  x[i] = (h >> 24) & 0xff
  x[i + 1] = (h >> 16) & 0xff
  x[i + 2] = (h >> 8) & 0xff
  x[i + 3] = h & 0xff
  x[i + 4] = (l >> 24) & 0xff
  x[i + 5] = (l >> 16) & 0xff
  x[i + 6] = (l >> 8) & 0xff
  x[i + 7] = l & 0xff
}
function vn(x, xi, y, yi, n) {
  var i, d = 0
  for (i = 0; i < n; i++)
    d |= x[xi + i] ^ y[yi + i]
  return (1 & ((d - 1) >>> 8)) - 1
}
function crypto_verify_32(x, xi, y, yi) {
  return vn(x, xi, y, yi, 32)
}
function set25519(r, a) {
  for (var i = 0; i < 16; i++)
    r[i] = a[i] | 0
}
function car25519(o) {
  var i, v, c = 1
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535
    c = Math.floor(v / 65536)
    o[i] = v - c * 65536
  }
  o[0] += c - 1 + 37 * (c - 1)
}
function sel25519(p, q, b) {
  var t, c = ~(b - 1)
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i])
    p[i] ^= t
    q[i] ^= t
  }
}
function pack25519(o, n) {
  var i, j, b
  var m = gf(), t = gf()
  for (i = 0; i < 16; i++)
    t[i] = n[i]
  car25519(t)
  car25519(t)
  car25519(t)
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i - 1] >> 16) & 1)
      m[i - 1] &= 0xffff
    }
    m[15] = t[15] - 0x7fff - ((m[14] >> 16) & 1)
    b = (m[15] >> 16) & 1
    m[14] &= 0xffff
    sel25519(t, m, 1 - b)
  }
  for (i = 0; i < 16; i++) {
    o[2 * i] = t[i] & 0xff
    o[2 * i + 1] = t[i] >> 8
  }
}
function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32)
  pack25519(c, a)
  pack25519(d, b)
  return crypto_verify_32(c, 0, d, 0)
}
function par25519(a) {
  var d = new Uint8Array(32)
  pack25519(d, a)
  return d[0] & 1
}
function unpack25519(o, n) {
  for (var i = 0; i < 16; i++)
    o[i] = n[2 * i] + (n[2 * i + 1] << 8)
  o[15] &= 0x7fff
}
function A(o, a, b) {
  for (var i = 0; i < 16; i++)
    o[i] = a[i] + b[i]
}
function Z(o, a, b) {
  for (var i = 0; i < 16; i++)
    o[i] = a[i] - b[i]
}
function M(o, a, b) {
  var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15]
  v = a[0]
  t0 += v * b0
  t1 += v * b1
  t2 += v * b2
  t3 += v * b3
  t4 += v * b4
  t5 += v * b5
  t6 += v * b6
  t7 += v * b7
  t8 += v * b8
  t9 += v * b9
  t10 += v * b10
  t11 += v * b11
  t12 += v * b12
  t13 += v * b13
  t14 += v * b14
  t15 += v * b15
  v = a[1]
  t1 += v * b0
  t2 += v * b1
  t3 += v * b2
  t4 += v * b3
  t5 += v * b4
  t6 += v * b5
  t7 += v * b6
  t8 += v * b7
  t9 += v * b8
  t10 += v * b9
  t11 += v * b10
  t12 += v * b11
  t13 += v * b12
  t14 += v * b13
  t15 += v * b14
  t16 += v * b15
  v = a[2]
  t2 += v * b0
  t3 += v * b1
  t4 += v * b2
  t5 += v * b3
  t6 += v * b4
  t7 += v * b5
  t8 += v * b6
  t9 += v * b7
  t10 += v * b8
  t11 += v * b9
  t12 += v * b10
  t13 += v * b11
  t14 += v * b12
  t15 += v * b13
  t16 += v * b14
  t17 += v * b15
  v = a[3]
  t3 += v * b0
  t4 += v * b1
  t5 += v * b2
  t6 += v * b3
  t7 += v * b4
  t8 += v * b5
  t9 += v * b6
  t10 += v * b7
  t11 += v * b8
  t12 += v * b9
  t13 += v * b10
  t14 += v * b11
  t15 += v * b12
  t16 += v * b13
  t17 += v * b14
  t18 += v * b15
  v = a[4]
  t4 += v * b0
  t5 += v * b1
  t6 += v * b2
  t7 += v * b3
  t8 += v * b4
  t9 += v * b5
  t10 += v * b6
  t11 += v * b7
  t12 += v * b8
  t13 += v * b9
  t14 += v * b10
  t15 += v * b11
  t16 += v * b12
  t17 += v * b13
  t18 += v * b14
  t19 += v * b15
  v = a[5]
  t5 += v * b0
  t6 += v * b1
  t7 += v * b2
  t8 += v * b3
  t9 += v * b4
  t10 += v * b5
  t11 += v * b6
  t12 += v * b7
  t13 += v * b8
  t14 += v * b9
  t15 += v * b10
  t16 += v * b11
  t17 += v * b12
  t18 += v * b13
  t19 += v * b14
  t20 += v * b15
  v = a[6]
  t6 += v * b0
  t7 += v * b1
  t8 += v * b2
  t9 += v * b3
  t10 += v * b4
  t11 += v * b5
  t12 += v * b6
  t13 += v * b7
  t14 += v * b8
  t15 += v * b9
  t16 += v * b10
  t17 += v * b11
  t18 += v * b12
  t19 += v * b13
  t20 += v * b14
  t21 += v * b15
  v = a[7]
  t7 += v * b0
  t8 += v * b1
  t9 += v * b2
  t10 += v * b3
  t11 += v * b4
  t12 += v * b5
  t13 += v * b6
  t14 += v * b7
  t15 += v * b8
  t16 += v * b9
  t17 += v * b10
  t18 += v * b11
  t19 += v * b12
  t20 += v * b13
  t21 += v * b14
  t22 += v * b15
  v = a[8]
  t8 += v * b0
  t9 += v * b1
  t10 += v * b2
  t11 += v * b3
  t12 += v * b4
  t13 += v * b5
  t14 += v * b6
  t15 += v * b7
  t16 += v * b8
  t17 += v * b9
  t18 += v * b10
  t19 += v * b11
  t20 += v * b12
  t21 += v * b13
  t22 += v * b14
  t23 += v * b15
  v = a[9]
  t9 += v * b0
  t10 += v * b1
  t11 += v * b2
  t12 += v * b3
  t13 += v * b4
  t14 += v * b5
  t15 += v * b6
  t16 += v * b7
  t17 += v * b8
  t18 += v * b9
  t19 += v * b10
  t20 += v * b11
  t21 += v * b12
  t22 += v * b13
  t23 += v * b14
  t24 += v * b15
  v = a[10]
  t10 += v * b0
  t11 += v * b1
  t12 += v * b2
  t13 += v * b3
  t14 += v * b4
  t15 += v * b5
  t16 += v * b6
  t17 += v * b7
  t18 += v * b8
  t19 += v * b9
  t20 += v * b10
  t21 += v * b11
  t22 += v * b12
  t23 += v * b13
  t24 += v * b14
  t25 += v * b15
  v = a[11]
  t11 += v * b0
  t12 += v * b1
  t13 += v * b2
  t14 += v * b3
  t15 += v * b4
  t16 += v * b5
  t17 += v * b6
  t18 += v * b7
  t19 += v * b8
  t20 += v * b9
  t21 += v * b10
  t22 += v * b11
  t23 += v * b12
  t24 += v * b13
  t25 += v * b14
  t26 += v * b15
  v = a[12]
  t12 += v * b0
  t13 += v * b1
  t14 += v * b2
  t15 += v * b3
  t16 += v * b4
  t17 += v * b5
  t18 += v * b6
  t19 += v * b7
  t20 += v * b8
  t21 += v * b9
  t22 += v * b10
  t23 += v * b11
  t24 += v * b12
  t25 += v * b13
  t26 += v * b14
  t27 += v * b15
  v = a[13]
  t13 += v * b0
  t14 += v * b1
  t15 += v * b2
  t16 += v * b3
  t17 += v * b4
  t18 += v * b5
  t19 += v * b6
  t20 += v * b7
  t21 += v * b8
  t22 += v * b9
  t23 += v * b10
  t24 += v * b11
  t25 += v * b12
  t26 += v * b13
  t27 += v * b14
  t28 += v * b15
  v = a[14]
  t14 += v * b0
  t15 += v * b1
  t16 += v * b2
  t17 += v * b3
  t18 += v * b4
  t19 += v * b5
  t20 += v * b6
  t21 += v * b7
  t22 += v * b8
  t23 += v * b9
  t24 += v * b10
  t25 += v * b11
  t26 += v * b12
  t27 += v * b13
  t28 += v * b14
  t29 += v * b15
  v = a[15]
  t15 += v * b0
  t16 += v * b1
  t17 += v * b2
  t18 += v * b3
  t19 += v * b4
  t20 += v * b5
  t21 += v * b6
  t22 += v * b7
  t23 += v * b8
  t24 += v * b9
  t25 += v * b10
  t26 += v * b11
  t27 += v * b12
  t28 += v * b13
  t29 += v * b14
  t30 += v * b15
  t0 += 38 * t16
  t1 += 38 * t17
  t2 += 38 * t18
  t3 += 38 * t19
  t4 += 38 * t20
  t5 += 38 * t21
  t6 += 38 * t22
  t7 += 38 * t23
  t8 += 38 * t24
  t9 += 38 * t25
  t10 += 38 * t26
  t11 += 38 * t27
  t12 += 38 * t28
  t13 += 38 * t29
  t14 += 38 * t30
  // t15 left as is
  // first car
  c = 1
  v = t0 + c + 65535
  c = Math.floor(v / 65536)
  t0 = v - c * 65536
  v = t1 + c + 65535
  c = Math.floor(v / 65536)
  t1 = v - c * 65536
  v = t2 + c + 65535
  c = Math.floor(v / 65536)
  t2 = v - c * 65536
  v = t3 + c + 65535
  c = Math.floor(v / 65536)
  t3 = v - c * 65536
  v = t4 + c + 65535
  c = Math.floor(v / 65536)
  t4 = v - c * 65536
  v = t5 + c + 65535
  c = Math.floor(v / 65536)
  t5 = v - c * 65536
  v = t6 + c + 65535
  c = Math.floor(v / 65536)
  t6 = v - c * 65536
  v = t7 + c + 65535
  c = Math.floor(v / 65536)
  t7 = v - c * 65536
  v = t8 + c + 65535
  c = Math.floor(v / 65536)
  t8 = v - c * 65536
  v = t9 + c + 65535
  c = Math.floor(v / 65536)
  t9 = v - c * 65536
  v = t10 + c + 65535
  c = Math.floor(v / 65536)
  t10 = v - c * 65536
  v = t11 + c + 65535
  c = Math.floor(v / 65536)
  t11 = v - c * 65536
  v = t12 + c + 65535
  c = Math.floor(v / 65536)
  t12 = v - c * 65536
  v = t13 + c + 65535
  c = Math.floor(v / 65536)
  t13 = v - c * 65536
  v = t14 + c + 65535
  c = Math.floor(v / 65536)
  t14 = v - c * 65536
  v = t15 + c + 65535
  c = Math.floor(v / 65536)
  t15 = v - c * 65536
  t0 += c - 1 + 37 * (c - 1)
  // second car
  c = 1
  v = t0 + c + 65535
  c = Math.floor(v / 65536)
  t0 = v - c * 65536
  v = t1 + c + 65535
  c = Math.floor(v / 65536)
  t1 = v - c * 65536
  v = t2 + c + 65535
  c = Math.floor(v / 65536)
  t2 = v - c * 65536
  v = t3 + c + 65535
  c = Math.floor(v / 65536)
  t3 = v - c * 65536
  v = t4 + c + 65535
  c = Math.floor(v / 65536)
  t4 = v - c * 65536
  v = t5 + c + 65535
  c = Math.floor(v / 65536)
  t5 = v - c * 65536
  v = t6 + c + 65535
  c = Math.floor(v / 65536)
  t6 = v - c * 65536
  v = t7 + c + 65535
  c = Math.floor(v / 65536)
  t7 = v - c * 65536
  v = t8 + c + 65535
  c = Math.floor(v / 65536)
  t8 = v - c * 65536
  v = t9 + c + 65535
  c = Math.floor(v / 65536)
  t9 = v - c * 65536
  v = t10 + c + 65535
  c = Math.floor(v / 65536)
  t10 = v - c * 65536
  v = t11 + c + 65535
  c = Math.floor(v / 65536)
  t11 = v - c * 65536
  v = t12 + c + 65535
  c = Math.floor(v / 65536)
  t12 = v - c * 65536
  v = t13 + c + 65535
  c = Math.floor(v / 65536)
  t13 = v - c * 65536
  v = t14 + c + 65535
  c = Math.floor(v / 65536)
  t14 = v - c * 65536
  v = t15 + c + 65535
  c = Math.floor(v / 65536)
  t15 = v - c * 65536
  t0 += c - 1 + 37 * (c - 1)
  o[0] = t0
  o[1] = t1
  o[2] = t2
  o[3] = t3
  o[4] = t4
  o[5] = t5
  o[6] = t6
  o[7] = t7
  o[8] = t8
  o[9] = t9
  o[10] = t10
  o[11] = t11
  o[12] = t12
  o[13] = t13
  o[14] = t14
  o[15] = t15
}
function S(o, a) {
  M(o, a, a)
}
function inv25519(o, i) {
  var c = gf()
  var a
  for (a = 0; a < 16; a++)
    c[a] = i[a]
  for (a = 253; a >= 0; a--) {
    S(c, c)
    if (a !== 2 && a !== 4)
      M(c, c, i)
  }
  for (a = 0; a < 16; a++)
    o[a] = c[a]
}
function pow2523(o, i) {
  var c = gf()
  var a
  for (a = 0; a < 16; a++)
    c[a] = i[a]
  for (a = 250; a >= 0; a--) {
    S(c, c)
    if (a !== 1)
      M(c, c, i)
  }
  for (a = 0; a < 16; a++)
    o[a] = c[a]
}
function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32)
  var x = new Float64Array(80)
  var r, i
  var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf()
  for (i = 0; i < 31; i++)
    z[i] = n[i]
  z[31] = (n[31] & 127) | 64
  z[0] &= 248
  unpack25519(x, p)
  for (i = 0; i < 16; i++) {
    b[i] = x[i]
    d[i] = a[i] = c[i] = 0
  }
  a[0] = d[0] = 1
  for (i = 254; i >= 0; --i) {
    r = (z[i >>> 3] >>> (i & 7)) & 1
    sel25519(a, b, r)
    sel25519(c, d, r)
    A(e, a, c)
    Z(a, a, c)
    A(c, b, d)
    Z(b, b, d)
    S(d, e)
    S(f, a)
    M(a, c, a)
    M(c, b, e)
    A(e, a, c)
    Z(a, a, c)
    S(b, a)
    Z(c, d, f)
    M(a, c, _121665)
    A(a, a, d)
    M(c, c, a)
    M(a, d, f)
    M(d, b, x)
    S(b, e)
    sel25519(a, b, r)
    sel25519(c, d, r)
  }
  for (i = 0; i < 16; i++) {
    x[i + 16] = a[i]
    x[i + 32] = c[i]
    x[i + 48] = b[i]
    x[i + 64] = d[i]
  }
  var x32 = x.subarray(32)
  var x16 = x.subarray(16)
  inv25519(x32, x32)
  M(x16, x16, x32)
  pack25519(q, x16)
  return 0
}
function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9)
}
var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817,
]
function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16)
  var bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d
  var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7]
  var pos = 0
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos
      wh[i] = (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3]
      wl[i] = (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7]
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0
      bh1 = ah1
      bh2 = ah2
      bh3 = ah3
      bh4 = ah4
      bh5 = ah5
      bh6 = ah6
      bh7 = ah7
      bl0 = al0
      bl1 = al1
      bl2 = al2
      bl3 = al3
      bl4 = al4
      bl5 = al5
      bl6 = al6
      bl7 = al7
      // add
      h = ah7
      l = al7
      a = l & 0xffff
      b = l >>> 16
      c = h & 0xffff
      d = h >>> 16
      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) | (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))))
      l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) | (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))))
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6)
      l = (al4 & al5) ^ (~al4 & al6)
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      // K
      h = K[i * 2]
      l = K[i * 2 + 1]
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      // w
      h = wh[i % 16]
      l = wl[i % 16]
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      b += a >>> 16
      c += b >>> 16
      d += c >>> 16
      th = c & 0xffff | d << 16
      tl = a & 0xffff | b << 16
      // add
      h = th
      l = tl
      a = l & 0xffff
      b = l >>> 16
      c = h & 0xffff
      d = h >>> 16
      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))))
      l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))))
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2)
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2)
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      b += a >>> 16
      c += b >>> 16
      d += c >>> 16
      bh7 = (c & 0xffff) | (d << 16)
      bl7 = (a & 0xffff) | (b << 16)
      // add
      h = bh3
      l = bl3
      a = l & 0xffff
      b = l >>> 16
      c = h & 0xffff
      d = h >>> 16
      h = th
      l = tl
      a += l & 0xffff
      b += l >>> 16
      c += h & 0xffff
      d += h >>> 16
      b += a >>> 16
      c += b >>> 16
      d += c >>> 16
      bh3 = (c & 0xffff) | (d << 16)
      bl3 = (a & 0xffff) | (b << 16)
      ah1 = bh0
      ah2 = bh1
      ah3 = bh2
      ah4 = bh3
      ah5 = bh4
      ah6 = bh5
      ah7 = bh6
      ah0 = bh7
      al1 = bl0
      al2 = bl1
      al3 = bl2
      al4 = bl3
      al5 = bl4
      al6 = bl5
      al7 = bl6
      al0 = bl7
      if (i % 16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j]
          l = wl[j]
          a = l & 0xffff
          b = l >>> 16
          c = h & 0xffff
          d = h >>> 16
          h = wh[(j + 9) % 16]
          l = wl[(j + 9) % 16]
          a += l & 0xffff
          b += l >>> 16
          c += h & 0xffff
          d += h >>> 16
          // sigma0
          th = wh[(j + 1) % 16]
          tl = wl[(j + 1) % 16]
          h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) | (tl << (32 - 8))) ^ (th >>> 7)
          l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) | (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)))
          a += l & 0xffff
          b += l >>> 16
          c += h & 0xffff
          d += h >>> 16
          // sigma1
          th = wh[(j + 14) % 16]
          tl = wl[(j + 14) % 16]
          h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^ (th >>> 6)
          l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)))
          a += l & 0xffff
          b += l >>> 16
          c += h & 0xffff
          d += h >>> 16
          b += a >>> 16
          c += b >>> 16
          d += c >>> 16
          wh[j] = (c & 0xffff) | (d << 16)
          wl[j] = (a & 0xffff) | (b << 16)
        }
      }
    }
    // add
    h = ah0
    l = al0
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[0]
    l = hl[0]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[0] = ah0 = (c & 0xffff) | (d << 16)
    hl[0] = al0 = (a & 0xffff) | (b << 16)
    h = ah1
    l = al1
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[1]
    l = hl[1]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[1] = ah1 = (c & 0xffff) | (d << 16)
    hl[1] = al1 = (a & 0xffff) | (b << 16)
    h = ah2
    l = al2
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[2]
    l = hl[2]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[2] = ah2 = (c & 0xffff) | (d << 16)
    hl[2] = al2 = (a & 0xffff) | (b << 16)
    h = ah3
    l = al3
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[3]
    l = hl[3]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[3] = ah3 = (c & 0xffff) | (d << 16)
    hl[3] = al3 = (a & 0xffff) | (b << 16)
    h = ah4
    l = al4
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[4]
    l = hl[4]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[4] = ah4 = (c & 0xffff) | (d << 16)
    hl[4] = al4 = (a & 0xffff) | (b << 16)
    h = ah5
    l = al5
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[5]
    l = hl[5]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[5] = ah5 = (c & 0xffff) | (d << 16)
    hl[5] = al5 = (a & 0xffff) | (b << 16)
    h = ah6
    l = al6
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[6]
    l = hl[6]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[6] = ah6 = (c & 0xffff) | (d << 16)
    hl[6] = al6 = (a & 0xffff) | (b << 16)
    h = ah7
    l = al7
    a = l & 0xffff
    b = l >>> 16
    c = h & 0xffff
    d = h >>> 16
    h = hh[7]
    l = hl[7]
    a += l & 0xffff
    b += l >>> 16
    c += h & 0xffff
    d += h >>> 16
    b += a >>> 16
    c += b >>> 16
    d += c >>> 16
    hh[7] = ah7 = (c & 0xffff) | (d << 16)
    hl[7] = al7 = (a & 0xffff) | (b << 16)
    pos += 128
    n -= 128
  }
  return n
}
function crypto_hash(out, m, n) {
  var hh = new Int32Array(8)
  var hl = new Int32Array(8)
  var x = new Uint8Array(256)
  var i, b = n
  hh[0] = 0x6a09e667
  hh[1] = 0xbb67ae85
  hh[2] = 0x3c6ef372
  hh[3] = 0xa54ff53a
  hh[4] = 0x510e527f
  hh[5] = 0x9b05688c
  hh[6] = 0x1f83d9ab
  hh[7] = 0x5be0cd19
  hl[0] = 0xf3bcc908
  hl[1] = 0x84caa73b
  hl[2] = 0xfe94f82b
  hl[3] = 0x5f1d36f1
  hl[4] = 0xade682d1
  hl[5] = 0x2b3e6c1f
  hl[6] = 0xfb41bd6b
  hl[7] = 0x137e2179
  crypto_hashblocks_hl(hh, hl, m, n)
  n %= 128
  for (i = 0; i < n; i++)
    x[i] = m[b - n + i]
  x[n] = 128
  n = 256 - 128 * (n < 112 ? 1 : 0)
  x[n - 9] = 0
  ts64(x, n - 8, (b / 0x20000000) | 0, b << 3)
  crypto_hashblocks_hl(hh, hl, x, n)
  for (i = 0; i < 8; i++)
    ts64(out, 8 * i, hh[i], hl[i])
  return 0
}
function add(p, q) {
  var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf()
  Z(a, p[1], p[0])
  Z(t, q[1], q[0])
  M(a, a, t)
  A(b, p[0], p[1])
  A(t, q[0], q[1])
  M(b, b, t)
  M(c, p[3], q[3])
  M(c, c, D2)
  M(d, p[2], q[2])
  A(d, d, d)
  Z(e, b, a)
  Z(f, d, c)
  A(g, d, c)
  A(h, b, a)
  M(p[0], e, f)
  M(p[1], h, g)
  M(p[2], g, f)
  M(p[3], e, h)
}
function cswap(p, q, b) {
  for (var i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b)
  }
}
function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf()
  inv25519(zi, p[2])
  M(tx, p[0], zi)
  M(ty, p[1], zi)
  pack25519(r, ty)
  r[31] ^= par25519(tx) << 7
}
function scalarmult(p, q, s) {
  var b, i
  set25519(p[0], gf0)
  set25519(p[1], gf1)
  set25519(p[2], gf1)
  set25519(p[3], gf0)
  for (i = 255; i >= 0; --i) {
    b = (s[(i / 8) | 0] >> (i & 7)) & 1
    cswap(p, q, b)
    add(q, p)
    add(p, p)
    cswap(p, q, b)
  }
}
function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()]
  set25519(q[0], X)
  set25519(q[1], Y)
  set25519(q[2], gf1)
  M(q[3], X, Y)
  scalarmult(p, q, s)
}
var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10])
function modL(r, x) {
  var carry, i, j, k
  for (i = 63; i >= 32; --i) {
    carry = 0
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)]
      carry = (x[j] + 128) >> 8
      x[j] -= carry * 256
    }
    x[j] += carry
    x[i] = 0
  }
  carry = 0
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j]
    carry = x[j] >> 8
    x[j] &= 255
  }
  for (j = 0; j < 32; j++)
    x[j] -= carry * L[j]
  for (i = 0; i < 32; i++) {
    x[i + 1] += x[i] >> 8
    r[i] = x[i] & 255
  }
}
function reduce(r) {
  var x = new Float64Array(64)
  var i
  for (i = 0; i < 64; i++)
    x[i] = r[i]
  for (i = 0; i < 64; i++)
    r[i] = 0
  modL(r, x)
}
// Like crypto_sign, but uses secret key directly in hash.
function crypto_sign_direct(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64)
  var x = new Float64Array(64)
  var p = [gf(), gf(), gf(), gf()]
  var i, j
  for (i = 0; i < n; i++)
    sm[64 + i] = m[i]
  for (i = 0; i < 32; i++)
    sm[32 + i] = sk[i]
  crypto_hash(r, sm.subarray(32), n + 32)
  reduce(r)
  scalarbase(p, r)
  pack(sm, p)
  for (i = 0; i < 32; i++)
    sm[i + 32] = sk[32 + i]
  crypto_hash(h, sm, n + 64)
  reduce(h)
  for (i = 0; i < 64; i++)
    x[i] = 0
  for (i = 0; i < 32; i++)
    x[i] = r[i]
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i + j] += h[i] * sk[j]
    }
  }
  modL(sm.subarray(32), x)
  return n + 64
}
// Note: sm must be n+128.
function crypto_sign_direct_rnd(sm, m, n, sk, rnd) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64)
  var x = new Float64Array(64)
  var p = [gf(), gf(), gf(), gf()]
  var i, j
  // Hash separation.
  sm[0] = 0xfe
  for (i = 1; i < 32; i++)
    sm[i] = 0xff
  // Secret key.
  for (i = 0; i < 32; i++)
    sm[32 + i] = sk[i]
  // Message.
  for (i = 0; i < n; i++)
    sm[64 + i] = m[i]
  // Random suffix.
  for (i = 0; i < 64; i++)
    sm[n + 64 + i] = rnd[i]
  crypto_hash(r, sm, n + 128)
  reduce(r)
  scalarbase(p, r)
  pack(sm, p)
  for (i = 0; i < 32; i++)
    sm[i + 32] = sk[32 + i]
  crypto_hash(h, sm, n + 64)
  reduce(h)
  // Wipe out random suffix.
  for (i = 0; i < 64; i++)
    sm[n + 64 + i] = 0
  for (i = 0; i < 64; i++)
    x[i] = 0
  for (i = 0; i < 32; i++)
    x[i] = r[i]
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i + j] += h[i] * sk[j]
    }
  }
  modL(sm.subarray(32, n + 64), x)
  return n + 64
}
function curve25519_sign(sm, m, n, sk, opt_rnd) {
  // If opt_rnd is provided, sm must have n + 128,
  // otherwise it must have n + 64 bytes.
  // Convert Curve25519 secret key into Ed25519 secret key (includes pub key).
  var edsk = new Uint8Array(64)
  var p = [gf(), gf(), gf(), gf()]
  for (var i = 0; i < 32; i++)
    edsk[i] = sk[i]
  // Ensure private key is in the correct format.
  edsk[0] &= 248
  edsk[31] &= 127
  edsk[31] |= 64
  scalarbase(p, edsk)
  pack(edsk.subarray(32), p)
  // Remember sign bit.
  var signBit = edsk[63] & 128
  var smlen
  if (opt_rnd) {
    smlen = crypto_sign_direct_rnd(sm, m, n, edsk, opt_rnd)
  }
  else {
    smlen = crypto_sign_direct(sm, m, n, edsk)
  }
  // Copy sign bit from public key into signature.
  sm[63] |= signBit
  return smlen
}
function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf()
  set25519(r[2], gf1)
  unpack25519(r[1], p)
  S(num, r[1])
  M(den, num, D)
  Z(num, num, r[2])
  A(den, r[2], den)
  S(den2, den)
  S(den4, den2)
  M(den6, den4, den2)
  M(t, den6, num)
  M(t, t, den)
  pow2523(t, t)
  M(t, t, num)
  M(t, t, den)
  M(t, t, den)
  M(r[0], t, den)
  S(chk, r[0])
  M(chk, chk, den)
  if (neq25519(chk, num))
    M(r[0], r[0], I)
  S(chk, r[0])
  M(chk, chk, den)
  if (neq25519(chk, num))
    return -1
  if (par25519(r[0]) === (p[31] >> 7))
    Z(r[0], gf0, r[0])
  M(r[3], r[0], r[1])
  return 0
}
function crypto_sign_open(m, sm, n, pk) {
  var i, mlen
  var t = new Uint8Array(32), h = new Uint8Array(64)
  var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()]
  mlen = -1
  if (n < 64)
    return -1
  if (unpackneg(q, pk))
    return -1
  for (i = 0; i < n; i++)
    m[i] = sm[i]
  for (i = 0; i < 32; i++)
    m[i + 32] = pk[i]
  crypto_hash(h, m, n)
  reduce(h)
  scalarmult(p, q, h)
  scalarbase(q, sm.subarray(32))
  add(p, q)
  pack(t, p)
  n -= 64
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++)
      m[i] = 0
    return -1
  }
  for (i = 0; i < n; i++)
    m[i] = sm[i + 64]
  mlen = n
  return mlen
}
// Converts Curve25519 public key back to Ed25519 public key.
// edwardsY = (montgomeryX - 1) / (montgomeryX + 1)
function convertPublicKey(pk) {
  var z = new Uint8Array(32), x = gf(), a = gf(), b = gf()
  unpack25519(x, pk)
  A(a, x, gf1)
  Z(b, x, gf1)
  inv25519(a, a)
  M(a, a, b)
  pack25519(z, a)
  return z
}
function curve25519_sign_open(m, sm, n, pk) {
  // Convert Curve25519 public key into Ed25519 public key.
  var edpk = convertPublicKey(pk)
  // Restore sign bit from signature.
  edpk[31] |= sm[63] & 128
  // Remove sign bit from signature.
  sm[63] &= 127
  // Verify signed message.
  return crypto_sign_open(m, sm, n, edpk)
}
/* High-level API */
function checkArrayTypes() {
  var args = []
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i]
  }
  var t, i
  for (i = 0; i < arguments.length; i++) {
    if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
      throw new TypeError('unexpected type ' + t + ', use Uint8Array')
  }
}
axlsign.sharedKey = function (secretKey, publicKey) {
  checkArrayTypes(publicKey, secretKey)
  if (publicKey.length !== 32)
    throw new Error('wrong public key length')
  if (secretKey.length !== 32)
    throw new Error('wrong secret key length')
  var sharedKey = new Uint8Array(32)
  crypto_scalarmult(sharedKey, secretKey, publicKey)
  return sharedKey
}
axlsign.signMessage = function (secretKey, msg, opt_random) {
  checkArrayTypes(msg, secretKey)
  if (secretKey.length !== 32)
    throw new Error('wrong secret key length')
  if (opt_random) {
    checkArrayTypes(opt_random)
    if (opt_random.length !== 64)
      throw new Error('wrong random data length')
    var buf = new Uint8Array(128 + msg.length)
    curve25519_sign(buf, msg, msg.length, secretKey, opt_random)
    return new Uint8Array(buf.subarray(0, 64 + msg.length))
  }
  else {
    var signedMsg = new Uint8Array(64 + msg.length)
    curve25519_sign(signedMsg, msg, msg.length, secretKey)
    return signedMsg
  }
}
axlsign.openMessage = function (publicKey, signedMsg) {
  checkArrayTypes(signedMsg, publicKey)
  if (publicKey.length !== 32)
    throw new Error('wrong public key length')
  var tmp = new Uint8Array(signedMsg.length)
  var mlen = curve25519_sign_open(tmp, signedMsg, signedMsg.length, publicKey)
  if (mlen < 0)
    return null
  var m = new Uint8Array(mlen)
  for (var i = 0; i < m.length; i++)
    m[i] = tmp[i]
  return m
}
axlsign.sign = function (secretKey, msg, opt_random) {
  checkArrayTypes(secretKey, msg)
  if (secretKey.length !== 32)
    throw new Error('wrong secret key length')
  if (opt_random) {
    checkArrayTypes(opt_random)
    if (opt_random.length !== 64)
      throw new Error('wrong random data length')
  }
  var buf = new Uint8Array((opt_random ? 128 : 64) + msg.length)
  curve25519_sign(buf, msg, msg.length, secretKey, opt_random)
  var signature = new Uint8Array(64)
  for (var i = 0; i < signature.length; i++)
    signature[i] = buf[i]
  return signature
}
axlsign.verify = function (publicKey, msg, signature) {
  checkArrayTypes(msg, signature, publicKey)
  if (signature.length !== 64)
    throw new Error('wrong signature length')
  if (publicKey.length !== 32)
    throw new Error('wrong public key length')
  var sm = new Uint8Array(64 + msg.length)
  var m = new Uint8Array(64 + msg.length)
  var i
  for (i = 0; i < 64; i++)
    sm[i] = signature[i]
  for (i = 0; i < msg.length; i++)
    sm[i + 64] = msg[i]
  return (curve25519_sign_open(m, sm, sm.length, publicKey) >= 0)
}
axlsign.generateKeyPair = function (seed) {
  checkArrayTypes(seed)
  if (seed.length !== 32)
    throw new Error('wrong seed length')
  var sk = new Uint8Array(32)
  var pk = new Uint8Array(32)
  for (var i = 0; i < 32; i++)
    sk[i] = seed[i]
  crypto_scalarmult_base(pk, sk)
  // Turn secret key into the correct format.
  sk[0] &= 248
  sk[31] &= 127
  sk[31] |= 64
  // Remove sign bit from public key.
  pk[31] &= 127
  return {
    public: pk,
    private: sk,
  }
}
exports['default'] = axlsign


/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/libs/base58.js":
/*!**********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/libs/base58.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var ALPHABET_MAP = ALPHABET.split('').reduce(function (map, c, i) {
    map[c] = i;
    return map;
}, {});
exports.default = {
    encode: function (buffer) {
        if (!buffer.length)
            return '';
        var digits = [0];
        for (var i = 0; i < buffer.length; i++) {
            for (var j = 0; j < digits.length; j++) {
                digits[j] <<= 8;
            }
            digits[0] += buffer[i];
            var carry = 0;
            for (var k = 0; k < digits.length; k++) {
                digits[k] += carry;
                carry = (digits[k] / 58) | 0;
                digits[k] %= 58;
            }
            while (carry) {
                digits.push(carry % 58);
                carry = (carry / 58) | 0;
            }
        }
        for (var i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) {
            digits.push(0);
        }
        return digits.reverse().map(function (digit) {
            return ALPHABET[digit];
        }).join('');
    },
    decode: function (string) {
        if (!string.length)
            return new Uint8Array(0);
        var bytes = [0];
        for (var i = 0; i < string.length; i++) {
            var c = string[i];
            if (!(c in ALPHABET_MAP)) {
                throw "There is no character \"" + c + "\" in the Base58 sequence!";
            }
            for (var j = 0; j < bytes.length; j++) {
                bytes[j] *= 58;
            }
            bytes[0] += ALPHABET_MAP[c];
            var carry = 0;
            for (var j = 0; j < bytes.length; j++) {
                bytes[j] += carry;
                carry = bytes[j] >> 8;
                bytes[j] &= 0xff;
            }
            while (carry) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        for (var i = 0; string[i] === '1' && i < string.length - 1; i++) {
            bytes.push(0);
        }
        return new Uint8Array(bytes.reverse());
    },
};
//# sourceMappingURL=base58.js.map

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/libs/blake2b.js":
/*!***********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/libs/blake2b.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
exports.__esModule = true;
var ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';
// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput(input) {
    var ret;
    if (input instanceof Uint8Array) {
        ret = input;
    }
    else if (input instanceof Buffer) {
        ret = new Uint8Array(input);
    }
    else if (typeof (input) === 'string') {
        ret = new Uint8Array(Buffer.from(input, 'utf8'));
    }
    else {
        throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
}
// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex(bytes) {
    return Array.prototype.map.call(bytes, function (n) {
        return (n < 16 ? '0' : '') + n.toString(16);
    }).join('');
}
// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex(val) {
    return (0x100000000 + val).toString(16).substring(1);
}
// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint(label, arr, size) {
    var msg = '\n' + label + ' = ';
    for (var i = 0; i < arr.length; i += 2) {
        if (size === 32) {
            msg += uint32ToHex(arr[i]).toUpperCase();
            msg += ' ';
            msg += uint32ToHex(arr[i + 1]).toUpperCase();
        }
        else if (size === 64) {
            msg += uint32ToHex(arr[i + 1]).toUpperCase();
            msg += uint32ToHex(arr[i]).toUpperCase();
        }
        else
            throw new Error('Invalid size ' + size);
        if (i % 6 === 4) {
            msg += '\n' + new Array(label.length + 4).join(' ');
        }
        else if (i < arr.length - 2) {
            msg += ' ';
        }
    }
}
// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed(hashFn, N, M) {
    var startMs = new Date().getTime();
    var input = new Uint8Array(N);
    for (var i = 0; i < N; i++) {
        input[i] = i % 256;
    }
    var genMs = new Date().getTime();
    startMs = genMs;
    for (i = 0; i < M; i++) {
        var hashHex = hashFn(input);
        var hashMs = new Date().getTime();
        var ms = hashMs - startMs;
        startMs = hashMs;
    }
}
// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch
// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA(v, a, b) {
    var o0 = v[a] + v[b];
    var o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC(v, a, b0, b1) {
    var o0 = v[a] + b0;
    if (b0 < 0) {
        o0 += 0x100000000;
    }
    var o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// Little-endian byte access
function B2B_GET32(arr, i) {
    return (arr[i] ^
        (arr[i + 1] << 8) ^
        (arr[i + 2] << 16) ^
        (arr[i + 3] << 24));
}
// G Mixing function
// The ROTRs are inlined for speed
function B2B_G(a, b, c, d, ix, iy) {
    var x0 = m[ix];
    var x1 = m[ix + 1];
    var y0 = m[iy];
    var y1 = m[iy + 1];
    ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    var xor0 = v[d] ^ v[a];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = (xor0 >>> 24) ^ (xor1 << 8);
    v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = (xor0 >>> 16) ^ (xor1 << 16);
    v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = (xor1 >>> 31) ^ (xor0 << 1);
    v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
}
// Initialization Vector
var BLAKE2B_IV32 = new Uint32Array([
    0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85,
    0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A,
    0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C,
    0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19
]);
var SIGMA8 = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,
    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,
    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,
    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,
    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,
    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,
    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,
    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
];
// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
    return x * 2;
}));
// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
var v = new Uint32Array(32);
var m = new Uint32Array(32);
function blake2bCompress(ctx, last) {
    var i = 0;
    // init work variables
    for (i = 0; i < 16; i++) {
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
    }
    // low 64 bits of offset
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ (ctx.t / 0x100000000);
    // high 64 bits not supported, offset may not be higher than 2**53-1
    // last block flag set ?
    if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
    }
    // get little-endian words
    for (i = 0; i < 32; i++) {
        m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    // twelve rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 64)
    for (i = 0; i < 12; i++) {
        // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    // util.debugPrint('   (i=12) v[16]', v, 64)
    for (i = 0; i < 16; i++) {
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
    // util.debugPrint('h[8]', ctx.h, 64)
}
// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
function blake2bInit(outlen, key) {
    if (outlen === 0 || outlen > 64) {
        throw new Error('Illegal output length, expected 0 < length <= 64');
    }
    if (key && key.length > 64) {
        throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64');
    }
    // state, 'param block'
    var ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        c: 0,
        outlen: outlen // output length in bytes
    };
    // initialize hash state
    for (var i = 0; i < 16; i++) {
        ctx.h[i] = BLAKE2B_IV32[i];
    }
    var keylen = key ? key.length : 0;
    ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;
    // key the hash, if applicable
    if (key) {
        blake2bUpdate(ctx, key);
        // at the end
        ctx.c = 128;
    }
    return ctx;
}
exports.blake2bInit = blake2bInit;
// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate(ctx, input) {
    for (var i = 0; i < input.length; i++) {
        if (ctx.c === 128) { // buffer full ?
            ctx.t += ctx.c; // add counters
            blake2bCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
exports.blake2bUpdate = blake2bUpdate;
// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal(ctx) {
    ctx.t += ctx.c; // mark last block offset
    while (ctx.c < 128) { // fill up with zeros
        ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1
    // little endian convert and store
    var out = new Uint8Array(ctx.outlen);
    for (var i = 0; i < ctx.outlen; i++) {
        out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
    }
    return out;
}
exports.blake2bFinal = blake2bFinal;
// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2b(input, key, outlen) {
    // preprocess inputs
    outlen = outlen || 64;
    input = normalizeInput(input);
    // do the math
    var ctx = blake2bInit(outlen, key);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
}
exports.blake2b = blake2b;
// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
function blake2bHex(input, key, outlen) {
    var output = blake2b(input, key, outlen);
    return toHex(output);
}
exports.blake2bHex = blake2bHex;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/@waves/ts-lib-crypto/libs/sha3.js":
/*!********************************************************!*\
  !*** ./node_modules/@waves/ts-lib-crypto/libs/sha3.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.5.7
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2016
 * @license MIT
 */
exports.__esModule = true;
var sha3 = {};
var HEX_CHARS = '0123456789abcdef'.split('');
var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
var KECCAK_PADDING = [1, 256, 65536, 16777216];
var PADDING = [6, 1536, 393216, 100663296];
var SHIFT = [0, 8, 16, 24];
var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
  0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
  2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
  2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
  2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
var BITS = [224, 256, 384, 512];
var SHAKE_BITS = [128, 256];
var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array'];
var createOutputMethod = function (bits, padding, outputType) {
  return function (message) {
    return new Keccak(bits, padding, bits).update(message)[outputType]();
  };
};
var createShakeOutputMethod = function (bits, padding, outputType) {
  return function (message, outputBits) {
    return new Keccak(bits, padding, outputBits).update(message)[outputType]();
  };
};
var createMethod = function (bits, padding) {
  var method = createOutputMethod(bits, padding, 'hex');
  method.create = function () {
    return new Keccak(bits, padding, bits);
  };
  method.update = function (message) {
    return method.create().update(message);
  };
  for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
    var type = OUTPUT_TYPES[i];
    method[type] = createOutputMethod(bits, padding, type);
  }
  return method;
};
var createShakeMethod = function (bits, padding) {
  var method = createShakeOutputMethod(bits, padding, 'hex');
  method.create = function (outputBits) {
    return new Keccak(bits, padding, outputBits);
  };
  method.update = function (message, outputBits) {
    return method.create(outputBits).update(message);
  };
  for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
    var type = OUTPUT_TYPES[i];
    method[type] = createShakeOutputMethod(bits, padding, type);
  }
  return method;
};
var algorithms = [
  { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
  { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
  { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod }
];
var methods = {}, methodNames = [];
for (var i = 0; i < algorithms.length; ++i) {
  var algorithm = algorithms[i];
  var bits = algorithm.bits;
  for (var j = 0; j < bits.length; ++j) {
    var methodName = algorithm.name + '_' + bits[j];
    methodNames.push(methodName);
    methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
  }
}
function Keccak(bits, padding, outputBits) {
  this.blocks = [];
  this.s = [];
  this.padding = padding;
  this.outputBits = outputBits;
  this.reset = true;
  this.block = 0;
  this.start = 0;
  this.blockCount = (1600 - (bits << 1)) >> 5;
  this.byteCount = this.blockCount << 2;
  this.outputBlocks = outputBits >> 5;
  this.extraBytes = (outputBits & 31) >> 3;
  for (var i = 0; i < 50; ++i) {
    this.s[i] = 0;
  }
}
Keccak.prototype.update = function (message) {
  var notString = typeof message !== 'string';
  if (notString && message.constructor === ArrayBuffer) {
    message = new Uint8Array(message);
  }
  var length = message.length, blocks = this.blocks, byteCount = this.byteCount;
  var blockCount = this.blockCount, index = 0, s = this.s, i, code;
  while (index < length) {
    if (this.reset) {
      this.reset = false;
      blocks[0] = this.block;
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    if (notString) {
      for (i = this.start; index < length && i < byteCount; ++index) {
        blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
      }
    }
    else {
      for (i = this.start; index < length && i < byteCount; ++index) {
        code = message.charCodeAt(index);
        if (code < 0x80) {
          blocks[i >> 2] |= code << SHIFT[i++ & 3];
        }
        else if (code < 0x800) {
          blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
        }
        else if (code < 0xd800 || code >= 0xe000) {
          blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
        }
        else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
          blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
          blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
        }
      }
    }
    this.lastByteIndex = i;
    if (i >= byteCount) {
      this.start = i - byteCount;
      this.block = blocks[blockCount];
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
      this.reset = true;
    }
    else {
      this.start = i;
    }
  }
  return this;
};
Keccak.prototype.finalize = function () {
  var blocks = this.blocks;
  var i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
  blocks[i >> 2] |= this.padding[i & 3];
  if (this.lastByteIndex === this.byteCount) {
    blocks[0] = blocks[blockCount];
    for (i = 1; i < blockCount + 1; ++i) {
      blocks[i] = 0;
    }
  }
  blocks[blockCount - 1] |= 0x80000000;
  for (i = 0; i < blockCount; ++i) {
    s[i] ^= blocks[i];
  }
  f(s);
};
Keccak.prototype.toString = Keccak.prototype.hex = function () {
  this.finalize();
  var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks;
  var extraBytes = this.extraBytes, i = 0, j = 0;
  var hex = '', block;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
        HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
        HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
        HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
    }
    if (j % blockCount === 0) {
      f(s);
      i = 0;
    }
  }
  if (extraBytes) {
    block = s[i];
    if (extraBytes > 0) {
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
    }
    if (extraBytes > 1) {
      hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
    }
    if (extraBytes > 2) {
      hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
    }
  }
  return hex;
};
Keccak.prototype.arrayBuffer = function () {
  this.finalize();
  var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks;
  var extraBytes = this.extraBytes, i = 0, j = 0;
  var bytes = this.outputBits >> 3;
  var buffer;
  if (extraBytes) {
    buffer = new ArrayBuffer((outputBlocks + 1) << 2);
  }
  else {
    buffer = new ArrayBuffer(bytes);
  }
  var array = new Uint32Array(buffer);
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      array[j] = s[i];
    }
    if (j % blockCount === 0) {
      f(s);
    }
  }
  if (extraBytes) {
    array[i] = s[i];
    buffer = buffer.slice(0, bytes);
  }
  return buffer;
};
Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
Keccak.prototype.digest = Keccak.prototype.array = function () {
  this.finalize();
  var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks;
  var extraBytes = this.extraBytes, i = 0, j = 0;
  var array = [];
  var offset, block;
  while (j < outputBlocks) {
    for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      array[offset + 1] = (block >> 8) & 0xFF;
      array[offset + 2] = (block >> 16) & 0xFF;
      array[offset + 3] = (block >> 24) & 0xFF;
    }
    if (j % blockCount === 0) {
      f(s);
    }
  }
  if (extraBytes) {
    offset = j << 2;
    block = s[i];
    if (extraBytes > 0) {
      array[offset] = block & 0xFF;
    }
    if (extraBytes > 1) {
      array[offset + 1] = (block >> 8) & 0xFF;
    }
    if (extraBytes > 2) {
      array[offset + 2] = (block >> 16) & 0xFF;
    }
  }
  return array;
};
var f = function (s) {
  var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
  for (n = 0; n < 48; n += 2) {
    c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    h = c8 ^ ((c2 << 1) | (c3 >>> 31));
    l = c9 ^ ((c3 << 1) | (c2 >>> 31));
    s[0] ^= h;
    s[1] ^= l;
    s[10] ^= h;
    s[11] ^= l;
    s[20] ^= h;
    s[21] ^= l;
    s[30] ^= h;
    s[31] ^= l;
    s[40] ^= h;
    s[41] ^= l;
    h = c0 ^ ((c4 << 1) | (c5 >>> 31));
    l = c1 ^ ((c5 << 1) | (c4 >>> 31));
    s[2] ^= h;
    s[3] ^= l;
    s[12] ^= h;
    s[13] ^= l;
    s[22] ^= h;
    s[23] ^= l;
    s[32] ^= h;
    s[33] ^= l;
    s[42] ^= h;
    s[43] ^= l;
    h = c2 ^ ((c6 << 1) | (c7 >>> 31));
    l = c3 ^ ((c7 << 1) | (c6 >>> 31));
    s[4] ^= h;
    s[5] ^= l;
    s[14] ^= h;
    s[15] ^= l;
    s[24] ^= h;
    s[25] ^= l;
    s[34] ^= h;
    s[35] ^= l;
    s[44] ^= h;
    s[45] ^= l;
    h = c4 ^ ((c8 << 1) | (c9 >>> 31));
    l = c5 ^ ((c9 << 1) | (c8 >>> 31));
    s[6] ^= h;
    s[7] ^= l;
    s[16] ^= h;
    s[17] ^= l;
    s[26] ^= h;
    s[27] ^= l;
    s[36] ^= h;
    s[37] ^= l;
    s[46] ^= h;
    s[47] ^= l;
    h = c6 ^ ((c0 << 1) | (c1 >>> 31));
    l = c7 ^ ((c1 << 1) | (c0 >>> 31));
    s[8] ^= h;
    s[9] ^= l;
    s[18] ^= h;
    s[19] ^= l;
    s[28] ^= h;
    s[29] ^= l;
    s[38] ^= h;
    s[39] ^= l;
    s[48] ^= h;
    s[49] ^= l;
    b0 = s[0];
    b1 = s[1];
    b32 = (s[11] << 4) | (s[10] >>> 28);
    b33 = (s[10] << 4) | (s[11] >>> 28);
    b14 = (s[20] << 3) | (s[21] >>> 29);
    b15 = (s[21] << 3) | (s[20] >>> 29);
    b46 = (s[31] << 9) | (s[30] >>> 23);
    b47 = (s[30] << 9) | (s[31] >>> 23);
    b28 = (s[40] << 18) | (s[41] >>> 14);
    b29 = (s[41] << 18) | (s[40] >>> 14);
    b20 = (s[2] << 1) | (s[3] >>> 31);
    b21 = (s[3] << 1) | (s[2] >>> 31);
    b2 = (s[13] << 12) | (s[12] >>> 20);
    b3 = (s[12] << 12) | (s[13] >>> 20);
    b34 = (s[22] << 10) | (s[23] >>> 22);
    b35 = (s[23] << 10) | (s[22] >>> 22);
    b16 = (s[33] << 13) | (s[32] >>> 19);
    b17 = (s[32] << 13) | (s[33] >>> 19);
    b48 = (s[42] << 2) | (s[43] >>> 30);
    b49 = (s[43] << 2) | (s[42] >>> 30);
    b40 = (s[5] << 30) | (s[4] >>> 2);
    b41 = (s[4] << 30) | (s[5] >>> 2);
    b22 = (s[14] << 6) | (s[15] >>> 26);
    b23 = (s[15] << 6) | (s[14] >>> 26);
    b4 = (s[25] << 11) | (s[24] >>> 21);
    b5 = (s[24] << 11) | (s[25] >>> 21);
    b36 = (s[34] << 15) | (s[35] >>> 17);
    b37 = (s[35] << 15) | (s[34] >>> 17);
    b18 = (s[45] << 29) | (s[44] >>> 3);
    b19 = (s[44] << 29) | (s[45] >>> 3);
    b10 = (s[6] << 28) | (s[7] >>> 4);
    b11 = (s[7] << 28) | (s[6] >>> 4);
    b42 = (s[17] << 23) | (s[16] >>> 9);
    b43 = (s[16] << 23) | (s[17] >>> 9);
    b24 = (s[26] << 25) | (s[27] >>> 7);
    b25 = (s[27] << 25) | (s[26] >>> 7);
    b6 = (s[36] << 21) | (s[37] >>> 11);
    b7 = (s[37] << 21) | (s[36] >>> 11);
    b38 = (s[47] << 24) | (s[46] >>> 8);
    b39 = (s[46] << 24) | (s[47] >>> 8);
    b30 = (s[8] << 27) | (s[9] >>> 5);
    b31 = (s[9] << 27) | (s[8] >>> 5);
    b12 = (s[18] << 20) | (s[19] >>> 12);
    b13 = (s[19] << 20) | (s[18] >>> 12);
    b44 = (s[29] << 7) | (s[28] >>> 25);
    b45 = (s[28] << 7) | (s[29] >>> 25);
    b26 = (s[38] << 8) | (s[39] >>> 24);
    b27 = (s[39] << 8) | (s[38] >>> 24);
    b8 = (s[48] << 14) | (s[49] >>> 18);
    b9 = (s[49] << 14) | (s[48] >>> 18);
    s[0] = b0 ^ (~b2 & b4);
    s[1] = b1 ^ (~b3 & b5);
    s[10] = b10 ^ (~b12 & b14);
    s[11] = b11 ^ (~b13 & b15);
    s[20] = b20 ^ (~b22 & b24);
    s[21] = b21 ^ (~b23 & b25);
    s[30] = b30 ^ (~b32 & b34);
    s[31] = b31 ^ (~b33 & b35);
    s[40] = b40 ^ (~b42 & b44);
    s[41] = b41 ^ (~b43 & b45);
    s[2] = b2 ^ (~b4 & b6);
    s[3] = b3 ^ (~b5 & b7);
    s[12] = b12 ^ (~b14 & b16);
    s[13] = b13 ^ (~b15 & b17);
    s[22] = b22 ^ (~b24 & b26);
    s[23] = b23 ^ (~b25 & b27);
    s[32] = b32 ^ (~b34 & b36);
    s[33] = b33 ^ (~b35 & b37);
    s[42] = b42 ^ (~b44 & b46);
    s[43] = b43 ^ (~b45 & b47);
    s[4] = b4 ^ (~b6 & b8);
    s[5] = b5 ^ (~b7 & b9);
    s[14] = b14 ^ (~b16 & b18);
    s[15] = b15 ^ (~b17 & b19);
    s[24] = b24 ^ (~b26 & b28);
    s[25] = b25 ^ (~b27 & b29);
    s[34] = b34 ^ (~b36 & b38);
    s[35] = b35 ^ (~b37 & b39);
    s[44] = b44 ^ (~b46 & b48);
    s[45] = b45 ^ (~b47 & b49);
    s[6] = b6 ^ (~b8 & b0);
    s[7] = b7 ^ (~b9 & b1);
    s[16] = b16 ^ (~b18 & b10);
    s[17] = b17 ^ (~b19 & b11);
    s[26] = b26 ^ (~b28 & b20);
    s[27] = b27 ^ (~b29 & b21);
    s[36] = b36 ^ (~b38 & b30);
    s[37] = b37 ^ (~b39 & b31);
    s[46] = b46 ^ (~b48 & b40);
    s[47] = b47 ^ (~b49 & b41);
    s[8] = b8 ^ (~b0 & b2);
    s[9] = b9 ^ (~b1 & b3);
    s[18] = b18 ^ (~b10 & b12);
    s[19] = b19 ^ (~b11 & b13);
    s[28] = b28 ^ (~b20 & b22);
    s[29] = b29 ^ (~b21 & b23);
    s[38] = b38 ^ (~b30 & b32);
    s[39] = b39 ^ (~b31 & b33);
    s[48] = b48 ^ (~b40 & b42);
    s[49] = b49 ^ (~b41 & b43);
    s[0] ^= RC[n];
    s[1] ^= RC[n + 1];
  }
};
exports.keccak256 = methods.keccak_256;


/***/ }),

/***/ "./node_modules/@waves/ts-types/dist/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@waves/ts-types/dist/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DATA_FIELD_TYPE = exports.TRANSACTION_TYPE = exports.BINARY_DATA_TYPE = exports.STRING_DATA_TYPE = exports.BOOLEAN_DATA_TYPE = exports.INTEGER_DATA_TYPE = exports.ETHEREUM = exports.INVOKE_EXPRESSION_TYPE = exports.UPDATE_ASSET_INFO_TYPE = exports.INVOKE_SCRIPT_TYPE = exports.SET_ASSET_SCRIPT_TYPE = exports.SPONSORSHIP_TYPE = exports.SET_SCRIPT_TYPE = exports.DATA_TYPE = exports.MASS_TRANSFER_TYPE = exports.ALIAS_TYPE = exports.CANCEL_LEASE_TYPE = exports.LEASE_TYPE = exports.EXCHANGE_TYPE = exports.BURN_TYPE = exports.REISSUE_TYPE = exports.TRANSFER_TYPE = exports.ISSUE_TYPE = exports.PAYMENT_TYPE = exports.GENESIS_TYPE = void 0;
__exportStar(__webpack_require__(/*! ../transactions */ "./node_modules/@waves/ts-types/dist/transactions/index.js"), exports);
__exportStar(__webpack_require__(/*! ./parts */ "./node_modules/@waves/ts-types/dist/src/parts.js"), exports);
exports.GENESIS_TYPE = 1;
exports.PAYMENT_TYPE = 2;
exports.ISSUE_TYPE = 3;
exports.TRANSFER_TYPE = 4;
exports.REISSUE_TYPE = 5;
exports.BURN_TYPE = 6;
exports.EXCHANGE_TYPE = 7;
exports.LEASE_TYPE = 8;
exports.CANCEL_LEASE_TYPE = 9;
exports.ALIAS_TYPE = 10;
exports.MASS_TRANSFER_TYPE = 11;
exports.DATA_TYPE = 12;
exports.SET_SCRIPT_TYPE = 13;
exports.SPONSORSHIP_TYPE = 14;
exports.SET_ASSET_SCRIPT_TYPE = 15;
exports.INVOKE_SCRIPT_TYPE = 16;
exports.UPDATE_ASSET_INFO_TYPE = 17;
exports.INVOKE_EXPRESSION_TYPE = 18;
exports.ETHEREUM = 19;
exports.INTEGER_DATA_TYPE = 'integer';
exports.BOOLEAN_DATA_TYPE = 'boolean';
exports.STRING_DATA_TYPE = 'string';
exports.BINARY_DATA_TYPE = 'binary';
exports.TRANSACTION_TYPE = {
    GENESIS: exports.GENESIS_TYPE,
    PAYMENT: exports.PAYMENT_TYPE,
    ISSUE: exports.ISSUE_TYPE,
    TRANSFER: exports.TRANSFER_TYPE,
    REISSUE: exports.REISSUE_TYPE,
    BURN: exports.BURN_TYPE,
    EXCHANGE: exports.EXCHANGE_TYPE,
    LEASE: exports.LEASE_TYPE,
    CANCEL_LEASE: exports.CANCEL_LEASE_TYPE,
    ALIAS: exports.ALIAS_TYPE,
    MASS_TRANSFER: exports.MASS_TRANSFER_TYPE,
    DATA: exports.DATA_TYPE,
    SET_SCRIPT: exports.SET_SCRIPT_TYPE,
    SPONSORSHIP: exports.SPONSORSHIP_TYPE,
    SET_ASSET_SCRIPT: exports.SET_ASSET_SCRIPT_TYPE,
    INVOKE_SCRIPT: exports.INVOKE_SCRIPT_TYPE,
    UPDATE_ASSET_INFO: exports.UPDATE_ASSET_INFO_TYPE,
    INVOKE_EXPRESSION: exports.INVOKE_EXPRESSION_TYPE,
    ETHEREUM: exports.ETHEREUM,
};
exports.DATA_FIELD_TYPE = {
    INTEGER: exports.INTEGER_DATA_TYPE,
    BOOLEAN: exports.BOOLEAN_DATA_TYPE,
    STRING: exports.STRING_DATA_TYPE,
    BINARY: exports.BINARY_DATA_TYPE,
};


/***/ }),

/***/ "./node_modules/@waves/ts-types/dist/src/parts.js":
/*!********************************************************!*\
  !*** ./node_modules/@waves/ts-types/dist/src/parts.js ***!
  \********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "./node_modules/@waves/ts-types/dist/transactions/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@waves/ts-types/dist/transactions/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var src_1 = __webpack_require__(/*! ../src */ "./node_modules/@waves/ts-types/dist/src/index.js");


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/adapters/Adapter.js":
/*!************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/adapters/Adapter.js ***!
  \************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Adapter = /** @class */ (function () {
    function Adapter() {
    }
    return Adapter;
}());
exports.Adapter = Adapter;


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/adapters/WindowAdapter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/adapters/WindowAdapter.js ***!
  \******************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Adapter_1 = __webpack_require__(/*! ./Adapter */ "./node_modules/@waves/waves-browser-bus/dist/adapters/Adapter.js");
var __1 = __webpack_require__(/*! .. */ "./node_modules/@waves/waves-browser-bus/dist/index.js");
var WindowProtocol_1 = __webpack_require__(/*! ../protocols/WindowProtocol */ "./node_modules/@waves/waves-browser-bus/dist/protocols/WindowProtocol.js");
var utils_1 = __webpack_require__(/*! ../utils/utils */ "./node_modules/@waves/waves-browser-bus/dist/utils/utils/index.js");
var EMPTY_OPTIONS = { origins: [], availableChanelId: [] };
var WindowAdapter = /** @class */ (function (_super) {
    __extends(WindowAdapter, _super);
    function WindowAdapter(listen, dispatch, options) {
        var _this = _super.call(this) || this;
        _this.id = __1.uniqueId('wa');
        _this.callbacks = [];
        _this.options = WindowAdapter.prepareOptions(options);
        _this.listen = listen;
        _this.dispatch = dispatch;
        _this.listen.forEach(function (protocol) { return protocol.on('message', _this.onMessage, _this); });
        return _this;
    }
    WindowAdapter.prototype.addListener = function (cb) {
        this.callbacks.push(cb);
        __1.console.info('WindowAdapter: Add iframe message listener');
        return this;
    };
    WindowAdapter.prototype.send = function (data) {
        var message = __assign({}, data, { chanelId: this.options.chanelId });
        this.dispatch.forEach(function (protocol) { return protocol.dispatch(message); });
        __1.console.info('WindowAdapter: Send message', message);
        return this;
    };
    WindowAdapter.prototype.destroy = function () {
        this.listen.forEach(function (protocol) { return protocol.destroy(); });
        this.dispatch.forEach(function (protocol) { return protocol.destroy(); });
        __1.console.info('WindowAdapter: Destroy');
    };
    WindowAdapter.prototype.onMessage = function (event) {
        if (this.accessEvent(event)) {
            this.callbacks.forEach(function (cb) {
                try {
                    cb(event.data);
                }
                catch (e) {
                    __1.console.warn('WindowAdapter: Unhandled exception!', e);
                }
            });
        }
    };
    WindowAdapter.prototype.accessEvent = function (event) {
        if (typeof event.data !== 'object' || event.data.type == null) {
            __1.console.info('WindowAdapter: Block event. Wrong event format!', event.data);
            return false;
        }
        if (!this.options.origins.has('*') && !this.options.origins.has(event.origin)) {
            __1.console.info("SimpleWindowAdapter: Block event by origin \"" + event.origin + "\"");
            return false;
        }
        if (!this.options.availableChanelId.size) {
            return true;
        }
        var access = !!(event.data.chanelId && this.options.availableChanelId.has(event.data.chanelId));
        if (!access) {
            __1.console.info("SimpleWindowAdapter: Block event by chanel id \"" + event.data.chanelId + "\"");
        }
        return access;
    };
    WindowAdapter.createSimpleWindowAdapter = function (iframe, options) {
        var _this = this;
        var origin = this.getContentOrigin(iframe);
        var myOptions = this.prepareOptions(options);
        var events = [];
        if (origin) {
            myOptions.origins.add(origin);
        }
        var listen = new WindowProtocol_1.WindowProtocol(window, WindowProtocol_1.WindowProtocol.PROTOCOL_TYPES.LISTEN);
        var handler = function (event) {
            events.push(event);
        };
        listen.on('message', handler);
        return this.getIframeContent(iframe)
            .then(function (win) {
            var dispatch = new WindowProtocol_1.WindowProtocol(win.win, WindowProtocol_1.WindowProtocol.PROTOCOL_TYPES.DISPATCH);
            var adapter = new WindowAdapter([listen], [dispatch], _this.unPrepareOptions(myOptions));
            events.forEach(function (event) {
                adapter.onMessage(event);
            });
            listen.off('message', handler);
            return adapter;
        });
    };
    WindowAdapter.prepareOptions = function (options) {
        if (options === void 0) { options = EMPTY_OPTIONS; }
        var concat = function (initialValue) { return function (list) { return list.reduce(function (set, item) { return set.add(item); }, initialValue); }; };
        var getCollection = function (data, initial) { return utils_1.pipe(__1.toArray, concat(initial))(data); };
        var origins = getCollection(options.origins || [], new __1.UniqPrimitiveCollection([window.location.origin]));
        var chanelId = getCollection(options.availableChanelId || [], new __1.UniqPrimitiveCollection());
        return __assign({}, options, { origins: origins, availableChanelId: chanelId });
    };
    WindowAdapter.unPrepareOptions = function (options) {
        return {
            origins: options.origins.toArray(),
            availableChanelId: options.availableChanelId.toArray(),
            chanelId: options.chanelId
        };
    };
    WindowAdapter.getIframeContent = function (content) {
        if (!content) {
            return Promise.resolve({ win: window.opener || window.parent });
        }
        if (!(content instanceof HTMLIFrameElement)) {
            return Promise.resolve({ win: content });
        }
        if (content.contentWindow) {
            return Promise.resolve({ win: content.contentWindow });
        }
        return new Promise(function (resolve, reject) {
            content.addEventListener('load', function () { return resolve({ win: content.contentWindow }); }, false);
            content.addEventListener('error', reject, false);
        });
    };
    WindowAdapter.getContentOrigin = function (content) {
        if (!content) {
            try {
                return new URL(document.referrer).origin;
            }
            catch (e) {
                return null;
            }
        }
        if (!(content instanceof HTMLIFrameElement)) {
            try {
                return window.top.origin;
            }
            catch (e) {
                return null;
            }
        }
        try {
            return new URL(content.src).origin || null;
        }
        catch (e) {
            return null;
        }
    };
    return WindowAdapter;
}(Adapter_1.Adapter));
exports.WindowAdapter = WindowAdapter;


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/bus/Bus.js":
/*!***************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/bus/Bus.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@waves/waves-browser-bus/dist/utils/index.js");
var EventType;
(function (EventType) {
    EventType[EventType["Event"] = 0] = "Event";
    EventType[EventType["Action"] = 1] = "Action";
    EventType[EventType["Response"] = 2] = "Response";
})(EventType = exports.EventType || (exports.EventType = {}));
var ResponseStatus;
(function (ResponseStatus) {
    ResponseStatus[ResponseStatus["Success"] = 0] = "Success";
    ResponseStatus[ResponseStatus["Error"] = 1] = "Error";
})(ResponseStatus = exports.ResponseStatus || (exports.ResponseStatus = {}));
var Bus = /** @class */ (function () {
    function Bus(adapter, defaultTimeout) {
        var _this = this;
        this.id = utils_1.uniqueId('bus');
        this._timeout = defaultTimeout || 5000;
        this._adapter = adapter;
        this._adapter.addListener(function (data) { return _this._onMessage(data); });
        this._eventHandlers = Object.create(null);
        this._activeRequestHash = Object.create(null);
        this._requestHandlers = Object.create(null);
        utils_1.console.info("Create Bus with id \"" + this.id + "\"");
    }
    Bus.prototype.dispatchEvent = function (name, data) {
        this._adapter.send(Bus._createEvent(name, data));
        utils_1.console.info("Dispatch event \"" + name + "\"", data);
        return this;
    };
    Bus.prototype.request = function (name, data, timeout) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var id = utils_1.uniqueId(_this.id + "-action");
            var wait = timeout || _this._timeout;
            var timer;
            if ((timeout || _this._timeout) !== -1) {
                timer = setTimeout(function () {
                    delete _this._activeRequestHash[id];
                    var error = new Error("Timeout error for request with name \"" + name + "\" and timeout " + wait + "!");
                    utils_1.console.error(error);
                    reject(error);
                }, wait);
            }
            var cancelTimeout = function () {
                if (timer) {
                    clearTimeout(timer);
                }
            };
            _this._activeRequestHash[id] = {
                reject: function (error) {
                    cancelTimeout();
                    utils_1.console.error("Error request with name \"" + name + "\"", error);
                    reject(error);
                },
                resolve: function (data) {
                    cancelTimeout();
                    utils_1.console.info("Request with name \"" + name + "\" success resolved!", data);
                    resolve(data);
                }
            };
            _this._adapter.send({ id: id, type: 1 /* Action */, name: name, data: data });
            utils_1.console.info("Request with name \"" + name + "\"", data);
        });
    };
    Bus.prototype.on = function (name, handler, context) {
        return this._addEventHandler(name, handler, context, false);
    };
    Bus.prototype.once = function (name, handler, context) {
        return this._addEventHandler(name, handler, context, true);
    };
    Bus.prototype.off = function (name, handler) {
        var _this = this;
        if (!name) {
            Object.keys(this._eventHandlers).forEach(function (name) { return _this.off(name, handler); });
            return this;
        }
        if (!this._eventHandlers[name]) {
            return this;
        }
        if (!handler) {
            this._eventHandlers[name].slice().forEach(function (info) {
                _this.off(name, info.handler);
            });
            return this;
        }
        this._eventHandlers[name] = this._eventHandlers[name].filter(function (info) { return info.handler !== handler; });
        if (!this._eventHandlers[name].length) {
            delete this._eventHandlers[name];
        }
        return this;
    };
    Bus.prototype.registerRequestHandler = function (name, handler) {
        if (this._requestHandlers[name]) {
            throw new Error('Duplicate request handler!');
        }
        this._requestHandlers[name] = handler;
        return this;
    };
    Bus.prototype.unregisterHandler = function (name) {
        if (this._requestHandlers[name]) {
            delete this._requestHandlers[name];
        }
        return this;
    };
    Bus.prototype.changeAdapter = function (adapter) {
        var _this = this;
        var bus = new Bus(adapter, this._timeout);
        Object.keys(this._eventHandlers).forEach(function (name) {
            _this._eventHandlers[name].forEach(function (info) {
                if (info.once) {
                    bus.once(name, info.handler, info.context);
                }
                else {
                    bus.on(name, info.handler, info.context);
                }
            });
        });
        Object.keys(this._requestHandlers).forEach(function (name) {
            bus.registerRequestHandler(name, _this._requestHandlers[name]);
        });
        return bus;
    };
    Bus.prototype.destroy = function () {
        utils_1.console.info('Destroy Bus');
        this.off();
        this._adapter.destroy();
    };
    Bus.prototype._addEventHandler = function (name, handler, context, once) {
        if (!this._eventHandlers[name]) {
            this._eventHandlers[name] = [];
        }
        this._eventHandlers[name].push({ handler: handler, once: once, context: context });
        return this;
    };
    Bus.prototype._onMessage = function (message) {
        switch (message.type) {
            case 0 /* Event */:
                utils_1.console.info("Has event with name \"" + String(message.name) + "\"", message.data);
                this._fireEvent(String(message.name), message.data);
                break;
            case 1 /* Action */:
                utils_1.console.info("Start action with id \"" + message.id + "\" and name \"" + String(message.name) + "\"", message.data);
                this._createResponse(message);
                break;
            case 2 /* Response */:
                utils_1.console.info("Start response with name \"" + message.id + "\" and status \"" + message.status + "\"", message.content);
                this._fireEndAction(message);
                break;
        }
    };
    Bus.prototype._createResponse = function (message) {
        var _this = this;
        var sendError = function (error) {
            utils_1.console.error(error);
            _this._adapter.send({
                id: message.id,
                type: 2 /* Response */,
                status: 1 /* Error */,
                content: String(error)
            });
        };
        if (!this._requestHandlers[String(message.name)]) {
            sendError(new Error("Has no handler for \"" + String(message.name) + "\" action!"));
            return void 0;
        }
        try {
            var result = this._requestHandlers[String(message.name)](message.data);
            if (Bus._isPromise(result)) {
                result.then(function (data) {
                    _this._adapter.send({
                        id: message.id,
                        type: 2 /* Response */,
                        status: 0 /* Success */,
                        content: data
                    });
                }, sendError);
            }
            else {
                this._adapter.send({
                    id: message.id,
                    type: 2 /* Response */,
                    status: 0 /* Success */,
                    content: result
                });
            }
        }
        catch (e) {
            sendError(e);
        }
    };
    Bus.prototype._fireEndAction = function (message) {
        if (this._activeRequestHash[message.id]) {
            switch (message.status) {
                case 1 /* Error */:
                    this._activeRequestHash[message.id].reject(message.content);
                    break;
                case 0 /* Success */:
                    this._activeRequestHash[message.id].resolve(message.content);
                    break;
            }
            delete this._activeRequestHash[message.id];
        }
    };
    Bus.prototype._fireEvent = function (name, value) {
        if (!this._eventHandlers[name]) {
            return void 0;
        }
        this._eventHandlers[name] = this._eventHandlers[name]
            .slice()
            .filter(function (handlerInfo) {
            try {
                handlerInfo.handler.call(handlerInfo.context, value);
            }
            catch (e) {
                utils_1.console.warn(e);
            }
            return !handlerInfo.once;
        });
        if (!this._eventHandlers[name].length) {
            delete this._eventHandlers[name];
        }
    };
    Bus._createEvent = function (eventName, data) {
        return {
            type: 0 /* Event */,
            name: eventName,
            data: data
        };
    };
    Bus._isPromise = function (some) {
        return some && some.then && typeof some.then === 'function';
    };
    return Bus;
}());
exports.Bus = Bus;


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/config/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/config/index.js ***!
  \********************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var config;
(function (config) {
    var console;
    (function (console) {
        console.LOG_LEVEL = {
            PRODUCTION: 0,
            ERRORS: 1,
            VERBOSE: 2
        };
        console.logLevel = console.LOG_LEVEL.PRODUCTION;
        console.methodsData = {
            log: { save: false, logLevel: console.LOG_LEVEL.VERBOSE },
            info: { save: false, logLevel: console.LOG_LEVEL.VERBOSE },
            warn: { save: false, logLevel: console.LOG_LEVEL.VERBOSE },
            error: { save: true, logLevel: console.LOG_LEVEL.ERRORS }
        };
    })(console = config.console || (config.console = {}));
})(config = exports.config || (exports.config = {}));


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/index.js ***!
  \*************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./bus/Bus */ "./node_modules/@waves/waves-browser-bus/dist/bus/Bus.js"));
__export(__webpack_require__(/*! ./adapters/Adapter */ "./node_modules/@waves/waves-browser-bus/dist/adapters/Adapter.js"));
__export(__webpack_require__(/*! ./adapters/WindowAdapter */ "./node_modules/@waves/waves-browser-bus/dist/adapters/WindowAdapter.js"));
__export(__webpack_require__(/*! ./protocols/WindowProtocol */ "./node_modules/@waves/waves-browser-bus/dist/protocols/WindowProtocol.js"));
__export(__webpack_require__(/*! ./config */ "./node_modules/@waves/waves-browser-bus/dist/config/index.js"));
__export(__webpack_require__(/*! ./utils */ "./node_modules/@waves/waves-browser-bus/dist/utils/index.js"));


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/protocols/WindowProtocol.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/protocols/WindowProtocol.js ***!
  \********************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var typed_ts_events_1 = __webpack_require__(/*! typed-ts-events */ "./node_modules/typed-ts-events/dist/events.min.js");
var WindowProtocol = /** @class */ (function (_super) {
    __extends(WindowProtocol, _super);
    function WindowProtocol(win, type) {
        var _this = _super.call(this) || this;
        _this.win = win;
        _this.type = type;
        _this.handler = function (event) {
            _this.trigger('message', event);
        };
        if (type === WindowProtocol.PROTOCOL_TYPES.LISTEN) {
            _this.win.addEventListener('message', _this.handler, false);
        }
        return _this;
    }
    WindowProtocol.prototype.dispatch = function (data) {
        this.win.postMessage(data, '*');
        return this;
    };
    WindowProtocol.prototype.destroy = function () {
        if (this.type === WindowProtocol.PROTOCOL_TYPES.LISTEN) {
            this.win.removeEventListener('message', this.handler, false);
        }
        this.win = WindowProtocol._fakeWin;
    };
    WindowProtocol._fakeWin = (function () {
        var empty = function () { return null; };
        return {
            postMessage: empty,
            addEventListener: empty,
            removeEventListener: empty
        };
    })();
    return WindowProtocol;
}(typed_ts_events_1.EventEmitter));
exports.WindowProtocol = WindowProtocol;
/* istanbul ignore next */
(function (WindowProtocol) {
    WindowProtocol.PROTOCOL_TYPES = {
        LISTEN: 'listen',
        DISPATCH: 'dispatch'
    };
})(WindowProtocol = exports.WindowProtocol || (exports.WindowProtocol = {}));
exports.WindowProtocol = WindowProtocol;


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/utils/UniqPrimitiveCollection.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/utils/UniqPrimitiveCollection.js ***!
  \*************************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UniqPrimitiveCollection = /** @class */ (function () {
    function UniqPrimitiveCollection(list) {
        this.size = 0;
        this.hash = Object.create(null);
        if (list) {
            list.forEach(this.add, this);
        }
    }
    UniqPrimitiveCollection.prototype.add = function (item) {
        this.hash[item] = true;
        this.size = Object.keys(this.hash).length;
        return this;
    };
    UniqPrimitiveCollection.prototype.has = function (key) {
        return key in this.hash;
    };
    UniqPrimitiveCollection.prototype.toArray = function () {
        return Object.keys(this.hash);
    };
    return UniqPrimitiveCollection;
}());
exports.UniqPrimitiveCollection = UniqPrimitiveCollection;


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/utils/console/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/utils/console/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var config_1 = __webpack_require__(/*! ../../config */ "./node_modules/@waves/waves-browser-bus/dist/config/index.js");
var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@waves/waves-browser-bus/dist/utils/utils/index.js");
/* istanbul ignore next */
var consoleModule = (function (root) {
    return root.console;
})(typeof self !== 'undefined' ? self : global);
var storage = Object.create(null);
function addNamespace(type) {
    if (!storage[type]) {
        storage[type] = [];
    }
}
function saveEvent(type, args) {
    storage[type].push(args);
}
function generateConsole() {
    return utils_1.keys(config_1.config.console.methodsData).reduce(function (api, method) {
        api[method] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (config_1.config.console.logLevel < config_1.config.console.methodsData[method].logLevel) {
                if (config_1.config.console.methodsData[method].save) {
                    addNamespace(method);
                    saveEvent(method, args);
                }
            }
            else {
                consoleModule[method].apply(consoleModule, args);
            }
        };
        return api;
    }, Object.create(null));
}
exports.console = __assign({}, generateConsole(), { getSavedMessages: function (type) {
        return storage[type] || [];
    } });

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/utils/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/utils/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./utils */ "./node_modules/@waves/waves-browser-bus/dist/utils/utils/index.js"));
__export(__webpack_require__(/*! ./console */ "./node_modules/@waves/waves-browser-bus/dist/utils/console/index.js"));
__export(__webpack_require__(/*! ./UniqPrimitiveCollection */ "./node_modules/@waves/waves-browser-bus/dist/utils/UniqPrimitiveCollection.js"));


/***/ }),

/***/ "./node_modules/@waves/waves-browser-bus/dist/utils/utils/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@waves/waves-browser-bus/dist/utils/utils/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function keys(o) {
    return Object.keys(o);
}
exports.keys = keys;
var salt = Math.floor(Date.now() * Math.random());
var counter = 0;
function uniqueId(prefix) {
    return prefix + "-" + salt + "-" + counter++;
}
exports.uniqueId = uniqueId;
function toArray(some) {
    return Array.isArray(some) ? some : [some];
}
exports.toArray = toArray;
function pipe() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (data) { return args.reduce(function (acc, cb) { return cb(acc); }, data); };
}
exports.pipe = pipe;


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/js-sha3/src/sha3.js":
/*!******************************************!*\
  !*** ./node_modules/js-sha3/src/sha3.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD =  true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js");
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return methods;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof global !== 'undefined') { return global; }
	throw new Error('unable to locate global object');
}

var global = getGlobal();

module.exports = exports = global.fetch;

// Needed for TypeScript and Webpack.
if (global.fetch) {
	exports.default = global.fetch.bind(global);
}

exports.Headers = global.Headers;
exports.Request = global.Request;
exports.Response = global.Response;

/***/ }),

/***/ "./node_modules/node-forge/lib/aes.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/aes.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Advanced Encryption Standard (AES) implementation.
 *
 * This implementation is based on the public domain library 'jscrypto' which
 * was written by:
 *
 * Emily Stark (estark@stanford.edu)
 * Mike Hamburg (mhamburg@stanford.edu)
 * Dan Boneh (dabo@cs.stanford.edu)
 *
 * Parts of this code are based on the OpenSSL implementation of AES:
 * http://www.openssl.org
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./cipher */ "./node_modules/node-forge/lib/cipher.js");
__webpack_require__(/*! ./cipherModes */ "./node_modules/node-forge/lib/cipherModes.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

/* AES API */
module.exports = forge.aes = forge.aes || {};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as a string of bytes, an array of bytes,
 * a byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates an AES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param key the symmetric key to use.
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};

/**
 * Creates a new AES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the AES algorithm object.
 */
forge.aes.Algorithm = function(name, mode) {
  if(!init) {
    initialize();
  }
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._w, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};

/**
 * Initializes this AES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */
forge.aes.Algorithm.prototype.initialize = function(options) {
  if(this._init) {
    return;
  }

  var key = options.key;
  var tmp;

  /* Note: The key may be a string of bytes, an array of bytes, a byte
    buffer, or an array of 32-bit integers. If the key is in bytes, then
    it must be 16, 24, or 32 bytes in length. If it is in 32-bit
    integers, it must be 4, 6, or 8 integers long. */

  if(typeof key === 'string' &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key string into byte buffer
    key = forge.util.createBuffer(key);
  } else if(forge.util.isArray(key) &&
    (key.length === 16 || key.length === 24 || key.length === 32)) {
    // convert key integer array into byte buffer
    tmp = key;
    key = forge.util.createBuffer();
    for(var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }

  // convert key byte buffer into 32-bit integer array
  if(!forge.util.isArray(key)) {
    tmp = key;
    key = [];

    // key lengths of 16, 24, 32 bytes allowed
    var len = tmp.length();
    if(len === 16 || len === 24 || len === 32) {
      len = len >>> 2;
      for(var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }

  // key must be an array of 32-bit integers by now
  if(!forge.util.isArray(key) ||
    !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error('Invalid key parameter.');
  }

  // encryption operation is always used for these modes
  var mode = this.mode.name;
  var encryptOp = (['CFB', 'OFB', 'CTR', 'GCM'].indexOf(mode) !== -1);

  // do key expansion
  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};

/**
 * Expands a key. Typically only used for testing.
 *
 * @param key the symmetric key to expand, as an array of 32-bit words.
 * @param decrypt true to expand for decryption, false for encryption.
 *
 * @return the expanded key.
 */
forge.aes._expandKey = function(key, decrypt) {
  if(!init) {
    initialize();
  }
  return _expandKey(key, decrypt);
};

/**
 * Updates a single block. Typically only used for testing.
 *
 * @param w the expanded key to use.
 * @param input an array of block-size 32-bit words.
 * @param output an array of block-size 32-bit words.
 * @param decrypt true to decrypt, false to encrypt.
 */
forge.aes._updateBlock = _updateBlock;

/** Register AES algorithms **/

registerAlgorithm('AES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('AES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('AES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('AES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('AES-CTR', forge.cipher.modes.ctr);
registerAlgorithm('AES-GCM', forge.cipher.modes.gcm);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.aes.Algorithm(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** AES implementation **/

var init = false; // not yet initialized
var Nb = 4;       // number of words comprising the state (AES = 4)
var sbox;         // non-linear substitution table used in key expansion
var isbox;        // inversion of sbox
var rcon;         // round constant word array
var mix;          // mix-columns table
var imix;         // inverse mix-columns table

/**
 * Performs initialization, ie: precomputes tables to optimize for speed.
 *
 * One way to understand how AES works is to imagine that 'addition' and
 * 'multiplication' are interfaces that require certain mathematical
 * properties to hold true (ie: they are associative) but they might have
 * different implementations and produce different kinds of results ...
 * provided that their mathematical properties remain true. AES defines
 * its own methods of addition and multiplication but keeps some important
 * properties the same, ie: associativity and distributivity. The
 * explanation below tries to shed some light on how AES defines addition
 * and multiplication of bytes and 32-bit words in order to perform its
 * encryption and decryption algorithms.
 *
 * The basics:
 *
 * The AES algorithm views bytes as binary representations of polynomials
 * that have either 1 or 0 as the coefficients. It defines the addition
 * or subtraction of two bytes as the XOR operation. It also defines the
 * multiplication of two bytes as a finite field referred to as GF(2^8)
 * (Note: 'GF' means "Galois Field" which is a field that contains a finite
 * number of elements so GF(2^8) has 256 elements).
 *
 * This means that any two bytes can be represented as binary polynomials;
 * when they multiplied together and modularly reduced by an irreducible
 * polynomial of the 8th degree, the results are the field GF(2^8). The
 * specific irreducible polynomial that AES uses in hexadecimal is 0x11b.
 * This multiplication is associative with 0x01 as the identity:
 *
 * (b * 0x01 = GF(b, 0x01) = b).
 *
 * The operation GF(b, 0x02) can be performed at the byte level by left
 * shifting b once and then XOR'ing it (to perform the modular reduction)
 * with 0x11b if b is >= 128. Repeated application of the multiplication
 * of 0x02 can be used to implement the multiplication of any two bytes.
 *
 * For instance, multiplying 0x57 and 0x13, denoted as GF(0x57, 0x13), can
 * be performed by factoring 0x13 into 0x01, 0x02, and 0x10. Then these
 * factors can each be multiplied by 0x57 and then added together. To do
 * the multiplication, values for 0x57 multiplied by each of these 3 factors
 * can be precomputed and stored in a table. To add them, the values from
 * the table are XOR'd together.
 *
 * AES also defines addition and multiplication of words, that is 4-byte
 * numbers represented as polynomials of 3 degrees where the coefficients
 * are the values of the bytes.
 *
 * The word [a0, a1, a2, a3] is a polynomial a3x^3 + a2x^2 + a1x + a0.
 *
 * Addition is performed by XOR'ing like powers of x. Multiplication
 * is performed in two steps, the first is an algebriac expansion as
 * you would do normally (where addition is XOR). But the result is
 * a polynomial larger than 3 degrees and thus it cannot fit in a word. So
 * next the result is modularly reduced by an AES-specific polynomial of
 * degree 4 which will always produce a polynomial of less than 4 degrees
 * such that it will fit in a word. In AES, this polynomial is x^4 + 1.
 *
 * The modular product of two polynomials 'a' and 'b' is thus:
 *
 * d(x) = d3x^3 + d2x^2 + d1x + d0
 * with
 * d0 = GF(a0, b0) ^ GF(a3, b1) ^ GF(a2, b2) ^ GF(a1, b3)
 * d1 = GF(a1, b0) ^ GF(a0, b1) ^ GF(a3, b2) ^ GF(a2, b3)
 * d2 = GF(a2, b0) ^ GF(a1, b1) ^ GF(a0, b2) ^ GF(a3, b3)
 * d3 = GF(a3, b0) ^ GF(a2, b1) ^ GF(a1, b2) ^ GF(a0, b3)
 *
 * As a matrix:
 *
 * [d0] = [a0 a3 a2 a1][b0]
 * [d1]   [a1 a0 a3 a2][b1]
 * [d2]   [a2 a1 a0 a3][b2]
 * [d3]   [a3 a2 a1 a0][b3]
 *
 * Special polynomials defined by AES (0x02 == {02}):
 * a(x)    = {03}x^3 + {01}x^2 + {01}x + {02}
 * a^-1(x) = {0b}x^3 + {0d}x^2 + {09}x + {0e}.
 *
 * These polynomials are used in the MixColumns() and InverseMixColumns()
 * operations, respectively, to cause each element in the state to affect
 * the output (referred to as diffusing).
 *
 * RotWord() uses: a0 = a1 = a2 = {00} and a3 = {01}, which is the
 * polynomial x3.
 *
 * The ShiftRows() method modifies the last 3 rows in the state (where
 * the state is 4 words with 4 bytes per word) by shifting bytes cyclically.
 * The 1st byte in the second row is moved to the end of the row. The 1st
 * and 2nd bytes in the third row are moved to the end of the row. The 1st,
 * 2nd, and 3rd bytes are moved in the fourth row.
 *
 * More details on how AES arithmetic works:
 *
 * In the polynomial representation of binary numbers, XOR performs addition
 * and subtraction and multiplication in GF(2^8) denoted as GF(a, b)
 * corresponds with the multiplication of polynomials modulo an irreducible
 * polynomial of degree 8. In other words, for AES, GF(a, b) will multiply
 * polynomial 'a' with polynomial 'b' and then do a modular reduction by
 * an AES-specific irreducible polynomial of degree 8.
 *
 * A polynomial is irreducible if its only divisors are one and itself. For
 * the AES algorithm, this irreducible polynomial is:
 *
 * m(x) = x^8 + x^4 + x^3 + x + 1,
 *
 * or {01}{1b} in hexadecimal notation, where each coefficient is a bit:
 * 100011011 = 283 = 0x11b.
 *
 * For example, GF(0x57, 0x83) = 0xc1 because
 *
 * 0x57 = 87  = 01010111 = x^6 + x^4 + x^2 + x + 1
 * 0x85 = 131 = 10000101 = x^7 + x + 1
 *
 * (x^6 + x^4 + x^2 + x + 1) * (x^7 + x + 1)
 * =  x^13 + x^11 + x^9 + x^8 + x^7 +
 *    x^7 + x^5 + x^3 + x^2 + x +
 *    x^6 + x^4 + x^2 + x + 1
 * =  x^13 + x^11 + x^9 + x^8 + x^6 + x^5 + x^4 + x^3 + 1 = y
 *    y modulo (x^8 + x^4 + x^3 + x + 1)
 * =  x^7 + x^6 + 1.
 *
 * The modular reduction by m(x) guarantees the result will be a binary
 * polynomial of less than degree 8, so that it can fit in a byte.
 *
 * The operation to multiply a binary polynomial b with x (the polynomial
 * x in binary representation is 00000010) is:
 *
 * b_7x^8 + b_6x^7 + b_5x^6 + b_4x^5 + b_3x^4 + b_2x^3 + b_1x^2 + b_0x^1
 *
 * To get GF(b, x) we must reduce that by m(x). If b_7 is 0 (that is the
 * most significant bit is 0 in b) then the result is already reduced. If
 * it is 1, then we can reduce it by subtracting m(x) via an XOR.
 *
 * It follows that multiplication by x (00000010 or 0x02) can be implemented
 * by performing a left shift followed by a conditional bitwise XOR with
 * 0x1b. This operation on bytes is denoted by xtime(). Multiplication by
 * higher powers of x can be implemented by repeated application of xtime().
 *
 * By adding intermediate results, multiplication by any constant can be
 * implemented. For instance:
 *
 * GF(0x57, 0x13) = 0xfe because:
 *
 * xtime(b) = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1)
 *
 * Note: We XOR with 0x11b instead of 0x1b because in javascript our
 * datatype for b can be larger than 1 byte, so a left shift will not
 * automatically eliminate bits that overflow a byte ... by XOR'ing the
 * overflow bit with 1 (the extra one from 0x11b) we zero it out.
 *
 * GF(0x57, 0x02) = xtime(0x57) = 0xae
 * GF(0x57, 0x04) = xtime(0xae) = 0x47
 * GF(0x57, 0x08) = xtime(0x47) = 0x8e
 * GF(0x57, 0x10) = xtime(0x8e) = 0x07
 *
 * GF(0x57, 0x13) = GF(0x57, (0x01 ^ 0x02 ^ 0x10))
 *
 * And by the distributive property (since XOR is addition and GF() is
 * multiplication):
 *
 * = GF(0x57, 0x01) ^ GF(0x57, 0x02) ^ GF(0x57, 0x10)
 * = 0x57 ^ 0xae ^ 0x07
 * = 0xfe.
 */
function initialize() {
  init = true;

  /* Populate the Rcon table. These are the values given by
    [x^(i-1),{00},{00},{00}] where x^(i-1) are powers of x (and x = 0x02)
    in the field of GF(2^8), where i starts at 1.

    rcon[0] = [0x00, 0x00, 0x00, 0x00]
    rcon[1] = [0x01, 0x00, 0x00, 0x00] 2^(1-1) = 2^0 = 1
    rcon[2] = [0x02, 0x00, 0x00, 0x00] 2^(2-1) = 2^1 = 2
    ...
    rcon[9]  = [0x1B, 0x00, 0x00, 0x00] 2^(9-1)  = 2^8 = 0x1B
    rcon[10] = [0x36, 0x00, 0x00, 0x00] 2^(10-1) = 2^9 = 0x36

    We only store the first byte because it is the only one used.
  */
  rcon = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36];

  // compute xtime table which maps i onto GF(i, 0x02)
  var xtime = new Array(256);
  for(var i = 0; i < 128; ++i) {
    xtime[i] = i << 1;
    xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
  }

  // compute all other tables
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for(var i = 0; i < 4; ++i) {
    mix[i] = new Array(256);
    imix[i] = new Array(256);
  }
  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
  for(var i = 0; i < 256; ++i) {
    /* We need to generate the SubBytes() sbox and isbox tables so that
      we can perform byte substitutions. This requires us to traverse
      all of the elements in GF, find their multiplicative inverses,
      and apply to each the following affine transformation:

      bi' = bi ^ b(i + 4) mod 8 ^ b(i + 5) mod 8 ^ b(i + 6) mod 8 ^
            b(i + 7) mod 8 ^ ci
      for 0 <= i < 8, where bi is the ith bit of the byte, and ci is the
      ith bit of a byte c with the value {63} or {01100011}.

      It is possible to traverse every possible value in a Galois field
      using what is referred to as a 'generator'. There are many
      generators (128 out of 256): 3,5,6,9,11,82 to name a few. To fully
      traverse GF we iterate 255 times, multiplying by our generator
      each time.

      On each iteration we can determine the multiplicative inverse for
      the current element.

      Suppose there is an element in GF 'e'. For a given generator 'g',
      e = g^x. The multiplicative inverse of e is g^(255 - x). It turns
      out that if use the inverse of a generator as another generator
      it will produce all of the corresponding multiplicative inverses
      at the same time. For this reason, we choose 5 as our inverse
      generator because it only requires 2 multiplies and 1 add and its
      inverse, 82, requires relatively few operations as well.

      In order to apply the affine transformation, the multiplicative
      inverse 'ei' of 'e' can be repeatedly XOR'd (4 times) with a
      bit-cycling of 'ei'. To do this 'ei' is first stored in 's' and
      'x'. Then 's' is left shifted and the high bit of 's' is made the
      low bit. The resulting value is stored in 's'. Then 'x' is XOR'd
      with 's' and stored in 'x'. On each subsequent iteration the same
      operation is performed. When 4 iterations are complete, 'x' is
      XOR'd with 'c' (0x63) and the transformed value is stored in 'x'.
      For example:

      s = 01000001
      x = 01000001

      iteration 1: s = 10000010, x ^= s
      iteration 2: s = 00000101, x ^= s
      iteration 3: s = 00001010, x ^= s
      iteration 4: s = 00010100, x ^= s
      x ^= 0x63

      This can be done with a loop where s = (s << 1) | (s >> 7). However,
      it can also be done by using a single 16-bit (in this case 32-bit)
      number 'sx'. Since XOR is an associative operation, we can set 'sx'
      to 'ei' and then XOR it with 'sx' left-shifted 1,2,3, and 4 times.
      The most significant bits will flow into the high 8 bit positions
      and be correctly XOR'd with one another. All that remains will be
      to cycle the high 8 bits by XOR'ing them all with the lower 8 bits
      afterwards.

      At the same time we're populating sbox and isbox we can precompute
      the multiplication we'll need to do to do MixColumns() later.
    */

    // apply affine transformation
    sx = ei ^ (ei << 1) ^ (ei << 2) ^ (ei << 3) ^ (ei << 4);
    sx = (sx >> 8) ^ (sx & 255) ^ 0x63;

    // update tables
    sbox[e] = sx;
    isbox[sx] = e;

    /* Mixing columns is done using matrix multiplication. The columns
      that are to be mixed are each a single word in the current state.
      The state has Nb columns (4 columns). Therefore each column is a
      4 byte word. So to mix the columns in a single column 'c' where
      its rows are r0, r1, r2, and r3, we use the following matrix
      multiplication:

      [2 3 1 1]*[r0,c]=[r'0,c]
      [1 2 3 1] [r1,c] [r'1,c]
      [1 1 2 3] [r2,c] [r'2,c]
      [3 1 1 2] [r3,c] [r'3,c]

      r0, r1, r2, and r3 are each 1 byte of one of the words in the
      state (a column). To do matrix multiplication for each mixed
      column c' we multiply the corresponding row from the left matrix
      with the corresponding column from the right matrix. In total, we
      get 4 equations:

      r0,c' = 2*r0,c + 3*r1,c + 1*r2,c + 1*r3,c
      r1,c' = 1*r0,c + 2*r1,c + 3*r2,c + 1*r3,c
      r2,c' = 1*r0,c + 1*r1,c + 2*r2,c + 3*r3,c
      r3,c' = 3*r0,c + 1*r1,c + 1*r2,c + 2*r3,c

      As usual, the multiplication is as previously defined and the
      addition is XOR. In order to optimize mixing columns we can store
      the multiplication results in tables. If you think of the whole
      column as a word (it might help to visualize by mentally rotating
      the equations above by counterclockwise 90 degrees) then you can
      see that it would be useful to map the multiplications performed on
      each byte (r0, r1, r2, r3) onto a word as well. For instance, we
      could map 2*r0,1*r0,1*r0,3*r0 onto a word by storing 2*r0 in the
      highest 8 bits and 3*r0 in the lowest 8 bits (with the other two
      respectively in the middle). This means that a table can be
      constructed that uses r0 as an index to the word. We can do the
      same with r1, r2, and r3, creating a total of 4 tables.

      To construct a full c', we can just look up each byte of c in
      their respective tables and XOR the results together.

      Also, to build each table we only have to calculate the word
      for 2,1,1,3 for every byte ... which we can do on each iteration
      of this loop since we will iterate over every byte. After we have
      calculated 2,1,1,3 we can get the results for the other tables
      by cycling the byte at the end to the beginning. For instance
      we can take the result of table 2,1,1,3 and produce table 3,2,1,1
      by moving the right most byte to the left most position just like
      how you can imagine the 3 moved out of 2,1,1,3 and to the front
      to produce 3,2,1,1.

      There is another optimization in that the same multiples of
      the current element we need in order to advance our generator
      to the next iteration can be reused in performing the 2,1,1,3
      calculation. We also calculate the inverse mix column tables,
      with e,9,d,b being the inverse of 2,1,1,3.

      When we're done, and we need to actually mix columns, the first
      byte of each state word should be put through mix[0] (2,1,1,3),
      the second through mix[1] (3,2,1,1) and so forth. Then they should
      be XOR'd together to produce the fully mixed column.
    */

    // calculate mix and imix table values
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me =
      (sx2 << 24) ^  // 2
      (sx << 16) ^   // 1
      (sx << 8) ^    // 1
      (sx ^ sx2);    // 3
    ime =
      (e2 ^ e4 ^ e8) << 24 ^  // E (14)
      (e ^ e8) << 16 ^        // 9
      (e ^ e4 ^ e8) << 8 ^    // D (13)
      (e ^ e2 ^ e8);          // B (11)
    // produce each of the mix tables by rotating the 2,1,1,3 value
    for(var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      // cycle the right most byte to the left most position
      // ie: 2,1,1,3 becomes 3,2,1,1
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }

    // get next element and inverse
    if(e === 0) {
      // 1 is the inverse of 1
      e = ei = 1;
    } else {
      // e = 2e + 2*2*2*(10e)) = multiply e by 82 (chosen generator)
      // ei = ei + 2*2*ei = multiply ei by 5 (inverse generator)
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}

/**
 * Generates a key schedule using the AES key expansion algorithm.
 *
 * The AES algorithm takes the Cipher Key, K, and performs a Key Expansion
 * routine to generate a key schedule. The Key Expansion generates a total
 * of Nb*(Nr + 1) words: the algorithm requires an initial set of Nb words,
 * and each of the Nr rounds requires Nb words of key data. The resulting
 * key schedule consists of a linear array of 4-byte words, denoted [wi ],
 * with i in the range 0 <= i < Nb(Nr + 1).
 *
 * KeyExpansion(byte key[4*Nk], word w[Nb*(Nr+1)], Nk)
 * AES-128 (Nb=4, Nk=4, Nr=10)
 * AES-192 (Nb=4, Nk=6, Nr=12)
 * AES-256 (Nb=4, Nk=8, Nr=14)
 * Note: Nr=Nk+6.
 *
 * Nb is the number of columns (32-bit words) comprising the State (or
 * number of bytes in a block). For AES, Nb=4.
 *
 * @param key the key to schedule (as an array of 32-bit words).
 * @param decrypt true to modify the key schedule to decrypt, false not to.
 *
 * @return the generated key schedule.
 */
function _expandKey(key, decrypt) {
  // copy the key's words to initialize the key schedule
  var w = key.slice(0);

  /* RotWord() will rotate a word, moving the first byte to the last
    byte's position (shifting the other bytes left).

    We will be getting the value of Rcon at i / Nk. 'i' will iterate
    from Nk to (Nb * Nr+1). Nk = 4 (4 byte key), Nb = 4 (4 words in
    a block), Nr = Nk + 6 (10). Therefore 'i' will iterate from
    4 to 44 (exclusive). Each time we iterate 4 times, i / Nk will
    increase by 1. We use a counter iNk to keep track of this.
   */

  // go through the rounds expanding the key
  var temp, iNk = 1;
  var Nk = w.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;
  for(var i = Nk; i < end; ++i) {
    temp = w[i - 1];
    if(i % Nk === 0) {
      // temp = SubWord(RotWord(temp)) ^ Rcon[i / Nk]
      temp =
        sbox[temp >>> 16 & 255] << 24 ^
        sbox[temp >>> 8 & 255] << 16 ^
        sbox[temp & 255] << 8 ^
        sbox[temp >>> 24] ^ (rcon[iNk] << 24);
      iNk++;
    } else if(Nk > 6 && (i % Nk === 4)) {
      // temp = SubWord(temp)
      temp =
        sbox[temp >>> 24] << 24 ^
        sbox[temp >>> 16 & 255] << 16 ^
        sbox[temp >>> 8 & 255] << 8 ^
        sbox[temp & 255];
    }
    w[i] = w[i - Nk] ^ temp;
  }

  /* When we are updating a cipher block we always use the code path for
     encryption whether we are decrypting or not (to shorten code and
     simplify the generation of look up tables). However, because there
     are differences in the decryption algorithm, other than just swapping
     in different look up tables, we must transform our key schedule to
     account for these changes:

     1. The decryption algorithm gets its key rounds in reverse order.
     2. The decryption algorithm adds the round key before mixing columns
       instead of afterwards.

     We don't need to modify our key schedule to handle the first case,
     we can just traverse the key schedule in reverse order when decrypting.

     The second case requires a little work.

     The tables we built for performing rounds will take an input and then
     perform SubBytes() and MixColumns() or, for the decrypt version,
     InvSubBytes() and InvMixColumns(). But the decrypt algorithm requires
     us to AddRoundKey() before InvMixColumns(). This means we'll need to
     apply some transformations to the round key to inverse-mix its columns
     so they'll be correct for moving AddRoundKey() to after the state has
     had its columns inverse-mixed.

     To inverse-mix the columns of the state when we're decrypting we use a
     lookup table that will apply InvSubBytes() and InvMixColumns() at the
     same time. However, the round key's bytes are not inverse-substituted
     in the decryption algorithm. To get around this problem, we can first
     substitute the bytes in the round key so that when we apply the
     transformation via the InvSubBytes()+InvMixColumns() table, it will
     undo our substitution leaving us with the original value that we
     want -- and then inverse-mix that value.

     This change will correctly alter our key schedule so that we can XOR
     each round key with our already transformed decryption state. This
     allows us to use the same code path as the encryption algorithm.

     We make one more change to the decryption key. Since the decryption
     algorithm runs in reverse from the encryption algorithm, we reverse
     the order of the round keys to avoid having to iterate over the key
     schedule backwards when running the encryption algorithm later in
     decryption mode. In addition to reversing the order of the round keys,
     we also swap each round key's 2nd and 4th rows. See the comments
     section where rounds are performed for more details about why this is
     done. These changes are done inline with the other substitution
     described above.
  */
  if(decrypt) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w.slice(0);
    end = w.length;
    for(var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      // do not sub the first or last round key (round keys are Nb
      // words) as no column mixing is performed before they are added,
      // but do change the key order
      if(i === 0 || i === (end - Nb)) {
        wnew[i] = w[wi];
        wnew[i + 1] = w[wi + 3];
        wnew[i + 2] = w[wi + 2];
        wnew[i + 3] = w[wi + 1];
      } else {
        // substitute each round key byte because the inverse-mix
        // table will inverse-substitute it (effectively cancel the
        // substitution because round key bytes aren't sub'd in
        // decryption mode) and swap indexes 3 and 1
        for(var n = 0; n < Nb; ++n) {
          tmp = w[wi + n];
          wnew[i + (3&-n)] =
            m0[sbox[tmp >>> 24]] ^
            m1[sbox[tmp >>> 16 & 255]] ^
            m2[sbox[tmp >>> 8 & 255]] ^
            m3[sbox[tmp & 255]];
        }
      }
    }
    w = wnew;
  }

  return w;
}

/**
 * Updates a single block (16 bytes) using AES. The update will either
 * encrypt or decrypt the block.
 *
 * @param w the key schedule.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */
function _updateBlock(w, input, output, decrypt) {
  /*
  Cipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[0, Nb-1])
    for round = 1 step 1 to Nr-1
      SubBytes(state)
      ShiftRows(state)
      MixColumns(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
    end for
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    out = state
  end

  InvCipher(byte in[4*Nb], byte out[4*Nb], word w[Nb*(Nr+1)])
  begin
    byte state[4,Nb]
    state = in
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
    for round = Nr-1 step -1 downto 1
      InvShiftRows(state)
      InvSubBytes(state)
      AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])
      InvMixColumns(state)
    end for
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
    out = state
  end
  */

  // Encrypt: AddRoundKey(state, w[0, Nb-1])
  // Decrypt: AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])
  var Nr = w.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if(decrypt) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d, a2, b2, c2;
  a = input[0] ^ w[0];
  b = input[decrypt ? 3 : 1] ^ w[1];
  c = input[2] ^ w[2];
  d = input[decrypt ? 1 : 3] ^ w[3];
  var i = 3;

  /* In order to share code we follow the encryption algorithm when both
    encrypting and decrypting. To account for the changes required in the
    decryption algorithm, we use different lookup tables when decrypting
    and use a modified key schedule to account for the difference in the
    order of transformations applied when performing rounds. We also get
    key rounds in reverse order (relative to encryption). */
  for(var round = 1; round < Nr; ++round) {
    /* As described above, we'll be using table lookups to perform the
      column mixing. Each column is stored as a word in the state (the
      array 'input' has one column as a word at each index). In order to
      mix a column, we perform these transformations on each row in c,
      which is 1 byte in each word. The new column for c0 is c'0:

               m0      m1      m2      m3
      r0,c'0 = 2*r0,c0 + 3*r1,c0 + 1*r2,c0 + 1*r3,c0
      r1,c'0 = 1*r0,c0 + 2*r1,c0 + 3*r2,c0 + 1*r3,c0
      r2,c'0 = 1*r0,c0 + 1*r1,c0 + 2*r2,c0 + 3*r3,c0
      r3,c'0 = 3*r0,c0 + 1*r1,c0 + 1*r2,c0 + 2*r3,c0

      So using mix tables where c0 is a word with r0 being its upper
      8 bits and r3 being its lower 8 bits:

      m0[c0 >> 24] will yield this word: [2*r0,1*r0,1*r0,3*r0]
      ...
      m3[c0 & 255] will yield this word: [1*r3,1*r3,3*r3,2*r3]

      Therefore to mix the columns in each word in the state we
      do the following (& 255 omitted for brevity):
      c'0,r0 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r1 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r2 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]
      c'0,r3 = m0[c0 >> 24] ^ m1[c1 >> 16] ^ m2[c2 >> 8] ^ m3[c3]

      However, before mixing, the algorithm requires us to perform
      ShiftRows(). The ShiftRows() transformation cyclically shifts the
      last 3 rows of the state over different offsets. The first row
      (r = 0) is not shifted.

      s'_r,c = s_r,(c + shift(r, Nb) mod Nb
      for 0 < r < 4 and 0 <= c < Nb and
      shift(1, 4) = 1
      shift(2, 4) = 2
      shift(3, 4) = 3.

      This causes the first byte in r = 1 to be moved to the end of
      the row, the first 2 bytes in r = 2 to be moved to the end of
      the row, the first 3 bytes in r = 3 to be moved to the end of
      the row:

      r1: [c0 c1 c2 c3] => [c1 c2 c3 c0]
      r2: [c0 c1 c2 c3]    [c2 c3 c0 c1]
      r3: [c0 c1 c2 c3]    [c3 c0 c1 c2]

      We can make these substitutions inline with our column mixing to
      generate an updated set of equations to produce each word in the
      state (note the columns have changed positions):

      c0 c1 c2 c3 => c0 c1 c2 c3
      c0 c1 c2 c3    c1 c2 c3 c0  (cycled 1 byte)
      c0 c1 c2 c3    c2 c3 c0 c1  (cycled 2 bytes)
      c0 c1 c2 c3    c3 c0 c1 c2  (cycled 3 bytes)

      Therefore:

      c'0 = 2*r0,c0 + 3*r1,c1 + 1*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 2*r1,c1 + 3*r2,c2 + 1*r3,c3
      c'0 = 1*r0,c0 + 1*r1,c1 + 2*r2,c2 + 3*r3,c3
      c'0 = 3*r0,c0 + 1*r1,c1 + 1*r2,c2 + 2*r3,c3

      c'1 = 2*r0,c1 + 3*r1,c2 + 1*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 2*r1,c2 + 3*r2,c3 + 1*r3,c0
      c'1 = 1*r0,c1 + 1*r1,c2 + 2*r2,c3 + 3*r3,c0
      c'1 = 3*r0,c1 + 1*r1,c2 + 1*r2,c3 + 2*r3,c0

      ... and so forth for c'2 and c'3. The important distinction is
      that the columns are cycling, with c0 being used with the m0
      map when calculating c0, but c1 being used with the m0 map when
      calculating c1 ... and so forth.

      When performing the inverse we transform the mirror image and
      skip the bottom row, instead of the top one, and move upwards:

      c3 c2 c1 c0 => c0 c3 c2 c1  (cycled 3 bytes) *same as encryption
      c3 c2 c1 c0    c1 c0 c3 c2  (cycled 2 bytes)
      c3 c2 c1 c0    c2 c1 c0 c3  (cycled 1 byte)  *same as encryption
      c3 c2 c1 c0    c3 c2 c1 c0

      If you compare the resulting matrices for ShiftRows()+MixColumns()
      and for InvShiftRows()+InvMixColumns() the 2nd and 4th columns are
      different (in encrypt mode vs. decrypt mode). So in order to use
      the same code to handle both encryption and decryption, we will
      need to do some mapping.

      If in encryption mode we let a=c0, b=c1, c=c2, d=c3, and r<N> be
      a row number in the state, then the resulting matrix in encryption
      mode for applying the above transformations would be:

      r1: a b c d
      r2: b c d a
      r3: c d a b
      r4: d a b c

      If we did the same in decryption mode we would get:

      r1: a d c b
      r2: b a d c
      r3: c b a d
      r4: d c b a

      If instead we swap d and b (set b=c3 and d=c1), then we get:

      r1: a b c d
      r2: d a b c
      r3: c d a b
      r4: b c d a

      Now the 1st and 3rd rows are the same as the encryption matrix. All
      we need to do then to make the mapping exactly the same is to swap
      the 2nd and 4th rows when in decryption mode. To do this without
      having to do it on each iteration, we swapped the 2nd and 4th rows
      in the decryption key schedule. We also have to do the swap above
      when we first pull in the input and when we set the final output. */
    a2 =
      m0[a >>> 24] ^
      m1[b >>> 16 & 255] ^
      m2[c >>> 8 & 255] ^
      m3[d & 255] ^ w[++i];
    b2 =
      m0[b >>> 24] ^
      m1[c >>> 16 & 255] ^
      m2[d >>> 8 & 255] ^
      m3[a & 255] ^ w[++i];
    c2 =
      m0[c >>> 24] ^
      m1[d >>> 16 & 255] ^
      m2[a >>> 8 & 255] ^
      m3[b & 255] ^ w[++i];
    d =
      m0[d >>> 24] ^
      m1[a >>> 16 & 255] ^
      m2[b >>> 8 & 255] ^
      m3[c & 255] ^ w[++i];
    a = a2;
    b = b2;
    c = c2;
  }

  /*
    Encrypt:
    SubBytes(state)
    ShiftRows(state)
    AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])

    Decrypt:
    InvShiftRows(state)
    InvSubBytes(state)
    AddRoundKey(state, w[0, Nb-1])
   */
  // Note: rows are shifted inline
  output[0] =
    (sub[a >>> 24] << 24) ^
    (sub[b >>> 16 & 255] << 16) ^
    (sub[c >>> 8 & 255] << 8) ^
    (sub[d & 255]) ^ w[++i];
  output[decrypt ? 3 : 1] =
    (sub[b >>> 24] << 24) ^
    (sub[c >>> 16 & 255] << 16) ^
    (sub[d >>> 8 & 255] << 8) ^
    (sub[a & 255]) ^ w[++i];
  output[2] =
    (sub[c >>> 24] << 24) ^
    (sub[d >>> 16 & 255] << 16) ^
    (sub[a >>> 8 & 255] << 8) ^
    (sub[b & 255]) ^ w[++i];
  output[decrypt ? 1 : 3] =
    (sub[d >>> 24] << 24) ^
    (sub[a >>> 16 & 255] << 16) ^
    (sub[b >>> 8 & 255] << 8) ^
    (sub[c & 255]) ^ w[++i];
}

/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('AES-<mode>', key);
 * forge.cipher.createDecipher('AES-<mode>', key);
 *
 * Creates a deprecated AES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key and iv may be given as a string of bytes, an array of bytes, a
 * byte buffer, or an array of 32-bit words.
 *
 * @param options the options to use.
 *          key the symmetric key to use.
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'AES-' + mode;

  var cipher;
  if(options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  }

  // backwards compatible start API
  var start = cipher.start;
  cipher.start = function(iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;
    if(options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }
    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}


/***/ }),

/***/ "./node_modules/node-forge/lib/asn1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/asn1.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of Abstract Syntax Notation Number One.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 *
 * An API for storing data using the Abstract Syntax Notation Number One
 * format using DER (Distinguished Encoding Rules) encoding. This encoding is
 * commonly used to store data for PKI, i.e. X.509 Certificates, and this
 * implementation exists for that purpose.
 *
 * Abstract Syntax Notation Number One (ASN.1) is used to define the abstract
 * syntax of information without restricting the way the information is encoded
 * for transmission. It provides a standard that allows for open systems
 * communication. ASN.1 defines the syntax of information data and a number of
 * simple data types as well as a notation for describing them and specifying
 * values for them.
 *
 * The RSA algorithm creates public and private keys that are often stored in
 * X.509 or PKCS#X formats -- which use ASN.1 (encoded in DER format). This
 * class provides the most basic functionality required to store and load DSA
 * keys that are encoded according to ASN.1.
 *
 * The most common binary encodings for ASN.1 are BER (Basic Encoding Rules)
 * and DER (Distinguished Encoding Rules). DER is just a subset of BER that
 * has stricter requirements for how data must be encoded.
 *
 * Each ASN.1 structure has a tag (a byte identifying the ASN.1 structure type)
 * and a byte array for the value of this ASN1 structure which may be data or a
 * list of ASN.1 structures.
 *
 * Each ASN.1 structure using BER is (Tag-Length-Value):
 *
 * | byte 0 | bytes X | bytes Y |
 * |--------|---------|----------
 * |  tag   | length  |  value  |
 *
 * ASN.1 allows for tags to be of "High-tag-number form" which allows a tag to
 * be two or more octets, but that is not supported by this class. A tag is
 * only 1 byte. Bits 1-5 give the tag number (ie the data type within a
 * particular 'class'), 6 indicates whether or not the ASN.1 value is
 * constructed from other ASN.1 values, and bits 7 and 8 give the 'class'. If
 * bits 7 and 8 are both zero, the class is UNIVERSAL. If only bit 7 is set,
 * then the class is APPLICATION. If only bit 8 is set, then the class is
 * CONTEXT_SPECIFIC. If both bits 7 and 8 are set, then the class is PRIVATE.
 * The tag numbers for the data types for the class UNIVERSAL are listed below:
 *
 * UNIVERSAL 0 Reserved for use by the encoding rules
 * UNIVERSAL 1 Boolean type
 * UNIVERSAL 2 Integer type
 * UNIVERSAL 3 Bitstring type
 * UNIVERSAL 4 Octetstring type
 * UNIVERSAL 5 Null type
 * UNIVERSAL 6 Object identifier type
 * UNIVERSAL 7 Object descriptor type
 * UNIVERSAL 8 External type and Instance-of type
 * UNIVERSAL 9 Real type
 * UNIVERSAL 10 Enumerated type
 * UNIVERSAL 11 Embedded-pdv type
 * UNIVERSAL 12 UTF8String type
 * UNIVERSAL 13 Relative object identifier type
 * UNIVERSAL 14-15 Reserved for future editions
 * UNIVERSAL 16 Sequence and Sequence-of types
 * UNIVERSAL 17 Set and Set-of types
 * UNIVERSAL 18-22, 25-30 Character string types
 * UNIVERSAL 23-24 Time types
 *
 * The length of an ASN.1 structure is specified after the tag identifier.
 * There is a definite form and an indefinite form. The indefinite form may
 * be used if the encoding is constructed and not all immediately available.
 * The indefinite form is encoded using a length byte with only the 8th bit
 * set. The end of the constructed object is marked using end-of-contents
 * octets (two zero bytes).
 *
 * The definite form looks like this:
 *
 * The length may take up 1 or more bytes, it depends on the length of the
 * value of the ASN.1 structure. DER encoding requires that if the ASN.1
 * structure has a value that has a length greater than 127, more than 1 byte
 * will be used to store its length, otherwise just one byte will be used.
 * This is strict.
 *
 * In the case that the length of the ASN.1 value is less than 127, 1 octet
 * (byte) is used to store the "short form" length. The 8th bit has a value of
 * 0 indicating the length is "short form" and not "long form" and bits 7-1
 * give the length of the data. (The 8th bit is the left-most, most significant
 * bit: also known as big endian or network format).
 *
 * In the case that the length of the ASN.1 value is greater than 127, 2 to
 * 127 octets (bytes) are used to store the "long form" length. The first
 * byte's 8th bit is set to 1 to indicate the length is "long form." Bits 7-1
 * give the number of additional octets. All following octets are in base 256
 * with the most significant digit first (typical big-endian binary unsigned
 * integer storage). So, for instance, if the length of a value was 257, the
 * first byte would be set to:
 *
 * 10000010 = 130 = 0x82.
 *
 * This indicates there are 2 octets (base 256) for the length. The second and
 * third bytes (the octets just mentioned) would store the length in base 256:
 *
 * octet 2: 00000001 = 1 * 256^1 = 256
 * octet 3: 00000001 = 1 * 256^0 = 1
 * total = 257
 *
 * The algorithm for converting a js integer value of 257 to base-256 is:
 *
 * var value = 257;
 * var bytes = [];
 * bytes[0] = (value >>> 8) & 0xFF; // most significant byte first
 * bytes[1] = value & 0xFF;        // least significant byte last
 *
 * On the ASN.1 UNIVERSAL Object Identifier (OID) type:
 *
 * An OID can be written like: "value1.value2.value3...valueN"
 *
 * The DER encoding rules:
 *
 * The first byte has the value 40 * value1 + value2.
 * The following bytes, if any, encode the remaining values. Each value is
 * encoded in base 128, most significant digit first (big endian), with as
 * few digits as possible, and the most significant bit of each byte set
 * to 1 except the last in each value's encoding. For example: Given the
 * OID "1.2.840.113549", its DER encoding is (remember each byte except the
 * last one in each encoding is OR'd with 0x80):
 *
 * byte 1: 40 * 1 + 2 = 42 = 0x2A.
 * bytes 2-3: 128 * 6 + 72 = 840 = 6 72 = 6 72 = 0x0648 = 0x8648
 * bytes 4-6: 16384 * 6 + 128 * 119 + 13 = 6 119 13 = 0x06770D = 0x86F70D
 *
 * The final value is: 0x2A864886F70D.
 * The full OID (including ASN.1 tag and length of 6 bytes) is:
 * 0x06062A864886F70D
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");

/* ASN.1 API */
var asn1 = module.exports = forge.asn1 = forge.asn1 || {};

/**
 * ASN.1 classes.
 */
asn1.Class = {
  UNIVERSAL:        0x00,
  APPLICATION:      0x40,
  CONTEXT_SPECIFIC: 0x80,
  PRIVATE:          0xC0
};

/**
 * ASN.1 types. Not all types are supported by this implementation, only
 * those necessary to implement a simple PKI are implemented.
 */
asn1.Type = {
  NONE:             0,
  BOOLEAN:          1,
  INTEGER:          2,
  BITSTRING:        3,
  OCTETSTRING:      4,
  NULL:             5,
  OID:              6,
  ODESC:            7,
  EXTERNAL:         8,
  REAL:             9,
  ENUMERATED:      10,
  EMBEDDED:        11,
  UTF8:            12,
  ROID:            13,
  SEQUENCE:        16,
  SET:             17,
  PRINTABLESTRING: 19,
  IA5STRING:       22,
  UTCTIME:         23,
  GENERALIZEDTIME: 24,
  BMPSTRING:       30
};

/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */
asn1.create = function(tagClass, type, constructed, value, options) {
  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */

  // remove undefined values
  if(forge.util.isArray(value)) {
    var tmp = [];
    for(var i = 0; i < value.length; ++i) {
      if(value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };
  if(options && 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents;
    // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes
    obj.original = asn1.copy(obj);
  }
  return obj;
};

/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */
asn1.copy = function(obj, options) {
  var copy;

  if(forge.util.isArray(obj)) {
    copy = [];
    for(var i = 0; i < obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }
    return copy;
  }

  if(typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };
  if(options && !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};

/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */
asn1.equals = function(obj1, obj2, options) {
  if(forge.util.isArray(obj1)) {
    if(!forge.util.isArray(obj2)) {
      return false;
    }
    if(obj1.length !== obj2.length) {
      return false;
    }
    for(var i = 0; i < obj1.length; ++i) {
      if(!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }

  if(typeof obj1 !== typeof obj2) {
    return false;
  }

  if(typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass &&
    obj1.type === obj2.type &&
    obj1.constructed === obj2.constructed &&
    obj1.composed === obj2.composed &&
    asn1.equals(obj1.value, obj2.value);
  if(options && options.includeBitStringContents) {
    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);
  }

  return equal;
};

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is "short form" or "long form" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 & 0x7F) << 3);
  }
  return length;
};

/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */
function _checkBufferLength(bytes, remaining, n) {
  if(n > remaining) {
    var error = new Error('Too few bytes to parse DER.');
    error.available = bytes.length();
    error.remaining = remaining;
    error.requested = n;
    throw error;
  }
}

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
var _getValueLength = function(bytes, remaining) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  // fromDer already checked that this byte exists
  var b2 = bytes.getByte();
  remaining--;
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is "short form" or "long form" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    var longFormBytes = b2 & 0x7F;
    _checkBufferLength(bytes, remaining, longFormBytes);
    length = bytes.getInt(longFormBytes << 3);
  }
  // FIXME: this will only happen for 32 bit getInt with high bit set
  if(length < 0) {
    throw new Error('Negative length: ' + length);
  }
  return length;
};

/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @return the parsed asn1 object.
 */
asn1.fromDer = function(bytes, options) {
  if(options === undefined) {
    options = {
      strict: true,
      decodeBitStrings: true
    };
  }
  if(typeof options === 'boolean') {
    options = {
      strict: options,
      decodeBitStrings: true
    };
  }
  if(!('strict' in options)) {
    options.strict = true;
  }
  if(!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  }

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  return _fromDer(bytes, bytes.length(), 0, options);
};

/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */
function _fromDer(bytes, remaining, depth, options) {
  // temporary storage for consumption calculations
  var start;

  // minimum length for ASN.1 DER structure is 2
  _checkBufferLength(bytes, remaining, 2);

  // get the first byte
  var b1 = bytes.getByte();
  // consumed one byte
  remaining--;

  // get the tag class
  var tagClass = (b1 & 0xC0);

  // get the type (bits 1-5)
  var type = b1 & 0x1F;

  // get the variable value length and adjust remaining bytes
  start = bytes.length();
  var length = _getValueLength(bytes, remaining);
  remaining -= start - bytes.length();

  // ensure there are enough bytes to get the value
  if(length !== undefined && length > remaining) {
    if(options.strict) {
      var error = new Error('Too few bytes to read ASN.1 value.');
      error.available = bytes.length();
      error.remaining = remaining;
      error.requested = length;
      throw error;
    }
    // Note: be lenient with truncated values and use remaining state bytes
    length = remaining;
  }

  // value storage
  var value;
  // possible BIT STRING contents storage
  var bitStringContents;

  // constructed flag is bit 6 (32 = 0x20) of the first byte
  var constructed = ((b1 & 0x20) === 0x20);
  if(constructed) {
    // parse child asn1 objects from the value
    value = [];
    if(length === undefined) {
      // asn1 object of indefinite length, read until end tag
      for(;;) {
        _checkBufferLength(bytes, remaining, 2);
        if(bytes.bytes(2) === String.fromCharCode(0, 0)) {
          bytes.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes.length();
        value.push(_fromDer(bytes, remaining, depth + 1, options));
        remaining -= start - bytes.length();
      }
    } else {
      // parsing asn1 object of definite length
      while(length > 0) {
        start = bytes.length();
        value.push(_fromDer(bytes, length, depth + 1, options));
        remaining -= start - bytes.length();
        length -= start - bytes.length();
      }
    }
  }

  // if a BIT STRING, save the contents including padding
  if(value === undefined && tagClass === asn1.Class.UNIVERSAL &&
    type === asn1.Type.BITSTRING) {
    bitStringContents = bytes.bytes(length);
  }

  // determine if a non-constructed value should be decoded as a composed
  // value that contains other ASN.1 objects. BIT STRINGs (and OCTET STRINGs)
  // can be used this way.
  if(value === undefined && options.decodeBitStrings &&
    tagClass === asn1.Class.UNIVERSAL &&
    // FIXME: OCTET STRINGs not yet supported here
    // .. other parts of forge expect to decode OCTET STRINGs manually
    (type === asn1.Type.BITSTRING /*|| type === asn1.Type.OCTETSTRING*/) &&
    length > 1) {
    // save read position
    var savedRead = bytes.read;
    var savedRemaining = remaining;
    var unused = 0;
    if(type === asn1.Type.BITSTRING) {
      /* The first octet gives the number of bits by which the length of the
        bit string is less than the next multiple of eight (this is called
        the "number of unused bits").

        The second and following octets give the value of the bit string
        converted to an octet string. */
      _checkBufferLength(bytes, remaining, 1);
      unused = bytes.getByte();
      remaining--;
    }
    // if all bits are used, maybe the BIT/OCTET STRING holds ASN.1 objs
    if(unused === 0) {
      try {
        // attempt to parse child asn1 object from the value
        // (stored in array to signal composed value)
        start = bytes.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          verbose: options.verbose,
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
        var used = start - bytes.length();
        remaining -= used;
        if(type == asn1.Type.BITSTRING) {
          used++;
        }

        // if the data all decoded and the class indicates UNIVERSAL or
        // CONTEXT_SPECIFIC then assume we've got an encapsulated ASN.1 object
        var tc = composed.tagClass;
        if(used === length &&
          (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
          value = [composed];
        }
      } catch(ex) {
      }
    }
    if(value === undefined) {
      // restore read position
      bytes.read = savedRead;
      remaining = savedRemaining;
    }
  }

  if(value === undefined) {
    // asn1 not constructed or composed, get raw value
    // TODO: do DER to OID conversion and vice-versa in .toDer?

    if(length === undefined) {
      if(options.strict) {
        throw new Error('Non-constructed ASN.1 object of indefinite length.');
      }
      // be lenient and use remaining state bytes
      length = remaining;
    }

    if(type === asn1.Type.BMPSTRING) {
      value = '';
      for(; length > 0; length -= 2) {
        _checkBufferLength(bytes, remaining, 2);
        value += String.fromCharCode(bytes.getInt16());
        remaining -= 2;
      }
    } else {
      value = bytes.getBytes(length);
    }
  }

  // add BIT STRING contents if available
  var asn1Options = bitStringContents === undefined ? null : {
    bitStringContents: bitStringContents
  };

  // create and return asn1 object
  return asn1.create(tagClass, type, constructed, value, asn1Options);
}

/**
 * Converts the given asn1 object to a buffer of bytes in DER format.
 *
 * @param asn1 the asn1 object to convert to bytes.
 *
 * @return the buffer of bytes.
 */
asn1.toDer = function(obj) {
  var bytes = forge.util.createBuffer();

  // build the first byte
  var b1 = obj.tagClass | obj.type;

  // for storing the ASN.1 value
  var value = forge.util.createBuffer();

  // use BIT STRING contents if available and data not changed
  var useBitStringContents = false;
  if('bitStringContents' in obj) {
    useBitStringContents = true;
    if(obj.original) {
      useBitStringContents = asn1.equals(obj, obj.original);
    }
  }

  if(useBitStringContents) {
    value.putBytes(obj.bitStringContents);
  } else if(obj.composed) {
    // if composed, use each child asn1 object's DER bytes as value
    // turn on 6th bit (0x20 = 32) to indicate asn1 is constructed
    // from other asn1 objects
    if(obj.constructed) {
      b1 |= 0x20;
    } else {
      // type is a bit string, add unused bits of 0x00
      value.putByte(0x00);
    }

    // add all of the child DER bytes together
    for(var i = 0; i < obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        value.putBuffer(asn1.toDer(obj.value[i]));
      }
    }
  } else {
    // use asn1.value directly
    if(obj.type === asn1.Type.BMPSTRING) {
      for(var i = 0; i < obj.value.length; ++i) {
        value.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      // ensure integer is minimally-encoded
      // TODO: should all leading bytes be stripped vs just one?
      // .. ex '00 00 01' => '01'?
      if(obj.type === asn1.Type.INTEGER &&
        obj.value.length > 1 &&
        // leading 0x00 for positive integer
        ((obj.value.charCodeAt(0) === 0 &&
        (obj.value.charCodeAt(1) & 0x80) === 0) ||
        // leading 0xFF for negative integer
        (obj.value.charCodeAt(0) === 0xFF &&
        (obj.value.charCodeAt(1) & 0x80) === 0x80))) {
        value.putBytes(obj.value.substr(1));
      } else {
        value.putBytes(obj.value);
      }
    }
  }

  // add tag byte
  bytes.putByte(b1);

  // use "short form" encoding
  if(value.length() <= 127) {
    // one byte describes the length
    // bit 8 = 0 and bits 7-1 = length
    bytes.putByte(value.length() & 0x7F);
  } else {
    // use "long form" encoding
    // 2 to 127 bytes describe the length
    // first byte: bit 8 = 1 and bits 7-1 = # of additional bytes
    // other bytes: length in base 256, big-endian
    var len = value.length();
    var lenBytes = '';
    do {
      lenBytes += String.fromCharCode(len & 0xFF);
      len = len >>> 8;
    } while(len > 0);

    // set first byte to # bytes used to store the length and turn on
    // bit 8 to indicate long-form length is used
    bytes.putByte(lenBytes.length | 0x80);

    // concatenate length bytes in reverse since they were generated
    // little endian and we need big endian
    for(var i = lenBytes.length - 1; i >= 0; --i) {
      bytes.putByte(lenBytes.charCodeAt(i));
    }
  }

  // concatenate value bytes
  bytes.putBuffer(value);
  return bytes;
};

/**
 * Converts an OID dot-separated string to a byte buffer. The byte buffer
 * contains only the DER-encoded value, not any tag or length bytes.
 *
 * @param oid the OID dot-separated string.
 *
 * @return the byte buffer.
 */
asn1.oidToDer = function(oid) {
  // split OID into individual values
  var values = oid.split('.');
  var bytes = forge.util.createBuffer();

  // first byte is 40 * value1 + value2
  bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var last, valueBytes, value, b;
  for(var i = 2; i < values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    do {
      b = value & 0x7F;
      value = value >>> 7;
      // if value is not last, then turn on 8th bit
      if(!last) {
        b |= 0x80;
      }
      valueBytes.push(b);
      last = false;
    } while(value > 0);

    // add value bytes in reverse (needs to be in big endian)
    for(var n = valueBytes.length - 1; n >= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
};

/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */
asn1.derToOid = function(bytes) {
  var oid;

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  // first byte is 40 * value1 + value2
  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + (b % 40);

  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var value = 0;
  while(bytes.length() > 0) {
    b = bytes.getByte();
    value = value << 7;
    // not the last byte for the value
    if(b & 0x80) {
      value += b & 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);
      value = 0;
    }
  }

  return oid;
};

/**
 * Converts a UTCTime value to a date.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Parsing that structure hasn't been implemented yet.
 *
 * @param utc the UTCTime value to convert.
 *
 * @return the date.
 */
asn1.utcTimeToDate = function(utc) {
  /* The following formats can be used:

    YYMMDDhhmmZ
    YYMMDDhhmm+hh'mm'
    YYMMDDhhmm-hh'mm'
    YYMMDDhhmmssZ
    YYMMDDhhmmss+hh'mm'
    YYMMDDhhmmss-hh'mm'

    Where:

    YY is the least significant two digits of the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date();

  // if YY >= 50 use 19xx, if YY < 50 use 20xx
  var year = parseInt(utc.substr(0, 2), 10);
  year = (year >= 50) ? 1900 + year : 2000 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;

  // not just YYMMDDhhmmZ
  if(utc.length > 11) {
    // get character after minutes
    var c = utc.charAt(10);
    var end = 10;

    // see if seconds are present
    if(c !== '+' && c !== '-') {
      // get seconds
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  }

  // update date
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);

  if(end) {
    // get +/- after end of time
    c = utc.charAt(end);
    if(c === '+' || c === '-') {
      // get hours+minutes offset
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);

      // calculate offset in milliseconds
      var offset = hhoffset * 60 + mmoffset;
      offset *= 60000;

      // apply offset
      if(c === '+') {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }

  return date;
};

/**
 * Converts a GeneralizedTime value to a date.
 *
 * @param gentime the GeneralizedTime value to convert.
 *
 * @return the date.
 */
asn1.generalizedTimeToDate = function(gentime) {
  /* The following formats can be used:

    YYYYMMDDHHMMSS
    YYYYMMDDHHMMSS.fff
    YYYYMMDDHHMMSSZ
    YYYYMMDDHHMMSS.fffZ
    YYYYMMDDHHMMSS+hh'mm'
    YYYYMMDDHHMMSS.fff+hh'mm'
    YYYYMMDDHHMMSS-hh'mm'
    YYYYMMDDHHMMSS.fff-hh'mm'

    Where:

    YYYY is the year
    MM is the month (01 to 12)
    DD is the day (01 to 31)
    hh is the hour (00 to 23)
    mm are the minutes (00 to 59)
    ss are the seconds (00 to 59)
    .fff is the second fraction, accurate to three decimal places
    Z indicates that local time is GMT, + indicates that local time is
    later than GMT, and - indicates that local time is earlier than GMT
    hh' is the absolute value of the offset from GMT in hours
    mm' is the absolute value of the offset from GMT in minutes */
  var date = new Date();

  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1; // use 0-11 for month
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;

  if(gentime.charAt(gentime.length - 1) === 'Z') {
    isUTC = true;
  }

  var end = gentime.length - 5, c = gentime.charAt(end);
  if(c === '+' || c === '-') {
    // get hours+minutes offset
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);

    // calculate offset in milliseconds
    offset = hhoffset * 60 + mmoffset;
    offset *= 60000;

    // apply offset
    if(c === '+') {
      offset *= -1;
    }

    isUTC = true;
  }

  // check for second fraction
  if(gentime.charAt(14) === '.') {
    fff = parseFloat(gentime.substr(14), 10) * 1000;
  }

  if(isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);

    // apply offset
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }

  return date;
};

/**
 * Converts a date to a UTCTime value.
 *
 * Note: GeneralizedTime has 4 digits for the year and is used for X.509
 * dates past 2049. Converting to a GeneralizedTime hasn't been
 * implemented yet.
 *
 * @param date the date to convert.
 *
 * @return the UTCTime value.
 */
asn1.dateToUtcTime = function(date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYMMDDhhmmssZ
  var format = [];
  format.push(('' + date.getUTCFullYear()).substr(2));
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i < format.length; ++i) {
    if(format[i].length < 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
};

/**
 * Converts a date to a GeneralizedTime value.
 *
 * @param date the date to convert.
 *
 * @return the GeneralizedTime value as a string.
 */
asn1.dateToGeneralizedTime = function(date) {
  // TODO: validate; currently assumes proper format
  if(typeof date === 'string') {
    return date;
  }

  var rval = '';

  // create format YYYYMMDDHHMMSSZ
  var format = [];
  format.push('' + date.getUTCFullYear());
  format.push('' + (date.getUTCMonth() + 1));
  format.push('' + date.getUTCDate());
  format.push('' + date.getUTCHours());
  format.push('' + date.getUTCMinutes());
  format.push('' + date.getUTCSeconds());

  // ensure 2 digits are used for each format entry
  for(var i = 0; i < format.length; ++i) {
    if(format[i].length < 2) {
      rval += '0';
    }
    rval += format[i];
  }
  rval += 'Z';

  return rval;
};

/**
 * Converts a javascript integer to a DER-encoded byte buffer to be used
 * as the value for an INTEGER type.
 *
 * @param x the integer.
 *
 * @return the byte buffer.
 */
asn1.integerToDer = function(x) {
  var rval = forge.util.createBuffer();
  if(x >= -0x80 && x < 0x80) {
    return rval.putSignedInt(x, 8);
  }
  if(x >= -0x8000 && x < 0x8000) {
    return rval.putSignedInt(x, 16);
  }
  if(x >= -0x800000 && x < 0x800000) {
    return rval.putSignedInt(x, 24);
  }
  if(x >= -0x80000000 && x < 0x80000000) {
    return rval.putSignedInt(x, 32);
  }
  var error = new Error('Integer too large; max is 32-bits.');
  error.integer = x;
  throw error;
};

/**
 * Converts a DER-encoded byte buffer to a javascript integer. This is
 * typically used to decode the value of an INTEGER type.
 *
 * @param bytes the byte buffer.
 *
 * @return the integer.
 */
asn1.derToInteger = function(bytes) {
  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var n = bytes.length() * 8;
  if(n > 32) {
    throw new Error('Integer too large; max is 32-bits.');
  }
  return bytes.getSignedInt(n);
};

/**
 * Validates that the given ASN.1 object is at least a super set of the
 * given ASN.1 structure. Only tag classes and types are checked. An
 * optional map may also be provided to capture ASN.1 values while the
 * structure is checked.
 *
 * To capture an ASN.1 value, set an object in the validator's 'capture'
 * parameter to the key to use in the capture map. To capture the full
 * ASN.1 object, specify 'captureAsn1'. To capture BIT STRING bytes, including
 * the leading unused bits counter byte, specify 'captureBitStringContents'.
 * To capture BIT STRING bytes, without the leading unused bits counter byte,
 * specify 'captureBitStringValue'.
 *
 * Objects in the validator may set a field 'optional' to true to indicate
 * that it isn't necessary to pass validation.
 *
 * @param obj the ASN.1 object to validate.
 * @param v the ASN.1 structure validator.
 * @param capture an optional map to capture values in.
 * @param errors an optional array for storing validation errors.
 *
 * @return true on success, false on failure.
 */
asn1.validate = function(obj, v, capture, errors) {
  var rval = false;

  // ensure tag class and type are the same if specified
  if((obj.tagClass === v.tagClass || typeof(v.tagClass) === 'undefined') &&
    (obj.type === v.type || typeof(v.type) === 'undefined')) {
    // ensure constructed flag is the same if specified
    if(obj.constructed === v.constructed ||
      typeof(v.constructed) === 'undefined') {
      rval = true;

      // handle sub values
      if(v.value && forge.util.isArray(v.value)) {
        var j = 0;
        for(var i = 0; rval && i < v.value.length; ++i) {
          rval = v.value[i].optional || false;
          if(obj.value[j]) {
            rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
            if(rval) {
              ++j;
            } else if(v.value[i].optional) {
              rval = true;
            }
          }
          if(!rval && errors) {
            errors.push(
              '[' + v.name + '] ' +
              'Tag class "' + v.tagClass + '", type "' +
              v.type + '" expected value length "' +
              v.value.length + '", got "' +
              obj.value.length + '"');
          }
        }
      }

      if(rval && capture) {
        if(v.capture) {
          capture[v.capture] = obj.value;
        }
        if(v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if(v.captureBitStringContents && 'bitStringContents' in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if(v.captureBitStringValue && 'bitStringContents' in obj) {
          var value;
          if(obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = '';
          } else {
            // FIXME: support unused bits with data shifting
            var unused = obj.bitStringContents.charCodeAt(0);
            if(unused !== 0) {
              throw new Error(
                'captureBitStringValue only supported for zero unused bits');
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if(errors) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected constructed "' + v.constructed + '", got "' +
        obj.constructed + '"');
    }
  } else if(errors) {
    if(obj.tagClass !== v.tagClass) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected tag class "' + v.tagClass + '", got "' +
        obj.tagClass + '"');
    }
    if(obj.type !== v.type) {
      errors.push(
        '[' + v.name + '] ' +
        'Expected type "' + v.type + '", got "' + obj.type + '"');
    }
  }
  return rval;
};

// regex for testing for non-latin characters
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;

/**
 * Pretty prints an ASN.1 object to a string.
 *
 * @param obj the object to write out.
 * @param level the level in the tree.
 * @param indentation the indentation to use.
 *
 * @return the string.
 */
asn1.prettyPrint = function(obj, level, indentation) {
  var rval = '';

  // set default level and indentation
  level = level || 0;
  indentation = indentation || 2;

  // start new line for deep levels
  if(level > 0) {
    rval += '\n';
  }

  // create indent
  var indent = '';
  for(var i = 0; i < level * indentation; ++i) {
    indent += ' ';
  }

  // print class:type
  rval += indent + 'Tag: ';
  switch(obj.tagClass) {
  case asn1.Class.UNIVERSAL:
    rval += 'Universal:';
    break;
  case asn1.Class.APPLICATION:
    rval += 'Application:';
    break;
  case asn1.Class.CONTEXT_SPECIFIC:
    rval += 'Context-Specific:';
    break;
  case asn1.Class.PRIVATE:
    rval += 'Private:';
    break;
  }

  if(obj.tagClass === asn1.Class.UNIVERSAL) {
    rval += obj.type;

    // known types
    switch(obj.type) {
    case asn1.Type.NONE:
      rval += ' (None)';
      break;
    case asn1.Type.BOOLEAN:
      rval += ' (Boolean)';
      break;
    case asn1.Type.INTEGER:
      rval += ' (Integer)';
      break;
    case asn1.Type.BITSTRING:
      rval += ' (Bit string)';
      break;
    case asn1.Type.OCTETSTRING:
      rval += ' (Octet string)';
      break;
    case asn1.Type.NULL:
      rval += ' (Null)';
      break;
    case asn1.Type.OID:
      rval += ' (Object Identifier)';
      break;
    case asn1.Type.ODESC:
      rval += ' (Object Descriptor)';
      break;
    case asn1.Type.EXTERNAL:
      rval += ' (External or Instance of)';
      break;
    case asn1.Type.REAL:
      rval += ' (Real)';
      break;
    case asn1.Type.ENUMERATED:
      rval += ' (Enumerated)';
      break;
    case asn1.Type.EMBEDDED:
      rval += ' (Embedded PDV)';
      break;
    case asn1.Type.UTF8:
      rval += ' (UTF8)';
      break;
    case asn1.Type.ROID:
      rval += ' (Relative Object Identifier)';
      break;
    case asn1.Type.SEQUENCE:
      rval += ' (Sequence)';
      break;
    case asn1.Type.SET:
      rval += ' (Set)';
      break;
    case asn1.Type.PRINTABLESTRING:
      rval += ' (Printable String)';
      break;
    case asn1.Type.IA5String:
      rval += ' (IA5String (ASCII))';
      break;
    case asn1.Type.UTCTIME:
      rval += ' (UTC time)';
      break;
    case asn1.Type.GENERALIZEDTIME:
      rval += ' (Generalized time)';
      break;
    case asn1.Type.BMPSTRING:
      rval += ' (BMP String)';
      break;
    }
  } else {
    rval += obj.type;
  }

  rval += '\n';
  rval += indent + 'Constructed: ' + obj.constructed + '\n';

  if(obj.composed) {
    var subvalues = 0;
    var sub = '';
    for(var i = 0; i < obj.value.length; ++i) {
      if(obj.value[i] !== undefined) {
        subvalues += 1;
        sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
        if((i + 1) < obj.value.length) {
          sub += ',';
        }
      }
    }
    rval += indent + 'Sub values: ' + subvalues + sub;
  } else {
    rval += indent + 'Value: ';
    if(obj.type === asn1.Type.OID) {
      var oid = asn1.derToOid(obj.value);
      rval += oid;
      if(forge.pki && forge.pki.oids) {
        if(oid in forge.pki.oids) {
          rval += ' (' + forge.pki.oids[oid] + ') ';
        }
      }
    }
    if(obj.type === asn1.Type.INTEGER) {
      try {
        rval += asn1.derToInteger(obj.value);
      } catch(ex) {
        rval += '0x' + forge.util.bytesToHex(obj.value);
      }
    } else if(obj.type === asn1.Type.BITSTRING) {
      // TODO: shift bits as needed to display without padding
      if(obj.value.length > 1) {
        // remove unused bits field
        rval += '0x' + forge.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += '(none)';
      }
      // show unused bit count
      if(obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);
        if(unused == 1) {
          rval += ' (1 unused bit shown)';
        } else if(unused > 1) {
          rval += ' (' + unused + ' unused bits shown)';
        }
      }
    } else if(obj.type === asn1.Type.OCTETSTRING) {
      if(!_nonLatinRegex.test(obj.value)) {
        rval += '(' + obj.value + ') ';
      }
      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if(obj.type === asn1.Type.UTF8) {
      rval += forge.util.decodeUtf8(obj.value);
    } else if(obj.type === asn1.Type.PRINTABLESTRING ||
      obj.type === asn1.Type.IA5String) {
      rval += obj.value;
    } else if(_nonLatinRegex.test(obj.value)) {
      rval += '0x' + forge.util.bytesToHex(obj.value);
    } else if(obj.value.length === 0) {
      rval += '[null]';
    } else {
      rval += obj.value;
    }
  }

  return rval;
};


/***/ }),

/***/ "./node_modules/node-forge/lib/baseN.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/baseN.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Base-N/Base-X encoding/decoding functions.
 *
 * Original implementation from base-x:
 * https://github.com/cryptocoinjs/base-x
 *
 * Which is MIT licensed:
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
var api = {};
module.exports = api;

// baseN alphabet indexes
var _reverseAlphabets = {};

/**
 * BaseN-encodes a Uint8Array using the given alphabet.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the baseN-encoded output string.
 */
api.encode = function(input, alphabet, maxline) {
  if(typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }
  if(maxline !== undefined && typeof maxline !== 'number') {
    throw new TypeError('"maxline" must be a number.');
  }

  var output = '';

  if(!(input instanceof Uint8Array)) {
    // assume forge byte buffer
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];
    for(i = 0; i < input.length; ++i) {
      for(var j = 0, carry = input[i]; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = (carry / base) | 0;
      }

      while(carry > 0) {
        digits.push(carry % base);
        carry = (carry / base) | 0;
      }
    }

    // deal with leading zeros
    for(i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first;
    }
    // convert digits to a string
    for(i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }

  if(maxline) {
    var regex = new RegExp('.{1,' + maxline + '}', 'g');
    output = output.match(regex).join('\r\n');
  }

  return output;
};

/**
 * Decodes a baseN-encoded (using the given alphabet) string to a
 * Uint8Array.
 *
 * @param input the baseN-encoded input string.
 *
 * @return the Uint8Array.
 */
api.decode = function(input, alphabet) {
  if(typeof input !== 'string') {
    throw new TypeError('"input" must be a string.');
  }
  if(typeof alphabet !== 'string') {
    throw new TypeError('"alphabet" must be a string.');
  }

  var table = _reverseAlphabets[alphabet];
  if(!table) {
    // compute reverse alphabet
    table = _reverseAlphabets[alphabet] = [];
    for(var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  }

  // remove whitespace characters
  input = input.replace(/\s/g, '');

  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var bytes = [0];
  for(var i = 0; i < input.length; i++) {
    var value = table[input.charCodeAt(i)];
    if(value === undefined) {
      return;
    }

    for(var j = 0, carry = value; j < bytes.length; ++j) {
      carry += bytes[j] * base;
      bytes[j] = carry & 0xff;
      carry >>= 8;
    }

    while(carry > 0) {
      bytes.push(carry & 0xff);
      carry >>= 8;
    }
  }

  // deal with leading zeros
  for(var k = 0; input[k] === first && k < input.length - 1; ++k) {
    bytes.push(0);
  }

  if(typeof Buffer !== 'undefined') {
    return Buffer.from(bytes.reverse());
  }

  return new Uint8Array(bytes.reverse());
};

function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first = alphabet.charAt(0);
  var digits = [0];
  for(i = 0; i < input.length(); ++i) {
    for(var j = 0, carry = input.at(i); j < digits.length; ++j) {
      carry += digits[j] << 8;
      digits[j] = carry % base;
      carry = (carry / base) | 0;
    }

    while(carry > 0) {
      digits.push(carry % base);
      carry = (carry / base) | 0;
    }
  }

  var output = '';

  // deal with leading zeros
  for(i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first;
  }
  // convert digits to a string
  for(i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }

  return output;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/node-forge/lib/cipher.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Cipher base API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

module.exports = forge.cipher = forge.cipher || {};

// registered algorithms
forge.cipher.algorithms = forge.cipher.algorithms || {};

/**
 * Creates a cipher object that can be used to encrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */
forge.cipher.createCipher = function(algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: false
  });
};

/**
 * Creates a decipher object that can be used to decrypt data using the given
 * algorithm and key. The algorithm may be provided as a string value for a
 * previously registered algorithm or it may be given as a cipher algorithm
 * API object.
 *
 * @param algorithm the algorithm to use, either a string or an algorithm API
 *          object.
 * @param key the key to use, as a binary-encoded string of bytes or a
 *          byte buffer.
 *
 * @return the cipher.
 */
forge.cipher.createDecipher = function(algorithm, key) {
  var api = algorithm;
  if(typeof api === 'string') {
    api = forge.cipher.getAlgorithm(api);
    if(api) {
      api = api();
    }
  }
  if(!api) {
    throw new Error('Unsupported algorithm: ' + algorithm);
  }

  // assume block cipher
  return new forge.cipher.BlockCipher({
    algorithm: api,
    key: key,
    decrypt: true
  });
};

/**
 * Registers an algorithm by name. If the name was already registered, the
 * algorithm API object will be overwritten.
 *
 * @param name the name of the algorithm.
 * @param algorithm the algorithm API object.
 */
forge.cipher.registerAlgorithm = function(name, algorithm) {
  name = name.toUpperCase();
  forge.cipher.algorithms[name] = algorithm;
};

/**
 * Gets a registered algorithm by name.
 *
 * @param name the name of the algorithm.
 *
 * @return the algorithm, if found, null if not.
 */
forge.cipher.getAlgorithm = function(name) {
  name = name.toUpperCase();
  if(name in forge.cipher.algorithms) {
    return forge.cipher.algorithms[name];
  }
  return null;
};

var BlockCipher = forge.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};

/**
 * Starts or restarts the encryption or decryption process, whichever
 * was previously configured.
 *
 * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array
 * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in
 * bytes, then it must be Nb (16) bytes in length. If the IV is given in as
 * 32-bit integers, then it must be 4 integers long.
 *
 * Note: an IV is not required or used in ECB mode.
 *
 * For GCM-mode, the IV must be given as a binary-encoded string of bytes or
 * a byte buffer. The number of bytes should be 12 (96 bits) as recommended
 * by NIST SP-800-38D but another length may be given.
 *
 * @param options the options to use:
 *          iv the initialization vector to use as a binary-encoded string of
 *            bytes, null to reuse the last ciphered block from a previous
 *            update() (this "residue" method is for legacy support only).
 *          additionalData additional authentication data as a binary-encoded
 *            string of bytes, for 'GCM' mode, (default: none).
 *          tagLength desired length of authentication tag, in bits, for
 *            'GCM' mode (0-128, default: 128).
 *          tag the authentication tag to check if decrypting, as a
 *             binary-encoded string of bytes.
 *          output the output the buffer to write to, null to create one.
 */
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for(var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge.util.createBuffer();
  this.output = options.output || forge.util.createBuffer();
  this.mode.start(opts);
};

/**
 * Updates the next block according to the cipher mode.
 *
 * @param input the buffer to read from.
 */
BlockCipher.prototype.update = function(input) {
  if(input) {
    // input given, so empty it into the input buffer
    this._input.putBuffer(input);
  }

  // do cipher operation until it needs more input and not finished
  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&
    !this._finish) {}

  // free consumed memory from input buffer
  this._input.compact();
};

/**
 * Finishes encrypting or decrypting.
 *
 * @param pad a padding function to use in CBC mode, null for default,
 *          signature(blockSize, buffer, decrypt).
 *
 * @return true if successful, false on error.
 */
BlockCipher.prototype.finish = function(pad) {
  // backwards-compatibility w/deprecated padding API
  // Note: will overwrite padding functions even after another start() call
  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }

  // build options for padding and afterFinish functions
  var options = {};
  options.decrypt = this._decrypt;

  // get # of bytes that won't fill a block
  options.overflow = this._input.length() % this.blockSize;

  if(!this._decrypt && this.mode.pad) {
    if(!this.mode.pad(this._input, options)) {
      return false;
    }
  }

  // do final update
  this._finish = true;
  this.update();

  if(this._decrypt && this.mode.unpad) {
    if(!this.mode.unpad(this.output, options)) {
      return false;
    }
  }

  if(this.mode.afterFinish) {
    if(!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }

  return true;
};


/***/ }),

/***/ "./node_modules/node-forge/lib/cipherModes.js":
/*!****************************************************!*\
  !*** ./node_modules/node-forge/lib/cipherModes.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Supported cipher modes.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

forge.cipher = forge.cipher || {};

// supported cipher modes
var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};

/** Electronic codebook (ECB) (Don't use this; it's not secure) **/

modes.ecb = function(options) {
  options = options || {};
  this.name = 'ECB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.ecb.prototype.start = function(options) {};

modes.ecb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};

modes.ecb.prototype.pad = function(input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
};

modes.ecb.prototype.unpad = function(output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow > 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count > (this.blockSize << 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
};

/** Cipher-block Chaining (CBC) **/

modes.cbc = function(options) {
  options = options || {};
  this.name = 'CBC';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};

modes.cbc.prototype.start = function(options) {
  // Note: legacy support for using IV residue (has security flaws)
  // if IV is null, reuse block from previous processing
  if(options.iv === null) {
    // must have a previous block
    if(!this._prev) {
      throw new Error('Invalid IV parameter.');
    }
    this._iv = this._prev.slice(0);
  } else if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  } else {
    // save IV as "previous" block
    this._iv = transformIV(options.iv);
    this._prev = this._iv.slice(0);
  }
};

modes.cbc.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  // CBC XOR's IV (or previous block) with plaintext
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // write output, save previous block
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
  this._prev = this._outBlock;
};

modes.cbc.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }

  // get next block
  for(var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }

  // decrypt block
  this.cipher.decrypt(this._inBlock, this._outBlock);

  // write output, save previous ciphered block
  // CBC XOR's IV (or previous block) with ciphertext
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }
  this._prev = this._inBlock.slice(0);
};

modes.cbc.prototype.pad = function(input, options) {
  // add PKCS#7 padding to block (each pad byte is the
  // value of the number of pad bytes)
  var padding = (input.length() === this.blockSize ?
    this.blockSize : (this.blockSize - input.length()));
  input.fillWithByte(padding, padding);
  return true;
};

modes.cbc.prototype.unpad = function(output, options) {
  // check for error: input data not a multiple of blockSize
  if(options.overflow > 0) {
    return false;
  }

  // ensure padding byte count is valid
  var len = output.length();
  var count = output.at(len - 1);
  if(count > (this.blockSize << 2)) {
    return false;
  }

  // trim off padding bytes
  output.truncate(count);
  return true;
};

/** Cipher feedback (CFB) **/

modes.cfb = function(options) {
  options = options || {};
  this.name = 'CFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.cfb.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.cfb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
    this._partialOutput.putInt32(this._partialBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.cfb.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output, write input as output
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output, write input as partial output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

/** Output feedback (OFB) **/

modes.ofb = function(options) {
  options = options || {};
  this.name = 'OFB';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ofb.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ofb.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(input.length() === 0) {
    return true;
  }

  // encrypt block (OFB always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output and update next input
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }

  // handle partial block
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if(partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }

  // XOR input with output
  this._partialOutput.clear();
  for(var i = 0; i < this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }

  if(partialBytes > 0) {
    // block still incomplete, restore input buffer
    input.read -= this.blockSize;
  } else {
    // block complete, update input block
    for(var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }

  // skip any previous partial bytes
  if(this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }

  if(partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes));
    this._partialBytes = partialBytes;
    return true;
  }

  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes));
  this._partialBytes = 0;
};

modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;

/** Counter (CTR) **/

modes.ctr = function(options) {
  options = options || {};
  this.name = 'CTR';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;
};

modes.ctr.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // use IV as first input
  this._iv = transformIV(options.iv);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};

modes.ctr.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block (CTR always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes > 0) {
      // block still incomplete, restore input buffer
      input.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // block complete, increment counter (input block)
  inc32(this._inBlock);
};

modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;

/** Galois/Counter Mode (GCM) **/

modes.gcm = function(options) {
  options = options || {};
  this.name = 'GCM';
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge.util.createBuffer();
  this._partialBytes = 0;

  // R is actually this value concatenated with 120 more zero bits, but
  // we only XOR against R so the other zeros have no effect -- we just
  // apply this value to the first integer in a block
  this._R = 0xE1000000;
};

modes.gcm.prototype.start = function(options) {
  if(!('iv' in options)) {
    throw new Error('Invalid IV parameter.');
  }
  // ensure IV is a byte buffer
  var iv = forge.util.createBuffer(options.iv);

  // no ciphered data processed yet
  this._cipherLength = 0;

  // default additional data is none
  var additionalData;
  if('additionalData' in options) {
    additionalData = forge.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge.util.createBuffer();
  }

  // default tag length is 128 bits
  if('tagLength' in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }

  // if tag is given, ensure tag matches tag length
  this._tag = null;
  if(options.decrypt) {
    // save tag to check later
    this._tag = forge.util.createBuffer(options.tag).getBytes();
    if(this._tag.length !== (this._tagLength / 8)) {
      throw new Error('Authentication tag does not match tag length.');
    }
  }

  // create tmp storage for hash calculation
  this._hashBlock = new Array(this._ints);

  // no tag generated yet
  this.tag = null;

  // generate hash subkey
  // (apply block cipher to "zero" block)
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);

  // generate table M
  // use 4-bit tables (32 component decomposition of a 16 byte value)
  // 8-bit tables take more space and are known to have security
  // vulnerabilities (in native implementations)
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);

  // Note: support IV length different from 96 bits? (only supporting
  // 96 bits is recommended by NIST SP-800-38D)
  // generate J_0
  var ivLength = iv.length();
  if(ivLength === 12) {
    // 96-bit IV
    this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
  } else {
    // IV is NOT 96-bits
    this._j0 = [0, 0, 0, 0];
    while(iv.length() > 0) {
      this._j0 = this.ghash(
        this._hashSubkey, this._j0,
        [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
    }
    this._j0 = this.ghash(
      this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
  }

  // generate ICB (initial counter block)
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;

  // consume authentication data
  additionalData = forge.util.createBuffer(additionalData);
  // save additional data length as a BE 64-bit number
  this._aDataLength = from64To32(additionalData.length() * 8);
  // pad additional data to 128 bit (16 byte) block size
  var overflow = additionalData.length() % this.blockSize;
  if(overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while(additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
};

modes.gcm.prototype.encrypt = function(input, output, finish) {
  // not enough input to encrypt
  var inputLength = input.length();
  if(inputLength === 0) {
    return true;
  }

  // encrypt block
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // handle full block
  if(this._partialBytes === 0 && inputLength >= this.blockSize) {
    // XOR input with output
    for(var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    // handle partial block
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if(partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }

    // XOR input with output
    this._partialOutput.clear();
    for(var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }

    if(partialBytes <= 0 || finish) {
      // handle overflow prior to hashing
      if(finish) {
        // get block overflow
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        // truncate for hash function
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }

      // get output block for hashing
      for(var i = 0; i < this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }

    // skip any previous partial bytes
    if(this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }

    if(partialBytes > 0 && !finish) {
      // block still incomplete, restore input buffer, get partial output,
      // and return early
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }

    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes));
    this._partialBytes = 0;
  }

  // update hash block S
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);
};

modes.gcm.prototype.decrypt = function(input, output, finish) {
  // not enough input to decrypt
  var inputLength = input.length();
  if(inputLength < this.blockSize && !(finish && inputLength > 0)) {
    return true;
  }

  // encrypt block (GCM always uses encryption mode)
  this.cipher.encrypt(this._inBlock, this._outBlock);

  // increment counter (input block)
  inc32(this._inBlock);

  // update hash block S
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);

  // XOR hash input with output
  for(var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  }

  // increment cipher data length
  if(inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};

modes.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;

  // handle overflow
  if(options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }

  // handle authentication tag
  this.tag = forge.util.createBuffer();

  // concatenate additional data length with cipher length
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));

  // include lengths in hash
  this._s = this.ghash(this._hashSubkey, this._s, lengths);

  // do GCTR(J_0, S)
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for(var i = 0; i < this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  }

  // trim tag to length
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));

  // check authentication tag
  if(options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }

  return rval;
};

/**
 * See NIST SP-800-38D 6.3 (Algorithm 1). This function performs Galois
 * field multiplication. The field, GF(2^128), is defined by the polynomial:
 *
 * x^128 + x^7 + x^2 + x + 1
 *
 * Which is represented in little-endian binary form as: 11100001 (0xe1). When
 * the value of a coefficient is 1, a bit is set. The value R, is the
 * concatenation of this value and 120 zero bits, yielding a 128-bit value
 * which matches the block size.
 *
 * This function will multiply two elements (vectors of bytes), X and Y, in
 * the field GF(2^128). The result is initialized to zero. For each bit of
 * X (out of 128), x_i, if x_i is set, then the result is multiplied (XOR'd)
 * by the current value of Y. For each bit, the value of Y will be raised by
 * a power of x (multiplied by the polynomial x). This can be achieved by
 * shifting Y once to the right. If the current value of Y, prior to being
 * multiplied by x, has 0 as its LSB, then it is a 127th degree polynomial.
 * Otherwise, we must divide by R after shifting to find the remainder.
 *
 * @param x the first block to multiply by the second.
 * @param y the second block to multiply by the first.
 *
 * @return the block result of the multiplication.
 */
modes.gcm.prototype.multiply = function(x, y) {
  var z_i = [0, 0, 0, 0];
  var v_i = y.slice(0);

  // calculate Z_128 (block has 128 bits)
  for(var i = 0; i < 128; ++i) {
    // if x_i is 0, Z_{i+1} = Z_i (unchanged)
    // else Z_{i+1} = Z_i ^ V_i
    // get x_i by finding 32-bit int position, then left shift 1 by remainder
    var x_i = x[(i / 32) | 0] & (1 << (31 - i % 32));
    if(x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }

    // if LSB(V_i) is 1, V_i = V_i >> 1
    // else V_i = (V_i >> 1) ^ R
    this.pow(v_i, v_i);
  }

  return z_i;
};

modes.gcm.prototype.pow = function(x, out) {
  // if LSB(x) is 1, x = x >>> 1
  // else x = (x >>> 1) ^ R
  var lsb = x[3] & 1;

  // always do x >>> 1:
  // starting with the rightmost integer, shift each integer to the right
  // one bit, pulling in the bit from the integer to the left as its top
  // most bit (do this for the last 3 integers)
  for(var i = 3; i > 0; --i) {
    out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31);
  }
  // shift the first integer normally
  out[0] = x[0] >>> 1;

  // if lsb was not set, then polynomial had a degree of 127 and doesn't
  // need to divided; otherwise, XOR with R to find the remainder; we only
  // need to XOR the first integer since R technically ends w/120 zero bits
  if(lsb) {
    out[0] ^= this._R;
  }
};

modes.gcm.prototype.tableMultiply = function(x) {
  // assumes 4-bit tables are used
  var z = [0, 0, 0, 0];
  for(var i = 0; i < 32; ++i) {
    var idx = (i / 8) | 0;
    var x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF;
    var ah = this._m[i][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }
  return z;
};

/**
 * A continuing version of the GHASH algorithm that operates on a single
 * block. The hash block, last hash value (Ym) and the new block to hash
 * are given.
 *
 * @param h the hash block.
 * @param y the previous value for Ym, use [0, 0, 0, 0] for a new hash.
 * @param x the block to hash.
 *
 * @return the hashed value (Ym).
 */
modes.gcm.prototype.ghash = function(h, y, x) {
  y[0] ^= x[0];
  y[1] ^= x[1];
  y[2] ^= x[2];
  y[3] ^= x[3];
  return this.tableMultiply(y);
  //return this.multiply(y, h);
};

/**
 * Precomputes a table for multiplying against the hash subkey. This
 * mechanism provides a substantial speed increase over multiplication
 * performed without a table. The table-based multiplication this table is
 * for solves X * H by multiplying each component of X by H and then
 * composing the results together using XOR.
 *
 * This function can be used to generate tables with different bit sizes
 * for the components, however, this implementation assumes there are
 * 32 components of X (which is a 16 byte vector), therefore each component
 * takes 4-bits (so the table is constructed with bits=4).
 *
 * @param h the hash subkey.
 * @param bits the bit size for a component.
 */
modes.gcm.prototype.generateHashTable = function(h, bits) {
  // TODO: There are further optimizations that would use only the
  // first table M_0 (or some variant) along with a remainder table;
  // this can be explored in the future
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m = new Array(size);
  for(var i = 0; i < size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = (i / perInt) | 0;
    var shft = ((perInt - 1 - (i % perInt)) * bits);
    tmp[idx] = (1 << (bits - 1)) << shft;
    m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
  }
  return m;
};

/**
 * Generates a table for multiplying against the hash subkey for one
 * particular component (out of all possible component values).
 *
 * @param mid the pre-multiplied value for the middle key of the table.
 * @param bits the bit size for a component.
 */
modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
  // compute the table quickly by minimizing the number of
  // POW operations -- they only need to be performed for powers of 2,
  // all other entries can be composed from those powers using XOR
  var size = 1 << bits;
  var half = size >>> 1;
  var m = new Array(size);
  m[half] = mid.slice(0);
  var i = half >>> 1;
  while(i > 0) {
    // raise m0[2 * i] and store in m0[i]
    this.pow(m[2 * i], m[i] = []);
    i >>= 1;
  }
  i = 2;
  while(i < half) {
    for(var j = 1; j < i; ++j) {
      var m_i = m[i];
      var m_j = m[j];
      m[i + j] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i *= 2;
  }
  m[0] = [0, 0, 0, 0];
  /* Note: We could avoid storing these by doing composition during multiply
  calculate top half using composition by speed is preferred. */
  for(i = half + 1; i < size; ++i) {
    var c = m[i ^ half];
    m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m;
};

/** Utility functions */

function transformIV(iv) {
  if(typeof iv === 'string') {
    // convert iv string into byte buffer
    iv = forge.util.createBuffer(iv);
  }

  if(forge.util.isArray(iv) && iv.length > 4) {
    // convert iv byte array into byte buffer
    var tmp = iv;
    iv = forge.util.createBuffer();
    for(var i = 0; i < tmp.length; ++i) {
      iv.putByte(tmp[i]);
    }
  }
  if(!forge.util.isArray(iv)) {
    // convert iv byte buffer into 32-bit integer array
    iv = [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()];
  }

  return iv;
}

function inc32(block) {
  // increment last 32 bits of block only
  block[block.length - 1] = (block[block.length - 1] + 1) & 0xFFFFFFFF;
}

function from64To32(num) {
  // convert 64-bit number to two BE Int32s
  return [(num / 0x100000000) | 0, num & 0xFFFFFFFF];
}


/***/ }),

/***/ "./node_modules/node-forge/lib/des.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/des.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * DES (Data Encryption Standard) implementation.
 *
 * This implementation supports DES as well as 3DES-EDE in ECB and CBC mode.
 * It is based on the BSD-licensed implementation by Paul Tero:
 *
 * Paul Tero, July 2001
 * http://www.tero.co.uk/des/
 *
 * Optimised for performance with large blocks by
 * Michael Hayworth, November 2001
 * http://www.netdealing.com
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2012-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./cipher */ "./node_modules/node-forge/lib/cipher.js");
__webpack_require__(/*! ./cipherModes */ "./node_modules/node-forge/lib/cipherModes.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

/* DES API */
module.exports = forge.des = forge.des || {};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 * cipher.start({iv: iv});
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */
forge.des.startEncrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: false,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var cipher = forge.cipher.createCipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to encrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.des.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: false,
    mode: mode
  });
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 * decipher.start({iv: iv});
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 * The output will be stored in the 'output' member of the returned cipher.
 *
 * The key and iv may be given as binary-encoded strings of bytes or
 * byte buffers.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 * @param mode the cipher mode to use (default: 'CBC' if IV is
 *          given, 'ECB' if null).
 *
 * @return the cipher.
 */
forge.des.startDecrypting = function(key, iv, output, mode) {
  var cipher = _createCipher({
    key: key,
    output: output,
    decrypt: true,
    mode: mode || (iv === null ? 'ECB' : 'CBC')
  });
  cipher.start(iv);
  return cipher;
};

/**
 * Deprecated. Instead, use:
 *
 * var decipher = forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates an DES cipher object to decrypt data using the given symmetric key.
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param key the symmetric key to use (64 or 192 bits).
 * @param mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
forge.des.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key: key,
    output: null,
    decrypt: true,
    mode: mode
  });
};

/**
 * Creates a new DES cipher algorithm object.
 *
 * @param name the name of the algorithm.
 * @param mode the mode factory function.
 *
 * @return the DES algorithm object.
 */
forge.des.Algorithm = function(name, mode) {
  var self = this;
  self.name = name;
  self.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self._keys, inBlock, outBlock, true);
      }
    }
  });
  self._init = false;
};

/**
 * Initializes this DES algorithm by expanding its key.
 *
 * @param options the options to use.
 *          key the key to use with this algorithm.
 *          decrypt true if the algorithm should be initialized for decryption,
 *            false for encryption.
 */
forge.des.Algorithm.prototype.initialize = function(options) {
  if(this._init) {
    return;
  }

  var key = forge.util.createBuffer(options.key);
  if(this.name.indexOf('3DES') === 0) {
    if(key.length() !== 24) {
      throw new Error('Invalid Triple-DES key size: ' + key.length() * 8);
    }
  }

  // do key expansion to 16 or 48 subkeys (single or triple DES)
  this._keys = _createKeys(key);
  this._init = true;
};

/** Register DES algorithms **/

registerAlgorithm('DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('DES-CTR', forge.cipher.modes.ctr);

registerAlgorithm('3DES-ECB', forge.cipher.modes.ecb);
registerAlgorithm('3DES-CBC', forge.cipher.modes.cbc);
registerAlgorithm('3DES-CFB', forge.cipher.modes.cfb);
registerAlgorithm('3DES-OFB', forge.cipher.modes.ofb);
registerAlgorithm('3DES-CTR', forge.cipher.modes.ctr);

function registerAlgorithm(name, mode) {
  var factory = function() {
    return new forge.des.Algorithm(name, mode);
  };
  forge.cipher.registerAlgorithm(name, factory);
}

/** DES implementation **/

var spfunction1 = [0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004];
var spfunction2 = [-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000];
var spfunction3 = [0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200];
var spfunction4 = [0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080];
var spfunction5 = [0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100];
var spfunction6 = [0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010];
var spfunction7 = [0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002];
var spfunction8 = [0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000];

/**
 * Create necessary sub keys.
 *
 * @param key the 64-bit or 192-bit key.
 *
 * @return the expanded keys.
 */
function _createKeys(key) {
  var pc2bytes0  = [0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204],
      pc2bytes1  = [0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101],
      pc2bytes2  = [0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808],
      pc2bytes3  = [0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000],
      pc2bytes4  = [0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010],
      pc2bytes5  = [0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420],
      pc2bytes6  = [0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002],
      pc2bytes7  = [0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800],
      pc2bytes8  = [0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002],
      pc2bytes9  = [0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408],
      pc2bytes10 = [0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020],
      pc2bytes11 = [0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200],
      pc2bytes12 = [0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010],
      pc2bytes13 = [0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105];

  // how many iterations (1 for des, 3 for triple des)
  // changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
  var iterations = key.length() > 8 ? 3 : 1;

  // stores the return keys
  var keys = [];

  // now define the left shifts which need to be done
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];

  var n = 0, tmp;
  for(var j = 0; j < iterations; j++) {
    var left = key.getInt32();
    var right = key.getInt32();

    tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
    right ^= tmp;
    left ^= (tmp << 4);

    tmp = ((right >>> -16) ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= (tmp << -16);

    tmp = ((left >>> 2) ^ right) & 0x33333333;
    right ^= tmp;
    left ^= (tmp << 2);

    tmp = ((right >>> -16) ^ left) & 0x0000ffff;
    left ^= tmp;
    right ^= (tmp << -16);

    tmp = ((left >>> 1) ^ right) & 0x55555555;
    right ^= tmp;
    left ^= (tmp << 1);

    tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
    left ^= tmp;
    right ^= (tmp << 8);

    tmp = ((left >>> 1) ^ right) & 0x55555555;
    right ^= tmp;
    left ^= (tmp << 1);

    // right needs to be shifted and OR'd with last four bits of left
    tmp = (left << 8) | ((right >>> 20) & 0x000000f0);

    // left needs to be put upside down
    left = ((right << 24) | ((right << 8) & 0xff0000) |
      ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0));
    right = tmp;

    // now go through and perform these shifts on the left and right keys
    for(var i = 0; i < shifts.length; ++i) {
      //shift the keys either one or two bits to the left
      if(shifts[i]) {
        left = (left << 2) | (left >>> 26);
        right = (right << 2) | (right >>> 26);
      } else {
        left = (left << 1) | (left >>> 27);
        right = (right << 1) | (right >>> 27);
      }
      left &= -0xf;
      right &= -0xf;

      // now apply PC-2, in such a way that E is easier when encrypting or
      // decrypting this conversion will look like PC-2 except only the last 6
      // bits of each byte are used rather than 48 consecutive bits and the
      // order of lines will be according to how the S selection functions will
      // be applied: S2, S4, S6, S8, S1, S3, S5, S7
      var lefttmp = (
        pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] |
        pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] |
        pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] |
        pc2bytes6[(left >>> 4) & 0xf]);
      var righttmp = (
        pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] |
        pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] |
        pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] |
        pc2bytes13[(right >>> 4) & 0xf]);
      tmp = ((righttmp >>> 16) ^ lefttmp) & 0x0000ffff;
      keys[n++] = lefttmp ^ tmp;
      keys[n++] = righttmp ^ (tmp << 16);
    }
  }

  return keys;
}

/**
 * Updates a single block (1 byte) using DES. The update will either
 * encrypt or decrypt the block.
 *
 * @param keys the expanded keys.
 * @param input the input block (an array of 32-bit words).
 * @param output the updated output block.
 * @param decrypt true to decrypt the block, false to encrypt it.
 */
function _updateBlock(keys, input, output, decrypt) {
  // set up loops for single or triple DES
  var iterations = keys.length === 32 ? 3 : 9;
  var looping;
  if(iterations === 3) {
    looping = decrypt ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = (decrypt ?
      [94, 62, -2, 32, 64, 2, 30, -2, -2] :
      [0, 32, 2, 62, 30, -2, 64, 96, 2]);
  }

  var tmp;

  var left = input[0];
  var right = input[1];

  // first each 64 bit chunk of the message must be permuted according to IP
  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= (tmp << 4);

  tmp = ((left >>> 16) ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= (tmp << 16);

  tmp = ((right >>> 2) ^ left) & 0x33333333;
  left ^= tmp;
  right ^= (tmp << 2);

  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= (tmp << 8);

  tmp = ((left >>> 1) ^ right) & 0x55555555;
  right ^= tmp;
  left ^= (tmp << 1);

  // rotate left 1 bit
  left = ((left << 1) | (left >>> 31));
  right = ((right << 1) | (right >>> 31));

  for(var j = 0; j < iterations; j += 3) {
    var endloop = looping[j + 1];
    var loopinc = looping[j + 2];

    // now go through and perform the encryption or decryption
    for(var i = looping[j]; i != endloop; i += loopinc) {
      var right1 = right ^ keys[i];
      var right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];

      // passing these bytes through the S selection functions
      tmp = left;
      left = right;
      right = tmp ^ (
        spfunction2[(right1 >>> 24) & 0x3f] |
        spfunction4[(right1 >>> 16) & 0x3f] |
        spfunction6[(right1 >>>  8) & 0x3f] |
        spfunction8[right1 & 0x3f] |
        spfunction1[(right2 >>> 24) & 0x3f] |
        spfunction3[(right2 >>> 16) & 0x3f] |
        spfunction5[(right2 >>>  8) & 0x3f] |
        spfunction7[right2 & 0x3f]);
    }
    // unreverse left and right
    tmp = left;
    left = right;
    right = tmp;
  }

  // rotate right 1 bit
  left = ((left >>> 1) | (left << 31));
  right = ((right >>> 1) | (right << 31));

  // now perform IP-1, which is IP in the opposite direction
  tmp = ((left >>> 1) ^ right) & 0x55555555;
  right ^= tmp;
  left ^= (tmp << 1);

  tmp = ((right >>> 8) ^ left) & 0x00ff00ff;
  left ^= tmp;
  right ^= (tmp << 8);

  tmp = ((right >>> 2) ^ left) & 0x33333333;
  left ^= tmp;
  right ^= (tmp << 2);

  tmp = ((left >>> 16) ^ right) & 0x0000ffff;
  right ^= tmp;
  left ^= (tmp << 16);

  tmp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
  right ^= tmp;
  left ^= (tmp << 4);

  output[0] = left;
  output[1] = right;
}

/**
 * Deprecated. Instead, use:
 *
 * forge.cipher.createCipher('DES-<mode>', key);
 * forge.cipher.createDecipher('DES-<mode>', key);
 *
 * Creates a deprecated DES cipher object. This object's mode will default to
 * CBC (cipher-block-chaining).
 *
 * The key may be given as a binary-encoded string of bytes or a byte buffer.
 *
 * @param options the options to use.
 *          key the symmetric key to use (64 or 192 bits).
 *          output the buffer to write to.
 *          decrypt true for decryption, false for encryption.
 *          mode the cipher mode to use (default: 'CBC').
 *
 * @return the cipher.
 */
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || 'CBC').toUpperCase();
  var algorithm = 'DES-' + mode;

  var cipher;
  if(options.decrypt) {
    cipher = forge.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge.cipher.createCipher(algorithm, options.key);
  }

  // backwards compatible start API
  var start = cipher.start;
  cipher.start = function(iv, options) {
    // backwards compatibility: support second arg as output buffer
    var output = null;
    if(options instanceof forge.util.ByteBuffer) {
      output = options;
      options = {};
    }
    options = options || {};
    options.output = output;
    options.iv = iv;
    start.call(cipher, options);
  };

  return cipher;
}


/***/ }),

/***/ "./node_modules/node-forge/lib/forge.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/forge.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Node.js module for Forge.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2016 Digital Bazaar, Inc.
 */
module.exports = {
  // default options
  options: {
    usePureJavaScript: false
  }
};


/***/ }),

/***/ "./node_modules/node-forge/lib/hmac.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/hmac.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Hash-based Message Authentication Code implementation. Requires a message
 * digest object that can be obtained, for example, from forge.md.sha1 or
 * forge.md.md5.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2012 Digital Bazaar, Inc. All rights reserved.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

/* HMAC API */
var hmac = module.exports = forge.hmac = forge.hmac || {};

/**
 * Creates an HMAC object that uses the given message digest object.
 *
 * @return an HMAC object.
 */
hmac.create = function() {
  // the hmac key to use
  var _key = null;

  // the message digest to use
  var _md = null;

  // the inner padding
  var _ipadding = null;

  // the outer padding
  var _opadding = null;

  // hmac context
  var ctx = {};

  /**
   * Starts or restarts the HMAC with the given key and message digest.
   *
   * @param md the message digest to use, null to reuse the previous one,
   *           a string to use builtin 'sha1', 'md5', 'sha256'.
   * @param key the key to use as a string, array of bytes, byte buffer,
   *           or null to reuse the previous key.
   */
  ctx.start = function(md, key) {
    if(md !== null) {
      if(typeof md === 'string') {
        // create builtin message digest
        md = md.toLowerCase();
        if(md in forge.md.algorithms) {
          _md = forge.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        // store message digest
        _md = md;
      }
    }

    if(key === null) {
      // reuse previous key
      key = _key;
    } else {
      if(typeof key === 'string') {
        // convert string into byte buffer
        key = forge.util.createBuffer(key);
      } else if(forge.util.isArray(key)) {
        // convert byte array into byte buffer
        var tmp = key;
        key = forge.util.createBuffer();
        for(var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }

      // if key is longer than blocksize, hash it
      var keylen = key.length();
      if(keylen > _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }

      // mix key into inner and outer padding
      // ipadding = [0x36 * blocksize] ^ key
      // opadding = [0x5C * blocksize] ^ key
      _ipadding = forge.util.createBuffer();
      _opadding = forge.util.createBuffer();
      keylen = key.length();
      for(var i = 0; i < keylen; ++i) {
        var tmp = key.at(i);
        _ipadding.putByte(0x36 ^ tmp);
        _opadding.putByte(0x5C ^ tmp);
      }

      // if key is shorter than blocksize, add additional padding
      if(keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for(var i = 0; i < tmp; ++i) {
          _ipadding.putByte(0x36);
          _opadding.putByte(0x5C);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }

    // digest is done like so: hash(opadding | hash(ipadding | message))

    // prepare to do inner hash
    // hash(ipadding | message)
    _md.start();
    _md.update(_ipadding);
  };

  /**
   * Updates the HMAC with the given message bytes.
   *
   * @param bytes the bytes to update with.
   */
  ctx.update = function(bytes) {
    _md.update(bytes);
  };

  /**
   * Produces the Message Authentication Code (MAC).
   *
   * @return a byte buffer containing the digest value.
   */
  ctx.getMac = function() {
    // digest is done like so: hash(opadding | hash(ipadding | message))
    // here we do the outer hashing
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  // alias for getMac
  ctx.digest = ctx.getMac;

  return ctx;
};


/***/ }),

/***/ "./node_modules/node-forge/lib/jsbn.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/jsbn.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2005  Tom Wu
// All Rights Reserved.
// See "LICENSE" for details.

// Basic JavaScript BN library - subset useful for RSA encryption.

/*
Licensing (LICENSE)
-------------------

This software is covered under the following copyright:
*/
/*
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */
/*
Address all questions regarding this license to:

  Tom Wu
  tjw@cs.Stanford.EDU
*/
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");

module.exports = forge.jsbn = forge.jsbn || {};

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary&0xffffff)==0xefcafe);

// (public) Constructor
function BigInteger(a,b,c) {
  this.data = [];
  if(a != null)
    if("number" == typeof a) this.fromNumber(a,b,c);
    else if(b == null && "string" != typeof a) this.fromString(a,256);
    else this.fromString(a,b);
}
forge.jsbn.BigInteger = BigInteger;

// return new, unset BigInteger
function nbi() { return new BigInteger(null); }

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i,x,w,j,c,n) {
  while(--n >= 0) {
    var v = x*this.data[i++]+w.data[j]+c;
    c = Math.floor(v/0x4000000);
    w.data[j++] = v&0x3ffffff;
  }
  return c;
}
// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i,x,w,j,c,n) {
  var xl = x&0x7fff, xh = x>>15;
  while(--n >= 0) {
    var l = this.data[i]&0x7fff;
    var h = this.data[i++]>>15;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x7fff)<<15)+w.data[j]+(c&0x3fffffff);
    c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
    w.data[j++] = l&0x3fffffff;
  }
  return c;
}
// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i,x,w,j,c,n) {
  var xl = x&0x3fff, xh = x>>14;
  while(--n >= 0) {
    var l = this.data[i]&0x3fff;
    var h = this.data[i++]>>14;
    var m = xh*l+h*xl;
    l = xl*l+((m&0x3fff)<<14)+w.data[j]+c;
    c = (l>>28)+(m>>14)+xh*h;
    w.data[j++] = l&0xfffffff;
  }
  return c;
}

// node.js (no browser)
if(typeof(navigator) === 'undefined')
{
   BigInteger.prototype.am = am3;
   dbits = 28;
} else if(j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if(j_lm && (navigator.appName != "Netscape")) {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else { // Mozilla/Netscape seems to prefer am3
  BigInteger.prototype.am = am3;
  dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1<<dbits)-1);
BigInteger.prototype.DV = (1<<dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2,BI_FP);
BigInteger.prototype.F1 = BI_FP-dbits;
BigInteger.prototype.F2 = 2*dbits-BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr,vv;
rr = "0".charCodeAt(0);
for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

function int2char(n) { return BI_RM.charAt(n); }
function intAt(s,i) {
  var c = BI_RC[s.charCodeAt(i)];
  return (c==null)?-1:c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
  for(var i = this.t-1; i >= 0; --i) r.data[i] = this.data[i];
  r.t = this.t;
  r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
  this.t = 1;
  this.s = (x<0)?-1:0;
  if(x > 0) this.data[0] = x;
  else if(x < -1) this.data[0] = x+this.DV;
  else this.t = 0;
}

// return bigint initialized to value
function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

// (protected) set from string and radix
function bnpFromString(s,b) {
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 256) k = 8; // byte array
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else { this.fromRadix(s,b); return; }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while(--i >= 0) {
    var x = (k==8)?s[i]&0xff:intAt(s,i);
    if(x < 0) {
      if(s.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if(sh == 0)
      this.data[this.t++] = x;
    else if(sh+k > this.DB) {
      this.data[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
      this.data[this.t++] = (x>>(this.DB-sh));
    } else
      this.data[this.t-1] |= x<<sh;
    sh += k;
    if(sh >= this.DB) sh -= this.DB;
  }
  if(k == 8 && (s[0]&0x80) != 0) {
    this.s = -1;
    if(sh > 0) this.data[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
  }
  this.clamp();
  if(mi) BigInteger.ZERO.subTo(this,this);
}

// (protected) clamp off excess high words
function bnpClamp() {
  var c = this.s&this.DM;
  while(this.t > 0 && this.data[this.t-1] == c) --this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
  if(this.s < 0) return "-"+this.negate().toString(b);
  var k;
  if(b == 16) k = 4;
  else if(b == 8) k = 3;
  else if(b == 2) k = 1;
  else if(b == 32) k = 5;
  else if(b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1<<k)-1, d, m = false, r = "", i = this.t;
  var p = this.DB-(i*this.DB)%k;
  if(i-- > 0) {
    if(p < this.DB && (d = this.data[i]>>p) > 0) { m = true; r = int2char(d); }
    while(i >= 0) {
      if(p < k) {
        d = (this.data[i]&((1<<p)-1))<<(k-p);
        d |= this.data[--i]>>(p+=this.DB-k);
      } else {
        d = (this.data[i]>>(p-=k))&km;
        if(p <= 0) { p += this.DB; --i; }
      }
      if(d > 0) m = true;
      if(m) r += int2char(d);
    }
  }
  return m?r:"0";
}

// (public) -this
function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

// (public) |this|
function bnAbs() { return (this.s<0)?this.negate():this; }

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
  var r = this.s-a.s;
  if(r != 0) return r;
  var i = this.t;
  r = i-a.t;
  if(r != 0) return (this.s<0)?-r:r;
  while(--i >= 0) if((r=this.data[i]-a.data[i]) != 0) return r;
  return 0;
}

// returns bit length of the integer x
function nbits(x) {
  var r = 1, t;
  if((t=x>>>16) != 0) { x = t; r += 16; }
  if((t=x>>8) != 0) { x = t; r += 8; }
  if((t=x>>4) != 0) { x = t; r += 4; }
  if((t=x>>2) != 0) { x = t; r += 2; }
  if((t=x>>1) != 0) { x = t; r += 1; }
  return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
  if(this.t <= 0) return 0;
  return this.DB*(this.t-1)+nbits(this.data[this.t-1]^(this.s&this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n,r) {
  var i;
  for(i = this.t-1; i >= 0; --i) r.data[i+n] = this.data[i];
  for(i = n-1; i >= 0; --i) r.data[i] = 0;
  r.t = this.t+n;
  r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n,r) {
  for(var i = n; i < this.t; ++i) r.data[i-n] = this.data[i];
  r.t = Math.max(this.t-n,0);
  r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n,r) {
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<cbs)-1;
  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
  for(i = this.t-1; i >= 0; --i) {
    r.data[i+ds+1] = (this.data[i]>>cbs)|c;
    c = (this.data[i]&bm)<<bs;
  }
  for(i = ds-1; i >= 0; --i) r.data[i] = 0;
  r.data[ds] = c;
  r.t = this.t+ds+1;
  r.s = this.s;
  r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n,r) {
  r.s = this.s;
  var ds = Math.floor(n/this.DB);
  if(ds >= this.t) { r.t = 0; return; }
  var bs = n%this.DB;
  var cbs = this.DB-bs;
  var bm = (1<<bs)-1;
  r.data[0] = this.data[ds]>>bs;
  for(var i = ds+1; i < this.t; ++i) {
    r.data[i-ds-1] |= (this.data[i]&bm)<<cbs;
    r.data[i-ds] = this.data[i]>>bs;
  }
  if(bs > 0) r.data[this.t-ds-1] |= (this.s&bm)<<cbs;
  r.t = this.t-ds;
  r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a,r) {
  var i = 0, c = 0, m = Math.min(a.t,this.t);
  while(i < m) {
    c += this.data[i]-a.data[i];
    r.data[i++] = c&this.DM;
    c >>= this.DB;
  }
  if(a.t < this.t) {
    c -= a.s;
    while(i < this.t) {
      c += this.data[i];
      r.data[i++] = c&this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while(i < a.t) {
      c -= a.data[i];
      r.data[i++] = c&this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = (c<0)?-1:0;
  if(c < -1) r.data[i++] = this.DV+c;
  else if(c > 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a,r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i+y.t;
  while(--i >= 0) r.data[i] = 0;
  for(i = 0; i < y.t; ++i) r.data[i+x.t] = x.am(0,y.data[i],r,i,0,x.t);
  r.s = 0;
  r.clamp();
  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2*x.t;
  while(--i >= 0) r.data[i] = 0;
  for(i = 0; i < x.t-1; ++i) {
    var c = x.am(i,x.data[i],r,2*i,0,1);
    if((r.data[i+x.t]+=x.am(i+1,2*x.data[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
      r.data[i+x.t] -= x.DV;
      r.data[i+x.t+1] = 1;
    }
  }
  if(r.t > 0) r.data[r.t-1] += x.am(i,x.data[i],r,2*i,0,1);
  r.s = 0;
  r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m,q,r) {
  var pm = m.abs();
  if(pm.t <= 0) return;
  var pt = this.abs();
  if(pt.t < pm.t) {
    if(q != null) q.fromInt(0);
    if(r != null) this.copyTo(r);
    return;
  }
  if(r == null) r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB-nbits(pm.data[pm.t-1]);	// normalize modulus
  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); }
  var ys = y.t;
  var y0 = y.data[ys-1];
  if(y0 == 0) return;
  var yt = y0*(1<<this.F1)+((ys>1)?y.data[ys-2]>>this.F2:0);
  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
  var i = r.t, j = i-ys, t = (q==null)?nbi():q;
  y.dlShiftTo(j,t);
  if(r.compareTo(t) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t,r);
  }
  BigInteger.ONE.dlShiftTo(ys,t);
  t.subTo(y,y);	// "negative" y so we can replace sub with am later
  while(y.t < ys) y.data[y.t++] = 0;
  while(--j >= 0) {
    // Estimate quotient digit
    var qd = (r.data[--i]==y0)?this.DM:Math.floor(r.data[i]*d1+(r.data[i-1]+e)*d2);
    if((r.data[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
      y.dlShiftTo(j,t);
      r.subTo(t,r);
      while(r.data[i] < --qd) r.subTo(t,r);
    }
  }
  if(q != null) {
    r.drShiftTo(ys,q);
    if(ts != ms) BigInteger.ZERO.subTo(q,q);
  }
  r.t = ys;
  r.clamp();
  if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
  if(ts < 0) BigInteger.ZERO.subTo(r,r);
}

// (public) this mod a
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a,null,r);
  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
  return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) { this.m = m; }
function cConvert(x) {
  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) { return x; }
function cReduce(x) { x.divRemTo(this.m,null,x); }
function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
  if(this.t < 1) return 0;
  var x = this.data[0];
  if((x&1) == 0) return 0;
  var y = x&3;		// y == 1/x mod 2^2
  y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
  y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
  // last step - calculate inverse mod DV directly;
  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
  y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
  // we really want the negative inverse, and -DV < y < DV
  return (y>0)?this.DV-y:-y;
}

// Montgomery reduction
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp&0x7fff;
  this.mph = this.mp>>15;
  this.um = (1<<(m.DB-15))-1;
  this.mt2 = 2*m.t;
}

// xR mod m
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t,r);
  r.divRemTo(this.m,null,r);
  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
  return r;
}

// x/R mod m
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
  while(x.t <= this.mt2)	// pad x so am has enough room later
    x.data[x.t++] = 0;
  for(var i = 0; i < this.m.t; ++i) {
    // faster way of calculating u0 = x.data[i]*mp mod DV
    var j = x.data[i]&0x7fff;
    var u0 = (j*this.mpl+(((j*this.mph+(x.data[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
    // use am to combine the multiply-shift-add into one call
    j = i+this.m.t;
    x.data[j] += this.m.am(0,u0,x,i,0,this.m.t);
    // propagate carry
    while(x.data[j] >= x.DV) { x.data[j] -= x.DV; x.data[++j]++; }
  }
  x.clamp();
  x.drShiftTo(this.m.t,x);
  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

// r = "xy/R mod m"; x,y != r
function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() { return ((this.t>0)?(this.data[0]&1):this.s) == 0; }

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e,z) {
  if(e > 0xffffffff || e < 1) return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
  g.copyTo(r);
  while(--i >= 0) {
    z.sqrTo(r,r2);
    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
    else { var t = r; r = r2; r2 = t; }
  }
  return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e,m) {
  var z;
  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
  return this.exp(e,z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// jsbn2 lib

//Copyright (c) 2005-2009  Tom Wu
//All Rights Reserved.
//See "LICENSE" for details (See jsbn.js for LICENSE).

//Extended JavaScript BN functions, required for RSA private ops.

//Version 1.1: new BigInteger("0", 10) returns "proper" zero

//(public)
function bnClone() { var r = nbi(); this.copyTo(r); return r; }

//(public) return value as integer
function bnIntValue() {
if(this.s < 0) {
 if(this.t == 1) return this.data[0]-this.DV;
 else if(this.t == 0) return -1;
} else if(this.t == 1) return this.data[0];
else if(this.t == 0) return 0;
// assumes 16 < DB < 32
return ((this.data[1]&((1<<(32-this.DB))-1))<<this.DB)|this.data[0];
}

//(public) return value as byte
function bnByteValue() { return (this.t==0)?this.s:(this.data[0]<<24)>>24; }

//(public) return value as short (assumes DB>=16)
function bnShortValue() { return (this.t==0)?this.s:(this.data[0]<<16)>>16; }

//(protected) return x s.t. r^x < DV
function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

//(public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
if(this.s < 0) return -1;
else if(this.t <= 0 || (this.t == 1 && this.data[0] <= 0)) return 0;
else return 1;
}

//(protected) convert to radix string
function bnpToRadix(b) {
if(b == null) b = 10;
if(this.signum() == 0 || b < 2 || b > 36) return "0";
var cs = this.chunkSize(b);
var a = Math.pow(b,cs);
var d = nbv(a), y = nbi(), z = nbi(), r = "";
this.divRemTo(d,y,z);
while(y.signum() > 0) {
 r = (a+z.intValue()).toString(b).substr(1) + r;
 y.divRemTo(d,y,z);
}
return z.intValue().toString(b) + r;
}

//(protected) convert from radix string
function bnpFromRadix(s,b) {
this.fromInt(0);
if(b == null) b = 10;
var cs = this.chunkSize(b);
var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
for(var i = 0; i < s.length; ++i) {
 var x = intAt(s,i);
 if(x < 0) {
   if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
   continue;
 }
 w = b*w+x;
 if(++j >= cs) {
   this.dMultiply(d);
   this.dAddOffset(w,0);
   j = 0;
   w = 0;
 }
}
if(j > 0) {
 this.dMultiply(Math.pow(b,j));
 this.dAddOffset(w,0);
}
if(mi) BigInteger.ZERO.subTo(this,this);
}

//(protected) alternate constructor
function bnpFromNumber(a,b,c) {
if("number" == typeof b) {
 // new BigInteger(int,int,RNG)
 if(a < 2) this.fromInt(1);
 else {
   this.fromNumber(a,c);
   if(!this.testBit(a-1))  // force MSB set
     this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
   if(this.isEven()) this.dAddOffset(1,0); // force odd
   while(!this.isProbablePrime(b)) {
     this.dAddOffset(2,0);
     if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
   }
 }
} else {
 // new BigInteger(int,RNG)
 var x = new Array(), t = a&7;
 x.length = (a>>3)+1;
 b.nextBytes(x);
 if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
 this.fromString(x,256);
}
}

//(public) convert to bigendian byte array
function bnToByteArray() {
var i = this.t, r = new Array();
r[0] = this.s;
var p = this.DB-(i*this.DB)%8, d, k = 0;
if(i-- > 0) {
 if(p < this.DB && (d = this.data[i]>>p) != (this.s&this.DM)>>p)
   r[k++] = d|(this.s<<(this.DB-p));
 while(i >= 0) {
   if(p < 8) {
     d = (this.data[i]&((1<<p)-1))<<(8-p);
     d |= this.data[--i]>>(p+=this.DB-8);
   } else {
     d = (this.data[i]>>(p-=8))&0xff;
     if(p <= 0) { p += this.DB; --i; }
   }
   if((d&0x80) != 0) d |= -256;
   if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
   if(k > 0 || d != this.s) r[k++] = d;
 }
}
return r;
}

function bnEquals(a) { return(this.compareTo(a)==0); }
function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

//(protected) r = this op a (bitwise)
function bnpBitwiseTo(a,op,r) {
var i, f, m = Math.min(a.t,this.t);
for(i = 0; i < m; ++i) r.data[i] = op(this.data[i],a.data[i]);
if(a.t < this.t) {
 f = a.s&this.DM;
 for(i = m; i < this.t; ++i) r.data[i] = op(this.data[i],f);
 r.t = this.t;
} else {
 f = this.s&this.DM;
 for(i = m; i < a.t; ++i) r.data[i] = op(f,a.data[i]);
 r.t = a.t;
}
r.s = op(this.s,a.s);
r.clamp();
}

//(public) this & a
function op_and(x,y) { return x&y; }
function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

//(public) this | a
function op_or(x,y) { return x|y; }
function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

//(public) this ^ a
function op_xor(x,y) { return x^y; }
function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

//(public) this & ~a
function op_andnot(x,y) { return x&~y; }
function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

//(public) ~this
function bnNot() {
var r = nbi();
for(var i = 0; i < this.t; ++i) r.data[i] = this.DM&~this.data[i];
r.t = this.t;
r.s = ~this.s;
return r;
}

//(public) this << n
function bnShiftLeft(n) {
var r = nbi();
if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
return r;
}

//(public) this >> n
function bnShiftRight(n) {
var r = nbi();
if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
return r;
}

//return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
if(x == 0) return -1;
var r = 0;
if((x&0xffff) == 0) { x >>= 16; r += 16; }
if((x&0xff) == 0) { x >>= 8; r += 8; }
if((x&0xf) == 0) { x >>= 4; r += 4; }
if((x&3) == 0) { x >>= 2; r += 2; }
if((x&1) == 0) ++r;
return r;
}

//(public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
for(var i = 0; i < this.t; ++i)
 if(this.data[i] != 0) return i*this.DB+lbit(this.data[i]);
if(this.s < 0) return this.t*this.DB;
return -1;
}

//return number of 1 bits in x
function cbit(x) {
var r = 0;
while(x != 0) { x &= x-1; ++r; }
return r;
}

//(public) return number of set bits
function bnBitCount() {
var r = 0, x = this.s&this.DM;
for(var i = 0; i < this.t; ++i) r += cbit(this.data[i]^x);
return r;
}

//(public) true iff nth bit is set
function bnTestBit(n) {
var j = Math.floor(n/this.DB);
if(j >= this.t) return(this.s!=0);
return((this.data[j]&(1<<(n%this.DB)))!=0);
}

//(protected) this op (1<<n)
function bnpChangeBit(n,op) {
var r = BigInteger.ONE.shiftLeft(n);
this.bitwiseTo(r,op,r);
return r;
}

//(public) this | (1<<n)
function bnSetBit(n) { return this.changeBit(n,op_or); }

//(public) this & ~(1<<n)
function bnClearBit(n) { return this.changeBit(n,op_andnot); }

//(public) this ^ (1<<n)
function bnFlipBit(n) { return this.changeBit(n,op_xor); }

//(protected) r = this + a
function bnpAddTo(a,r) {
var i = 0, c = 0, m = Math.min(a.t,this.t);
while(i < m) {
 c += this.data[i]+a.data[i];
 r.data[i++] = c&this.DM;
 c >>= this.DB;
}
if(a.t < this.t) {
 c += a.s;
 while(i < this.t) {
   c += this.data[i];
   r.data[i++] = c&this.DM;
   c >>= this.DB;
 }
 c += this.s;
} else {
 c += this.s;
 while(i < a.t) {
   c += a.data[i];
   r.data[i++] = c&this.DM;
   c >>= this.DB;
 }
 c += a.s;
}
r.s = (c<0)?-1:0;
if(c > 0) r.data[i++] = c;
else if(c < -1) r.data[i++] = this.DV+c;
r.t = i;
r.clamp();
}

//(public) this + a
function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

//(public) this - a
function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

//(public) this * a
function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

//(public) this / a
function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

//(public) this % a
function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

//(public) [this/a,this%a]
function bnDivideAndRemainder(a) {
var q = nbi(), r = nbi();
this.divRemTo(a,q,r);
return new Array(q,r);
}

//(protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
this.data[this.t] = this.am(0,n-1,this,0,0,this.t);
++this.t;
this.clamp();
}

//(protected) this += n << w words, this >= 0
function bnpDAddOffset(n,w) {
if(n == 0) return;
while(this.t <= w) this.data[this.t++] = 0;
this.data[w] += n;
while(this.data[w] >= this.DV) {
 this.data[w] -= this.DV;
 if(++w >= this.t) this.data[this.t++] = 0;
 ++this.data[w];
}
}

//A "null" reducer
function NullExp() {}
function nNop(x) { return x; }
function nMulTo(x,y,r) { x.multiplyTo(y,r); }
function nSqrTo(x,r) { x.squareTo(r); }

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

//(public) this^e
function bnPow(e) { return this.exp(e,new NullExp()); }

//(protected) r = lower n words of "this * a", a.t <= n
//"this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a,n,r) {
var i = Math.min(this.t+a.t,n);
r.s = 0; // assumes a,this >= 0
r.t = i;
while(i > 0) r.data[--i] = 0;
var j;
for(j = r.t-this.t; i < j; ++i) r.data[i+this.t] = this.am(0,a.data[i],r,i,0,this.t);
for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a.data[i],r,i,0,n-i);
r.clamp();
}

//(protected) r = "this * a" without lower n words, n > 0
//"this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a,n,r) {
--n;
var i = r.t = this.t+a.t-n;
r.s = 0; // assumes a,this >= 0
while(--i >= 0) r.data[i] = 0;
for(i = Math.max(n-this.t,0); i < a.t; ++i)
 r.data[this.t+i-n] = this.am(n-i,a.data[i],r,0,0,this.t+i-n);
r.clamp();
r.drShiftTo(1,r);
}

//Barrett modular reduction
function Barrett(m) {
// setup Barrett
this.r2 = nbi();
this.q3 = nbi();
BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
this.mu = this.r2.divide(m);
this.m = m;
}

function barrettConvert(x) {
if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
else if(x.compareTo(this.m) < 0) return x;
else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
}

function barrettRevert(x) { return x; }

//x = x mod m (HAC 14.42)
function barrettReduce(x) {
x.drShiftTo(this.m.t-1,this.r2);
if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
x.subTo(this.r2,x);
while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
}

//r = x^2 mod m; x != r
function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

//r = x*y mod m; x,y != r
function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

//(public) this^e % m (HAC 14.85)
function bnModPow(e,m) {
var i = e.bitLength(), k, r = nbv(1), z;
if(i <= 0) return r;
else if(i < 18) k = 1;
else if(i < 48) k = 3;
else if(i < 144) k = 4;
else if(i < 768) k = 5;
else k = 6;
if(i < 8)
 z = new Classic(m);
else if(m.isEven())
 z = new Barrett(m);
else
 z = new Montgomery(m);

// precomputation
var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
g[1] = z.convert(this);
if(k > 1) {
 var g2 = nbi();
 z.sqrTo(g[1],g2);
 while(n <= km) {
   g[n] = nbi();
   z.mulTo(g2,g[n-2],g[n]);
   n += 2;
 }
}

var j = e.t-1, w, is1 = true, r2 = nbi(), t;
i = nbits(e.data[j])-1;
while(j >= 0) {
 if(i >= k1) w = (e.data[j]>>(i-k1))&km;
 else {
   w = (e.data[j]&((1<<(i+1))-1))<<(k1-i);
   if(j > 0) w |= e.data[j-1]>>(this.DB+i-k1);
 }

 n = k;
 while((w&1) == 0) { w >>= 1; --n; }
 if((i -= n) < 0) { i += this.DB; --j; }
 if(is1) {  // ret == 1, don't bother squaring or multiplying it
   g[w].copyTo(r);
   is1 = false;
 } else {
   while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
   if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
   z.mulTo(r2,g[w],r);
 }

 while(j >= 0 && (e.data[j]&(1<<i)) == 0) {
   z.sqrTo(r,r2); t = r; r = r2; r2 = t;
   if(--i < 0) { i = this.DB-1; --j; }
 }
}
return z.revert(r);
}

//(public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
var x = (this.s<0)?this.negate():this.clone();
var y = (a.s<0)?a.negate():a.clone();
if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
var i = x.getLowestSetBit(), g = y.getLowestSetBit();
if(g < 0) return x;
if(i < g) g = i;
if(g > 0) {
 x.rShiftTo(g,x);
 y.rShiftTo(g,y);
}
while(x.signum() > 0) {
 if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
 if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
 if(x.compareTo(y) >= 0) {
   x.subTo(y,x);
   x.rShiftTo(1,x);
 } else {
   y.subTo(x,y);
   y.rShiftTo(1,y);
 }
}
if(g > 0) y.lShiftTo(g,y);
return y;
}

//(protected) this % n, n < 2^26
function bnpModInt(n) {
if(n <= 0) return 0;
var d = this.DV%n, r = (this.s<0)?n-1:0;
if(this.t > 0)
 if(d == 0) r = this.data[0]%n;
 else for(var i = this.t-1; i >= 0; --i) r = (d*r+this.data[i])%n;
return r;
}

//(public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
var ac = m.isEven();
if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
var u = m.clone(), v = this.clone();
var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
while(u.signum() != 0) {
 while(u.isEven()) {
   u.rShiftTo(1,u);
   if(ac) {
     if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
     a.rShiftTo(1,a);
   } else if(!b.isEven()) b.subTo(m,b);
   b.rShiftTo(1,b);
 }
 while(v.isEven()) {
   v.rShiftTo(1,v);
   if(ac) {
     if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
     c.rShiftTo(1,c);
   } else if(!d.isEven()) d.subTo(m,d);
   d.rShiftTo(1,d);
 }
 if(u.compareTo(v) >= 0) {
   u.subTo(v,u);
   if(ac) a.subTo(c,a);
   b.subTo(d,b);
 } else {
   v.subTo(u,v);
   if(ac) c.subTo(a,c);
   d.subTo(b,d);
 }
}
if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
if(d.compareTo(m) >= 0) return d.subtract(m);
if(d.signum() < 0) d.addTo(m,d); else return d;
if(d.signum() < 0) return d.add(m); else return d;
}

var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509];
var lplim = (1<<26)/lowprimes[lowprimes.length-1];

//(public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
var i, x = this.abs();
if(x.t == 1 && x.data[0] <= lowprimes[lowprimes.length-1]) {
 for(i = 0; i < lowprimes.length; ++i)
   if(x.data[0] == lowprimes[i]) return true;
 return false;
}
if(x.isEven()) return false;
i = 1;
while(i < lowprimes.length) {
 var m = lowprimes[i], j = i+1;
 while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
 m = x.modInt(m);
 while(i < j) if(m%lowprimes[i++] == 0) return false;
}
return x.millerRabin(t);
}

//(protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if(k <= 0) return false;
var r = n1.shiftRight(k);
var prng = bnGetPrng();
var a;
for(var i = 0; i < t; ++i) {
 // select witness 'a' at random from between 1 and n1
 do {
   a = new BigInteger(this.bitLength(), prng);
 }
 while(a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
 var y = a.modPow(r,this);
 if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
   var j = 1;
   while(j++ < k && y.compareTo(n1) != 0) {
     y = y.modPowInt(2,this);
     if(y.compareTo(BigInteger.ONE) == 0) return false;
   }
   if(y.compareTo(n1) != 0) return false;
 }
}
return true;
}

// get pseudo random number generator
function bnGetPrng() {
  // create prng with api that matches BigInteger secure random
  return {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      for(var i = 0; i < x.length; ++i) {
        x[i] = Math.floor(Math.random() * 0x0100);
      }
    }
  };
}

//protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

//public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

//BigInteger interfaces not implemented in jsbn:

//BigInteger(int signum, byte[] magnitude)
//double doubleValue()
//float floatValue()
//int hashCode()
//long longValue()
//static BigInteger valueOf(long val)


/***/ }),

/***/ "./node_modules/node-forge/lib/md.js":
/*!*******************************************!*\
  !*** ./node_modules/node-forge/lib/md.js ***!
  \*******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Node.js module for Forge message digests.
 *
 * @author Dave Longley
 *
 * Copyright 2011-2017 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");

module.exports = forge.md = forge.md || {};
forge.md.algorithms = forge.md.algorithms || {};


/***/ }),

/***/ "./node_modules/node-forge/lib/md5.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/md5.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Message Digest Algorithm 5 with 128-bit digest (MD5) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var md5 = module.exports = forge.md5 = forge.md5 || {};
forge.md.md5 = forge.md.algorithms.md5 = md5;

/**
 * Creates an MD5 message digest object.
 *
 * @return a message digest object.
 */
md5.create = function() {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // MD5 state contains four 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(16);

  // message digest object
  var md = {
    algorithm: 'md5',
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = (len[1] / 0x100000000) >>> 0;
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate MD5 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in little-endian order; since length
    // is stored in bytes we multiply by 8 and add carry
    var bits, carry = 0;
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      bits = md.fullMessageLength[i] * 8 + carry;
      carry = (bits / 0x100000000) >>> 0;
      finalBlock.putInt32Le(bits >>> 0);
    }

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32Le(s2.h0);
    rval.putInt32Le(s2.h1);
    rval.putInt32Le(s2.h2);
    rval.putInt32Le(s2.h3);
    return rval;
  };

  return md;
};

// padding, constant tables for calculating md5
var _padding = null;
var _g = null;
var _r = null;
var _k = null;
var _initialized = false;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // g values
  _g = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,
    5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,
    0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9];

  // rounds table
  _r = [
    7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
    5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
    4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
    6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21];

  // get the result of abs(sin(i + 1)) as a 32-bit integer
  _k = new Array(64);
  for(var i = 0; i < 64; ++i) {
    _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 0x100000000);
  }

  // now initialized
  _initialized = true;
}

/**
 * Updates an MD5 state with the given byte buffer.
 *
 * @param s the MD5 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, f, r, i;
  var len = bytes.length();
  while(len >= 64) {
    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;

    // round 1
    for(i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32Le();
      f = d ^ (b & (c ^ d));
      t = (a + f + _k[i] + w[i]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 2
    for(; i < 32; ++i) {
      f = c ^ (d & (b ^ c));
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 3
    for(; i < 48; ++i) {
      f = b ^ c ^ d;
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }
    // round 4
    for(; i < 64; ++i) {
      f = c ^ (b | ~d);
      t = (a + f + _k[i] + w[_g[i]]);
      r = _r[i];
      a = d;
      d = c;
      c = b;
      b += (t << r) | (t >>> (32 - r));
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;

    len -= 64;
  }
}


/***/ }),

/***/ "./node_modules/node-forge/lib/mgf.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/mgf.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Node.js module for Forge mask generation functions.
 *
 * @author Stefan Siegl
 *
 * Copyright 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./mgf1 */ "./node_modules/node-forge/lib/mgf1.js");

module.exports = forge.mgf = forge.mgf || {};
forge.mgf.mgf1 = forge.mgf1;


/***/ }),

/***/ "./node_modules/node-forge/lib/mgf1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/mgf1.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of mask generation function MGF1.
 *
 * @author Stefan Siegl
 * @author Dave Longley
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

forge.mgf = forge.mgf || {};
var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};

/**
 * Creates a MGF1 mask generation function object.
 *
 * @param md the message digest API to use (eg: forge.md.sha1.create()).
 *
 * @return a mask generation function object.
 */
mgf1.create = function(md) {
  var mgf = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(seed, maskLen) {
      /* 2. Let T be the empty octet string. */
      var t = new forge.util.ByteBuffer();

      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */
      var len = Math.ceil(maskLen / md.digestLength);
      for(var i = 0; i < len; i++) {
        /* a. Convert counter to an octet string C of length 4 octets */
        var c = new forge.util.ByteBuffer();
        c.putInt32(i);

        /* b. Concatenate the hash of the seed mgfSeed and C to the octet
         * string T: */
        md.start();
        md.update(seed + c.getBytes());
        t.putBuffer(md.digest());
      }

      /* Output the leading maskLen octets of T as the octet string mask. */
      t.truncate(t.length() - maskLen);
      return t.getBytes();
    }
  };

  return mgf;
};


/***/ }),

/***/ "./node_modules/node-forge/lib/oids.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/oids.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Object IDs for ASN.1.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");

forge.pki = forge.pki || {};
var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};

// set id to name mapping and name to id mapping
function _IN(id, name) {
  oids[id] = name;
  oids[name] = id;
}
// set id to name mapping only
function _I_(id, name) {
  oids[id] = name;
}

// algorithm OIDs
_IN('1.2.840.113549.1.1.1', 'rsaEncryption');
// Note: md2 & md4 not implemented
//_IN('1.2.840.113549.1.1.2', 'md2WithRSAEncryption');
//_IN('1.2.840.113549.1.1.3', 'md4WithRSAEncryption');
_IN('1.2.840.113549.1.1.4', 'md5WithRSAEncryption');
_IN('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption');
_IN('1.2.840.113549.1.1.7', 'RSAES-OAEP');
_IN('1.2.840.113549.1.1.8', 'mgf1');
_IN('1.2.840.113549.1.1.9', 'pSpecified');
_IN('1.2.840.113549.1.1.10', 'RSASSA-PSS');
_IN('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption');
_IN('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption');
_IN('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption');

_IN('1.2.840.10040.4.3', 'dsa-with-sha1');

_IN('1.3.14.3.2.7', 'desCBC');

_IN('1.3.14.3.2.26', 'sha1');
_IN('2.16.840.1.101.3.4.2.1', 'sha256');
_IN('2.16.840.1.101.3.4.2.2', 'sha384');
_IN('2.16.840.1.101.3.4.2.3', 'sha512');
_IN('1.2.840.113549.2.5', 'md5');

// pkcs#7 content types
_IN('1.2.840.113549.1.7.1', 'data');
_IN('1.2.840.113549.1.7.2', 'signedData');
_IN('1.2.840.113549.1.7.3', 'envelopedData');
_IN('1.2.840.113549.1.7.4', 'signedAndEnvelopedData');
_IN('1.2.840.113549.1.7.5', 'digestedData');
_IN('1.2.840.113549.1.7.6', 'encryptedData');

// pkcs#9 oids
_IN('1.2.840.113549.1.9.1', 'emailAddress');
_IN('1.2.840.113549.1.9.2', 'unstructuredName');
_IN('1.2.840.113549.1.9.3', 'contentType');
_IN('1.2.840.113549.1.9.4', 'messageDigest');
_IN('1.2.840.113549.1.9.5', 'signingTime');
_IN('1.2.840.113549.1.9.6', 'counterSignature');
_IN('1.2.840.113549.1.9.7', 'challengePassword');
_IN('1.2.840.113549.1.9.8', 'unstructuredAddress');
_IN('1.2.840.113549.1.9.14', 'extensionRequest');

_IN('1.2.840.113549.1.9.20', 'friendlyName');
_IN('1.2.840.113549.1.9.21', 'localKeyId');
_IN('1.2.840.113549.1.9.22.1', 'x509Certificate');

// pkcs#12 safe bags
_IN('1.2.840.113549.1.12.10.1.1', 'keyBag');
_IN('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag');
_IN('1.2.840.113549.1.12.10.1.3', 'certBag');
_IN('1.2.840.113549.1.12.10.1.4', 'crlBag');
_IN('1.2.840.113549.1.12.10.1.5', 'secretBag');
_IN('1.2.840.113549.1.12.10.1.6', 'safeContentsBag');

// password-based-encryption for pkcs#12
_IN('1.2.840.113549.1.5.13', 'pkcs5PBES2');
_IN('1.2.840.113549.1.5.12', 'pkcs5PBKDF2');

_IN('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4');
_IN('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4');
_IN('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC');
_IN('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC');
_IN('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC');
_IN('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC');

// hmac OIDs
_IN('1.2.840.113549.2.7', 'hmacWithSHA1');
_IN('1.2.840.113549.2.8', 'hmacWithSHA224');
_IN('1.2.840.113549.2.9', 'hmacWithSHA256');
_IN('1.2.840.113549.2.10', 'hmacWithSHA384');
_IN('1.2.840.113549.2.11', 'hmacWithSHA512');

// symmetric key algorithm oids
_IN('1.2.840.113549.3.7', 'des-EDE3-CBC');
_IN('2.16.840.1.101.3.4.1.2', 'aes128-CBC');
_IN('2.16.840.1.101.3.4.1.22', 'aes192-CBC');
_IN('2.16.840.1.101.3.4.1.42', 'aes256-CBC');

// certificate issuer/subject OIDs
_IN('2.5.4.3', 'commonName');
_IN('2.5.4.5', 'serialName');
_IN('2.5.4.6', 'countryName');
_IN('2.5.4.7', 'localityName');
_IN('2.5.4.8', 'stateOrProvinceName');
_IN('2.5.4.10', 'organizationName');
_IN('2.5.4.11', 'organizationalUnitName');
_IN('2.5.4.13', 'description');

// X.509 extension OIDs
_IN('2.16.840.1.113730.1.1', 'nsCertType');
_IN('2.16.840.1.113730.1.13', 'nsComment'); // deprecated in theory; still widely used
_I_('2.5.29.1', 'authorityKeyIdentifier'); // deprecated, use .35
_I_('2.5.29.2', 'keyAttributes'); // obsolete use .37 or .15
_I_('2.5.29.3', 'certificatePolicies'); // deprecated, use .32
_I_('2.5.29.4', 'keyUsageRestriction'); // obsolete use .37 or .15
_I_('2.5.29.5', 'policyMapping'); // deprecated use .33
_I_('2.5.29.6', 'subtreesConstraint'); // obsolete use .30
_I_('2.5.29.7', 'subjectAltName'); // deprecated use .17
_I_('2.5.29.8', 'issuerAltName'); // deprecated use .18
_I_('2.5.29.9', 'subjectDirectoryAttributes');
_I_('2.5.29.10', 'basicConstraints'); // deprecated use .19
_I_('2.5.29.11', 'nameConstraints'); // deprecated use .30
_I_('2.5.29.12', 'policyConstraints'); // deprecated use .36
_I_('2.5.29.13', 'basicConstraints'); // deprecated use .19
_IN('2.5.29.14', 'subjectKeyIdentifier');
_IN('2.5.29.15', 'keyUsage');
_I_('2.5.29.16', 'privateKeyUsagePeriod');
_IN('2.5.29.17', 'subjectAltName');
_IN('2.5.29.18', 'issuerAltName');
_IN('2.5.29.19', 'basicConstraints');
_I_('2.5.29.20', 'cRLNumber');
_I_('2.5.29.21', 'cRLReason');
_I_('2.5.29.22', 'expirationDate');
_I_('2.5.29.23', 'instructionCode');
_I_('2.5.29.24', 'invalidityDate');
_I_('2.5.29.25', 'cRLDistributionPoints'); // deprecated use .31
_I_('2.5.29.26', 'issuingDistributionPoint'); // deprecated use .28
_I_('2.5.29.27', 'deltaCRLIndicator');
_I_('2.5.29.28', 'issuingDistributionPoint');
_I_('2.5.29.29', 'certificateIssuer');
_I_('2.5.29.30', 'nameConstraints');
_IN('2.5.29.31', 'cRLDistributionPoints');
_IN('2.5.29.32', 'certificatePolicies');
_I_('2.5.29.33', 'policyMappings');
_I_('2.5.29.34', 'policyConstraints'); // deprecated use .36
_IN('2.5.29.35', 'authorityKeyIdentifier');
_I_('2.5.29.36', 'policyConstraints');
_IN('2.5.29.37', 'extKeyUsage');
_I_('2.5.29.46', 'freshestCRL');
_I_('2.5.29.54', 'inhibitAnyPolicy');

// extKeyUsage purposes
_IN('1.3.6.1.4.1.11129.2.4.2', 'timestampList');
_IN('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess');
_IN('1.3.6.1.5.5.7.3.1', 'serverAuth');
_IN('1.3.6.1.5.5.7.3.2', 'clientAuth');
_IN('1.3.6.1.5.5.7.3.3', 'codeSigning');
_IN('1.3.6.1.5.5.7.3.4', 'emailProtection');
_IN('1.3.6.1.5.5.7.3.8', 'timeStamping');


/***/ }),

/***/ "./node_modules/node-forge/lib/pbe.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pbe.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Password-based encryption functions.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * An EncryptedPrivateKeyInfo:
 *
 * EncryptedPrivateKeyInfo ::= SEQUENCE {
 *   encryptionAlgorithm  EncryptionAlgorithmIdentifier,
 *   encryptedData        EncryptedData }
 *
 * EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedData ::= OCTET STRING
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./aes */ "./node_modules/node-forge/lib/aes.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./des */ "./node_modules/node-forge/lib/des.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");
__webpack_require__(/*! ./pbkdf2 */ "./node_modules/node-forge/lib/pbkdf2.js");
__webpack_require__(/*! ./pem */ "./node_modules/node-forge/lib/pem.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");
__webpack_require__(/*! ./rc2 */ "./node_modules/node-forge/lib/rc2.js");
__webpack_require__(/*! ./rsa */ "./node_modules/node-forge/lib/rsa.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

if(typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Password-based encryption implementation. */
var pki = forge.pki = forge.pki || {};
module.exports = pki.pbe = forge.pbe = forge.pbe || {};
var oids = pki.oids;

// validator for an EncryptedPrivateKeyInfo structure
// Note: Currently only works w/algorithm params
var encryptedPrivateKeyValidator = {
  name: 'EncryptedPrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encryptionOid'
    }, {
      name: 'AlgorithmIdentifier.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'encryptionParams'
    }]
  }, {
    // encryptedData
    name: 'EncryptedPrivateKeyInfo.encryptedData',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encryptedData'
  }]
};

// validator for a PBES2Algorithms structure
// Note: Currently only works w/PBKDF2 + AES encryption schemes
var PBES2AlgorithmsValidator = {
  name: 'PBES2Algorithms',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'PBES2Algorithms.keyDerivationFunc',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.keyDerivationFunc.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'kdfOid'
    }, {
      name: 'PBES2Algorithms.params',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'PBES2Algorithms.params.salt',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'kdfSalt'
      }, {
        name: 'PBES2Algorithms.params.iterationCount',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'kdfIterationCount'
      }, {
        name: 'PBES2Algorithms.params.keyLength',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: 'keyLength'
      }, {
        // prf
        name: 'PBES2Algorithms.params.prf',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: 'PBES2Algorithms.params.prf.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'prfOid'
        }]
      }]
    }]
  }, {
    name: 'PBES2Algorithms.encryptionScheme',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'PBES2Algorithms.encryptionScheme.oid',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encOid'
    }, {
      name: 'PBES2Algorithms.encryptionScheme.iv',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: 'encIv'
    }]
  }]
};

var pkcs12PbeParamsValidator = {
  name: 'pkcs-12PbeParams',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'pkcs-12PbeParams.salt',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'salt'
  }, {
    name: 'pkcs-12PbeParams.iterations',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'iterations'
  }]
};

/**
 * Encrypts a ASN.1 PrivateKeyInfo object, producing an EncryptedPrivateKeyInfo.
 *
 * PBES2Algorithms ALGORITHM-IDENTIFIER ::=
 *   { {PBES2-params IDENTIFIED BY id-PBES2}, ...}
 *
 * id-PBES2 OBJECT IDENTIFIER ::= {pkcs-5 13}
 *
 * PBES2-params ::= SEQUENCE {
 *   keyDerivationFunc AlgorithmIdentifier {{PBES2-KDFs}},
 *   encryptionScheme AlgorithmIdentifier {{PBES2-Encs}}
 * }
 *
 * PBES2-KDFs ALGORITHM-IDENTIFIER ::=
 *   { {PBKDF2-params IDENTIFIED BY id-PBKDF2}, ... }
 *
 * PBES2-Encs ALGORITHM-IDENTIFIER ::= { ... }
 *
 * PBKDF2-params ::= SEQUENCE {
 *   salt CHOICE {
 *     specified OCTET STRING,
 *     otherSource AlgorithmIdentifier {{PBKDF2-SaltSources}}
 *   },
 *   iterationCount INTEGER (1..MAX),
 *   keyLength INTEGER (1..MAX) OPTIONAL,
 *   prf AlgorithmIdentifier {{PBKDF2-PRFs}} DEFAULT algid-hmacWithSHA1
 * }
 *
 * @param obj the ASN.1 PrivateKeyInfo object.
 * @param password the password to encrypt with.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          prfAlgorithm the PRF message digest algorithm to use
 *            ('sha1', 'sha224', 'sha256', 'sha384', 'sha512')
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptPrivateKeyInfo = function(obj, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || 'aes128';
  options.prfAlgorithm = options.prfAlgorithm || 'sha1';

  // generate PBE params
  var salt = forge.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if(options.algorithm.indexOf('aes') === 0 || options.algorithm === 'des') {
    // do PBES2
    var ivLen, encOid, cipherFn;
    switch(options.algorithm) {
    case 'aes128':
      dkLen = 16;
      ivLen = 16;
      encOid = oids['aes128-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes192':
      dkLen = 24;
      ivLen = 16;
      encOid = oids['aes192-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'aes256':
      dkLen = 32;
      ivLen = 16;
      encOid = oids['aes256-CBC'];
      cipherFn = forge.aes.createEncryptionCipher;
      break;
    case 'des':
      dkLen = 8;
      ivLen = 8;
      encOid = oids['desCBC'];
      cipherFn = forge.des.createEncryptionCipher;
      break;
    default:
      var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
      error.algorithm = options.algorithm;
      throw error;
    }

    // get PRF message digest
    var prfAlgorithm = 'hmacWith' + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);

    // encrypt private key using pbe SHA-1 and AES/DES
    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = forge.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    // get PBKDF2-params
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pkcs5PBES2']).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // keyDerivationFunc
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(oids['pkcs5PBKDF2']).getBytes()),
          // PBKDF2-params
          params
        ]),
        // encryptionScheme
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(encOid).getBytes()),
          // iv
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
        ])
      ])
    ]);
  } else if(options.algorithm === '3des') {
    // Do PKCS12 PBE
    dkLen = 24;

    var saltBytes = new forge.util.ByteBuffer(salt);
    var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge.des.createEncryptionCipher(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();

    encryptionAlgorithm = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(oids['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),
      // pkcs-12PbeParams
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
        // iteration count
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
          countBytes.getBytes())
      ])
    ]);
  } else {
    var error = new Error('Cannot encrypt private key. Unknown encryption algorithm.');
    error.algorithm = options.algorithm;
    throw error;
  }

  // EncryptedPrivateKeyInfo
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // encryptionAlgorithm
    encryptionAlgorithm,
    // encryptedData
    asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
  ]);
  return rval;
};

/**
 * Decrypts a ASN.1 PrivateKeyInfo object.
 *
 * @param obj the ASN.1 EncryptedPrivateKeyInfo object.
 * @param password the password to decrypt with.
 *
 * @return the ASN.1 PrivateKeyInfo on success, null on failure.
 */
pki.decryptPrivateKeyInfo = function(obj, password) {
  var rval = null;

  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read encrypted private key. ' +
      'ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // get cipher
  var oid = asn1.derToOid(capture.encryptionOid);
  var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);

  // get encrypted data
  var encrypted = forge.util.createBuffer(capture.encryptedData);

  cipher.update(encrypted);
  if(cipher.finish()) {
    rval = asn1.fromDer(cipher.output);
  }

  return rval;
};

/**
 * Converts a EncryptedPrivateKeyInfo to PEM format.
 *
 * @param epki the EncryptedPrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted encrypted private key.
 */
pki.encryptedPrivateKeyToPem = function(epki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'ENCRYPTED PRIVATE KEY',
    body: asn1.toDer(epki).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts a PEM-encoded EncryptedPrivateKeyInfo to ASN.1 format. Decryption
 * is not performed.
 *
 * @param pem the EncryptedPrivateKeyInfo in PEM-format.
 *
 * @return the ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptedPrivateKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY') {
    var error = new Error('Could not convert encrypted private key from PEM; ' +
      'PEM header type is "ENCRYPTED PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert encrypted private key from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  return asn1.fromDer(msg.body);
};

/**
 * Encrypts an RSA private key. By default, the key will be wrapped in
 * a PrivateKeyInfo and encrypted to produce a PKCS#8 EncryptedPrivateKeyInfo.
 * This is the standard, preferred way to encrypt a private key.
 *
 * To produce a non-standard PEM-encrypted private key that uses encapsulated
 * headers to indicate the encryption algorithm (old-style non-PKCS#8 OpenSSL
 * private key encryption), set the 'legacy' option to true. Note: Using this
 * option will cause the iteration count to be forced to 1.
 *
 * Note: The 'des' algorithm is supported, but it is not considered to be
 * secure because it only uses a single 56-bit key. If possible, it is highly
 * recommended that a different algorithm be used.
 *
 * @param rsaKey the RSA key to encrypt.
 * @param password the password to use.
 * @param options:
 *          algorithm: the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des', 'des').
 *          count: the iteration count to use.
 *          saltSize: the salt size to use.
 *          legacy: output an old non-PKCS#8 PEM-encrypted+encapsulated
 *            headers (DEK-Info) private key.
 *
 * @return the PEM-encoded ASN.1 EncryptedPrivateKeyInfo.
 */
pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
  // standard PKCS#8
  options = options || {};
  if(!options.legacy) {
    // encrypt PrivateKeyInfo
    var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
    rval = pki.encryptPrivateKeyInfo(rval, password, options);
    return pki.encryptedPrivateKeyToPem(rval);
  }

  // legacy non-PKCS#8
  var algorithm;
  var iv;
  var dkLen;
  var cipherFn;
  switch(options.algorithm) {
  case 'aes128':
    algorithm = 'AES-128-CBC';
    dkLen = 16;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes192':
    algorithm = 'AES-192-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case 'aes256':
    algorithm = 'AES-256-CBC';
    dkLen = 32;
    iv = forge.random.getBytesSync(16);
    cipherFn = forge.aes.createEncryptionCipher;
    break;
  case '3des':
    algorithm = 'DES-EDE3-CBC';
    dkLen = 24;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  case 'des':
    algorithm = 'DES-CBC';
    dkLen = 8;
    iv = forge.random.getBytesSync(8);
    cipherFn = forge.des.createEncryptionCipher;
    break;
  default:
    var error = new Error('Could not encrypt RSA private key; unsupported ' +
      'encryption algorithm "' + options.algorithm + '".');
    error.algorithm = options.algorithm;
    throw error;
  }

  // encrypt private key using OpenSSL legacy key derivation
  var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv);
  cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
  cipher.finish();

  var msg = {
    type: 'RSA PRIVATE KEY',
    procType: {
      version: '4',
      type: 'ENCRYPTED'
    },
    dekInfo: {
      algorithm: algorithm,
      parameters: forge.util.bytesToHex(iv).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge.pem.encode(msg);
};

/**
 * Decrypts an RSA private key.
 *
 * @param pem the PEM-formatted EncryptedPrivateKeyInfo to decrypt.
 * @param password the password to use.
 *
 * @return the RSA key on success, null on failure.
 */
pki.decryptRsaPrivateKey = function(pem, password) {
  var rval = null;

  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'ENCRYPTED PRIVATE KEY' &&
    msg.type !== 'PRIVATE KEY' &&
    msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM header type ' +
      'is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error.headerType = error;
    throw error;
  }

  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    var dkLen;
    var cipherFn;
    switch(msg.dekInfo.algorithm) {
    case 'DES-CBC':
      dkLen = 8;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'DES-EDE3-CBC':
      dkLen = 24;
      cipherFn = forge.des.createDecryptionCipher;
      break;
    case 'AES-128-CBC':
      dkLen = 16;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-192-CBC':
      dkLen = 24;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'AES-256-CBC':
      dkLen = 32;
      cipherFn = forge.aes.createDecryptionCipher;
      break;
    case 'RC2-40-CBC':
      dkLen = 5;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 40);
      };
      break;
    case 'RC2-64-CBC':
      dkLen = 8;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 64);
      };
      break;
    case 'RC2-128-CBC':
      dkLen = 16;
      cipherFn = function(key) {
        return forge.rc2.createDecryptionCipher(key, 128);
      };
      break;
    default:
      var error = new Error('Could not decrypt private key; unsupported ' +
        'encryption algorithm "' + msg.dekInfo.algorithm + '".');
      error.algorithm = msg.dekInfo.algorithm;
      throw error;
    }

    // use OpenSSL legacy key derivation
    var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(forge.util.createBuffer(msg.body));
    if(cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }

  if(msg.type === 'ENCRYPTED PRIVATE KEY') {
    rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
  } else {
    // decryption already performed above
    rval = asn1.fromDer(rval);
  }

  if(rval !== null) {
    rval = pki.privateKeyFromAsn1(rval);
  }

  return rval;
};

/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */
pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
  var j, l;

  if(typeof md === 'undefined' || md === null) {
    if(!('sha1' in forge.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge.md.sha1.create();
  }

  var u = md.digestLength;
  var v = md.blockLength;
  var result = new forge.util.ByteBuffer();

  /* Convert password to Unicode byte buffer + trailing 0-byte. */
  var passBuf = new forge.util.ByteBuffer();
  if(password !== null && password !== undefined) {
    for(l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }

  /* Length of salt and password in BYTES. */
  var p = passBuf.length();
  var s = salt.length();

  /* 1. Construct a string, D (the "diversifier"), by concatenating
        v copies of ID. */
  var D = new forge.util.ByteBuffer();
  D.fillWithByte(id, v);

  /* 2. Concatenate copies of the salt together to create a string S of length
        v * ceil(s / v) bytes (the final copy of the salt may be trunacted
        to create S).
        Note that if the salt is the empty string, then so is S. */
  var Slen = v * Math.ceil(s / v);
  var S = new forge.util.ByteBuffer();
  for(l = 0; l < Slen; l++) {
    S.putByte(salt.at(l % s));
  }

  /* 3. Concatenate copies of the password together to create a string P of
        length v * ceil(p / v) bytes (the final copy of the password may be
        truncated to create P).
        Note that if the password is the empty string, then so is P. */
  var Plen = v * Math.ceil(p / v);
  var P = new forge.util.ByteBuffer();
  for(l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }

  /* 4. Set I=S||P to be the concatenation of S and P. */
  var I = S;
  I.putBuffer(P);

  /* 5. Set c=ceil(n / u). */
  var c = Math.ceil(n / u);

  /* 6. For i=1, 2, ..., c, do the following: */
  for(var i = 1; i <= c; i++) {
    /* a) Set Ai=H^r(D||I). (l.e. the rth hash of D||I, H(H(H(...H(D||I)))) */
    var buf = new forge.util.ByteBuffer();
    buf.putBytes(D.bytes());
    buf.putBytes(I.bytes());
    for(var round = 0; round < iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }

    /* b) Concatenate copies of Ai to create a string B of length v bytes (the
          final copy of Ai may be truncated to create B). */
    var B = new forge.util.ByteBuffer();
    for(l = 0; l < v; l++) {
      B.putByte(buf.at(l % u));
    }

    /* c) Treating I as a concatenation I0, I1, ..., Ik-1 of v-byte blocks,
          where k=ceil(s / v) + ceil(p / v), modify I by setting
          Ij=(Ij+B+1) mod 2v for each j.  */
    var k = Math.ceil(s / v) + Math.ceil(p / v);
    var Inew = new forge.util.ByteBuffer();
    for(j = 0; j < k; j++) {
      var chunk = new forge.util.ByteBuffer(I.getBytes(v));
      var x = 0x1ff;
      for(l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 0xff);
      }
      Inew.putBuffer(chunk);
    }
    I = Inew;

    /* Add Ai to A. */
    result.putBuffer(buf);
  }

  result.truncate(result.length() - n);
  return result;
};

/**
 * Get new Forge cipher object instance.
 *
 * @param oid the OID (in string notation).
 * @param params the ASN.1 params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */
pki.pbe.getCipher = function(oid, params, password) {
  switch(oid) {
  case pki.oids['pkcs5PBES2']:
    return pki.pbe.getCipherForPBES2(oid, params, password);

  case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
  case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
    return pki.pbe.getCipherForPKCS12PBE(oid, params, password);

  default:
    var error = new Error('Cannot read encrypted PBE data block. Unsupported OID.');
    error.oid = oid;
    error.supportedOids = [
      'pkcs5PBES2',
      'pbeWithSHAAnd3-KeyTripleDES-CBC',
      'pbewithSHAAnd40BitRC2-CBC'
    ];
    throw error;
  }
};

/**
 * Get new Forge cipher object instance according to PBES2 params block.
 *
 * The returned cipher instance is already started using the IV
 * from PBES2 parameter block.
 *
 * @param oid the PKCS#5 PBKDF2 OID (in string notation).
 * @param params the ASN.1 PBES2-params object.
 * @param password the password to decrypt with.
 *
 * @return new cipher object instance.
 */
pki.pbe.getCipherForPBES2 = function(oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  // check oids
  oid = asn1.derToOid(capture.kdfOid);
  if(oid !== pki.oids['pkcs5PBKDF2']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported key derivation function OID.');
    error.oid = oid;
    error.supportedOids = ['pkcs5PBKDF2'];
    throw error;
  }
  oid = asn1.derToOid(capture.encOid);
  if(oid !== pki.oids['aes128-CBC'] &&
    oid !== pki.oids['aes192-CBC'] &&
    oid !== pki.oids['aes256-CBC'] &&
    oid !== pki.oids['des-EDE3-CBC'] &&
    oid !== pki.oids['desCBC']) {
    var error = new Error('Cannot read encrypted private key. ' +
      'Unsupported encryption scheme OID.');
    error.oid = oid;
    error.supportedOids = [
      'aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC'];
    throw error;
  }

  // set PBE params
  var salt = capture.kdfSalt;
  var count = forge.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch(pki.oids[oid]) {
  case 'aes128-CBC':
    dkLen = 16;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes192-CBC':
    dkLen = 24;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'aes256-CBC':
    dkLen = 32;
    cipherFn = forge.aes.createDecryptionCipher;
    break;
  case 'des-EDE3-CBC':
    dkLen = 24;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  case 'desCBC':
    dkLen = 8;
    cipherFn = forge.des.createDecryptionCipher;
    break;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);

  // decrypt private key using pbe with chosen PRF and AES/DES
  var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv);

  return cipher;
};

/**
 * Get new Forge cipher object instance for PKCS#12 PBE.
 *
 * The returned cipher instance is already started using the key & IV
 * derived from the provided password and PKCS#12 PBE salt.
 *
 * @param oid The PKCS#12 PBE OID (in string notation).
 * @param params The ASN.1 PKCS#12 PBE-params object.
 * @param password The password to decrypt with.
 *
 * @return the new cipher object instance.
 */
pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  // get PBE params
  var capture = {};
  var errors = [];
  if(!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
    var error = new Error('Cannot read password-based-encryption algorithm ' +
      'parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.');
    error.errors = errors;
    throw error;
  }

  var salt = forge.util.createBuffer(capture.salt);
  var count = forge.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);

  var dkLen, dIvLen, cipherFn;
  switch(oid) {
    case pki.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge.des.startDecrypting;
      break;

    case pki.oids['pbewithSHAAnd40BitRC2-CBC']:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key, iv) {
        var cipher = forge.rc2.createDecryptionCipher(key, 40);
        cipher.start(iv, null);
        return cipher;
      };
      break;

    default:
      var error = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.');
      error.oid = oid;
      throw error;
  }

  // get PRF message digest
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);

  return cipherFn(key, iv);
};

/**
 * OpenSSL's legacy key derivation function.
 *
 * See: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 *
 * @param password the password to derive the key from.
 * @param salt the salt to use, null for none.
 * @param dkLen the number of bytes needed for the derived key.
 * @param [options] the options to use:
 *          [md] an optional message digest object to use.
 */
pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
  if(typeof md === 'undefined' || md === null) {
    if(!('md5' in forge.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge.md.md5.create();
  }
  if(salt === null) {
    salt = '';
  }
  var digests = [hash(md, password + salt)];
  for(var length = 16, i = 1; length < dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }
  return digests.join('').substr(0, dkLen);
};

function hash(md, bytes) {
  return md.start().update(bytes).digest().getBytes();
}

function prfOidToMessageDigest(prfOid) {
  // get PRF algorithm, default to SHA-1
  var prfAlgorithm;
  if(!prfOid) {
    prfAlgorithm = 'hmacWithSHA1';
  } else {
    prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
    if(!prfAlgorithm) {
      var error = new Error('Unsupported PRF OID.');
      error.oid = prfOid;
      error.supported = [
        'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',
        'hmacWithSHA512'];
      throw error;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}

function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory = forge.md;
  switch(prfAlgorithm) {
  case 'hmacWithSHA224':
    factory = forge.md.sha512;
  case 'hmacWithSHA1':
  case 'hmacWithSHA256':
  case 'hmacWithSHA384':
  case 'hmacWithSHA512':
    prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
    break;
  default:
    var error = new Error('Unsupported PRF algorithm.');
    error.algorithm = prfAlgorithm;
    error.supported = [
      'hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384',
      'hmacWithSHA512'];
    throw error;
  }
  if(!factory || !(prfAlgorithm in factory)) {
    throw new Error('Unknown hash algorithm: ' + prfAlgorithm);
  }
  return factory[prfAlgorithm].create();
}

function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // salt
    asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
    // iteration count
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      countBytes.getBytes())
  ]);
  // when PRF algorithm is not SHA-1 default, add key length and PRF algorithm
  if(prfAlgorithm !== 'hmacWithSHA1') {
    params.value.push(
      // key length
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        forge.util.hexToBytes(dkLen.toString(16))),
      // AlgorithmIdentifier
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
      ]));
  }
  return params;
}


/***/ }),

/***/ "./node_modules/node-forge/lib/pbkdf2.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/pbkdf2.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Password-Based Key-Derivation Function #2 implementation.
 *
 * See RFC 2898 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./hmac */ "./node_modules/node-forge/lib/hmac.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};

var crypto;
if(forge.util.isNodejs && !forge.options.usePureJavaScript) {
  crypto = __webpack_require__(/*! crypto */ 0);
}

/**
 * Derives a key from a password.
 *
 * @param p the password as a binary-encoded string of bytes.
 * @param s the salt as a binary-encoded string of bytes.
 * @param c the iteration count, a positive integer.
 * @param dkLen the intended length, in bytes, of the derived key,
 *          (max: 2^32 - 1) * hash length of the PRF.
 * @param [md] the message digest (or algorithm identifier as a string) to use
 *          in the PRF, defaults to SHA-1.
 * @param [callback(err, key)] presence triggers asynchronous version, called
 *          once the operation completes.
 *
 * @return the derived key, as a binary-encoded string of bytes, for the
 *           synchronous version (if no callback is specified).
 */
module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(
  p, s, c, dkLen, md, callback) {
  if(typeof md === 'function') {
    callback = md;
    md = null;
  }

  // use native implementation if possible and not disabled, note that
  // some node versions only support SHA-1, others allow digest to be changed
  if(forge.util.isNodejs && !forge.options.usePureJavaScript &&
    crypto.pbkdf2 && (md === null || typeof md !== 'object') &&
    (crypto.pbkdf2Sync.length > 4 || (!md || md === 'sha1'))) {
    if(typeof md !== 'string') {
      // default prf to SHA-1
      md = 'sha1';
    }
    p = Buffer.from(p, 'binary');
    s = Buffer.from(s, 'binary');
    if(!callback) {
      if(crypto.pbkdf2Sync.length === 4) {
        return crypto.pbkdf2Sync(p, s, c, dkLen).toString('binary');
      }
      return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString('binary');
    }
    if(crypto.pbkdf2Sync.length === 4) {
      return crypto.pbkdf2(p, s, c, dkLen, function(err, key) {
        if(err) {
          return callback(err);
        }
        callback(null, key.toString('binary'));
      });
    }
    return crypto.pbkdf2(p, s, c, dkLen, md, function(err, key) {
      if(err) {
        return callback(err);
      }
      callback(null, key.toString('binary'));
    });
  }

  if(typeof md === 'undefined' || md === null) {
    // default prf to SHA-1
    md = 'sha1';
  }
  if(typeof md === 'string') {
    if(!(md in forge.md.algorithms)) {
      throw new Error('Unknown hash algorithm: ' + md);
    }
    md = forge.md[md].create();
  }

  var hLen = md.digestLength;

  /* 1. If dkLen > (2^32 - 1) * hLen, output "derived key too long" and
    stop. */
  if(dkLen > (0xFFFFFFFF * hLen)) {
    var err = new Error('Derived key is too long.');
    if(callback) {
      return callback(err);
    }
    throw err;
  }

  /* 2. Let len be the number of hLen-octet blocks in the derived key,
    rounding up, and let r be the number of octets in the last
    block:

    len = CEIL(dkLen / hLen),
    r = dkLen - (len - 1) * hLen. */
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;

  /* 3. For each block of the derived key apply the function F defined
    below to the password P, the salt S, the iteration count c, and
    the block index to compute the block:

    T_1 = F(P, S, c, 1),
    T_2 = F(P, S, c, 2),
    ...
    T_len = F(P, S, c, len),

    where the function F is defined as the exclusive-or sum of the
    first c iterates of the underlying pseudorandom function PRF
    applied to the password P and the concatenation of the salt S
    and the block index i:

    F(P, S, c, i) = u_1 XOR u_2 XOR ... XOR u_c

    where

    u_1 = PRF(P, S || INT(i)),
    u_2 = PRF(P, u_1),
    ...
    u_c = PRF(P, u_{c-1}).

    Here, INT(i) is a four-octet encoding of the integer i, most
    significant octet first. */
  var prf = forge.hmac.create();
  prf.start(md, p);
  var dk = '';
  var xor, u_c, u_c1;

  // sync version
  if(!callback) {
    for(var i = 1; i <= len; ++i) {
      // PRF(P, S || INT(i)) (first iteration)
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();

      // PRF(P, u_{c-1}) (other iterations)
      for(var j = 2; j <= c; ++j) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        // F(p, s, c, i)
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }

      /* 4. Concatenate the blocks and extract the first dkLen octets to
        produce a derived key DK:

        DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */
      dk += (i < len) ? xor : xor.substr(0, r);
    }
    /* 5. Output the derived key DK. */
    return dk;
  }

  // async version
  var i = 1, j;
  function outer() {
    if(i > len) {
      // done
      return callback(null, dk);
    }

    // PRF(P, S || INT(i)) (first iteration)
    prf.start(null, null);
    prf.update(s);
    prf.update(forge.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();

    // PRF(P, u_{c-1}) (other iterations)
    j = 2;
    inner();
  }

  function inner() {
    if(j <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      // F(p, s, c, i)
      xor = forge.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j;
      return forge.util.setImmediate(inner);
    }

    /* 4. Concatenate the blocks and extract the first dkLen octets to
      produce a derived key DK:

      DK = T_1 || T_2 ||  ...  || T_len<0..r-1> */
    dk += (i < len) ? xor : xor.substr(0, r);

    ++i;
    outer();
  }

  outer();
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/node-forge/lib/pem.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pem.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of basic PEM (Privacy Enhanced Mail) algorithms.
 *
 * See: RFC 1421.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 *
 * A Forge PEM object has the following fields:
 *
 * type: identifies the type of message (eg: "RSA PRIVATE KEY").
 *
 * procType: identifies the type of processing performed on the message,
 *   it has two subfields: version and type, eg: 4,ENCRYPTED.
 *
 * contentDomain: identifies the type of content in the message, typically
 *   only uses the value: "RFC822".
 *
 * dekInfo: identifies the message encryption algorithm and mode and includes
 *   any parameters for the algorithm, it has two subfields: algorithm and
 *   parameters, eg: DES-CBC,F8143EDE5960C597.
 *
 * headers: contains all other PEM encapsulated headers -- where order is
 *   significant (for pairing data like recipient ID + key info).
 *
 * body: the binary-encoded body.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

// shortcut for pem API
var pem = module.exports = forge.pem = forge.pem || {};

/**
 * Encodes (serializes) the given PEM object.
 *
 * @param msg the PEM message object to encode.
 * @param options the options to use:
 *          maxline the maximum characters per line for the body, (default: 64).
 *
 * @return the PEM-formatted string.
 */
pem.encode = function(msg, options) {
  options = options || {};
  var rval = '-----BEGIN ' + msg.type + '-----\r\n';

  // encode special headers
  var header;
  if(msg.procType) {
    header = {
      name: 'Proc-Type',
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header);
  }
  if(msg.contentDomain) {
    header = {name: 'Content-Domain', values: [msg.contentDomain]};
    rval += foldHeader(header);
  }
  if(msg.dekInfo) {
    header = {name: 'DEK-Info', values: [msg.dekInfo.algorithm]};
    if(msg.dekInfo.parameters) {
      header.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header);
  }

  if(msg.headers) {
    // encode all other headers
    for(var i = 0; i < msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  }

  // terminate header
  if(msg.procType) {
    rval += '\r\n';
  }

  // add body
  rval += forge.util.encode64(msg.body, options.maxline || 64) + '\r\n';

  rval += '-----END ' + msg.type + '-----\r\n';
  return rval;
};

/**
 * Decodes (deserializes) all PEM messages found in the given string.
 *
 * @param str the PEM-formatted string to decode.
 *
 * @return the PEM message objects in an array.
 */
pem.decode = function(str) {
  var rval = [];

  // split string into PEM messages (be lenient w/EOF on BEGIN line)
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match;
  while(true) {
    match = rMessage.exec(str);
    if(!match) {
      break;
    }

    var msg = {
      type: match[1],
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge.util.decode64(match[3])
    };
    rval.push(msg);

    // no headers
    if(!match[2]) {
      continue;
    }

    // parse headers
    var lines = match[2].split(rCRLF);
    var li = 0;
    while(match && li < lines.length) {
      // get line, trim any rhs whitespace
      var line = lines[li].replace(/\s+$/, '');

      // RFC2822 unfold any following folded lines
      for(var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if(!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }

      // parse header
      match = line.match(rHeader);
      if(match) {
        var header = {name: match[1], values: []};
        var values = match[2].split(',');
        for(var vi = 0; vi < values.length; ++vi) {
          header.values.push(ltrim(values[vi]));
        }

        // Proc-Type must be the first header
        if(!msg.procType) {
          if(header.name !== 'Proc-Type') {
            throw new Error('Invalid PEM formatted message. The first ' +
              'encapsulated header must be "Proc-Type".');
          } else if(header.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" ' +
              'header must have two subfields.');
          }
          msg.procType = {version: values[0], type: values[1]};
        } else if(!msg.contentDomain && header.name === 'Content-Domain') {
          // special-case Content-Domain
          msg.contentDomain = values[0] || '';
        } else if(!msg.dekInfo && header.name === 'DEK-Info') {
          // special-case DEK-Info
          if(header.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
              'header must have at least one subfield.');
          }
          msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
        } else {
          msg.headers.push(header);
        }
      }

      ++li;
    }

    if(msg.procType === 'ENCRYPTED' && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" ' +
        'header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }

  if(rval.length === 0) {
    throw new Error('Invalid PEM formatted message.');
  }

  return rval;
};

function foldHeader(header) {
  var rval = header.name + ': ';

  // ensure values with CRLF are folded
  var values = [];
  var insertSpace = function(match, $1) {
    return ' ' + $1;
  };
  for(var i = 0; i < header.values.length; ++i) {
    values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(',') + '\r\n';

  // do folding
  var length = 0;
  var candidate = -1;
  for(var i = 0; i < rval.length; ++i, ++length) {
    if(length > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if(insert === ',') {
        ++candidate;
        rval = rval.substr(0, candidate) + '\r\n ' + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) +
          '\r\n' + insert + rval.substr(candidate + 1);
      }
      length = (i - candidate - 1);
      candidate = -1;
      ++i;
    } else if(rval[i] === ' ' || rval[i] === '\t' || rval[i] === ',') {
      candidate = i;
    }
  }

  return rval;
}

function ltrim(str) {
  return str.replace(/^\s+/, '');
}


/***/ }),

/***/ "./node_modules/node-forge/lib/pkcs1.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs1.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Partial implementation of PKCS#1 v2.2: RSA-OEAP
 *
 * Modified but based on the following MIT and BSD licensed code:
 *
 * https://github.com/kjur/jsjws/blob/master/rsa.js:
 *
 * The 'jsjws'(JSON Web Signature JavaScript Library) License
 *
 * Copyright (c) 2012 Kenji Urushima
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:
 *
 * RSAES-OAEP.js
 * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $
 * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)
 * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.
 * Contact: ellis@nukinetics.com
 * Distributed under the BSD License.
 *
 * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125
 *
 * @author Evan Jones (http://evanjones.ca/)
 * @author Dave Longley
 *
 * Copyright (c) 2013-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");
__webpack_require__(/*! ./sha1 */ "./node_modules/node-forge/lib/sha1.js");

// shortcut for PKCS#1 API
var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};

/**
 * Encode the given RSAES-OAEP message (M) using key, with optional label (L)
 * and seed.
 *
 * This method does not perform RSA encryption, it only encodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param message the message to encode.
 * @param options the options to use:
 *          label an optional label to use.
 *          seed the seed to use.
 *          md the message digest object to use, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the encoded message bytes.
 */
pkcs1.encode_rsa_oaep = function(key, message, options) {
  // parse arguments
  var label;
  var seed;
  var md;
  var mgf1Md;
  // legacy args (label, seed, md)
  if(typeof options === 'string') {
    label = options;
    seed = arguments[3] || undefined;
    md = arguments[4] || undefined;
  } else if(options) {
    label = options.label || undefined;
    seed = options.seed || undefined;
    md = options.md || undefined;
    if(options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // default OAEP to SHA-1 message digest
  if(!md) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  // compute length in bytes and check output
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if(message.length > maxLength) {
    var error = new Error('RSAES-OAEP input message length is too long.');
    error.length = message.length;
    error.maxLength = maxLength;
    throw error;
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest();

  var PS = '';
  var PS_length = maxLength - message.length;
  for(var i = 0; i < PS_length; i++) {
    PS += '\x00';
  }

  var DB = lHash.getBytes() + PS + '\x01' + message;

  if(!seed) {
    seed = forge.random.getBytes(md.digestLength);
  } else if(seed.length !== md.digestLength) {
    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +
      'match the digest length.');
    error.seedLength = seed.length;
    error.digestLength = md.digestLength;
    throw error;
  }

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);

  // return encoded message
  return '\x00' + maskedSeed + maskedDB;
};

/**
 * Decode the given RSAES-OAEP encoded message (EM) using key, with optional
 * label (L).
 *
 * This method does not perform RSA decryption, it only decodes the message
 * using RSAES-OAEP.
 *
 * @param key the RSA key to use.
 * @param em the encoded message to decode.
 * @param options the options to use:
 *          label an optional label to use.
 *          md the message digest object to use for OAEP, undefined for SHA-1.
 *          mgf1 optional mgf1 parameters:
 *            md the message digest object to use for MGF1.
 *
 * @return the decoded message bytes.
 */
pkcs1.decode_rsa_oaep = function(key, em, options) {
  // parse args
  var label;
  var md;
  var mgf1Md;
  // legacy args
  if(typeof options === 'string') {
    label = options;
    md = arguments[3] || undefined;
  } else if(options) {
    label = options.label || undefined;
    md = options.md || undefined;
    if(options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }

  // compute length in bytes
  var keyLength = Math.ceil(key.n.bitLength() / 8);

  if(em.length !== keyLength) {
    var error = new Error('RSAES-OAEP encoded message length is invalid.');
    error.length = em.length;
    error.expectedLength = keyLength;
    throw error;
  }

  // default OAEP to SHA-1 message digest
  if(md === undefined) {
    md = forge.md.sha1.create();
  } else {
    md.start();
  }

  // default MGF-1 to same as OAEP
  if(!mgf1Md) {
    mgf1Md = md;
  }

  if(keyLength < 2 * md.digestLength + 2) {
    throw new Error('RSAES-OAEP key is too short for the hash function.');
  }

  if(!label) {
    label = '';
  }
  md.update(label, 'raw');
  var lHash = md.digest().getBytes();

  // split the message into its parts
  var y = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);

  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);

  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);

  var lHashPrime = db.substring(0, md.digestLength);

  // constant time check that all values match what is expected
  var error = (y !== '\x00');

  // constant time check lHash vs lHashPrime
  for(var i = 0; i < md.digestLength; ++i) {
    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));
  }

  // "constant time" find the 0x1 byte separating the padding (zeros) from the
  // message
  // TODO: It must be possible to do this in a better/smarter way?
  var in_ps = 1;
  var index = md.digestLength;
  for(var j = md.digestLength; j < db.length; j++) {
    var code = db.charCodeAt(j);

    var is_0 = (code & 0x1) ^ 0x1;

    // non-zero if not 0 or 1 in the ps section
    var error_mask = in_ps ? 0xfffe : 0x0000;
    error |= (code & error_mask);

    // latch in_ps to zero after we find 0x1
    in_ps = in_ps & is_0;
    index += in_ps;
  }

  if(error || db.charCodeAt(index) !== 0x1) {
    throw new Error('Invalid RSAES-OAEP padding.');
  }

  return db.substring(index + 1);
};

function rsa_mgf1(seed, maskLength, hash) {
  // default to SHA-1 message digest
  if(!hash) {
    hash = forge.md.sha1.create();
  }
  var t = '';
  var count = Math.ceil(maskLength / hash.digestLength);
  for(var i = 0; i < count; ++i) {
    var c = String.fromCharCode(
      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);
    hash.start();
    hash.update(seed + c);
    t += hash.digest().getBytes();
  }
  return t.substring(0, maskLength);
}


/***/ }),

/***/ "./node_modules/node-forge/lib/pkcs12.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs12.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of PKCS#12.
 *
 * @author Dave Longley
 * @author Stefan Siegl <stesie@brokenpipe.de>
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#12 is as follows
 * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)
 *
 * PFX ::= SEQUENCE {
 *   version  INTEGER {v3(3)}(v3,...),
 *   authSafe ContentInfo,
 *   macData  MacData OPTIONAL
 * }
 *
 * MacData ::= SEQUENCE {
 *   mac DigestInfo,
 *   macSalt OCTET STRING,
 *   iterations INTEGER DEFAULT 1
 * }
 * Note: The iterations default is for historical reasons and its use is
 * deprecated. A higher value, like 1024, is recommended.
 *
 * DigestInfo is defined in PKCS#7 as follows:
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of SHA1 there is none.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * Digest ::= OCTET STRING
 *
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType ContentType,
 *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * AuthenticatedSafe ::= SEQUENCE OF ContentInfo
 * -- Data if unencrypted
 * -- EncryptedData if password-encrypted
 * -- EnvelopedData if public key-encrypted
 *
 *
 * SafeContents ::= SEQUENCE OF SafeBag
 *
 * SafeBag ::= SEQUENCE {
 *   bagId     BAG-TYPE.&id ({PKCS12BagSet})
 *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),
 *   bagAttributes SET OF PKCS12Attribute OPTIONAL
 * }
 *
 * PKCS12Attribute ::= SEQUENCE {
 *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),
 *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})
 * } -- This type is compatible with the X.500 type 'Attribute'
 *
 * PKCS12AttrSet ATTRIBUTE ::= {
 *   friendlyName | -- from PKCS #9
 *   localKeyId, -- from PKCS #9
 *   ... -- Other attributes are allowed
 * }
 *
 * CertBag ::= SEQUENCE {
 *   certId    BAG-TYPE.&id   ({CertTypes}),
 *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})
 * }
 *
 * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}
 *   -- DER-encoded X.509 certificate stored in OCTET STRING
 *
 * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}
 * -- Base64-encoded SDSI certificate stored in IA5String
 *
 * CertTypes BAG-TYPE ::= {
 *   x509Certificate |
 *   sdsiCertificate,
 *   ... -- For future extensions
 * }
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./hmac */ "./node_modules/node-forge/lib/hmac.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");
__webpack_require__(/*! ./pkcs7asn1 */ "./node_modules/node-forge/lib/pkcs7asn1.js");
__webpack_require__(/*! ./pbe */ "./node_modules/node-forge/lib/pbe.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");
__webpack_require__(/*! ./rsa */ "./node_modules/node-forge/lib/rsa.js");
__webpack_require__(/*! ./sha1 */ "./node_modules/node-forge/lib/sha1.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");
__webpack_require__(/*! ./x509 */ "./node_modules/node-forge/lib/x509.js");

// shortcut for asn.1 & PKI API
var asn1 = forge.asn1;
var pki = forge.pki;

// shortcut for PKCS#12 API
var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};

var contentInfoValidator = {
  name: 'ContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,  // a ContentInfo
  constructed: true,
  value: [{
    name: 'ContentInfo.contentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'ContentInfo.content',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: 'content'
  }]
};

var pfxValidator = {
  name: 'PFX',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'PFX.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  },
  contentInfoValidator, {
    name: 'PFX.macData',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    optional: true,
    captureAsn1: 'mac',
    value: [{
      name: 'PFX.macData.mac',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,  // DigestInfo
      constructed: true,
      value: [{
        name: 'PFX.macData.mac.digestAlgorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier
        constructed: true,
        value: [{
          name: 'PFX.macData.mac.digestAlgorithm.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'macAlgorithm'
        }, {
          name: 'PFX.macData.mac.digestAlgorithm.parameters',
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: 'macAlgorithmParameters'
        }]
      }, {
        name: 'PFX.macData.mac.digest',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: 'macDigest'
      }]
    }, {
      name: 'PFX.macData.macSalt',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: 'macSalt'
    }, {
      name: 'PFX.macData.iterations',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      optional: true,
      capture: 'macIterations'
    }]
  }]
};

var safeBagValidator = {
  name: 'SafeBag',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SafeBag.bagId',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'bagId'
  }, {
    name: 'SafeBag.bagValue',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: 'bagValue'
  }, {
    name: 'SafeBag.bagAttributes',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    optional: true,
    capture: 'bagAttributes'
  }]
};

var attributeValidator = {
  name: 'Attribute',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'Attribute.attrId',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'oid'
  }, {
    name: 'Attribute.attrValues',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    capture: 'values'
  }]
};

var certBagValidator = {
  name: 'CertBag',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'CertBag.certId',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'certId'
  }, {
    name: 'CertBag.certValue',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    constructed: true,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: 'CertBag.certValue[0]',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.OCTETSTRING,
      constructed: false,
      capture: 'cert'
    }]
  }]
};

/**
 * Search SafeContents structure for bags with matching attributes.
 *
 * The search can optionally be narrowed by a certain bag type.
 *
 * @param safeContents the SafeContents structure to search in.
 * @param attrName the name of the attribute to compare against.
 * @param attrValue the attribute value to search for.
 * @param [bagType] bag type to narrow search by.
 *
 * @return an array of matching bags.
 */
function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
  var result = [];

  for(var i = 0; i < safeContents.length; i++) {
    for(var j = 0; j < safeContents[i].safeBags.length; j++) {
      var bag = safeContents[i].safeBags[j];
      if(bagType !== undefined && bag.type !== bagType) {
        continue;
      }
      // only filter by bag type, no attribute specified
      if(attrName === null) {
        result.push(bag);
        continue;
      }
      if(bag.attributes[attrName] !== undefined &&
        bag.attributes[attrName].indexOf(attrValue) >= 0) {
        result.push(bag);
      }
    }
  }

  return result;
}

/**
 * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.
 *
 * @param obj The PKCS#12 PFX in ASN.1 notation.
 * @param strict true to use strict DER decoding, false not to (default: true).
 * @param {String} password Password to decrypt with (optional).
 *
 * @return PKCS#12 PFX object.
 */
p12.pkcs12FromAsn1 = function(obj, strict, password) {
  // handle args
  if(typeof strict === 'string') {
    password = strict;
    strict = true;
  } else if(strict === undefined) {
    strict = true;
  }

  // validate PFX and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, pfxValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#12 PFX. ' +
      'ASN.1 object is not an PKCS#12 PFX.');
    error.errors = error;
    throw error;
  }

  var pfx = {
    version: capture.version.charCodeAt(0),
    safeContents: [],

    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(filter) {
      var rval = {};

      var localKeyId;
      if('localKeyId' in filter) {
        localKeyId = filter.localKeyId;
      } else if('localKeyIdHex' in filter) {
        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
      }

      // filter on bagType only
      if(localKeyId === undefined && !('friendlyName' in filter) &&
        'bagType' in filter) {
        rval[filter.bagType] = _getBagsByAttribute(
          pfx.safeContents, null, null, filter.bagType);
      }

      if(localKeyId !== undefined) {
        rval.localKeyId = _getBagsByAttribute(
          pfx.safeContents, 'localKeyId',
          localKeyId, filter.bagType);
      }
      if('friendlyName' in filter) {
        rval.friendlyName = _getBagsByAttribute(
          pfx.safeContents, 'friendlyName',
          filter.friendlyName, filter.bagType);
      }

      return rval;
    },

    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(friendlyName, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents, 'friendlyName', friendlyName, bagType);
    },

    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(localKeyId, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents, 'localKeyId', localKeyId, bagType);
    }
  };

  if(capture.version.charCodeAt(0) !== 3) {
    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');
    error.version = capture.version.charCodeAt(0);
    throw error;
  }

  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {
    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');
    error.oid = asn1.derToOid(capture.contentType);
    throw error;
  }

  var data = capture.content.value[0];
  if(data.tagClass !== asn1.Class.UNIVERSAL ||
     data.type !== asn1.Type.OCTETSTRING) {
    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');
  }
  data = _decodePkcs7Data(data);

  // check for MAC
  if(capture.mac) {
    var md = null;
    var macKeyBytes = 0;
    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
    switch(macAlgorithm) {
    case pki.oids.sha1:
      md = forge.md.sha1.create();
      macKeyBytes = 20;
      break;
    case pki.oids.sha256:
      md = forge.md.sha256.create();
      macKeyBytes = 32;
      break;
    case pki.oids.sha384:
      md = forge.md.sha384.create();
      macKeyBytes = 48;
      break;
    case pki.oids.sha512:
      md = forge.md.sha512.create();
      macKeyBytes = 64;
      break;
    case pki.oids.md5:
      md = forge.md.md5.create();
      macKeyBytes = 16;
      break;
    }
    if(md === null) {
      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);
    }

    // verify MAC (iterations default to 1)
    var macSalt = new forge.util.ByteBuffer(capture.macSalt);
    var macIterations = (('macIterations' in capture) ?
      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);
    var macKey = p12.generateKey(
      password, macSalt, 3, macIterations, macKeyBytes, md);
    var mac = forge.hmac.create();
    mac.start(md, macKey);
    mac.update(data.value);
    var macValue = mac.getMac();
    if(macValue.getBytes() !== capture.macDigest) {
      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');
    }
  }

  _decodeAuthenticatedSafe(pfx, data.value, strict, password);
  return pfx;
};

/**
 * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines "Data" as an OCTET STRING,
 * but it is sometimes an OCTET STRING that is composed/constructed of chunks,
 * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This
 * function transforms this corner-case into the usual simple,
 * non-composed/constructed OCTET STRING.
 *
 * This function may be moved to ASN.1 at some point to better deal with
 * more BER-encoding issues, should they arise.
 *
 * @param data the ASN.1 Data object to transform.
 */
function _decodePkcs7Data(data) {
  // handle special case of "chunked" data content: an octet string composed
  // of other octet strings
  if(data.composed || data.constructed) {
    var value = forge.util.createBuffer();
    for(var i = 0; i < data.value.length; ++i) {
      value.putBytes(data.value[i].value);
    }
    data.composed = data.constructed = false;
    data.value = value.getBytes();
  }
  return data;
}

/**
 * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.
 *
 * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.
 *
 * @param pfx The PKCS#12 PFX object to fill.
 * @param {String} authSafe BER-encoded AuthenticatedSafe.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 */
function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */

  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||
     authSafe.type !== asn1.Type.SEQUENCE ||
     authSafe.constructed !== true) {
    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +
      'SEQUENCE OF ContentInfo');
  }

  for(var i = 0; i < authSafe.value.length; i++) {
    var contentInfo = authSafe.value[i];

    // validate contentInfo and capture data
    var capture = {};
    var errors = [];
    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
      var error = new Error('Cannot read ContentInfo.');
      error.errors = errors;
      throw error;
    }

    var obj = {
      encrypted: false
    };
    var safeContents = null;
    var data = capture.content.value[0];
    switch(asn1.derToOid(capture.contentType)) {
    case pki.oids.data:
      if(data.tagClass !== asn1.Class.UNIVERSAL ||
         data.type !== asn1.Type.OCTETSTRING) {
        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');
      }
      safeContents = _decodePkcs7Data(data).value;
      break;
    case pki.oids.encryptedData:
      safeContents = _decryptSafeContents(data, password);
      obj.encrypted = true;
      break;
    default:
      var error = new Error('Unsupported PKCS#12 contentType.');
      error.contentType = asn1.derToOid(capture.contentType);
      throw error;
    }

    obj.safeBags = _decodeSafeContents(safeContents, strict, password);
    pfx.safeContents.push(obj);
  }
}

/**
 * Decrypt PKCS#7 EncryptedData structure.
 *
 * @param data ASN.1 encoded EncryptedContentInfo object.
 * @param password The user-provided password.
 *
 * @return The decrypted SafeContents (ASN.1 object).
 */
function _decryptSafeContents(data, password) {
  var capture = {};
  var errors = [];
  if(!asn1.validate(
    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
    var error = new Error('Cannot read EncryptedContentInfo.');
    error.errors = errors;
    throw error;
  }

  var oid = asn1.derToOid(capture.contentType);
  if(oid !== pki.oids.data) {
    var error = new Error(
      'PKCS#12 EncryptedContentInfo ContentType is not Data.');
    error.oid = oid;
    throw error;
  }

  // get cipher
  oid = asn1.derToOid(capture.encAlgorithm);
  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);

  // get encrypted data
  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);

  cipher.update(encrypted);
  if(!cipher.finish()) {
    throw new Error('Failed to decrypt PKCS#12 SafeContents.');
  }

  return cipher.output.getBytes();
}

/**
 * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.
 *
 * The safeContents is a BER-encoded SEQUENCE OF SafeBag.
 *
 * @param {String} safeContents BER-encoded safeContents.
 * @param strict true to use strict DER decoding, false not to.
 * @param {String} password Password to decrypt with (optional).
 *
 * @return {Array} Array of Bag objects.
 */
function _decodeSafeContents(safeContents, strict, password) {
  // if strict and no safe contents, return empty safes
  if(!strict && safeContents.length === 0) {
    return [];
  }

  // actually it's BER-encoded
  safeContents = asn1.fromDer(safeContents, strict);

  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||
    safeContents.type !== asn1.Type.SEQUENCE ||
    safeContents.constructed !== true) {
    throw new Error(
      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');
  }

  var res = [];
  for(var i = 0; i < safeContents.value.length; i++) {
    var safeBag = safeContents.value[i];

    // validate SafeBag and capture data
    var capture = {};
    var errors = [];
    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
      var error = new Error('Cannot read SafeBag.');
      error.errors = errors;
      throw error;
    }

    /* Create bag object and push to result array. */
    var bag = {
      type: asn1.derToOid(capture.bagId),
      attributes: _decodeBagAttributes(capture.bagAttributes)
    };
    res.push(bag);

    var validator, decoder;
    var bagAsn1 = capture.bagValue.value[0];
    switch(bag.type) {
      case pki.oids.pkcs8ShroudedKeyBag:
        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.
           Afterwards we can handle it like a keyBag,
           which is a PrivateKeyInfo. */
        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
        if(bagAsn1 === null) {
          throw new Error(
            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');
        }

        /* fall through */
      case pki.oids.keyBag:
        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our
           PKI module, hence we don't have to do validation/capturing here,
           just pass what we already got. */
        try {
          bag.key = pki.privateKeyFromAsn1(bagAsn1);
        } catch(e) {
          // ignore unknown key type, pass asn1 value
          bag.key = null;
          bag.asn1 = bagAsn1;
        }
        continue;  /* Nothing more to do. */

      case pki.oids.certBag:
        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.
           Therefore put the SafeBag content through another validator to
           capture the fields.  Afterwards check & store the results. */
        validator = certBagValidator;
        decoder = function() {
          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
            var error = new Error(
              'Unsupported certificate type, only X.509 supported.');
            error.oid = asn1.derToOid(capture.certId);
            throw error;
          }

          // true=produce cert hash
          var certAsn1 = asn1.fromDer(capture.cert, strict);
          try {
            bag.cert = pki.certificateFromAsn1(certAsn1, true);
          } catch(e) {
            // ignore unknown cert type, pass asn1 value
            bag.cert = null;
            bag.asn1 = certAsn1;
          }
        };
        break;

      default:
        var error = new Error('Unsupported PKCS#12 SafeBag type.');
        error.oid = bag.type;
        throw error;
    }

    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */
    if(validator !== undefined &&
       !asn1.validate(bagAsn1, validator, capture, errors)) {
      var error = new Error('Cannot read PKCS#12 ' + validator.name);
      error.errors = errors;
      throw error;
    }

    /* Call decoder function from above to store the results. */
    decoder();
  }

  return res;
}

/**
 * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.
 *
 * @param attributes SET OF PKCS12Attribute (ASN.1 object).
 *
 * @return the decoded attributes.
 */
function _decodeBagAttributes(attributes) {
  var decodedAttrs = {};

  if(attributes !== undefined) {
    for(var i = 0; i < attributes.length; ++i) {
      var capture = {};
      var errors = [];
      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
        var error = new Error('Cannot read PKCS#12 BagAttribute.');
        error.errors = errors;
        throw error;
      }

      var oid = asn1.derToOid(capture.oid);
      if(pki.oids[oid] === undefined) {
        // unsupported attribute type, ignore.
        continue;
      }

      decodedAttrs[pki.oids[oid]] = [];
      for(var j = 0; j < capture.values.length; ++j) {
        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
      }
    }
  }

  return decodedAttrs;
}

/**
 * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a
 * password is provided then the private key will be encrypted.
 *
 * An entire certificate chain may also be included. To do this, pass
 * an array for the "cert" parameter where the first certificate is
 * the one that is paired with the private key and each subsequent one
 * verifies the previous one. The certificates may be in PEM format or
 * have been already parsed by Forge.
 *
 * @todo implement password-based-encryption for the whole package
 *
 * @param key the private key.
 * @param cert the certificate (may be an array of certificates in order
 *          to specify a certificate chain).
 * @param password the password to use, null for none.
 * @param options:
 *          algorithm the encryption algorithm to use
 *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.
 *          count the iteration count to use.
 *          saltSize the salt size to use.
 *          useMac true to include a MAC, false not to, defaults to true.
 *          localKeyId the local key ID to use, in hex.
 *          friendlyName the friendly name to use.
 *          generateLocalKeyId true to generate a random local key ID,
 *            false not to, defaults to true.
 *
 * @return the PKCS#12 PFX ASN.1 object.
 */
p12.toPkcs12Asn1 = function(key, cert, password, options) {
  // set default options
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';
  if(!('useMac' in options)) {
    options.useMac = true;
  }
  if(!('localKeyId' in options)) {
    options.localKeyId = null;
  }
  if(!('generateLocalKeyId' in options)) {
    options.generateLocalKeyId = true;
  }

  var localKeyId = options.localKeyId;
  var bagAttrs;
  if(localKeyId !== null) {
    localKeyId = forge.util.hexToBytes(localKeyId);
  } else if(options.generateLocalKeyId) {
    // use SHA-1 of paired cert, if available
    if(cert) {
      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
      if(typeof pairedCert === 'string') {
        pairedCert = pki.certificateFromPem(pairedCert);
      }
      var sha1 = forge.md.sha1.create();
      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
      localKeyId = sha1.digest().getBytes();
    } else {
      // FIXME: consider using SHA-1 of public key (which can be generated
      // from private key components), see: cert.generateSubjectKeyIdentifier
      // generate random bytes
      localKeyId = forge.random.getBytes(20);
    }
  }

  var attrs = [];
  if(localKeyId !== null) {
    attrs.push(
      // localKeyID
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // attrId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.localKeyId).getBytes()),
        // attrValues
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
            localKeyId)
        ])
      ]));
  }
  if('friendlyName' in options) {
    attrs.push(
      // friendlyName
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // attrId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.friendlyName).getBytes()),
        // attrValues
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,
            options.friendlyName)
        ])
      ]));
  }

  if(attrs.length > 0) {
    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
  }

  // collect contents for AuthenticatedSafe
  var contents = [];

  // create safe bag(s) for certificate chain
  var chain = [];
  if(cert !== null) {
    if(forge.util.isArray(cert)) {
      chain = cert;
    } else {
      chain = [cert];
    }
  }

  var certSafeBags = [];
  for(var i = 0; i < chain.length; ++i) {
    // convert cert from PEM as necessary
    cert = chain[i];
    if(typeof cert === 'string') {
      cert = pki.certificateFromPem(cert);
    }

    // SafeBag
    var certBagAttrs = (i === 0) ? bagAttrs : undefined;
    var certAsn1 = pki.certificateToAsn1(cert);
    var certSafeBag =
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // bagId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.certBag).getBytes()),
        // bagValue
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // CertBag
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // certId
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),
            // certValue (x509Certificate)
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
                asn1.toDer(certAsn1).getBytes())
            ])])]),
        // bagAttributes (OPTIONAL)
        certBagAttrs
      ]);
    certSafeBags.push(certSafeBag);
  }

  if(certSafeBags.length > 0) {
    // SafeContents
    var certSafeContents = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);

    // ContentInfo
    var certCI =
      // PKCS#7 ContentInfo
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // contentType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          // OID for the content type is 'data'
          asn1.oidToDer(pki.oids.data).getBytes()),
        // content
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
            asn1.toDer(certSafeContents).getBytes())
        ])
      ]);
    contents.push(certCI);
  }

  // create safe contents for private key
  var keyBag = null;
  if(key !== null) {
    // SafeBag
    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
    if(password === null) {
      // no encryption
      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // bagId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.keyBag).getBytes()),
        // bagValue
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // PrivateKeyInfo
          pkAsn1
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    } else {
      // encrypted PrivateKeyInfo
      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // bagId
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),
        // bagValue
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // EncryptedPrivateKeyInfo
          pki.encryptPrivateKeyInfo(pkAsn1, password, options)
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    }

    // SafeContents
    var keySafeContents =
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);

    // ContentInfo
    var keyCI =
      // PKCS#7 ContentInfo
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // contentType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          // OID for the content type is 'data'
          asn1.oidToDer(pki.oids.data).getBytes()),
        // content
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
            asn1.toDer(keySafeContents).getBytes())
        ])
      ]);
    contents.push(keyCI);
  }

  // create AuthenticatedSafe by stringing together the contents
  var safe = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);

  var macData;
  if(options.useMac) {
    // MacData
    var sha1 = forge.md.sha1.create();
    var macSalt = new forge.util.ByteBuffer(
      forge.random.getBytes(options.saltSize));
    var count = options.count;
    // 160-bit key
    var key = p12.generateKey(password, macSalt, 3, count, 20);
    var mac = forge.hmac.create();
    mac.start(sha1, key);
    mac.update(asn1.toDer(safe).getBytes());
    var macValue = mac.getMac();
    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // mac DigestInfo
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm = SHA-1
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
            asn1.oidToDer(pki.oids.sha1).getBytes()),
          // parameters = Null
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
        ]),
        // digest
        asn1.create(
          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,
          false, macValue.getBytes())
      ]),
      // macSalt OCTET STRING
      asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),
      // iterations INTEGER (XXX: Only support count < 65536)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(count).getBytes()
      )
    ]);
  }

  // PFX
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (3)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(3).getBytes()),
    // PKCS#7 ContentInfo
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // contentType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        // OID for the content type is 'data'
        asn1.oidToDer(pki.oids.data).getBytes()),
      // content
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(
          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
          asn1.toDer(safe).getBytes())
      ])
    ]),
    macData
  ]);
};

/**
 * Derives a PKCS#12 key.
 *
 * @param password the password to derive the key material from, null or
 *          undefined for none.
 * @param salt the salt, as a ByteBuffer, to use.
 * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).
 * @param iter the iteration count.
 * @param n the number of bytes to derive from the password.
 * @param md the message digest to use, defaults to SHA-1.
 *
 * @return a ByteBuffer with the bytes derived from the password.
 */
p12.generateKey = forge.pbe.generatePkcs12Key;


/***/ }),

/***/ "./node_modules/node-forge/lib/pkcs7asn1.js":
/*!**************************************************!*\
  !*** ./node_modules/node-forge/lib/pkcs7asn1.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of ASN.1 validators for PKCS#7 v1.5.
 *
 * @author Dave Longley
 * @author Stefan Siegl
 *
 * Copyright (c) 2012-2015 Digital Bazaar, Inc.
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * The ASN.1 representation of PKCS#7 is as follows
 * (see RFC #2315 for details, http://www.ietf.org/rfc/rfc2315.txt):
 *
 * A PKCS#7 message consists of a ContentInfo on root level, which may
 * contain any number of further ContentInfo nested into it.
 *
 * ContentInfo ::= SEQUENCE {
 *   contentType                ContentType,
 *   content               [0]  EXPLICIT ANY DEFINED BY contentType OPTIONAL
 * }
 *
 * ContentType ::= OBJECT IDENTIFIER
 *
 * EnvelopedData ::= SEQUENCE {
 *   version                    Version,
 *   recipientInfos             RecipientInfos,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * EncryptedData ::= SEQUENCE {
 *   version                    Version,
 *   encryptedContentInfo       EncryptedContentInfo
 * }
 *
 * id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)
 *   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }
 *
 * SignedData ::= SEQUENCE {
 *   version           INTEGER,
 *   digestAlgorithms  DigestAlgorithmIdentifiers,
 *   contentInfo       ContentInfo,
 *   certificates      [0] IMPLICIT Certificates OPTIONAL,
 *   crls              [1] IMPLICIT CertificateRevocationLists OPTIONAL,
 *   signerInfos       SignerInfos
 * }
 *
 * SignerInfos ::= SET OF SignerInfo
 *
 * SignerInfo ::= SEQUENCE {
 *   version                    Version,
 *   issuerAndSerialNumber      IssuerAndSerialNumber,
 *   digestAlgorithm            DigestAlgorithmIdentifier,
 *   authenticatedAttributes    [0] IMPLICIT Attributes OPTIONAL,
 *   digestEncryptionAlgorithm  DigestEncryptionAlgorithmIdentifier,
 *   encryptedDigest            EncryptedDigest,
 *   unauthenticatedAttributes  [1] IMPLICIT Attributes OPTIONAL
 * }
 *
 * EncryptedDigest ::= OCTET STRING
 *
 * Attributes ::= SET OF Attribute
 *
 * Attribute ::= SEQUENCE {
 *   attrType    OBJECT IDENTIFIER,
 *   attrValues  SET OF AttributeValue
 * }
 *
 * AttributeValue ::= ANY
 *
 * Version ::= INTEGER
 *
 * RecipientInfos ::= SET OF RecipientInfo
 *
 * EncryptedContentInfo ::= SEQUENCE {
 *   contentType                 ContentType,
 *   contentEncryptionAlgorithm  ContentEncryptionAlgorithmIdentifier,
 *   encryptedContent       [0]  IMPLICIT EncryptedContent OPTIONAL
 * }
 *
 * ContentEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of AES and DES3, there is only one,
 * the IV.
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *    algorithm OBJECT IDENTIFIER,
 *    parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * EncryptedContent ::= OCTET STRING
 *
 * RecipientInfo ::= SEQUENCE {
 *   version                     Version,
 *   issuerAndSerialNumber       IssuerAndSerialNumber,
 *   keyEncryptionAlgorithm      KeyEncryptionAlgorithmIdentifier,
 *   encryptedKey                EncryptedKey
 * }
 *
 * IssuerAndSerialNumber ::= SEQUENCE {
 *   issuer                      Name,
 *   serialNumber                CertificateSerialNumber
 * }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * KeyEncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
 *
 * EncryptedKey ::= OCTET STRING
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

// shortcut for ASN.1 API
var asn1 = forge.asn1;

// shortcut for PKCS#7 API
var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
forge.pkcs7 = forge.pkcs7 || {};
forge.pkcs7.asn1 = p7v;

var contentInfoValidator = {
  name: 'ContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'ContentInfo.ContentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'ContentInfo.content',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: 'content'
  }]
};
p7v.contentInfoValidator = contentInfoValidator;

var encryptedContentInfoValidator = {
  name: 'EncryptedContentInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedContentInfo.contentType',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OID,
    constructed: false,
    capture: 'contentType'
  }, {
    name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'EncryptedContentInfo.encryptedContent',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: 'encryptedContent',
    captureAsn1: 'encryptedContentAsn1'
  }]
};

p7v.envelopedDataValidator = {
  name: 'EnvelopedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EnvelopedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'EnvelopedData.RecipientInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'recipientInfos'
  }].concat(encryptedContentInfoValidator)
};

p7v.encryptedDataValidator = {
  name: 'EncryptedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'EncryptedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }].concat(encryptedContentInfoValidator)
};

var signerValidator = {
  name: 'SignerInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignerInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false
  }, {
    name: 'SignerInfo.issuerAndSerialNumber',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.issuerAndSerialNumber.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'SignerInfo.digestAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'SignerInfo.digestAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'digestAlgorithm'
    }, {
      name: 'SignerInfo.digestAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'digestParameter',
      optional: true
    }]
  }, {
    name: 'SignerInfo.authenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'authenticatedAttributes'
  }, {
    name: 'SignerInfo.digestEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    capture: 'signatureAlgorithm'
  }, {
    name: 'SignerInfo.encryptedDigest',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'signature'
  }, {
    name: 'SignerInfo.unauthenticatedAttributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: 'unauthenticatedAttributes'
  }]
};

p7v.signedDataValidator = {
  name: 'SignedData',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'SignedData.Version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'SignedData.DigestAlgorithms',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    constructed: true,
    captureAsn1: 'digestAlgorithms'
  },
  contentInfoValidator,
  {
    name: 'SignedData.Certificates',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    optional: true,
    captureAsn1: 'certificates'
  }, {
    name: 'SignedData.CertificateRevocationLists',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    optional: true,
    captureAsn1: 'crls'
  }, {
    name: 'SignedData.SignerInfos',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SET,
    capture: 'signerInfos',
    optional: true,
    value: [signerValidator]
  }]
};

p7v.recipientInfoValidator = {
  name: 'RecipientInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'RecipientInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'version'
  }, {
    name: 'RecipientInfo.issuerAndSerial',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.issuerAndSerial.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'issuer'
    }, {
      name: 'RecipientInfo.issuerAndSerial.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'serial'
    }]
  }, {
    name: 'RecipientInfo.keyEncryptionAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'encAlgorithm'
    }, {
      name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
      tagClass: asn1.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: 'encParameter'
    }]
  }, {
    name: 'RecipientInfo.encryptedKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'encKey'
  }]
};


/***/ }),

/***/ "./node_modules/node-forge/lib/pki.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pki.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of a basic Public Key Infrastructure, including
 * support for RSA public and private keys.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2013 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");
__webpack_require__(/*! ./pbe */ "./node_modules/node-forge/lib/pbe.js");
__webpack_require__(/*! ./pem */ "./node_modules/node-forge/lib/pem.js");
__webpack_require__(/*! ./pbkdf2 */ "./node_modules/node-forge/lib/pbkdf2.js");
__webpack_require__(/*! ./pkcs12 */ "./node_modules/node-forge/lib/pkcs12.js");
__webpack_require__(/*! ./pss */ "./node_modules/node-forge/lib/pss.js");
__webpack_require__(/*! ./rsa */ "./node_modules/node-forge/lib/rsa.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");
__webpack_require__(/*! ./x509 */ "./node_modules/node-forge/lib/x509.js");

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Public Key Infrastructure (PKI) implementation. */
var pki = module.exports = forge.pki = forge.pki || {};

/**
 * NOTE: THIS METHOD IS DEPRECATED. Use pem.decode() instead.
 *
 * Converts PEM-formatted data to DER.
 *
 * @param pem the PEM-formatted data.
 *
 * @return the DER-formatted data.
 */
pki.pemToDer = function(pem) {
  var msg = forge.pem.decode(pem)[0];
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert PEM to DER; PEM is encrypted.');
  }
  return forge.util.createBuffer(msg.body);
};

/**
 * Converts an RSA private key from PEM format.
 *
 * @param pem the PEM-formatted private key.
 *
 * @return the private key.
 */
pki.privateKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PRIVATE KEY' && msg.type !== 'RSA PRIVATE KEY') {
    var error = new Error('Could not convert private key from PEM; PEM ' +
      'header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert private key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.privateKeyFromAsn1(obj);
};

/**
 * Converts an RSA private key to PEM format.
 *
 * @param key the private key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */
pki.privateKeyToPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PRIVATE KEY',
    body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts a PrivateKeyInfo to PEM format.
 *
 * @param pki the PrivateKeyInfo.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted private key.
 */
pki.privateKeyInfoToPem = function(pki, maxline) {
  // convert to DER, then PEM-encode
  var msg = {
    type: 'PRIVATE KEY',
    body: asn1.toDer(pki).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};


/***/ }),

/***/ "./node_modules/node-forge/lib/prime.js":
/*!**********************************************!*\
  !*** ./node_modules/node-forge/lib/prime.js ***!
  \**********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Prime number generation API.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");
__webpack_require__(/*! ./jsbn */ "./node_modules/node-forge/lib/jsbn.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");

(function() {

// forge.prime already defined
if(forge.prime) {
  module.exports = forge.prime;
  return;
}

/* PRIME API */
var prime = module.exports = forge.prime = forge.prime || {};

var BigInteger = forge.jsbn.BigInteger;

// primes are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var THIRTY = new BigInteger(null);
THIRTY.fromInt(30);
var op_or = function(x, y) {return x|y;};

/**
 * Generates a random probable prime with the given number of bits.
 *
 * Alternative algorithms can be specified by name as a string or as an
 * object with custom options like so:
 *
 * {
 *   name: 'PRIMEINC',
 *   options: {
 *     maxBlockTime: <the maximum amount of time to block the main
 *       thread before allowing I/O other JS to run>,
 *     millerRabinTests: <the number of miller-rabin tests to run>,
 *     workerScript: <the worker script URL>,
 *     workers: <the number of web workers (if supported) to use,
 *       -1 to use estimated cores minus one>.
 *     workLoad: the size of the work load, ie: number of possible prime
 *       numbers for each web worker to check per work assignment,
 *       (default: 100).
 *   }
 * }
 *
 * @param bits the number of bits for the prime number.
 * @param options the options to use.
 *          [algorithm] the algorithm to use (default: 'PRIMEINC').
 *          [prng] a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *
 * @return callback(err, num) called once the operation completes.
 */
prime.generateProbablePrime = function(bits, options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};

  // default to PRIMEINC algorithm
  var algorithm = options.algorithm || 'PRIMEINC';
  if(typeof algorithm === 'string') {
    algorithm = {name: algorithm};
  }
  algorithm.options = algorithm.options || {};

  // create prng with api that matches BigInteger secure random
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  if(algorithm.name === 'PRIMEINC') {
    return primeincFindPrime(bits, rng, algorithm.options, callback);
  }

  throw new Error('Invalid prime generation algorithm: ' + algorithm.name);
};

function primeincFindPrime(bits, rng, options, callback) {
  if('workers' in options) {
    return primeincFindPrimeWithWorkers(bits, rng, options, callback);
  }
  return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
}

function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
  // initialize random number
  var num = generateRandom(bits, rng);

  /* Note: All primes are of the form 30k+i for i < 30 and gcd(30, i)=1. The
  number we are given is always aligned at 30k + 1. Each time the number is
  determined not to be prime we add to get to the next 'i', eg: if the number
  was at 30k + 1 we add 6. */
  var deltaIdx = 0;

  // get required number of MR tests
  var mrTests = getMillerRabinTests(num.bitLength());
  if('millerRabinTests' in options) {
    mrTests = options.millerRabinTests;
  }

  // find prime nearest to 'num' for maxBlockTime ms
  // 10 ms gives 5ms of leeway for other calculations before dropping
  // below 60fps (1000/60 == 16.67), but in reality, the number will
  // likely be higher due to an 'atomic' big int modPow
  var maxBlockTime = 10;
  if('maxBlockTime' in options) {
    maxBlockTime = options.maxBlockTime;
  }

  _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
}

function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
  var start = +new Date();
  do {
    // overflow, regenerate random number
    if(num.bitLength() > bits) {
      num = generateRandom(bits, rng);
    }
    // do primality test
    if(num.isProbablePrime(mrTests)) {
      return callback(null, num);
    }
    // get next potential prime
    num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
  } while(maxBlockTime < 0 || (+new Date() - start < maxBlockTime));

  // keep trying later
  forge.util.setImmediate(function() {
    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  });
}

// NOTE: This algorithm is indeterminate in nature because workers
// run in parallel looking at different segments of numbers. Even if this
// algorithm is run twice with the same input from a predictable RNG, it
// may produce different outputs.
function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
  // web workers unavailable
  if(typeof Worker === 'undefined') {
    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }

  // initialize random number
  var num = generateRandom(bits, rng);

  // use web workers to generate keys
  var numWorkers = options.workers;
  var workLoad = options.workLoad || 100;
  var range = workLoad * 30 / 8;
  var workerScript = options.workerScript || 'forge/prime.worker.js';
  if(numWorkers === -1) {
    return forge.util.estimateCores(function(err, cores) {
      if(err) {
        // default to 2
        cores = 2;
      }
      numWorkers = cores - 1;
      generate();
    });
  }
  generate();

  function generate() {
    // require at least 1 worker
    numWorkers = Math.max(1, numWorkers);

    // TODO: consider optimizing by starting workers outside getPrime() ...
    // note that in order to clean up they will have to be made internally
    // asynchronous which may actually be slower

    // start workers immediately
    var workers = [];
    for(var i = 0; i < numWorkers; ++i) {
      // FIXME: fix path or use blob URLs
      workers[i] = new Worker(workerScript);
    }
    var running = numWorkers;

    // listen for requests from workers and assign ranges to find prime
    for(var i = 0; i < numWorkers; ++i) {
      workers[i].addEventListener('message', workerMessage);
    }

    /* Note: The distribution of random numbers is unknown. Therefore, each
    web worker is continuously allocated a range of numbers to check for a
    random number until one is found.

    Every 30 numbers will be checked just 8 times, because prime numbers
    have the form:

    30k+i, for i < 30 and gcd(30, i)=1 (there are 8 values of i for this)

    Therefore, if we want a web worker to run N checks before asking for
    a new range of numbers, each range must contain N*30/8 numbers.

    For 100 checks (workLoad), this is a range of 375. */

    var found = false;
    function workerMessage(e) {
      // ignore message, prime already found
      if(found) {
        return;
      }

      --running;
      var data = e.data;
      if(data.found) {
        // terminate all workers
        for(var i = 0; i < workers.length; ++i) {
          workers[i].terminate();
        }
        found = true;
        return callback(null, new BigInteger(data.prime, 16));
      }

      // overflow, regenerate random number
      if(num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      }

      // assign new range to check
      var hex = num.toString(16);

      // start prime search
      e.target.postMessage({
        hex: hex,
        workLoad: workLoad
      });

      num.dAddOffset(range, 0);
    }
  }
}

/**
 * Generates a random number using the given number of bits and RNG.
 *
 * @param bits the number of bits for the number.
 * @param rng the random number generator to use.
 *
 * @return the random number.
 */
function generateRandom(bits, rng) {
  var num = new BigInteger(bits, rng);
  // force MSB set
  var bits1 = bits - 1;
  if(!num.testBit(bits1)) {
    num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
  }
  // align number on 30k+1 boundary
  num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
  return num;
}

/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */
function getMillerRabinTests(bits) {
  if(bits <= 100) return 27;
  if(bits <= 150) return 18;
  if(bits <= 200) return 15;
  if(bits <= 250) return 12;
  if(bits <= 300) return 9;
  if(bits <= 350) return 8;
  if(bits <= 400) return 7;
  if(bits <= 500) return 6;
  if(bits <= 600) return 5;
  if(bits <= 800) return 4;
  if(bits <= 1250) return 3;
  return 2;
}

})();


/***/ }),

/***/ "./node_modules/node-forge/lib/prng.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/prng.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * A javascript implementation of a cryptographically-secure
 * Pseudo Random Number Generator (PRNG). The Fortuna algorithm is followed
 * here though the use of SHA-256 is not enforced; when generating an
 * a PRNG context, the hashing algorithm and block cipher used for
 * the generator are specified via a plugin.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var _crypto = null;
if(forge.util.isNodejs && !forge.options.usePureJavaScript &&
  !process.versions['node-webkit']) {
  _crypto = __webpack_require__(/*! crypto */ 0);
}

/* PRNG API */
var prng = module.exports = forge.prng = forge.prng || {};

/**
 * Creates a new PRNG context.
 *
 * A PRNG plugin must be passed in that will provide:
 *
 * 1. A function that initializes the key and seed of a PRNG context. It
 *   will be given a 16 byte key and a 16 byte seed. Any key expansion
 *   or transformation of the seed from a byte string into an array of
 *   integers (or similar) should be performed.
 * 2. The cryptographic function used by the generator. It takes a key and
 *   a seed.
 * 3. A seed increment function. It takes the seed and returns seed + 1.
 * 4. An api to create a message digest.
 *
 * For an example, see random.js.
 *
 * @param plugin the PRNG plugin to use.
 */
prng.create = function(plugin) {
  var ctx = {
    plugin: plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ''
  };

  // create 32 entropy pools (each is a message digest)
  var md = plugin.md;
  var pools = new Array(32);
  for(var i = 0; i < 32; ++i) {
    pools[i] = md.create();
  }
  ctx.pools = pools;

  // entropy pools are written to cyclically, starting at index 0
  ctx.pool = 0;

  /**
   * Generates random bytes. The bytes may be generated synchronously or
   * asynchronously. Web workers must use the asynchronous interface or
   * else the behavior is undefined.
   *
   * @param count the number of random bytes to generate.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return count random bytes as a string.
   */
  ctx.generate = function(count, callback) {
    // do synchronously
    if(!callback) {
      return ctx.generateSync(count);
    }

    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge.util.createBuffer();

    // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generate` call
    ctx.key = null;

    generate();

    function generate(err) {
      if(err) {
        return callback(err);
      }

      // sufficient bytes generated
      if(b.length() >= count) {
        return callback(null, b.getBytes(count));
      }

      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        // prevent stack overflow
        return forge.util.nextTick(function() {
          _reseed(generate);
        });
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));

      forge.util.setImmediate(generate);
    }
  };

  /**
   * Generates random bytes synchronously.
   *
   * @param count the number of random bytes to generate.
   *
   * @return count random bytes as a string.
   */
  ctx.generateSync = function(count) {
    // simple generator using counter-based CBC
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;

    // paranoid deviation from Fortuna:
    // reset key for every request to protect previously
    // generated random bytes should the key be discovered;
    // there is no 100ms based reseeding because of this
    // forced reseed for every `generateSync` call
    ctx.key = null;

    var b = forge.util.createBuffer();
    while(b.length() < count) {
      // if amount of data generated is greater than 1 MiB, trigger reseed
      if(ctx.generated > 0xfffff) {
        ctx.key = null;
      }

      if(ctx.key === null) {
        _reseedSync();
      }

      // generate the random bytes
      var bytes = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes.length;
      b.putBytes(bytes);

      // generate bytes for a new key and seed
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }

    return b.getBytes(count);
  };

  /**
   * Private function that asynchronously reseeds a generator.
   *
   * @param callback(err) called once the operation completes.
   */
  function _reseed(callback) {
    if(ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.seedFile(needed, function(err, bytes) {
      if(err) {
        return callback(err);
      }
      ctx.collect(bytes);
      _seed();
      callback();
    });
  }

  /**
   * Private function that synchronously reseeds a generator.
   */
  function _reseedSync() {
    if(ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    // not enough seed data...
    var needed = (32 - ctx.pools[0].messageLength) << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }

  /**
   * Private function that seeds a generator once enough bytes are available.
   */
  function _seed() {
    // update reseed count
    ctx.reseeds = (ctx.reseeds === 0xffffffff) ? 0 : ctx.reseeds + 1;

    // goal is to update `key` via:
    // key = hash(key + s)
    //   where 's' is all collected entropy from selected pools, then...

    // create a plugin-based message digest
    var md = ctx.plugin.md.create();

    // consume current key bytes
    md.update(ctx.keyBytes);

    // digest the entropy of pools whose index k meet the
    // condition 'n mod 2^k == 0' where n is the number of reseeds
    var _2powK = 1;
    for(var k = 0; k < 32; ++k) {
      if(ctx.reseeds % _2powK === 0) {
        md.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }
      _2powK = _2powK << 1;
    }

    // get digest for key bytes
    ctx.keyBytes = md.digest().getBytes();

    // paranoid deviation from Fortuna:
    // update `seed` via `seed = hash(key)`
    // instead of initializing to zero once and only
    // ever incrementing it
    md.start();
    md.update(ctx.keyBytes);
    var seedBytes = md.digest().getBytes();

    // update state
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }

  /**
   * The built-in default seedFile. This seedFile is used when entropy
   * is needed immediately.
   *
   * @param needed the number of bytes that are needed.
   *
   * @return the random bytes.
   */
  function defaultSeedFile(needed) {
    // use window.crypto.getRandomValues strong source of entropy if available
    var getRandomValues = null;
    var globalScope = forge.util.globalScope;
    var _crypto = globalScope.crypto || globalScope.msCrypto;
    if(_crypto && _crypto.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto.getRandomValues(arr);
      };
    }

    var b = forge.util.createBuffer();
    if(getRandomValues) {
      while(b.length() < needed) {
        // max byte length is 65536 before QuotaExceededError is thrown
        // http://www.w3.org/TR/WebCryptoAPI/#RandomSource-method-getRandomValues
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for(var i = 0; i < entropy.length; ++i) {
            b.putInt32(entropy[i]);
          }
        } catch(e) {
          /* only ignore QuotaExceededError */
          if(!(typeof QuotaExceededError !== 'undefined' &&
            e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    }

    // be sad and add some weak random data
    if(b.length() < needed) {
      /* Draws from Park-Miller "minimal standard" 31 bit PRNG,
      implemented with David G. Carta's optimization: with 32 bit math
      and without division (Public Domain). */
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 0x010000);
      while(b.length() < needed) {
        lo = 16807 * (seed & 0xFFFF);
        hi = 16807 * (seed >> 16);
        lo += (hi & 0x7FFF) << 16;
        lo += hi >> 15;
        lo = (lo & 0x7FFFFFFF) + (lo >> 31);
        seed = lo & 0xFFFFFFFF;

        // consume lower 3 bytes of seed
        for(var i = 0; i < 3; ++i) {
          // throw in more pseudo random
          next = seed >>> (i << 3);
          next ^= Math.floor(Math.random() * 0x0100);
          b.putByte(String.fromCharCode(next & 0xFF));
        }
      }
    }

    return b.getBytes(needed);
  }
  // initialize seed file APIs
  if(_crypto) {
    // use nodejs async API
    ctx.seedFile = function(needed, callback) {
      _crypto.randomBytes(needed, function(err, bytes) {
        if(err) {
          return callback(err);
        }
        callback(null, bytes.toString());
      });
    };
    // use nodejs sync API
    ctx.seedFileSync = function(needed) {
      return _crypto.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch(e) {
        callback(e);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }

  /**
   * Adds entropy to a prng ctx's accumulator.
   *
   * @param bytes the bytes of entropy as a string.
   */
  ctx.collect = function(bytes) {
    // iterate over pools distributing entropy cyclically
    var count = bytes.length;
    for(var i = 0; i < count; ++i) {
      ctx.pools[ctx.pool].update(bytes.substr(i, 1));
      ctx.pool = (ctx.pool === 31) ? 0 : ctx.pool + 1;
    }
  };

  /**
   * Collects an integer of n bits.
   *
   * @param i the integer entropy.
   * @param n the number of bits in the integer.
   */
  ctx.collectInt = function(i, n) {
    var bytes = '';
    for(var x = 0; x < n; x += 8) {
      bytes += String.fromCharCode((i >> x) & 0xFF);
    }
    ctx.collect(bytes);
  };

  /**
   * Registers a Web Worker to receive immediate entropy from the main thread.
   * This method is required until Web Workers can access the native crypto
   * API. This method should be called twice for each created worker, once in
   * the main thread, and once in the worker itself.
   *
   * @param worker the worker to register.
   */
  ctx.registerWorker = function(worker) {
    // worker receives random bytes
    if(worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener(e) {
          var data = e.data;
          if(data.forge && data.forge.prng) {
            self.removeEventListener('message', listener);
            callback(data.forge.prng.err, data.forge.prng.bytes);
          }
        }
        self.addEventListener('message', listener);
        self.postMessage({forge: {prng: {needed: needed}}});
      };
    } else {
      // main thread sends random bytes upon request
      var listener = function(e) {
        var data = e.data;
        if(data.forge && data.forge.prng) {
          ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
            worker.postMessage({forge: {prng: {err: err, bytes: bytes}}});
          });
        }
      };
      // TODO: do we need to remove the event listener when the worker dies?
      worker.addEventListener('message', listener);
    }
  };

  return ctx;
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/node-forge/lib/pss.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/pss.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of PKCS#1 PSS signature padding.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

// shortcut for PSS API
var pss = module.exports = forge.pss = forge.pss || {};

/**
 * Creates a PSS signature scheme object.
 *
 * There are several ways to provide a salt for encoding:
 *
 * 1. Specify the saltLength only and the built-in PRNG will generate it.
 * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that
 *   will be used.
 * 3. Specify the salt itself as a forge.util.ByteBuffer.
 *
 * @param options the options to use:
 *          md the message digest object to use, a forge md instance.
 *          mgf the mask generation function to use, a forge mgf instance.
 *          [saltLength] the length of the salt in octets.
 *          [prng] the pseudo-random number generator to use to produce a salt.
 *          [salt] the salt to use when encoding.
 *
 * @return a signature scheme object.
 */
pss.create = function(options) {
  // backwards compatibility w/legacy args: hash, mgf, sLen
  if(arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }

  var hash = options.md;
  var mgf = options.mgf;
  var hLen = hash.digestLength;

  var salt_ = options.salt || null;
  if(typeof salt_ === 'string') {
    // assume binary-encoded string
    salt_ = forge.util.createBuffer(salt_);
  }

  var sLen;
  if('saltLength' in options) {
    sLen = options.saltLength;
  } else if(salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error('Salt length not specified or specific salt not given.');
  }

  if(salt_ !== null && salt_.length() !== sLen) {
    throw new Error('Given salt length does not match length of given salt.');
  }

  var prng = options.prng || forge.random;

  var pssobj = {};

  /**
   * Encodes a PSS signature.
   *
   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.
   *
   * @param md the message digest object with the hash to sign.
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return the encoded message as a binary-encoded string of length
   *           ceil((modBits - 1) / 8).
   */
  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* 2. Let mHash = Hash(M), an octet string of length hLen. */
    var mHash = md.digest().getBytes();

    /* 3. If emLen < hLen + sLen + 2, output "encoding error" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Message is too long to encrypt.');
    }

    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,
     *    then salt is the empty string. */
    var salt;
    if(salt_ === null) {
      salt = prng.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }

    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 6. Let H = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h = hash.digest().getBytes();

    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2
     *    zero octets.  The length of PS may be 0. */
    var ps = new forge.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);

    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length
     *    emLen - hLen - 1. */
    ps.putByte(0x01);
    ps.putBytes(salt);
    var db = ps.getBytes();

    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h, maskLen);

    /* 10. Let maskedDB = DB \xor dbMask. */
    var maskedDB = '';
    for(i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in
     *     maskedDB to zero. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +
      maskedDB.substr(1);

    /* 12. Let EM = maskedDB || H || 0xbc.
     * 13. Output EM. */
    return maskedDB + h + String.fromCharCode(0xbc);
  };

  /**
   * Verifies a PSS signature.
   *
   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.
   *
   * @param mHash the message digest hash, as a binary-encoded string, to
   *         compare against the signature.
   * @param em the encoded message, as a binary-encoded string
   *          (RSA decryption result).
   * @param modsBits the length of the RSA modulus in bits.
   *
   * @return true if the signature was verified, false if not.
   */
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);

    /* c. Convert the message representative m to an encoded message EM
     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits
     *    is the length in bits of the RSA modulus n */
    em = em.substr(-emLen);

    /* 3. If emLen < hLen + sLen + 2, output "inconsistent" and stop. */
    if(emLen < hLen + sLen + 2) {
      throw new Error('Inconsistent parameters to PSS signature verification.');
    }

    /* 4. If the rightmost octet of EM does not have hexadecimal value
     *    0xbc, output "inconsistent" and stop. */
    if(em.charCodeAt(emLen - 1) !== 0xbc) {
      throw new Error('Encoded message does not end in 0xBC.');
    }

    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
     *    let H be the next hLen octets. */
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h = em.substr(maskLen, hLen);

    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in
     *    maskedDB are not all equal to zero, output "inconsistent" and stop. */
    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;
    if((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error('Bits beyond keysize not zero as expected.');
    }

    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */
    var dbMask = mgf.generate(h, maskLen);

    /* 8. Let DB = maskedDB \xor dbMask. */
    var db = '';
    for(i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }

    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet
     * in DB to zero. */
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);

    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost
     * position is "position 1") does not have hexadecimal value 0x01,
     * output "inconsistent" and stop. */
    var checkLen = emLen - hLen - sLen - 2;
    for(i = 0; i < checkLen; i++) {
      if(db.charCodeAt(i) !== 0x00) {
        throw new Error('Leftmost octets not zero as expected');
      }
    }

    if(db.charCodeAt(checkLen) !== 0x01) {
      throw new Error('Inconsistent PSS signature, 0x01 marker not found');
    }

    /* 11. Let salt be the last sLen octets of DB. */
    var salt = db.substr(-sLen);

    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */
    var m_ = new forge.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);

    /* 13. Let H' = Hash(M'), an octet string of length hLen. */
    hash.start();
    hash.update(m_.getBytes());
    var h_ = hash.digest().getBytes();

    /* 14. If H = H', output "consistent." Otherwise, output "inconsistent." */
    return h === h_;
  };

  return pssobj;
};


/***/ }),

/***/ "./node_modules/node-forge/lib/random.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/random.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * An API for getting cryptographically-secure random bytes. The bytes are
 * generated using the Fortuna algorithm devised by Bruce Schneier and
 * Niels Ferguson.
 *
 * Getting strong random bytes is not yet easy to do in javascript. The only
 * truish random entropy that can be collected is from the mouse, keyboard, or
 * from timing with respect to page loads, etc. This generator makes a poor
 * attempt at providing random bytes when those sources haven't yet provided
 * enough entropy to initially seed or to reseed the PRNG.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2009-2014 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./aes */ "./node_modules/node-forge/lib/aes.js");
__webpack_require__(/*! ./sha256 */ "./node_modules/node-forge/lib/sha256.js");
__webpack_require__(/*! ./prng */ "./node_modules/node-forge/lib/prng.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

(function() {

// forge.random already defined
if(forge.random && forge.random.getBytes) {
  module.exports = forge.random;
  return;
}

(function(jQuery) {

// the default prng plugin, uses AES-128
var prng_aes = {};
var _prng_aes_output = new Array(4);
var _prng_aes_buffer = forge.util.createBuffer();
prng_aes.formatKey = function(key) {
  // convert the key into 32-bit integers
  var tmp = forge.util.createBuffer(key);
  key = new Array(4);
  key[0] = tmp.getInt32();
  key[1] = tmp.getInt32();
  key[2] = tmp.getInt32();
  key[3] = tmp.getInt32();

  // return the expanded key
  return forge.aes._expandKey(key, false);
};
prng_aes.formatSeed = function(seed) {
  // convert seed into 32-bit integers
  var tmp = forge.util.createBuffer(seed);
  seed = new Array(4);
  seed[0] = tmp.getInt32();
  seed[1] = tmp.getInt32();
  seed[2] = tmp.getInt32();
  seed[3] = tmp.getInt32();
  return seed;
};
prng_aes.cipher = function(key, seed) {
  forge.aes._updateBlock(key, seed, _prng_aes_output, false);
  _prng_aes_buffer.putInt32(_prng_aes_output[0]);
  _prng_aes_buffer.putInt32(_prng_aes_output[1]);
  _prng_aes_buffer.putInt32(_prng_aes_output[2]);
  _prng_aes_buffer.putInt32(_prng_aes_output[3]);
  return _prng_aes_buffer.getBytes();
};
prng_aes.increment = function(seed) {
  // FIXME: do we care about carry or signed issues?
  ++seed[3];
  return seed;
};
prng_aes.md = forge.md.sha256;

/**
 * Creates a new PRNG.
 */
function spawnPrng() {
  var ctx = forge.prng.create(prng_aes);

  /**
   * Gets random bytes. If a native secure crypto API is unavailable, this
   * method tries to make the bytes more unpredictable by drawing from data that
   * can be collected from the user of the browser, eg: mouse movement.
   *
   * If a callback is given, this method will be called asynchronously.
   *
   * @param count the number of random bytes to get.
   * @param [callback(err, bytes)] called once the operation completes.
   *
   * @return the random bytes in a string.
   */
  ctx.getBytes = function(count, callback) {
    return ctx.generate(count, callback);
  };

  /**
   * Gets random bytes asynchronously. If a native secure crypto API is
   * unavailable, this method tries to make the bytes more unpredictable by
   * drawing from data that can be collected from the user of the browser,
   * eg: mouse movement.
   *
   * @param count the number of random bytes to get.
   *
   * @return the random bytes in a string.
   */
  ctx.getBytesSync = function(count) {
    return ctx.generate(count);
  };

  return ctx;
}

// create default prng context
var _ctx = spawnPrng();

// add other sources of entropy only if window.crypto.getRandomValues is not
// available -- otherwise this source will be automatically used by the prng
var getRandomValues = null;
var globalScope = forge.util.globalScope;
var _crypto = globalScope.crypto || globalScope.msCrypto;
if(_crypto && _crypto.getRandomValues) {
  getRandomValues = function(arr) {
    return _crypto.getRandomValues(arr);
  };
}

if(forge.options.usePureJavaScript ||
  (!forge.util.isNodejs && !getRandomValues)) {
  // if this is a web worker, do not use weak entropy, instead register to
  // receive strong entropy asynchronously from the main thread
  if(typeof window === 'undefined' || window.document === undefined) {
    // FIXME:
  }

  // get load time entropy
  _ctx.collectInt(+new Date(), 32);

  // add some entropy from navigator object
  if(typeof(navigator) !== 'undefined') {
    var _navBytes = '';
    for(var key in navigator) {
      try {
        if(typeof(navigator[key]) == 'string') {
          _navBytes += navigator[key];
        }
      } catch(e) {
        /* Some navigator keys might not be accessible, e.g. the geolocation
          attribute throws an exception if touched in Mozilla chrome://
          context.

          Silently ignore this and just don't use this as a source of
          entropy. */
      }
    }
    _ctx.collect(_navBytes);
    _navBytes = null;
  }

  // add mouse and keyboard collectors if jquery is available
  if(jQuery) {
    // set up mouse entropy capture
    jQuery().mousemove(function(e) {
      // add mouse coords
      _ctx.collectInt(e.clientX, 16);
      _ctx.collectInt(e.clientY, 16);
    });

    // set up keyboard entropy capture
    jQuery().keypress(function(e) {
      _ctx.collectInt(e.charCode, 8);
    });
  }
}

/* Random API */
if(!forge.random) {
  forge.random = _ctx;
} else {
  // extend forge.random with _ctx
  for(var key in _ctx) {
    forge.random[key] = _ctx[key];
  }
}

// expose spawn PRNG
forge.random.createInstance = spawnPrng;

module.exports = forge.random;

})(typeof(jQuery) !== 'undefined' ? jQuery : null);

})();


/***/ }),

/***/ "./node_modules/node-forge/lib/rc2.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rc2.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * RC2 implementation.
 *
 * @author Stefan Siegl
 *
 * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>
 *
 * Information on the RC2 cipher is available from RFC #2268,
 * http://www.ietf.org/rfc/rfc2268.txt
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var piTable = [
  0xd9, 0x78, 0xf9, 0xc4, 0x19, 0xdd, 0xb5, 0xed, 0x28, 0xe9, 0xfd, 0x79, 0x4a, 0xa0, 0xd8, 0x9d,
  0xc6, 0x7e, 0x37, 0x83, 0x2b, 0x76, 0x53, 0x8e, 0x62, 0x4c, 0x64, 0x88, 0x44, 0x8b, 0xfb, 0xa2,
  0x17, 0x9a, 0x59, 0xf5, 0x87, 0xb3, 0x4f, 0x13, 0x61, 0x45, 0x6d, 0x8d, 0x09, 0x81, 0x7d, 0x32,
  0xbd, 0x8f, 0x40, 0xeb, 0x86, 0xb7, 0x7b, 0x0b, 0xf0, 0x95, 0x21, 0x22, 0x5c, 0x6b, 0x4e, 0x82,
  0x54, 0xd6, 0x65, 0x93, 0xce, 0x60, 0xb2, 0x1c, 0x73, 0x56, 0xc0, 0x14, 0xa7, 0x8c, 0xf1, 0xdc,
  0x12, 0x75, 0xca, 0x1f, 0x3b, 0xbe, 0xe4, 0xd1, 0x42, 0x3d, 0xd4, 0x30, 0xa3, 0x3c, 0xb6, 0x26,
  0x6f, 0xbf, 0x0e, 0xda, 0x46, 0x69, 0x07, 0x57, 0x27, 0xf2, 0x1d, 0x9b, 0xbc, 0x94, 0x43, 0x03,
  0xf8, 0x11, 0xc7, 0xf6, 0x90, 0xef, 0x3e, 0xe7, 0x06, 0xc3, 0xd5, 0x2f, 0xc8, 0x66, 0x1e, 0xd7,
  0x08, 0xe8, 0xea, 0xde, 0x80, 0x52, 0xee, 0xf7, 0x84, 0xaa, 0x72, 0xac, 0x35, 0x4d, 0x6a, 0x2a,
  0x96, 0x1a, 0xd2, 0x71, 0x5a, 0x15, 0x49, 0x74, 0x4b, 0x9f, 0xd0, 0x5e, 0x04, 0x18, 0xa4, 0xec,
  0xc2, 0xe0, 0x41, 0x6e, 0x0f, 0x51, 0xcb, 0xcc, 0x24, 0x91, 0xaf, 0x50, 0xa1, 0xf4, 0x70, 0x39,
  0x99, 0x7c, 0x3a, 0x85, 0x23, 0xb8, 0xb4, 0x7a, 0xfc, 0x02, 0x36, 0x5b, 0x25, 0x55, 0x97, 0x31,
  0x2d, 0x5d, 0xfa, 0x98, 0xe3, 0x8a, 0x92, 0xae, 0x05, 0xdf, 0x29, 0x10, 0x67, 0x6c, 0xba, 0xc9,
  0xd3, 0x00, 0xe6, 0xcf, 0xe1, 0x9e, 0xa8, 0x2c, 0x63, 0x16, 0x01, 0x3f, 0x58, 0xe2, 0x89, 0xa9,
  0x0d, 0x38, 0x34, 0x1b, 0xab, 0x33, 0xff, 0xb0, 0xbb, 0x48, 0x0c, 0x5f, 0xb9, 0xb1, 0xcd, 0x2e,
  0xc5, 0xf3, 0xdb, 0x47, 0xe5, 0xa5, 0x9c, 0x77, 0x0a, 0xa6, 0x20, 0x68, 0xfe, 0x7f, 0xc1, 0xad
];

var s = [1, 2, 3, 5];

/**
 * Rotate a word left by given number of bits.
 *
 * Bits that are shifted out on the left are put back in on the right
 * hand side.
 *
 * @param word The word to shift left.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */
var rol = function(word, bits) {
  return ((word << bits) & 0xffff) | ((word & 0xffff) >> (16 - bits));
};

/**
 * Rotate a word right by given number of bits.
 *
 * Bits that are shifted out on the right are put back in on the left
 * hand side.
 *
 * @param word The word to shift right.
 * @param bits The number of bits to shift by.
 * @return The rotated word.
 */
var ror = function(word, bits) {
  return ((word & 0xffff) >> bits) | ((word << (16 - bits)) & 0xffff);
};

/* RC2 API */
module.exports = forge.rc2 = forge.rc2 || {};

/**
 * Perform RC2 key expansion as per RFC #2268, section 2.
 *
 * @param key variable-length user key (between 1 and 128 bytes)
 * @param effKeyBits number of effective key bits (default: 128)
 * @return the expanded RC2 key (ByteBuffer of 128 bytes)
 */
forge.rc2.expandKey = function(key, effKeyBits) {
  if(typeof key === 'string') {
    key = forge.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;

  /* introduce variables that match the names used in RFC #2268 */
  var L = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 0xff >> (T1 & 0x07);
  var i;

  for(i = T; i < 128; i++) {
    L.putByte(piTable[(L.at(i - 1) + L.at(i - T)) & 0xff]);
  }

  L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);

  for(i = 127 - T8; i >= 0; i--) {
    L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
  }

  return L;
};

/**
 * Creates a RC2 cipher object.
 *
 * @param key the symmetric key to use (as base for key generation).
 * @param bits the number of effective key bits.
 * @param encrypt false for decryption, true for encryption.
 *
 * @return the cipher.
 */
var createCipher = function(key, bits, encrypt) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i, j, K = [];

  /* Expand key and fill into K[] Array */
  key = forge.rc2.expandKey(key, bits);
  for(i = 0; i < 64; i++) {
    K.push(key.getInt16Le());
  }

  if(encrypt) {
    /**
     * Perform one mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function(R) {
      for(i = 0; i < 4; i++) {
        R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +
          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
        R[i] = rol(R[i], s[i]);
        j++;
      }
    };

    /**
     * Perform one mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */
    mashRound = function(R) {
      for(i = 0; i < 4; i++) {
        R[i] += K[R[(i + 3) % 4] & 63];
      }
    };
  } else {
    /**
     * Perform one r-mixing round "in place".
     *
     * @param R Array of four words to perform mixing on.
     */
    mixRound = function(R) {
      for(i = 3; i >= 0; i--) {
        R[i] = ror(R[i], s[i]);
        R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) +
          ((~R[(i + 3) % 4]) & R[(i + 1) % 4]);
        j--;
      }
    };

    /**
     * Perform one r-mashing round "in place".
     *
     * @param R Array of four words to perform mashing on.
     */
    mashRound = function(R) {
      for(i = 3; i >= 0; i--) {
        R[i] -= K[R[(i + 3) % 4] & 63];
      }
    };
  }

  /**
   * Run the specified cipher execution plan.
   *
   * This function takes four words from the input buffer, applies the IV on
   * it (if requested) and runs the provided execution plan.
   *
   * The plan must be put together in form of a array of arrays.  Where the
   * outer one is simply a list of steps to perform and the inner one needs
   * to have two elements: the first one telling how many rounds to perform,
   * the second one telling what to do (i.e. the function to call).
   *
   * @param {Array} plan The plan to execute.
   */
  var runPlan = function(plan) {
    var R = [];

    /* Get data from input buffer and fill the four words into R */
    for(i = 0; i < 4; i++) {
      var val = _input.getInt16Le();

      if(_iv !== null) {
        if(encrypt) {
          /* We're encrypting, apply the IV first. */
          val ^= _iv.getInt16Le();
        } else {
          /* We're decryption, keep cipher text for next block. */
          _iv.putInt16Le(val);
        }
      }

      R.push(val & 0xffff);
    }

    /* Reset global "j" variable as per spec. */
    j = encrypt ? 0 : 63;

    /* Run execution plan. */
    for(var ptr = 0; ptr < plan.length; ptr++) {
      for(var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R);
      }
    }

    /* Write back result to output buffer. */
    for(i = 0; i < 4; i++) {
      if(_iv !== null) {
        if(encrypt) {
          /* We're encrypting in CBC-mode, feed back encrypted bytes into
             IV buffer to carry it forward to next block. */
          _iv.putInt16Le(R[i]);
        } else {
          R[i] ^= _iv.getInt16Le();
        }
      }

      _output.putInt16Le(R[i]);
    }
  };

  /* Create cipher object */
  var cipher = null;
  cipher = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(iv, output) {
      if(iv) {
        /* CBC mode */
        if(typeof iv === 'string') {
          iv = forge.util.createBuffer(iv);
        }
      }

      _finish = false;
      _input = forge.util.createBuffer();
      _output = output || new forge.util.createBuffer();
      _iv = iv;

      cipher.output = _output;
    },

    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(input) {
      if(!_finish) {
        // not finishing, so fill the input buffer with more input
        _input.putBuffer(input);
      }

      while(_input.length() >= 8) {
        runPlan([
            [ 5, mixRound ],
            [ 1, mashRound ],
            [ 6, mixRound ],
            [ 1, mashRound ],
            [ 5, mixRound ]
          ]);
      }
    },

    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(pad) {
      var rval = true;

      if(encrypt) {
        if(pad) {
          rval = pad(8, _input, !encrypt);
        } else {
          // add PKCS#7 padding to block (each pad byte is the
          // value of the number of pad bytes)
          var padding = (_input.length() === 8) ? 8 : (8 - _input.length());
          _input.fillWithByte(padding, padding);
        }
      }

      if(rval) {
        // do final update
        _finish = true;
        cipher.update();
      }

      if(!encrypt) {
        // check for error: input data not a multiple of block size
        rval = (_input.length() === 0);
        if(rval) {
          if(pad) {
            rval = pad(8, _output, !encrypt);
          } else {
            // ensure padding byte count is valid
            var len = _output.length();
            var count = _output.at(len - 1);

            if(count > len) {
              rval = false;
            } else {
              // trim off padding bytes
              _output.truncate(count);
            }
          }
        }
      }

      return rval;
    }
  };

  return cipher;
};

/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */
forge.rc2.startEncrypting = function(key, iv, output) {
  var cipher = forge.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};

/**
 * Creates an RC2 cipher object to encrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start encrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */
forge.rc2.createEncryptionCipher = function(key, bits) {
  return createCipher(key, bits, true);
};

/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key. The output will be stored in the 'output' member
 * of the returned cipher.
 *
 * The key and iv may be given as a string of bytes or a byte buffer.
 * The cipher is initialized to use 128 effective key bits.
 *
 * @param key the symmetric key to use.
 * @param iv the initialization vector to use.
 * @param output the buffer to write to, null to create one.
 *
 * @return the cipher.
 */
forge.rc2.startDecrypting = function(key, iv, output) {
  var cipher = forge.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv, output);
  return cipher;
};

/**
 * Creates an RC2 cipher object to decrypt data in ECB or CBC mode using the
 * given symmetric key.
 *
 * The key may be given as a string of bytes or a byte buffer.
 *
 * To start decrypting call start() on the cipher with an iv and optional
 * output buffer.
 *
 * @param key the symmetric key to use.
 *
 * @return the cipher.
 */
forge.rc2.createDecryptionCipher = function(key, bits) {
  return createCipher(key, bits, false);
};


/***/ }),

/***/ "./node_modules/node-forge/lib/rsa.js":
/*!********************************************!*\
  !*** ./node_modules/node-forge/lib/rsa.js ***!
  \********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of basic RSA algorithms.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The only algorithm currently supported for PKI is RSA.
 *
 * An RSA key is often stored in ASN.1 DER format. The SubjectPublicKeyInfo
 * ASN.1 structure is composed of an algorithm of type AlgorithmIdentifier
 * and a subjectPublicKey of type bit string.
 *
 * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters
 * for the algorithm, if any. In the case of RSA, there aren't any.
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm AlgorithmIdentifier,
 *   subjectPublicKey BIT STRING
 * }
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * For an RSA public key, the subjectPublicKey is:
 *
 * RSAPublicKey ::= SEQUENCE {
 *   modulus            INTEGER,    -- n
 *   publicExponent     INTEGER     -- e
 * }
 *
 * PrivateKeyInfo ::= SEQUENCE {
 *   version                   Version,
 *   privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
 *   privateKey                PrivateKey,
 *   attributes           [0]  IMPLICIT Attributes OPTIONAL
 * }
 *
 * Version ::= INTEGER
 * PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
 * PrivateKey ::= OCTET STRING
 * Attributes ::= SET OF Attribute
 *
 * An RSA private key as the following structure:
 *
 * RSAPrivateKey ::= SEQUENCE {
 *   version Version,
 *   modulus INTEGER, -- n
 *   publicExponent INTEGER, -- e
 *   privateExponent INTEGER, -- d
 *   prime1 INTEGER, -- p
 *   prime2 INTEGER, -- q
 *   exponent1 INTEGER, -- d mod (p-1)
 *   exponent2 INTEGER, -- d mod (q-1)
 *   coefficient INTEGER -- (inverse of q) mod p
 * }
 *
 * Version ::= INTEGER
 *
 * The OID for the RSA key algorithm is: 1.2.840.113549.1.1.1
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./jsbn */ "./node_modules/node-forge/lib/jsbn.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");
__webpack_require__(/*! ./pkcs1 */ "./node_modules/node-forge/lib/pkcs1.js");
__webpack_require__(/*! ./prime */ "./node_modules/node-forge/lib/prime.js");
__webpack_require__(/*! ./random */ "./node_modules/node-forge/lib/random.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

if(typeof BigInteger === 'undefined') {
  var BigInteger = forge.jsbn.BigInteger;
}

var _crypto = forge.util.isNodejs ? __webpack_require__(/*! crypto */ 0) : null;

// shortcut for asn.1 API
var asn1 = forge.asn1;

// shortcut for util API
var util = forge.util;

/*
 * RSA encryption and decryption, see RFC 2313.
 */
forge.pki = forge.pki || {};
module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
var pki = forge.pki;

// for finding primes, which are 30k+i for i = 1, 7, 11, 13, 17, 19, 23, 29
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];

// validator for a PrivateKeyInfo structure
var privateKeyValidator = {
  // PrivateKeyInfo
  name: 'PrivateKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'PrivateKeyInfo.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // privateKeyAlgorithm
    name: 'PrivateKeyInfo.privateKeyAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'privateKeyOid'
    }]
  }, {
    // PrivateKey
    name: 'PrivateKeyInfo',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.OCTETSTRING,
    constructed: false,
    capture: 'privateKey'
  }]
};

// validator for an RSA private key
var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: 'RSAPrivateKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: 'RSAPrivateKey.version',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyVersion'
  }, {
    // modulus (n)
    name: 'RSAPrivateKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPrivateKey.publicExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPublicExponent'
  }, {
    // privateExponent (d)
    name: 'RSAPrivateKey.privateExponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrivateExponent'
  }, {
    // prime1 (p)
    name: 'RSAPrivateKey.prime1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime1'
  }, {
    // prime2 (q)
    name: 'RSAPrivateKey.prime2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyPrime2'
  }, {
    // exponent1 (d mod (p-1))
    name: 'RSAPrivateKey.exponent1',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent1'
  }, {
    // exponent2 (d mod (q-1))
    name: 'RSAPrivateKey.exponent2',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyExponent2'
  }, {
    // coefficient ((inverse of q) mod p)
    name: 'RSAPrivateKey.coefficient',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'privateKeyCoefficient'
  }]
};

// validator for an RSA public key
var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: 'RSAPublicKey',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: 'RSAPublicKey.modulus',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyModulus'
  }, {
    // publicExponent (e)
    name: 'RSAPublicKey.exponent',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'publicKeyExponent'
  }]
};

// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
  name: 'SubjectPublicKeyInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'subjectPublicKeyInfo',
  value: [{
    name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: 'AlgorithmIdentifier.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'publicKeyOid'
    }]
  }, {
    // subjectPublicKey
    name: 'SubjectPublicKeyInfo.subjectPublicKey',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: 'rsaPublicKey'
    }]
  }]
};

/**
 * Wrap digest in DigestInfo object.
 *
 * This function implements EMSA-PKCS1-v1_5-ENCODE as per RFC 3447.
 *
 * DigestInfo ::= SEQUENCE {
 *   digestAlgorithm DigestAlgorithmIdentifier,
 *   digest Digest
 * }
 *
 * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
 * Digest ::= OCTET STRING
 *
 * @param md the message digest object with the hash to sign.
 *
 * @return the encoded message (ready for RSA encrytion)
 */
var emsaPkcs1v15encode = function(md) {
  // get the oid for the algorithm
  var oid;
  if(md.algorithm in pki.oids) {
    oid = pki.oids[md.algorithm];
  } else {
    var error = new Error('Unknown message digest algorithm.');
    error.algorithm = md.algorithm;
    throw error;
  }
  var oidBytes = asn1.oidToDer(oid).getBytes();

  // create the digest info
  var digestInfo = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  var digestAlgorithm = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  digestAlgorithm.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
  digestAlgorithm.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ''));
  var digest = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,
    false, md.digest().getBytes());
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest);

  // encode digest info
  return asn1.toDer(digestInfo).getBytes();
};

/**
 * Performs x^c mod n (RSA encryption or decryption operation).
 *
 * @param x the number to raise and mod.
 * @param key the key to use.
 * @param pub true if the key is public, false if private.
 *
 * @return the result of x^c mod n.
 */
var _modPow = function(x, key, pub) {
  if(pub) {
    return x.modPow(key.e, key.n);
  }

  if(!key.p || !key.q) {
    // allow calculation without CRT params (slow)
    return x.modPow(key.d, key.n);
  }

  // pre-compute dP, dQ, and qInv if necessary
  if(!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
  }
  if(!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
  }
  if(!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }

  /* Chinese remainder theorem (CRT) states:

    Suppose n1, n2, ..., nk are positive integers which are pairwise
    coprime (n1 and n2 have no common factors other than 1). For any
    integers x1, x2, ..., xk there exists an integer x solving the
    system of simultaneous congruences (where ~= means modularly
    congruent so a ~= b mod n means a mod n = b mod n):

    x ~= x1 mod n1
    x ~= x2 mod n2
    ...
    x ~= xk mod nk

    This system of congruences has a single simultaneous solution x
    between 0 and n - 1. Furthermore, each xk solution and x itself
    is congruent modulo the product n = n1*n2*...*nk.
    So x1 mod n = x2 mod n = xk mod n = x mod n.

    The single simultaneous solution x can be solved with the following
    equation:

    x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.

    Where x is less than n, xi = x mod ni.

    For RSA we are only concerned with k = 2. The modulus n = pq, where
    p and q are coprime. The RSA decryption algorithm is:

    y = x^d mod n

    Given the above:

    x1 = x^d mod p
    r1 = n/p = q
    s1 = q^-1 mod p
    x2 = x^d mod q
    r2 = n/q = p
    s2 = p^-1 mod q

    So y = (x1r1s1 + x2r2s2) mod n
         = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n

    According to Fermat's Little Theorem, if the modulus P is prime,
    for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
    Since A is not divisible by P it follows that if:
    N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:

    A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
    to calculate). In order to calculate x^d mod p more quickly the
    exponent d mod (p - 1) is stored in the RSA private key (the same
    is done for x^d mod q). These values are referred to as dP and dQ
    respectively. Therefore we now have:

    y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n

    Since we'll be reducing x^dP by modulo p (same for q) we can also
    reduce x by p (and q respectively) before hand. Therefore, let

    xp = ((x mod p)^dP mod p), and
    xq = ((x mod q)^dQ mod q), yielding:

    y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n

    This can be further reduced to a simple algorithm that only
    requires 1 inverse (the q inverse is used) to be used and stored.
    The algorithm is called Garner's algorithm. If qInv is the
    inverse of q, we simply calculate:

    y = (qInv*(xp - xq) mod p) * q + xq

    However, there are two further complications. First, we need to
    ensure that xp > xq to prevent signed BigIntegers from being used
    so we add p until this is true (since we will be mod'ing with
    p anyway). Then, there is a known timing attack on algorithms
    using the CRT. To mitigate this risk, "cryptographic blinding"
    should be used. This requires simply generating a random number r
    between 0 and n-1 and its inverse and multiplying x by r^e before
    calculating y and then multiplying y by r^-1 afterwards. Note that
    r must be coprime with n (gcd(r, n) === 1) in order to have an
    inverse.
  */

  // cryptographic blinding
  var r;
  do {
    r = new BigInteger(
      forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
      16);
  } while(r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);

  // calculate xp and xq
  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q);

  // xp must be larger than xq to avoid signed bit usage
  while(xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  }

  // do last step
  var y = xp.subtract(xq)
    .multiply(key.qInv).mod(key.p)
    .multiply(key.q).add(xq);

  // remove effect of random for cryptographic blinding
  y = y.multiply(r.modInverse(key.n)).mod(key.n);

  return y;
};

/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'sign' on a private key object or
 * 'encrypt' on a public key object instead.
 *
 * Performs RSA encryption.
 *
 * The parameter bt controls whether to put padding bytes before the
 * message passed in. Set bt to either true or false to disable padding
 * completely (in order to handle e.g. EMSA-PSS encoding seperately before),
 * signaling whether the encryption operation is a public key operation
 * (i.e. encrypting data) or not, i.e. private key operation (data signing).
 *
 * For PKCS#1 v1.5 padding pass in the block type to use, i.e. either 0x01
 * (for signing) or 0x02 (for encryption). The key operation mode (private
 * or public) is derived from this flag in that case).
 *
 * @param m the message to encrypt as a byte string.
 * @param key the RSA key to use.
 * @param bt for PKCS#1 v1.5 padding, the block type to use
 *   (0x01 for private key, 0x02 for public),
 *   to disable padding: true = public key, false = private key.
 *
 * @return the encrypted bytes as a string.
 */
pki.rsa.encrypt = function(m, key, bt) {
  var pub = bt;
  var eb;

  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  if(bt !== false && bt !== true) {
    // legacy, default to PKCS#1 v1.5 padding
    pub = (bt === 0x02);
    eb = _encodePkcs1_v1_5(m, key, bt);
  } else {
    eb = forge.util.createBuffer();
    eb.putBytes(m);
  }

  // load encryption block as big integer 'x'
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var x = new BigInteger(eb.toHex(), 16);

  // do RSA encryption
  var y = _modPow(x, key, pub);

  // convert y into the encrypted data byte string, if y is shorter in
  // bytes than k, then prepend zero bytes to fill up ed
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var yhex = y.toString(16);
  var ed = forge.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while(zeros > 0) {
    ed.putByte(0x00);
    --zeros;
  }
  ed.putBytes(forge.util.hexToBytes(yhex));
  return ed.getBytes();
};

/**
 * NOTE: THIS METHOD IS DEPRECATED, use 'decrypt' on a private key object or
 * 'verify' on a public key object instead.
 *
 * Performs RSA decryption.
 *
 * The parameter ml controls whether to apply PKCS#1 v1.5 padding
 * or not.  Set ml = false to disable padding removal completely
 * (in order to handle e.g. EMSA-PSS later on) and simply pass back
 * the RSA encryption block.
 *
 * @param ed the encrypted data to decrypt in as a byte string.
 * @param key the RSA key to use.
 * @param pub true for a public key operation, false for private.
 * @param ml the message length, if known, false to disable padding.
 *
 * @return the decrypted message as a byte string.
 */
pki.rsa.decrypt = function(ed, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  // error if the length of the encrypted data ED is not k
  if(ed.length !== k) {
    var error = new Error('Encrypted message length is invalid.');
    error.length = ed.length;
    error.expected = k;
    throw error;
  }

  // convert encrypted data into a big integer
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);

  // y must be less than the modulus or it wasn't the result of
  // a previous mod operation (encryption) using that modulus
  if(y.compareTo(key.n) >= 0) {
    throw new Error('Encrypted message is invalid.');
  }

  // do RSA decryption
  var x = _modPow(y, key, pub);

  // create the encryption block, if x is shorter in bytes than k, then
  // prepend zero bytes to fill up eb
  // FIXME: hex conversion inefficient, get BigInteger w/byte strings
  var xhex = x.toString(16);
  var eb = forge.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while(zeros > 0) {
    eb.putByte(0x00);
    --zeros;
  }
  eb.putBytes(forge.util.hexToBytes(xhex));

  if(ml !== false) {
    // legacy, default to PKCS#1 v1.5 padding
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }

  // return message
  return eb.getBytes();
};

/**
 * Creates an RSA key-pair generation state object. It is used to allow
 * key-generation to be performed in steps. It also allows for a UI to
 * display progress updates.
 *
 * @param bits the size for the private key in bits, defaults to 2048.
 * @param e the public exponent to use, defaults to 65537 (0x10001).
 * @param [options] the options to use.
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync".
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 *
 * @return the state object to use to generate the key-pair.
 */
pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
  // TODO: migrate step-based prime generation code to forge.prime

  // set default bits
  if(typeof(bits) === 'string') {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;

  // create prng with api that matches BigInteger secure random
  options = options || {};
  var prng = options.prng || forge.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng.getBytesSync(x.length);
      for(var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };

  var algorithm = options.algorithm || 'PRIMEINC';

  // create PRIMEINC algorithm state
  var rval;
  if(algorithm === 'PRIMEINC') {
    rval = {
      algorithm: algorithm,
      state: 0,
      bits: bits,
      rng: rng,
      eInt: e || 65537,
      e: new BigInteger(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error('Invalid key generation algorithm: ' + algorithm);
  }

  return rval;
};

/**
 * Attempts to runs the key-generation algorithm for at most n seconds
 * (approximately) using the given state. When key-generation has completed,
 * the keys will be stored in state.keys.
 *
 * To use this function to update a UI while generating a key or to prevent
 * causing browser lockups/warnings, set "n" to a value other than 0. A
 * simple pattern for generating a key and showing a progress indicator is:
 *
 * var state = pki.rsa.createKeyPairGenerationState(2048);
 * var step = function() {
 *   // step key-generation, run algorithm for 100 ms, repeat
 *   if(!forge.pki.rsa.stepKeyPairGenerationState(state, 100)) {
 *     setTimeout(step, 1);
 *   } else {
 *     // key-generation complete
 *     // TODO: turn off progress indicator here
 *     // TODO: use the generated key-pair in "state.keys"
 *   }
 * };
 * // TODO: turn on progress indicator here
 * setTimeout(step, 0);
 *
 * @param state the state to use.
 * @param n the maximum number of milliseconds to run the algorithm for, 0
 *          to run the algorithm to completion.
 *
 * @return true if the key-generation completed, false if not.
 */
pki.rsa.stepKeyPairGenerationState = function(state, n) {
  // set default algorithm if not set
  if(!('algorithm' in state)) {
    state.algorithm = 'PRIMEINC';
  }

  // TODO: migrate step-based prime generation code to forge.prime
  // TODO: abstract as PRIMEINC algorithm

  // do key generation (based on Tom Wu's rsa.js, see jsbn.js license)
  // with some minor optimizations and designed to run in steps

  // local state vars
  var THIRTY = new BigInteger(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or = function(x, y) {return x | y;};

  // keep stepping until time limit is reached or done
  var t1 = +new Date();
  var t2;
  var total = 0;
  while(state.keys === null && (n <= 0 || total < n)) {
    // generate p or q
    if(state.state === 0) {
      /* Note: All primes are of the form:

        30k+i, for i < 30 and gcd(30, i)=1, where there are 8 values for i

        When we generate a random number, we always align it at 30k + 1. Each
        time the number is determined not to be prime we add to get to the
        next 'i', eg: if the number was at 30k + 1 we add 6. */
      var bits = (state.p === null) ? state.pBits : state.qBits;
      var bits1 = bits - 1;

      // get a random number
      if(state.pqState === 0) {
        state.num = new BigInteger(bits, state.rng);
        // force MSB set
        if(!state.num.testBit(bits1)) {
          state.num.bitwiseTo(
            BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
        }
        // align number on 30k+1 boundary
        state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;

        ++state.pqState;
      } else if(state.pqState === 1) {
        // try to make the number a prime
        if(state.num.bitLength() > bits) {
          // overflow, try again
          state.pqState = 0;
          // do primality test
        } else if(state.num.isProbablePrime(
          _getMillerRabinTests(state.num.bitLength()))) {
          ++state.pqState;
        } else {
          // get next potential prime
          state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if(state.pqState === 2) {
        // ensure number is coprime with e
        state.pqState =
          (state.num.subtract(BigInteger.ONE).gcd(state.e)
            .compareTo(BigInteger.ONE) === 0) ? 3 : 0;
      } else if(state.pqState === 3) {
        // store p or q
        state.pqState = 0;
        if(state.p === null) {
          state.p = state.num;
        } else {
          state.q = state.num;
        }

        // advance state if both p and q are ready
        if(state.p !== null && state.q !== null) {
          ++state.state;
        }
        state.num = null;
      }
    } else if(state.state === 1) {
      // ensure p is larger than q (swap them if not)
      if(state.p.compareTo(state.q) < 0) {
        state.num = state.p;
        state.p = state.q;
        state.q = state.num;
      }
      ++state.state;
    } else if(state.state === 2) {
      // compute phi: (p - 1)(q - 1) (Euler's totient function)
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      ++state.state;
    } else if(state.state === 3) {
      // ensure e and phi are coprime
      if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
        // phi and e are coprime, advance
        ++state.state;
      } else {
        // phi and e aren't coprime, so generate a new p and q
        state.p = null;
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 4) {
      // create n, ensure n is has the right number of bits
      state.n = state.p.multiply(state.q);

      // ensure n is right number of bits
      if(state.n.bitLength() === state.bits) {
        // success, advance
        ++state.state;
      } else {
        // failed, get new q
        state.q = null;
        state.state = 0;
      }
    } else if(state.state === 5) {
      // set keys
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(
          state.n, state.e, d, state.p, state.q,
          d.mod(state.p1), d.mod(state.q1),
          state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      };
    }

    // update timing
    t2 = +new Date();
    total += t2 - t1;
    t1 = t2;
  }

  return state.keys !== null;
};

/**
 * Generates an RSA public-private key pair in a single call.
 *
 * To generate a key-pair in steps (to allow for progress updates and to
 * prevent blocking or warnings in slow browsers) then use the key-pair
 * generation state functions.
 *
 * To generate a key-pair asynchronously (either through web-workers, if
 * available, or by breaking up the work on the main thread), pass a
 * callback function.
 *
 * @param [bits] the size for the private key in bits, defaults to 2048.
 * @param [e] the public exponent to use, defaults to 65537.
 * @param [options] options for key-pair generation, if given then 'bits'
 *            and 'e' must *not* be given:
 *          bits the size for the private key in bits, (default: 2048).
 *          e the public exponent to use, (default: 65537 (0x10001)).
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 *          prng a custom crypto-secure pseudo-random number generator to use,
 *            that must define "getBytesSync". Disables use of native APIs.
 *          algorithm the algorithm to use (default: 'PRIMEINC').
 * @param [callback(err, keypair)] called once the operation completes.
 *
 * @return an object with privateKey and publicKey properties.
 */
pki.rsa.generateKeyPair = function(bits, e, options, callback) {
  // (bits), (options), (callback)
  if(arguments.length === 1) {
    if(typeof bits === 'object') {
      options = bits;
      bits = undefined;
    } else if(typeof bits === 'function') {
      callback = bits;
      bits = undefined;
    }
  } else if(arguments.length === 2) {
    // (bits, e), (bits, options), (bits, callback), (options, callback)
    if(typeof bits === 'number') {
      if(typeof e === 'function') {
        callback = e;
        e = undefined;
      } else if(typeof e !== 'number') {
        options = e;
        e = undefined;
      }
    } else {
      options = bits;
      callback = e;
      bits = undefined;
      e = undefined;
    }
  } else if(arguments.length === 3) {
    // (bits, e, options), (bits, e, callback), (bits, options, callback)
    if(typeof e === 'number') {
      if(typeof options === 'function') {
        callback = options;
        options = undefined;
      }
    } else {
      callback = options;
      options = e;
      e = undefined;
    }
  }
  options = options || {};
  if(bits === undefined) {
    bits = options.bits || 2048;
  }
  if(e === undefined) {
    e = options.e || 0x10001;
  }

  // use native code if permitted, available, and parameters are acceptable
  if(!forge.options.usePureJavaScript && !options.prng &&
    bits >= 256 && bits <= 16384 && (e === 0x10001 || e === 3)) {
    if(callback) {
      // try native async
      if(_detectNodeCrypto('generateKeyPair')) {
        return _crypto.generateKeyPair('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        }, function(err, pub, priv) {
          if(err) {
            return callback(err);
          }
          callback(null, {
            privateKey: pki.privateKeyFromPem(priv),
            publicKey: pki.publicKeyFromPem(pub)
          });
        });
      }
      if(_detectSubtleCrypto('generateKey') &&
        _detectSubtleCrypto('exportKey')) {
        // use standard native generateKey
        return util.globalScope.crypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {name: 'SHA-256'}
        }, true /* key can be exported*/, ['sign', 'verify'])
        .then(function(pair) {
          return util.globalScope.crypto.subtle.exportKey(
            'pkcs8', pair.privateKey);
        // avoiding catch(function(err) {...}) to support IE <= 8
        }).then(undefined, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if(pkcs8) {
            var privateKey = pki.privateKeyFromAsn1(
              asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }
      if(_detectSubtleMsCrypto('generateKey') &&
        _detectSubtleMsCrypto('exportKey')) {
        var genOp = util.globalScope.msCrypto.subtle.generateKey({
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: {name: 'SHA-256'}
        }, true /* key can be exported*/, ['sign', 'verify']);
        genOp.oncomplete = function(e) {
          var pair = e.target.result;
          var exportOp = util.globalScope.msCrypto.subtle.exportKey(
            'pkcs8', pair.privateKey);
          exportOp.oncomplete = function(e) {
            var pkcs8 = e.target.result;
            var privateKey = pki.privateKeyFromAsn1(
              asn1.fromDer(forge.util.createBuffer(pkcs8)));
            callback(null, {
              privateKey: privateKey,
              publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      // try native sync
      if(_detectNodeCrypto('generateKeyPairSync')) {
        var keypair = _crypto.generateKeyPairSync('rsa', {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
          },
          privateKeyEncoding: {
            type: 'pkcs8',
            format: 'pem'
          }
        });
        return {
          privateKey: pki.privateKeyFromPem(keypair.privateKey),
          publicKey: pki.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  }

  // use JavaScript implementation
  var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
  if(!callback) {
    pki.rsa.stepKeyPairGenerationState(state, 0);
    return state.keys;
  }
  _generateKeyPair(state, options, callback);
};

/**
 * Sets an RSA public key from BigIntegers modulus and exponent.
 *
 * @param n the modulus.
 * @param e the exponent.
 *
 * @return the public key.
 */
pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
  var key = {
    n: n,
    e: e
  };

  /**
   * Encrypts the given data with this public key. Newer applications
   * should use the 'RSA-OAEP' decryption scheme, 'RSAES-PKCS1-V1_5' is for
   * legacy applications.
   *
   * @param data the byte string to encrypt.
   * @param scheme the encryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA encryption,
   *          an object with an 'encode' property set to a function
   *          with the signature 'function(data, key)' that returns
   *          a binary-encoded string representing the encoded data.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the encrypted byte string.
   */
  key.encrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {
        encode: function(m, key, pub) {
          return _encodePkcs1_v1_5(m, key, 0x02).getBytes();
        }
      };
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        encode: function(m, key) {
          return forge.pkcs1.encode_rsa_oaep(key, m, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {encode: function(e) {return e;}};
    } else if(typeof scheme === 'string') {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // do scheme-based encoding then rsa encryption
    var e = scheme.encode(data, key, true);
    return pki.rsa.encrypt(e, key, true);
  };

  /**
   * Verifies the given signature against the given digest.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5, in which case once RSA-decrypted, the
   * signature is an OCTET STRING that holds a DigestInfo.
   *
   * DigestInfo ::= SEQUENCE {
   *   digestAlgorithm DigestAlgorithmIdentifier,
   *   digest Digest
   * }
   * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
   * Digest ::= OCTET STRING
   *
   * To perform PSS signature verification, provide an instance
   * of Forge PSS object as the scheme parameter.
   *
   * @param digest the message digest hash to compare against the signature,
   *          as a binary-encoded string.
   * @param signature the signature to verify, as a binary-encoded string.
   * @param scheme signature verification scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be expected, but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return true if the signature was verified, false if not.
   */
  key.verify = function(digest, signature, scheme) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSASSA-PKCS1-V1_5';
    }

    if(scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {
        verify: function(digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true);
          // d is ASN.1 BER-encoded DigestInfo
          var obj = asn1.fromDer(d);
          // compare the given digest to the decrypted one
          return digest === obj.value[1].value;
        }
      };
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {
        verify: function(digest, d) {
          // remove padding
          d = _decodePkcs1_v1_5(d, key, true);
          return digest === d;
        }
      };
    }

    // do rsa decryption w/o any decoding, then verify -- which does decoding
    var d = pki.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest, d, key.n.bitLength());
  };

  return key;
};

/**
 * Sets an RSA private key from BigIntegers modulus, exponent, primes,
 * prime exponents, and modular multiplicative inverse.
 *
 * @param n the modulus.
 * @param e the public exponent.
 * @param d the private exponent ((inverse of e) mod n).
 * @param p the first prime.
 * @param q the second prime.
 * @param dP exponent1 (d mod (p-1)).
 * @param dQ exponent2 (d mod (q-1)).
 * @param qInv ((inverse of q) mod p)
 *
 * @return the private key.
 */
pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(
  n, e, d, p, q, dP, dQ, qInv) {
  var key = {
    n: n,
    e: e,
    d: d,
    p: p,
    q: q,
    dP: dP,
    dQ: dQ,
    qInv: qInv
  };

  /**
   * Decrypts the given data with this private key. The decryption scheme
   * must match the one used to encrypt the data.
   *
   * @param data the byte string to decrypt.
   * @param scheme the decryption scheme to use:
   *          'RSAES-PKCS1-V1_5' (default),
   *          'RSA-OAEP',
   *          'RAW', 'NONE', or null to perform raw RSA decryption.
   * @param schemeOptions any scheme-specific options.
   *
   * @return the decrypted byte string.
   */
  key.decrypt = function(data, scheme, schemeOptions) {
    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    } else if(scheme === undefined) {
      scheme = 'RSAES-PKCS1-V1_5';
    }

    // do rsa decryption w/o any decoding
    var d = pki.rsa.decrypt(data, key, false, false);

    if(scheme === 'RSAES-PKCS1-V1_5') {
      scheme = {decode: _decodePkcs1_v1_5};
    } else if(scheme === 'RSA-OAEP' || scheme === 'RSAES-OAEP') {
      scheme = {
        decode: function(d, key) {
          return forge.pkcs1.decode_rsa_oaep(key, d, schemeOptions);
        }
      };
    } else if(['RAW', 'NONE', 'NULL', null].indexOf(scheme) !== -1) {
      scheme = {decode: function(d) {return d;}};
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }

    // decode according to scheme
    return scheme.decode(d, key, false);
  };

  /**
   * Signs the given digest, producing a signature.
   *
   * PKCS#1 supports multiple (currently two) signature schemes:
   * RSASSA-PKCS1-V1_5 and RSASSA-PSS.
   *
   * By default this implementation uses the "old scheme", i.e.
   * RSASSA-PKCS1-V1_5. In order to generate a PSS signature, provide
   * an instance of Forge PSS object as the scheme parameter.
   *
   * @param md the message digest object with the hash to sign.
   * @param scheme the signature scheme to use:
   *          'RSASSA-PKCS1-V1_5' or undefined for RSASSA PKCS#1 v1.5,
   *          a Forge PSS object for RSASSA-PSS,
   *          'NONE' or null for none, DigestInfo will not be used but
   *            PKCS#1 v1.5 padding will still be used.
   *
   * @return the signature as a byte string.
   */
  key.sign = function(md, scheme) {
    /* Note: The internal implementation of RSA operations is being
      transitioned away from a PKCS#1 v1.5 hard-coded scheme. Some legacy
      code like the use of an encoding block identifier 'bt' will eventually
      be removed. */

    // private key operation
    var bt = false;

    if(typeof scheme === 'string') {
      scheme = scheme.toUpperCase();
    }

    if(scheme === undefined || scheme === 'RSASSA-PKCS1-V1_5') {
      scheme = {encode: emsaPkcs1v15encode};
      bt = 0x01;
    } else if(scheme === 'NONE' || scheme === 'NULL' || scheme === null) {
      scheme = {encode: function() {return md;}};
      bt = 0x01;
    }

    // encode and then encrypt
    var d = scheme.encode(md, key.n.bitLength());
    return pki.rsa.encrypt(d, key, bt);
  };

  return key;
};

/**
 * Wraps an RSAPrivateKey ASN.1 object in an ASN.1 PrivateKeyInfo object.
 *
 * @param rsaKey the ASN.1 RSAPrivateKey.
 *
 * @return the ASN.1 PrivateKeyInfo.
 */
pki.wrapRsaPrivateKey = function(rsaKey) {
  // PrivateKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // privateKeyAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // PrivateKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,
      asn1.toDer(rsaKey).getBytes())
  ]);
};

/**
 * Converts a private key from an ASN.1 object.
 *
 * @param obj the ASN.1 representation of a PrivateKeyInfo containing an
 *          RSAPrivateKey or an RSAPrivateKey.
 *
 * @return the private key.
 */
pki.privateKeyFromAsn1 = function(obj) {
  // get PrivateKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, privateKeyValidator, capture, errors)) {
    obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
  }

  // get RSAPrivateKey
  capture = {};
  errors = [];
  if(!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
    var error = new Error('Cannot read private key. ' +
      'ASN.1 object does not contain an RSAPrivateKey.');
    error.errors = errors;
    throw error;
  }

  // Note: Version is currently ignored.
  // capture.privateKeyVersion
  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n, e, d, p, q, dP, dQ, qInv;
  n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();

  // set private key
  return pki.setRsaPrivateKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16),
    new BigInteger(d, 16),
    new BigInteger(p, 16),
    new BigInteger(q, 16),
    new BigInteger(dP, 16),
    new BigInteger(dQ, 16),
    new BigInteger(qInv, 16));
};

/**
 * Converts a private key to an ASN.1 RSAPrivateKey.
 *
 * @param key the private key.
 *
 * @return the ASN.1 representation of an RSAPrivateKey.
 */
pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
  // RSAPrivateKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(0).getBytes()),
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e)),
    // privateExponent (d)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.d)),
    // privateKeyPrime1 (p)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.p)),
    // privateKeyPrime2 (q)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.q)),
    // privateKeyExponent1 (dP)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dP)),
    // privateKeyExponent2 (dQ)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.dQ)),
    // coefficient (qInv)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.qInv))
  ]);
};

/**
 * Converts a public key from an ASN.1 SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @param obj the asn1 representation of a SubjectPublicKeyInfo or RSAPublicKey.
 *
 * @return the public key.
 */
pki.publicKeyFromAsn1 = function(obj) {
  // get SubjectPublicKeyInfo
  var capture = {};
  var errors = [];
  if(asn1.validate(obj, publicKeyValidator, capture, errors)) {
    // get oid
    var oid = asn1.derToOid(capture.publicKeyOid);
    if(oid !== pki.oids.rsaEncryption) {
      var error = new Error('Cannot read public key. Unknown OID.');
      error.oid = oid;
      throw error;
    }
    obj = capture.rsaPublicKey;
  }

  // get RSA params
  errors = [];
  if(!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
    var error = new Error('Cannot read public key. ' +
      'ASN.1 object does not contain an RSAPublicKey.');
    error.errors = errors;
    throw error;
  }

  // FIXME: inefficient, get a BigInteger that uses byte strings
  var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();

  // set public key
  return pki.setRsaPublicKey(
    new BigInteger(n, 16),
    new BigInteger(e, 16));
};

/**
 * Converts a public key to an ASN.1 SubjectPublicKeyInfo.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a SubjectPublicKeyInfo.
 */
pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
  // SubjectPublicKeyInfo
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
    ]),
    // subjectPublicKey
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
      pki.publicKeyToRSAPublicKey(key)
    ])
  ]);
};

/**
 * Converts a public key to an ASN.1 RSAPublicKey.
 *
 * @param key the public key.
 *
 * @return the asn1 representation of a RSAPublicKey.
 */
pki.publicKeyToRSAPublicKey = function(key) {
  // RSAPublicKey
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // modulus (n)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.n)),
    // publicExponent (e)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      _bnToBytes(key.e))
  ]);
};

/**
 * Encodes a message using PKCS#1 v1.5 padding.
 *
 * @param m the message to encode.
 * @param key the RSA key to use.
 * @param bt the block type to use, i.e. either 0x01 (for signing) or 0x02
 *          (for encryption).
 *
 * @return the padded byte buffer.
 */
function _encodePkcs1_v1_5(m, key, bt) {
  var eb = forge.util.createBuffer();

  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  /* use PKCS#1 v1.5 padding */
  if(m.length > (k - 11)) {
    var error = new Error('Message is too long for PKCS#1 v1.5 padding.');
    error.length = m.length;
    error.max = k - 11;
    throw error;
  }

  /* A block type BT, a padding string PS, and the data D shall be
    formatted into an octet string EB, the encryption block:

    EB = 00 || BT || PS || 00 || D

    The block type BT shall be a single octet indicating the structure of
    the encryption block. For this version of the document it shall have
    value 00, 01, or 02. For a private-key operation, the block type
    shall be 00 or 01. For a public-key operation, it shall be 02.

    The padding string PS shall consist of k-3-||D|| octets. For block
    type 00, the octets shall have value 00; for block type 01, they
    shall have value FF; and for block type 02, they shall be
    pseudorandomly generated and nonzero. This makes the length of the
    encryption block EB equal to k. */

  // build the encryption block
  eb.putByte(0x00);
  eb.putByte(bt);

  // create the padding
  var padNum = k - 3 - m.length;
  var padByte;
  // private key op
  if(bt === 0x00 || bt === 0x01) {
    padByte = (bt === 0x00) ? 0x00 : 0xFF;
    for(var i = 0; i < padNum; ++i) {
      eb.putByte(padByte);
    }
  } else {
    // public key op
    // pad with random non-zero values
    while(padNum > 0) {
      var numZeros = 0;
      var padBytes = forge.random.getBytes(padNum);
      for(var i = 0; i < padNum; ++i) {
        padByte = padBytes.charCodeAt(i);
        if(padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }

  // zero followed by message
  eb.putByte(0x00);
  eb.putBytes(m);

  return eb;
}

/**
 * Decodes a message using PKCS#1 v1.5 padding.
 *
 * @param em the message to decode.
 * @param key the RSA key to use.
 * @param pub true if the key is a public key, false if it is private.
 * @param ml the message length, if specified.
 *
 * @return the decoded bytes.
 */
function _decodePkcs1_v1_5(em, key, pub, ml) {
  // get the length of the modulus in bytes
  var k = Math.ceil(key.n.bitLength() / 8);

  /* It is an error if any of the following conditions occurs:

    1. The encryption block EB cannot be parsed unambiguously.
    2. The padding string PS consists of fewer than eight octets
      or is inconsisent with the block type BT.
    3. The decryption process is a public-key operation and the block
      type BT is not 00 or 01, or the decryption process is a
      private-key operation and the block type is not 02.
   */

  // parse the encryption block
  var eb = forge.util.createBuffer(em);
  var first = eb.getByte();
  var bt = eb.getByte();
  if(first !== 0x00 ||
    (pub && bt !== 0x00 && bt !== 0x01) ||
    (!pub && bt != 0x02) ||
    (pub && bt === 0x00 && typeof(ml) === 'undefined')) {
    throw new Error('Encryption block is invalid.');
  }

  var padNum = 0;
  if(bt === 0x00) {
    // check all padding bytes for 0x00
    padNum = k - 3 - ml;
    for(var i = 0; i < padNum; ++i) {
      if(eb.getByte() !== 0x00) {
        throw new Error('Encryption block is invalid.');
      }
    }
  } else if(bt === 0x01) {
    // find the first byte that isn't 0xFF, should be after all padding
    padNum = 0;
    while(eb.length() > 1) {
      if(eb.getByte() !== 0xFF) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if(bt === 0x02) {
    // look for 0x00 byte
    padNum = 0;
    while(eb.length() > 1) {
      if(eb.getByte() === 0x00) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }

  // zero must be 0x00 and padNum must be (k - 3 - message length)
  var zero = eb.getByte();
  if(zero !== 0x00 || padNum !== (k - 3 - eb.length())) {
    throw new Error('Encryption block is invalid.');
  }

  return eb.getBytes();
}

/**
 * Runs the key-generation algorithm asynchronously, either in the background
 * via Web Workers, or using the main thread and setImmediate.
 *
 * @param state the key-pair generation state.
 * @param [options] options for key-pair generation:
 *          workerScript the worker script URL.
 *          workers the number of web workers (if supported) to use,
 *            (default: 2, -1 to use estimated cores minus one).
 *          workLoad the size of the work load, ie: number of possible prime
 *            numbers for each web worker to check per work assignment,
 *            (default: 100).
 * @param callback(err, keypair) called once the operation completes.
 */
function _generateKeyPair(state, options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};

  var opts = {
    algorithm: {
      name: options.algorithm || 'PRIMEINC',
      options: {
        workers: options.workers || 2,
        workLoad: options.workLoad || 100,
        workerScript: options.workerScript
      }
    }
  };
  if('prng' in options) {
    opts.prng = options.prng;
  }

  generate();

  function generate() {
    // find p and then q (done in series to simplify)
    getPrime(state.pBits, function(err, num) {
      if(err) {
        return callback(err);
      }
      state.p = num;
      if(state.q !== null) {
        return finish(err, state.q);
      }
      getPrime(state.qBits, finish);
    });
  }

  function getPrime(bits, callback) {
    forge.prime.generateProbablePrime(bits, opts, callback);
  }

  function finish(err, num) {
    if(err) {
      return callback(err);
    }

    // set q
    state.q = num;

    // ensure p is larger than q (swap them if not)
    if(state.p.compareTo(state.q) < 0) {
      var tmp = state.p;
      state.p = state.q;
      state.q = tmp;
    }

    // ensure p is coprime with e
    if(state.p.subtract(BigInteger.ONE).gcd(state.e)
      .compareTo(BigInteger.ONE) !== 0) {
      state.p = null;
      generate();
      return;
    }

    // ensure q is coprime with e
    if(state.q.subtract(BigInteger.ONE).gcd(state.e)
      .compareTo(BigInteger.ONE) !== 0) {
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }

    // compute phi: (p - 1)(q - 1) (Euler's totient function)
    state.p1 = state.p.subtract(BigInteger.ONE);
    state.q1 = state.q.subtract(BigInteger.ONE);
    state.phi = state.p1.multiply(state.q1);

    // ensure e and phi are coprime
    if(state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
      // phi and e aren't coprime, so generate a new p and q
      state.p = state.q = null;
      generate();
      return;
    }

    // create n, ensure n is has the right number of bits
    state.n = state.p.multiply(state.q);
    if(state.n.bitLength() !== state.bits) {
      // failed, get new q
      state.q = null;
      getPrime(state.qBits, finish);
      return;
    }

    // set keys
    var d = state.e.modInverse(state.phi);
    state.keys = {
      privateKey: pki.rsa.setPrivateKey(
        state.n, state.e, d, state.p, state.q,
        d.mod(state.p1), d.mod(state.q1),
        state.q.modInverse(state.p)),
      publicKey: pki.rsa.setPublicKey(state.n, state.e)
    };

    callback(null, state.keys);
  }
}

/**
 * Converts a positive BigInteger into 2's-complement big-endian bytes.
 *
 * @param b the big integer to convert.
 *
 * @return the bytes.
 */
function _bnToBytes(b) {
  // prepend 0x00 if first byte >= 0x80
  var hex = b.toString(16);
  if(hex[0] >= '8') {
    hex = '00' + hex;
  }
  var bytes = forge.util.hexToBytes(hex);

  // ensure integer is minimally-encoded
  if(bytes.length > 1 &&
    // leading 0x00 for positive integer
    ((bytes.charCodeAt(0) === 0 &&
    (bytes.charCodeAt(1) & 0x80) === 0) ||
    // leading 0xFF for negative integer
    (bytes.charCodeAt(0) === 0xFF &&
    (bytes.charCodeAt(1) & 0x80) === 0x80))) {
    return bytes.substr(1);
  }
  return bytes;
}

/**
 * Returns the required number of Miller-Rabin tests to generate a
 * prime with an error probability of (1/2)^80.
 *
 * See Handbook of Applied Cryptography Chapter 4, Table 4.4.
 *
 * @param bits the bit size.
 *
 * @return the required number of iterations.
 */
function _getMillerRabinTests(bits) {
  if(bits <= 100) return 27;
  if(bits <= 150) return 18;
  if(bits <= 200) return 15;
  if(bits <= 250) return 12;
  if(bits <= 300) return 9;
  if(bits <= 350) return 8;
  if(bits <= 400) return 7;
  if(bits <= 500) return 6;
  if(bits <= 600) return 5;
  if(bits <= 800) return 4;
  if(bits <= 1250) return 3;
  return 2;
}

/**
 * Performs feature detection on the Node crypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectNodeCrypto(fn) {
  return forge.util.isNodejs && typeof _crypto[fn] === 'function';
}

/**
 * Performs feature detection on the SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectSubtleCrypto(fn) {
  return (typeof util.globalScope !== 'undefined' &&
    typeof util.globalScope.crypto === 'object' &&
    typeof util.globalScope.crypto.subtle === 'object' &&
    typeof util.globalScope.crypto.subtle[fn] === 'function');
}

/**
 * Performs feature detection on the deprecated Microsoft Internet Explorer
 * outdated SubtleCrypto interface. This function should only be used after
 * checking for the modern, standard SubtleCrypto interface.
 *
 * @param fn the feature (function) to detect.
 *
 * @return true if detected, false if not.
 */
function _detectSubtleMsCrypto(fn) {
  return (typeof util.globalScope !== 'undefined' &&
    typeof util.globalScope.msCrypto === 'object' &&
    typeof util.globalScope.msCrypto.subtle === 'object' &&
    typeof util.globalScope.msCrypto.subtle[fn] === 'function');
}

function _intToUint8Array(x) {
  var bytes = forge.util.hexToBytes(x.toString(16));
  var buffer = new Uint8Array(bytes.length);
  for(var i = 0; i < bytes.length; ++i) {
    buffer[i] = bytes.charCodeAt(i);
  }
  return buffer;
}

function _privateKeyFromJwk(jwk) {
  if(jwk.kty !== 'RSA') {
    throw new Error(
      'Unsupported key algorithm "' + jwk.kty + '"; algorithm must be "RSA".');
  }
  return pki.setRsaPrivateKey(
    _base64ToBigInt(jwk.n),
    _base64ToBigInt(jwk.e),
    _base64ToBigInt(jwk.d),
    _base64ToBigInt(jwk.p),
    _base64ToBigInt(jwk.q),
    _base64ToBigInt(jwk.dp),
    _base64ToBigInt(jwk.dq),
    _base64ToBigInt(jwk.qi));
}

function _publicKeyFromJwk(jwk) {
  if(jwk.kty !== 'RSA') {
    throw new Error('Key algorithm must be "RSA".');
  }
  return pki.setRsaPublicKey(
    _base64ToBigInt(jwk.n),
    _base64ToBigInt(jwk.e));
}

function _base64ToBigInt(b64) {
  return new BigInteger(forge.util.bytesToHex(forge.util.decode64(b64)), 16);
}


/***/ }),

/***/ "./node_modules/node-forge/lib/sha1.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/sha1.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Secure Hash Algorithm with 160-bit digest (SHA-1) implementation.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
forge.md.sha1 = forge.md.algorithms.sha1 = sha1;

/**
 * Creates a SHA-1 message digest object.
 *
 * @return a message digest object.
 */
sha1.create = function() {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-1 state contains five 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(80);

  // message digest object
  var md = {
    algorithm: 'sha1',
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x67452301,
      h1: 0xEFCDAB89,
      h2: 0x98BADCFE,
      h3: 0x10325476,
      h4: 0xC3D2E1F0
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = ((len[1] / 0x100000000) >>> 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-1 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = (next / 0x100000000) >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };

  return md;
};

// sha-1 padding bytes not initialized yet
var _padding = null;
var _initialized = false;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // now initialized
  _initialized = true;
}

/**
 * Updates a SHA-1 state with the given byte buffer.
 *
 * @param s the SHA-1 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t, a, b, c, d, e, f, i;
  var len = bytes.length();
  while(len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 80 32-bit words according to SHA-1 algorithm
    // and for 32-79 using Max Locktyukhin's optimization

    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;

    // round 1
    for(i = 0; i < 16; ++i) {
      t = bytes.getInt32();
      w[i] = t;
      f = d ^ (b & (c ^ d));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    for(; i < 20; ++i) {
      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      t = (t << 1) | (t >>> 31);
      w[i] = t;
      f = d ^ (b & (c ^ d));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x5A827999 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 2
    for(; i < 32; ++i) {
      t = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      t = (t << 1) | (t >>> 31);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    for(; i < 40; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0x6ED9EBA1 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 3
    for(; i < 60; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = (b & c) | (d & (b ^ c));
      t = ((a << 5) | (a >>> 27)) + f + e + 0x8F1BBCDC + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }
    // round 4
    for(; i < 80; ++i) {
      t = (w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32]);
      t = (t << 2) | (t >>> 30);
      w[i] = t;
      f = b ^ c ^ d;
      t = ((a << 5) | (a >>> 27)) + f + e + 0xCA62C1D6 + t;
      e = d;
      d = c;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      c = ((b << 30) | (b >>> 2)) >>> 0;
      b = a;
      a = t;
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;
    s.h4 = (s.h4 + e) | 0;

    len -= 64;
  }
}


/***/ }),

/***/ "./node_modules/node-forge/lib/sha256.js":
/*!***********************************************!*\
  !*** ./node_modules/node-forge/lib/sha256.js ***!
  \***********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Secure Hash Algorithm with 256-bit digest (SHA-256) implementation.
 *
 * See FIPS 180-2 for details.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2015 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
forge.md.sha256 = forge.md.algorithms.sha256 = sha256;

/**
 * Creates a SHA-256 message digest object.
 *
 * @return a message digest object.
 */
sha256.create = function() {
  // do initialization as necessary
  if(!_initialized) {
    _init();
  }

  // SHA-256 state contains eight 32-bit integers
  var _state = null;

  // input buffer
  var _input = forge.util.createBuffer();

  // used for word storage
  var _w = new Array(64);

  // message digest object
  var md = {
    algorithm: 'sha256',
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };

  /**
   * Starts the digest.
   *
   * @return this digest object.
   */
  md.start = function() {
    // up to 56-bit message length for convenience
    md.messageLength = 0;

    // full message length (set md.messageLength64 for backwards-compatibility)
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for(var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge.util.createBuffer();
    _state = {
      h0: 0x6A09E667,
      h1: 0xBB67AE85,
      h2: 0x3C6EF372,
      h3: 0xA54FF53A,
      h4: 0x510E527F,
      h5: 0x9B05688C,
      h6: 0x1F83D9AB,
      h7: 0x5BE0CD19
    };
    return md;
  };
  // start digest automatically for first time
  md.start();

  /**
   * Updates the digest with the given message input. The given input can
   * treated as raw input (no encoding will be applied) or an encoding of
   * 'utf8' maybe given to encode the input using UTF-8.
   *
   * @param msg the message input to update with.
   * @param encoding the encoding to use (default: 'raw', other: 'utf8').
   *
   * @return this digest object.
   */
  md.update = function(msg, encoding) {
    if(encoding === 'utf8') {
      msg = forge.util.encodeUtf8(msg);
    }

    // update message length
    var len = msg.length;
    md.messageLength += len;
    len = [(len / 0x100000000) >>> 0, len >>> 0];
    for(var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + ((md.fullMessageLength[i] / 0x100000000) >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = ((len[1] / 0x100000000) >>> 0);
    }

    // add bytes to input buffer
    _input.putBytes(msg);

    // process bytes
    _update(_state, _w, _input);

    // compact input buffer every 2K or if empty
    if(_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }

    return md;
  };

  /**
   * Produces the digest.
   *
   * @return a byte buffer containing the digest value.
   */
  md.digest = function() {
    /* Note: Here we copy the remaining bytes in the input buffer and
    add the appropriate SHA-256 padding. Then we do the final update
    on a copy of the state so that if the user wants to get
    intermediate digests they can do so. */

    /* Determine the number of bytes that must be added to the message
    to ensure its length is congruent to 448 mod 512. In other words,
    the data to be digested must be a multiple of 512 bits (or 128 bytes).
    This data includes the message, some padding, and the length of the
    message. Since the length of the message will be encoded as 8 bytes (64
    bits), that means that the last segment of the data must have 56 bytes
    (448 bits) of message and padding. Therefore, the length of the message
    plus the padding must be congruent to 448 mod 512 because
    512 - 128 = 448.

    In order to fill up the message length it must be filled with
    padding that begins with 1 bit followed by all 0 bits. Padding
    must *always* be present, so if the message length is already
    congruent to 448 mod 512, then 512 padding bits must be added. */

    var finalBlock = forge.util.createBuffer();
    finalBlock.putBytes(_input.bytes());

    // compute remaining size to be digested (include message length size)
    var remaining = (
      md.fullMessageLength[md.fullMessageLength.length - 1] +
      md.messageLengthSize);

    // add padding for overflow blockSize - overflow
    // _padding starts with 1 byte with first bit is set (byte value 128), then
    // there may be up to (blockSize - 1) other pad bytes
    var overflow = remaining & (md.blockLength - 1);
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));

    // serialize message length in bits in big-endian order; since length
    // is stored in bytes we multiply by 8 and add carry from next int
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for(var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = (next / 0x100000000) >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);

    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };
    _update(s2, _w, finalBlock);
    var rval = forge.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };

  return md;
};

// sha-256 padding bytes not initialized yet
var _padding = null;
var _initialized = false;

// table of constants
var _k = null;

/**
 * Initializes the constant tables.
 */
function _init() {
  // create padding
  _padding = String.fromCharCode(128);
  _padding += forge.util.fillString(String.fromCharCode(0x00), 64);

  // create K table for SHA-256
  _k = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

  // now initialized
  _initialized = true;
}

/**
 * Updates a SHA-256 state with the given byte buffer.
 *
 * @param s the SHA-256 state to update.
 * @param w the array to use to store words.
 * @param bytes the byte buffer to update with.
 */
function _update(s, w, bytes) {
  // consume 512 bit (64 byte) chunks
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
  var len = bytes.length();
  while(len >= 64) {
    // the w array will be populated with sixteen 32-bit big-endian words
    // and then extended into 64 32-bit words according to SHA-256
    for(i = 0; i < 16; ++i) {
      w[i] = bytes.getInt32();
    }
    for(; i < 64; ++i) {
      // XOR word 2 words ago rot right 17, rot right 19, shft right 10
      t1 = w[i - 2];
      t1 =
        ((t1 >>> 17) | (t1 << 15)) ^
        ((t1 >>> 19) | (t1 << 13)) ^
        (t1 >>> 10);
      // XOR word 15 words ago rot right 7, rot right 18, shft right 3
      t2 = w[i - 15];
      t2 =
        ((t2 >>> 7) | (t2 << 25)) ^
        ((t2 >>> 18) | (t2 << 14)) ^
        (t2 >>> 3);
      // sum(t1, word 7 ago, t2, word 16 ago) modulo 2^32
      w[i] = (t1 + w[i - 7] + t2 + w[i - 16]) | 0;
    }

    // initialize hash value for this chunk
    a = s.h0;
    b = s.h1;
    c = s.h2;
    d = s.h3;
    e = s.h4;
    f = s.h5;
    g = s.h6;
    h = s.h7;

    // round function
    for(i = 0; i < 64; ++i) {
      // Sum1(e)
      s1 =
        ((e >>> 6) | (e << 26)) ^
        ((e >>> 11) | (e << 21)) ^
        ((e >>> 25) | (e << 7));
      // Ch(e, f, g) (optimized the same way as SHA-1)
      ch = g ^ (e & (f ^ g));
      // Sum0(a)
      s0 =
        ((a >>> 2) | (a << 30)) ^
        ((a >>> 13) | (a << 19)) ^
        ((a >>> 22) | (a << 10));
      // Maj(a, b, c) (optimized the same way as SHA-1)
      maj = (a & b) | (c & (a ^ b));

      // main algorithm
      t1 = h + s1 + ch + _k[i] + w[i];
      t2 = s0 + maj;
      h = g;
      g = f;
      f = e;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`
      e = (d + t1) >>> 0;
      d = c;
      c = b;
      b = a;
      // `>>> 0` necessary to avoid iOS/Safari 10 optimization bug
      // can't truncate with `| 0`
      a = (t1 + t2) >>> 0;
    }

    // update hash state
    s.h0 = (s.h0 + a) | 0;
    s.h1 = (s.h1 + b) | 0;
    s.h2 = (s.h2 + c) | 0;
    s.h3 = (s.h3 + d) | 0;
    s.h4 = (s.h4 + e) | 0;
    s.h5 = (s.h5 + f) | 0;
    s.h6 = (s.h6 + g) | 0;
    s.h7 = (s.h7 + h) | 0;
    len -= 64;
  }
}


/***/ }),

/***/ "./node_modules/node-forge/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/util.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, setImmediate, global, Buffer) {/**
 * Utility functions for web applications.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2018 Digital Bazaar, Inc.
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
var baseN = __webpack_require__(/*! ./baseN */ "./node_modules/node-forge/lib/baseN.js");

/* Utilities API */
var util = module.exports = forge.util = forge.util || {};

// define setImmediate and nextTick
(function() {
  // use native nextTick (unless we're in webpack)
  // webpack (or better node-libs-browser polyfill) sets process.browser.
  // this way we can detect webpack properly
  if(typeof process !== 'undefined' && process.nextTick && !process.browser) {
    util.nextTick = process.nextTick;
    if(typeof setImmediate === 'function') {
      util.setImmediate = setImmediate;
    } else {
      // polyfill setImmediate with nextTick, older versions of node
      // (those w/o setImmediate) won't totally starve IO
      util.setImmediate = util.nextTick;
    }
    return;
  }

  // polyfill nextTick with native setImmediate
  if(typeof setImmediate === 'function') {
    util.setImmediate = function() { return setImmediate.apply(undefined, arguments); };
    util.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }

  /* Note: A polyfill upgrade pattern is used here to allow combining
  polyfills. For example, MutationObserver is fast, but blocks UI updates,
  so it needs to allow UI updates periodically, so it falls back on
  postMessage or setTimeout. */

  // polyfill with setTimeout
  util.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };

  // upgrade polyfill to use postMessage
  if(typeof window !== 'undefined' &&
    typeof window.postMessage === 'function') {
    var msg = 'forge.setImmediate';
    var callbacks = [];
    util.setImmediate = function(callback) {
      callbacks.push(callback);
      // only send message when one hasn't been sent in
      // the current turn of the event loop
      if(callbacks.length === 1) {
        window.postMessage(msg, '*');
      }
    };
    function handler(event) {
      if(event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }
    }
    window.addEventListener('message', handler, true);
  }

  // upgrade polyfill to use MutationObserver
  if(typeof MutationObserver !== 'undefined') {
    // polyfill with MutationObserver
    var now = Date.now();
    var attr = true;
    var div = document.createElement('div');
    var callbacks = [];
    new MutationObserver(function() {
      var copy = callbacks.slice();
      callbacks.length = 0;
      copy.forEach(function(callback) {
        callback();
      });
    }).observe(div, {attributes: true});
    var oldSetImmediate = util.setImmediate;
    util.setImmediate = function(callback) {
      if(Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        // only trigger observer when it hasn't been triggered in
        // the current turn of the event loop
        if(callbacks.length === 1) {
          div.setAttribute('a', attr = !attr);
        }
      }
    };
  }

  util.nextTick = util.setImmediate;
})();

// check if running under Node.js
util.isNodejs =
  typeof process !== 'undefined' && process.versions && process.versions.node;


// 'self' will also work in Web Workers (instance of WorkerGlobalScope) while
// it will point to `window` in the main thread.
// To remain compatible with older browsers, we fall back to 'window' if 'self'
// is not available.
util.globalScope = (function() {
  if(util.isNodejs) {
    return global;
  }

  return typeof self === 'undefined' ? window : self;
})();

// define isArray
util.isArray = Array.isArray || function(x) {
  return Object.prototype.toString.call(x) === '[object Array]';
};

// define isArrayBuffer
util.isArrayBuffer = function(x) {
  return typeof ArrayBuffer !== 'undefined' && x instanceof ArrayBuffer;
};

// define isArrayBufferView
util.isArrayBufferView = function(x) {
  return x && util.isArrayBuffer(x.buffer) && x.byteLength !== undefined;
};

/**
 * Ensure a bits param is 8, 16, 24, or 32. Used to validate input for
 * algorithms where bit manipulation, JavaScript limitations, and/or algorithm
 * design only allow for byte operations of a limited size.
 *
 * @param n number of bits.
 *
 * Throw Error if n invalid.
 */
function _checkBitsParam(n) {
  if(!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error('Only 8, 16, 24, or 32 bits supported: ' + n);
  }
}

// TODO: set ByteBuffer to best available backing
util.ByteBuffer = ByteStringBuffer;

/** Buffer w/BinaryString backing */

/**
 * Constructor for a binary string backed byte buffer.
 *
 * @param [b] the bytes to wrap (either encoded as string, one byte per
 *          character, or as an ArrayBuffer or Typed Array).
 */
function ByteStringBuffer(b) {
  // TODO: update to match DataBuffer API

  // the data in this buffer
  this.data = '';
  // the pointer for reading from this buffer
  this.read = 0;

  if(typeof b === 'string') {
    this.data = b;
  } else if(util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
    if(typeof Buffer !== 'undefined' && b instanceof Buffer) {
      this.data = b.toString('binary');
    } else {
      // convert native buffer to forge buffer
      // FIXME: support native buffers internally instead
      var arr = new Uint8Array(b);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch(e) {
        for(var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if(b instanceof ByteStringBuffer ||
    (typeof b === 'object' && typeof b.data === 'string' &&
    typeof b.read === 'number')) {
    // copy existing buffer
    this.data = b.data;
    this.read = b.read;
  }

  // used for v8 optimization
  this._constructedStringLength = 0;
}
util.ByteStringBuffer = ByteStringBuffer;

/* Note: This is an optimization for V8-based browsers. When V8 concatenates
  a string, the strings are only joined logically using a "cons string" or
  "constructed/concatenated string". These containers keep references to one
  another and can result in very large memory usage. For example, if a 2MB
  string is constructed by concatenating 4 bytes together at a time, the
  memory usage will be ~44MB; so ~22x increase. The strings are only joined
  together when an operation requiring their joining takes place, such as
  substr(). This function is called when adding data to this buffer to ensure
  these types of strings are periodically joined to reduce the memory
  footprint. */
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  this._constructedStringLength += x;
  if(this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    // this substr() should cause the constructed string to join
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};

/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */
util.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};

/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */
util.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};

/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putByte = function(b) {
  return this.putBytes(String.fromCharCode(b));
};

/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
  b = String.fromCharCode(b);
  var d = this.data;
  while(n > 0) {
    if(n & 1) {
      d += b;
    }
    n >>>= 1;
    if(n > 0) {
      b += b;
    }
  }
  this.data = d;
  this._optimizeConstructedString(n);
  return this;
};

/**
 * Puts bytes in this buffer.
 *
 * @param bytes the bytes (as a UTF-8 encoded string) to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putBytes = function(bytes) {
  this.data += bytes;
  this._optimizeConstructedString(bytes.length);
  return this;
};

/**
 * Puts a UTF-16 encoded string into this buffer.
 *
 * @param str the string to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putString = function(str) {
  return this.putBytes(util.encodeUtf8(str));
};

/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt16 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt24 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt32 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 24 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt16Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF));
};

/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt24Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF));
};

/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt32Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 24 & 0xFF));
};

/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  var bytes = '';
  do {
    n -= 8;
    bytes += String.fromCharCode((i >> n) & 0xFF);
  } while(n > 0);
  return this.putBytes(bytes);
};

/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
  // putInt checks n
  if(i < 0) {
    i += 2 << (n - 1);
  }
  return this.putInt(i, n);
};

/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
  return this.putBytes(buffer.getBytes());
};

/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */
util.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};

/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 8 ^
    this.data.charCodeAt(this.read + 1));
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 16 ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2));
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = (
    this.data.charCodeAt(this.read) << 24 ^
    this.data.charCodeAt(this.read + 1) << 16 ^
    this.data.charCodeAt(this.read + 2) << 8 ^
    this.data.charCodeAt(this.read + 3));
  this.read += 4;
  return rval;
};

/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2) << 16);
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = (
    this.data.charCodeAt(this.read) ^
    this.data.charCodeAt(this.read + 1) << 8 ^
    this.data.charCodeAt(this.read + 2) << 16 ^
    this.data.charCodeAt(this.read + 3) << 24);
  this.read += 4;
  return rval;
};

/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by ceil(n/8).
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.ByteStringBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while(n > 0);
  return rval;
};

/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.ByteStringBuffer.prototype.getSignedInt = function(n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << (n - 2);
  if(x >= max) {
    x -= max << 1;
  }
  return x;
};

/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */
util.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};

/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */
util.ByteStringBuffer.prototype.bytes = function(count) {
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
};

/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */
util.ByteStringBuffer.prototype.at = function(i) {
  return this.data.charCodeAt(this.read + i);
};

/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.setAt = function(i, b) {
  this.data = this.data.substr(0, this.read + i) +
    String.fromCharCode(b) +
    this.data.substr(this.read + i + 1);
  return this;
};

/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */
util.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};

/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */
util.ByteStringBuffer.prototype.copy = function() {
  var c = util.createBuffer(this.data);
  c.read = this.read;
  return c;
};

/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.compact = function() {
  if(this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};

/**
 * Clears this buffer.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.clear = function() {
  this.data = '';
  this.read = 0;
  return this;
};

/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */
util.ByteStringBuffer.prototype.truncate = function(count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};

/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */
util.ByteStringBuffer.prototype.toHex = function() {
  var rval = '';
  for(var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);
    if(b < 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
};

/**
 * Converts this buffer to a UTF-16 string (standard JavaScript string).
 *
 * @return a UTF-16 string.
 */
util.ByteStringBuffer.prototype.toString = function() {
  return util.decodeUtf8(this.bytes());
};

/** End Buffer w/BinaryString backing */

/** Buffer w/UInt8Array backing */

/**
 * FIXME: Experimental. Do not use yet.
 *
 * Constructor for an ArrayBuffer-backed byte buffer.
 *
 * The buffer may be constructed from a string, an ArrayBuffer, DataView, or a
 * TypedArray.
 *
 * If a string is given, its encoding should be provided as an option,
 * otherwise it will default to 'binary'. A 'binary' string is encoded such
 * that each character is one byte in length and size.
 *
 * If an ArrayBuffer, DataView, or TypedArray is given, it will be used
 * *directly* without any copying. Note that, if a write to the buffer requires
 * more space, the buffer will allocate a new backing ArrayBuffer to
 * accommodate. The starting read and write offsets for the buffer may be
 * given as options.
 *
 * @param [b] the initial bytes for this buffer.
 * @param options the options to use:
 *          [readOffset] the starting read offset to use (default: 0).
 *          [writeOffset] the starting write offset to use (default: the
 *            length of the first parameter).
 *          [growSize] the minimum amount, in bytes, to grow the buffer by to
 *            accommodate writes (default: 1024).
 *          [encoding] the encoding ('binary', 'utf8', 'utf16', 'hex') for the
 *            first parameter, if it is a string (default: 'binary').
 */
function DataBuffer(b, options) {
  // default options
  options = options || {};

  // pointers for read from/write to buffer
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;

  var isArrayBuffer = util.isArrayBuffer(b);
  var isArrayBufferView = util.isArrayBufferView(b);
  if(isArrayBuffer || isArrayBufferView) {
    // use ArrayBuffer directly
    if(isArrayBuffer) {
      this.data = new DataView(b);
    } else {
      // TODO: adjust read/write offset based on the type of view
      // or specify that this must be done in the options ... that the
      // offsets are byte-based
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = ('writeOffset' in options ?
      options.writeOffset : this.data.byteLength);
    return;
  }

  // initialize to empty array buffer and add any given bytes using putBytes
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;

  if(b !== null && b !== undefined) {
    this.putBytes(b);
  }

  if('writeOffset' in options) {
    this.write = options.writeOffset;
  }
}
util.DataBuffer = DataBuffer;

/**
 * Gets the number of bytes in this buffer.
 *
 * @return the number of bytes in this buffer.
 */
util.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};

/**
 * Gets whether or not this buffer is empty.
 *
 * @return true if this buffer is empty, false if not.
 */
util.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};

/**
 * Ensures this buffer has enough empty space to accommodate the given number
 * of bytes. An optional parameter may be given that indicates a minimum
 * amount to grow the buffer if necessary. If the parameter is not given,
 * the buffer will be grown by some previously-specified default amount
 * or heuristic.
 *
 * @param amount the number of bytes to accommodate.
 * @param [growSize] the minimum amount, in bytes, to grow the buffer by if
 *          necessary.
 */
util.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if(this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);

  // grow buffer
  var src = new Uint8Array(
    this.data.buffer, this.data.byteOffset, this.data.byteLength);
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src);
  this.data = new DataView(dst.buffer);

  return this;
};

/**
 * Puts a byte in this buffer.
 *
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putByte = function(b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};

/**
 * Puts a byte in this buffer N times.
 *
 * @param b the byte to put.
 * @param n the number of bytes of value b to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.fillWithByte = function(b, n) {
  this.accommodate(n);
  for(var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }
  return this;
};

/**
 * Puts bytes in this buffer. The bytes may be given as a string, an
 * ArrayBuffer, a DataView, or a TypedArray.
 *
 * @param bytes the bytes to put.
 * @param [encoding] the encoding for the first parameter ('binary', 'utf8',
 *          'utf16', 'hex'), if it is a string (default: 'binary').
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
  if(util.isArrayBufferView(bytes)) {
    var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    var len = src.byteLength - src.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src);
    this.write += len;
    return this;
  }

  if(util.isArrayBuffer(bytes)) {
    var src = new Uint8Array(bytes);
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src, this.write);
    this.write += src.byteLength;
    return this;
  }

  // bytes is a util.DataBuffer or equivalent
  if(bytes instanceof util.DataBuffer ||
    (typeof bytes === 'object' &&
    typeof bytes.read === 'number' && typeof bytes.write === 'number' &&
    util.isArrayBufferView(bytes.data))) {
    var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
    this.accommodate(src.byteLength);
    var dst = new Uint8Array(bytes.data.byteLength, this.write);
    dst.set(src);
    this.write += src.byteLength;
    return this;
  }

  if(bytes instanceof util.ByteStringBuffer) {
    // copy binary string and process as the same as a string parameter below
    bytes = bytes.data;
    encoding = 'binary';
  }

  // string conversion
  encoding = encoding || 'binary';
  if(typeof bytes === 'string') {
    var view;

    // decode from string
    if(encoding === 'hex') {
      this.accommodate(Math.ceil(bytes.length / 2));
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.hex.decode(bytes, view, this.write);
      return this;
    }
    if(encoding === 'base64') {
      this.accommodate(Math.ceil(bytes.length / 4) * 3);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.base64.decode(bytes, view, this.write);
      return this;
    }

    // encode text as UTF-8 bytes
    if(encoding === 'utf8') {
      // encode as UTF-8 then decode string as raw binary
      bytes = util.encodeUtf8(bytes);
      encoding = 'binary';
    }

    // decode string as raw binary
    if(encoding === 'binary' || encoding === 'raw') {
      // one byte per character
      this.accommodate(bytes.length);
      view = new Uint8Array(this.data.buffer, this.write);
      this.write += util.binary.raw.decode(view);
      return this;
    }

    // encode text as UTF-16 bytes
    if(encoding === 'utf16') {
      // two bytes per character
      this.accommodate(bytes.length * 2);
      view = new Uint16Array(this.data.buffer, this.write);
      this.write += util.text.utf16.encode(view);
      return this;
    }

    throw new Error('Invalid encoding: ' + encoding);
  }

  throw Error('Invalid parameter: ' + bytes);
};

/**
 * Puts the given buffer into this buffer.
 *
 * @param buffer the buffer to put into this one.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putBuffer = function(buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};

/**
 * Puts a string into this buffer.
 *
 * @param str the string to put.
 * @param [encoding] the encoding for the string (default: 'utf16').
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putString = function(str) {
  return this.putBytes(str, 'utf16');
};

/**
 * Puts a 16-bit integer in this buffer in big-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt16 = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};

/**
 * Puts a 24-bit integer in this buffer in big-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt24 = function(i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.write += 3;
  return this;
};

/**
 * Puts a 32-bit integer in this buffer in big-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt32 = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};

/**
 * Puts a 16-bit integer in this buffer in little-endian order.
 *
 * @param i the 16-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt16Le = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};

/**
 * Puts a 24-bit integer in this buffer in little-endian order.
 *
 * @param i the 24-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt24Le = function(i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 0xFF);
  this.data.setInt16(this.write, i >> 8 & 0xFFFF, true);
  this.write += 3;
  return this;
};

/**
 * Puts a 32-bit integer in this buffer in little-endian order.
 *
 * @param i the 32-bit integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt32Le = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};

/**
 * Puts an n-bit integer in this buffer in big-endian order.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, (i >> n) & 0xFF);
  } while(n > 0);
  return this;
};

/**
 * Puts a signed n-bit integer in this buffer in big-endian order. Two's
 * complement representation is used.
 *
 * @param i the n-bit integer.
 * @param n the number of bits in the integer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.putSignedInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if(i < 0) {
    i += 2 << (n - 1);
  }
  return this.putInt(i, n);
};

/**
 * Gets a byte from this buffer and advances the read pointer by 1.
 *
 * @return the byte.
 */
util.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};

/**
 * Gets a uint16 from this buffer in big-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in big-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.DataBuffer.prototype.getInt24 = function() {
  var rval = (
    this.data.getInt16(this.read) << 8 ^
    this.data.getInt8(this.read + 2));
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in big-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};

/**
 * Gets a uint16 from this buffer in little-endian order and advances the read
 * pointer by 2.
 *
 * @return the uint16.
 */
util.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};

/**
 * Gets a uint24 from this buffer in little-endian order and advances the read
 * pointer by 3.
 *
 * @return the uint24.
 */
util.DataBuffer.prototype.getInt24Le = function() {
  var rval = (
    this.data.getInt8(this.read) ^
    this.data.getInt16(this.read + 1, true) << 8);
  this.read += 3;
  return rval;
};

/**
 * Gets a uint32 from this buffer in little-endian order and advances the read
 * pointer by 4.
 *
 * @return the word.
 */
util.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};

/**
 * Gets an n-bit integer from this buffer in big-endian order and advances the
 * read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.DataBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    // TODO: Use (rval * 0x100) if adding support for 33 to 53 bits.
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while(n > 0);
  return rval;
};

/**
 * Gets a signed n-bit integer from this buffer in big-endian order, using
 * two's complement, and advances the read pointer by n/8.
 *
 * @param n the number of bits in the integer (8, 16, 24, or 32).
 *
 * @return the integer.
 */
util.DataBuffer.prototype.getSignedInt = function(n) {
  // getInt checks n
  var x = this.getInt(n);
  var max = 2 << (n - 2);
  if(x >= max) {
    x -= max << 1;
  }
  return x;
};

/**
 * Reads bytes out into a UTF-8 string and clears them from the buffer.
 *
 * @param count the number of bytes to read, undefined or null for all.
 *
 * @return a UTF-8 string of bytes.
 */
util.DataBuffer.prototype.getBytes = function(count) {
  // TODO: deprecate this method, it is poorly named and
  // this.toString('binary') replaces it
  // add a toTypedArray()/toArrayBuffer() function
  var rval;
  if(count) {
    // read count bytes
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if(count === 0) {
    rval = '';
  } else {
    // read all bytes, optimize to only copy when needed
    rval = (this.read === 0) ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};

/**
 * Gets a UTF-8 encoded string of the bytes from this buffer without modifying
 * the read pointer.
 *
 * @param count the number of bytes to get, omit to get all.
 *
 * @return a string full of UTF-8 encoded characters.
 */
util.DataBuffer.prototype.bytes = function(count) {
  // TODO: deprecate this method, it is poorly named, add "getString()"
  return (typeof(count) === 'undefined' ?
    this.data.slice(this.read) :
    this.data.slice(this.read, this.read + count));
};

/**
 * Gets a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 *
 * @return the byte.
 */
util.DataBuffer.prototype.at = function(i) {
  return this.data.getUint8(this.read + i);
};

/**
 * Puts a byte at the given index without modifying the read pointer.
 *
 * @param i the byte index.
 * @param b the byte to put.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.setAt = function(i, b) {
  this.data.setUint8(i, b);
  return this;
};

/**
 * Gets the last byte without modifying the read pointer.
 *
 * @return the last byte.
 */
util.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};

/**
 * Creates a copy of this buffer.
 *
 * @return the copy.
 */
util.DataBuffer.prototype.copy = function() {
  return new util.DataBuffer(this);
};

/**
 * Compacts this buffer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.compact = function() {
  if(this.read > 0) {
    var src = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src.byteLength);
    dst.set(src);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};

/**
 * Clears this buffer.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};

/**
 * Shortens this buffer by triming bytes off of the end of this buffer.
 *
 * @param count the number of bytes to trim off.
 *
 * @return this buffer.
 */
util.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};

/**
 * Converts this buffer to a hexadecimal string.
 *
 * @return a hexadecimal string.
 */
util.DataBuffer.prototype.toHex = function() {
  var rval = '';
  for(var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);
    if(b < 16) {
      rval += '0';
    }
    rval += b.toString(16);
  }
  return rval;
};

/**
 * Converts this buffer to a string, using the given encoding. If no
 * encoding is given, 'utf8' (UTF-8) is used.
 *
 * @param [encoding] the encoding to use: 'binary', 'utf8', 'utf16', 'hex',
 *          'base64' (default: 'utf8').
 *
 * @return a string representation of the bytes in this buffer.
 */
util.DataBuffer.prototype.toString = function(encoding) {
  var view = new Uint8Array(this.data, this.read, this.length());
  encoding = encoding || 'utf8';

  // encode to string
  if(encoding === 'binary' || encoding === 'raw') {
    return util.binary.raw.encode(view);
  }
  if(encoding === 'hex') {
    return util.binary.hex.encode(view);
  }
  if(encoding === 'base64') {
    return util.binary.base64.encode(view);
  }

  // decode to text
  if(encoding === 'utf8') {
    return util.text.utf8.decode(view);
  }
  if(encoding === 'utf16') {
    return util.text.utf16.decode(view);
  }

  throw new Error('Invalid encoding: ' + encoding);
};

/** End Buffer w/UInt8Array backing */

/**
 * Creates a buffer that stores bytes. A value may be given to put into the
 * buffer that is either a string of bytes or a UTF-16 string that will
 * be encoded using UTF-8 (to do the latter, specify 'utf8' as the encoding).
 *
 * @param [input] the bytes to wrap (as a string) or a UTF-16 string to encode
 *          as UTF-8.
 * @param [encoding] (default: 'raw', other: 'utf8').
 */
util.createBuffer = function(input, encoding) {
  // TODO: deprecate, use new ByteBuffer() instead
  encoding = encoding || 'raw';
  if(input !== undefined && encoding === 'utf8') {
    input = util.encodeUtf8(input);
  }
  return new util.ByteBuffer(input);
};

/**
 * Fills a string with a particular value. If you want the string to be a byte
 * string, pass in String.fromCharCode(theByte).
 *
 * @param c the character to fill the string with, use String.fromCharCode
 *          to fill the string with a byte value.
 * @param n the number of characters of value c to fill with.
 *
 * @return the filled string.
 */
util.fillString = function(c, n) {
  var s = '';
  while(n > 0) {
    if(n & 1) {
      s += c;
    }
    n >>>= 1;
    if(n > 0) {
      c += c;
    }
  }
  return s;
};

/**
 * Performs a per byte XOR between two byte strings and returns the result as a
 * string of bytes.
 *
 * @param s1 first string of bytes.
 * @param s2 second string of bytes.
 * @param n the number of bytes to XOR.
 *
 * @return the XOR'd result.
 */
util.xorBytes = function(s1, s2, n) {
  var s3 = '';
  var b = '';
  var t = '';
  var i = 0;
  var c = 0;
  for(; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
    if(c >= 10) {
      s3 += t;
      t = '';
      c = 0;
    }
    t += String.fromCharCode(b);
    ++c;
  }
  s3 += t;
  return s3;
};

/**
 * Converts a hex string into a 'binary' encoded string of bytes.
 *
 * @param hex the hexadecimal string to convert.
 *
 * @return the binary-encoded string of bytes.
 */
util.hexToBytes = function(hex) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.decode instead."
  var rval = '';
  var i = 0;
  if(hex.length & 1 == 1) {
    // odd number of characters, convert first character alone
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  // convert 2 characters (1 byte) at a time
  for(; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return rval;
};

/**
 * Converts a 'binary' encoded string of bytes to hex.
 *
 * @param bytes the byte string to convert.
 *
 * @return the string of hexadecimal characters.
 */
util.bytesToHex = function(bytes) {
  // TODO: deprecate: "Deprecated. Use util.binary.hex.encode instead."
  return util.createBuffer(bytes).toHex();
};

/**
 * Converts an 32-bit integer to 4-big-endian byte string.
 *
 * @param i the integer.
 *
 * @return the byte string.
 */
util.int32ToBytes = function(i) {
  return (
    String.fromCharCode(i >> 24 & 0xFF) +
    String.fromCharCode(i >> 16 & 0xFF) +
    String.fromCharCode(i >> 8 & 0xFF) +
    String.fromCharCode(i & 0xFF));
};

// base64 characters, reverse mapping
var _base64 =
  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var _base64Idx = [
/*43 -43 = 0*/
/*'+',  1,  2,  3,'/' */
   62, -1, -1, -1, 63,

/*'0','1','2','3','4','5','6','7','8','9' */
   52, 53, 54, 55, 56, 57, 58, 59, 60, 61,

/*15, 16, 17,'=', 19, 20, 21 */
  -1, -1, -1, 64, -1, -1, -1,

/*65 - 43 = 22*/
/*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,

/*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
   13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,

/*91 - 43 = 48 */
/*48, 49, 50, 51, 52, 53 */
  -1, -1, -1, -1, -1, -1,

/*97 - 43 = 54*/
/*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
   26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,

/*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
];

// base58 characters (Bitcoin alphabet)
var _base58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

/**
 * Base64 encodes a 'binary' encoded string of bytes.
 *
 * @param input the binary encoded string of bytes to base64-encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output.
 */
util.encode64 = function(input, maxline) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.encode instead."
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;
  while(i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);

    // encode 4 character group
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
    if(isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if(maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};

/**
 * Base64 decodes a string into a 'binary' encoded string of bytes.
 *
 * @param input the base64-encoded input.
 *
 * @return the binary encoded string.
 */
util.decode64 = function(input) {
  // TODO: deprecate: "Deprecated. Use util.binary.base64.decode instead."

  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  var output = '';
  var enc1, enc2, enc3, enc4;
  var i = 0;

  while(i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

    output += String.fromCharCode((enc1 << 2) | (enc2 >> 4));
    if(enc3 !== 64) {
      // decoded at least 2 bytes
      output += String.fromCharCode(((enc2 & 15) << 4) | (enc3 >> 2));
      if(enc4 !== 64) {
        // decoded 3 bytes
        output += String.fromCharCode(((enc3 & 3) << 6) | enc4);
      }
    }
  }

  return output;
};

/**
 * UTF-8 encodes the given UTF-16 encoded string (a standard JavaScript
 * string). Non-ASCII characters will be encoded as multiple bytes according
 * to UTF-8.
 *
 * @param str the string to encode.
 *
 * @return the UTF-8 encoded string.
 */
util.encodeUtf8 = function(str) {
  return unescape(encodeURIComponent(str));
};

/**
 * Decodes a UTF-8 encoded string into a UTF-16 string.
 *
 * @param str the string to decode.
 *
 * @return the UTF-16 encoded string (standard JavaScript string).
 */
util.decodeUtf8 = function(str) {
  return decodeURIComponent(escape(str));
};

// binary encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN : {
    encode: baseN.encode,
    decode: baseN.decode
  }
};

/**
 * Encodes a Uint8Array as a binary-encoded string. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param bytes the Uint8Array to encode.
 *
 * @return the binary-encoded string.
 */
util.binary.raw.encode = function(bytes) {
  return String.fromCharCode.apply(null, bytes);
};

/**
 * Decodes a binary-encoded string to a Uint8Array. This encoding uses
 * a value between 0 and 255 for each character.
 *
 * @param str the binary-encoded string to decode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.raw.decode = function(str, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for(var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }
  return output ? (j - offset) : out;
};

/**
 * Encodes a 'binary' string, ArrayBuffer, DataView, TypedArray, or
 * ByteBuffer as a string of hexadecimal characters.
 *
 * @param bytes the bytes to convert.
 *
 * @return the string of hexadecimal characters.
 */
util.binary.hex.encode = util.bytesToHex;

/**
 * Decodes a hex-encoded string to a Uint8Array.
 *
 * @param hex the hexadecimal string to convert.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i = 0, j = offset;
  if(hex.length & 1) {
    // odd number of characters, convert first character alone
    i = 1;
    out[j++] = parseInt(hex[0], 16);
  }
  // convert 2 characters (1 byte) at a time
  for(; i < hex.length; i += 2) {
    out[j++] = parseInt(hex.substr(i, 2), 16);
  }
  return output ? (j - offset) : out;
};

/**
 * Base64-encodes a Uint8Array.
 *
 * @param input the Uint8Array to encode.
 * @param maxline the maximum number of encoded characters per line to use,
 *          defaults to none.
 *
 * @return the base64-encoded output string.
 */
util.binary.base64.encode = function(input, maxline) {
  var line = '';
  var output = '';
  var chr1, chr2, chr3;
  var i = 0;
  while(i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++];

    // encode 4 character group
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt(((chr1 & 3) << 4) | (chr2 >> 4));
    if(isNaN(chr2)) {
      line += '==';
    } else {
      line += _base64.charAt(((chr2 & 15) << 2) | (chr3 >> 6));
      line += isNaN(chr3) ? '=' : _base64.charAt(chr3 & 63);
    }

    if(maxline && line.length > maxline) {
      output += line.substr(0, maxline) + '\r\n';
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};

/**
 * Decodes a base64-encoded string to a Uint8Array.
 *
 * @param input the base64-encoded input string.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }

  // remove all non-base64 characters
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0, j = offset;

  while(i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];

    out[j++] = (enc1 << 2) | (enc2 >> 4);
    if(enc3 !== 64) {
      // decoded at least 2 bytes
      out[j++] = ((enc2 & 15) << 4) | (enc3 >> 2);
      if(enc4 !== 64) {
        // decoded 3 bytes
        out[j++] = ((enc3 & 3) << 6) | enc4;
      }
    }
  }

  // make sure result is the exact decoded length
  return output ? (j - offset) : out.subarray(0, j);
};

// add support for base58 encoding/decoding with Bitcoin alphabet
util.binary.base58.encode = function(input, maxline) {
  return util.binary.baseN.encode(input, _base58, maxline);
};
util.binary.base58.decode = function(input, maxline) {
  return util.binary.baseN.decode(input, _base58, maxline);
};

// text encoding/decoding tools
// FIXME: Experimental. Do not use yet.
util.text = {
  utf8: {},
  utf16: {}
};

/**
 * Encodes the given string as UTF-8 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.text.utf8.encode = function(str, output, offset) {
  str = util.encodeUtf8(str);
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length);
  }
  offset = offset || 0;
  var j = offset;
  for(var i = 0; i < str.length; ++i) {
    out[j++] = str.charCodeAt(i);
  }
  return output ? (j - offset) : out;
};

/**
 * Decodes the UTF-8 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */
util.text.utf8.decode = function(bytes) {
  return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
};

/**
 * Encodes the given string as UTF-16 in a Uint8Array.
 *
 * @param str the string to encode.
 * @param [output] an optional Uint8Array to write the output to; if it
 *          is too small, an exception will be thrown.
 * @param [offset] the start offset for writing to the output (default: 0).
 *
 * @return the Uint8Array or the number of bytes written if output was given.
 */
util.text.utf16.encode = function(str, output, offset) {
  var out = output;
  if(!out) {
    out = new Uint8Array(str.length * 2);
  }
  var view = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j = offset;
  var k = offset;
  for(var i = 0; i < str.length; ++i) {
    view[k++] = str.charCodeAt(i);
    j += 2;
  }
  return output ? (j - offset) : out;
};

/**
 * Decodes the UTF-16 contents from a Uint8Array.
 *
 * @param bytes the Uint8Array to decode.
 *
 * @return the resulting string.
 */
util.text.utf16.decode = function(bytes) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
};

/**
 * Deflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true to return only raw deflate data, false to include zlib
 *          header and trailer.
 *
 * @return the deflated data as a string.
 */
util.deflate = function(api, bytes, raw) {
  bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);

  // strip zlib header and trailer if necessary
  if(raw) {
    // zlib header is 2 bytes (CMF,FLG) where FLG indicates that
    // there is a 4-byte DICT (alder-32) block before the data if
    // its 5th bit is set
    var start = 2;
    var flg = bytes.charCodeAt(1);
    if(flg & 0x20) {
      start = 6;
    }
    // zlib trailer is 4 bytes of adler-32
    bytes = bytes.substring(start, bytes.length - 4);
  }

  return bytes;
};

/**
 * Inflates the given data using a flash interface.
 *
 * @param api the flash interface.
 * @param bytes the data.
 * @param raw true if the incoming data has no zlib header or trailer and is
 *          raw DEFLATE data.
 *
 * @return the inflated data as a string, null on error.
 */
util.inflate = function(api, bytes, raw) {
  // TODO: add zlib header and trailer if necessary/possible
  var rval = api.inflate(util.encode64(bytes)).rval;
  return (rval === null) ? null : util.decode64(rval);
};

/**
 * Sets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param obj the storage object, null to remove.
 */
var _setStorageObject = function(api, id, obj) {
  if(!api) {
    throw new Error('WebStorage not available.');
  }

  var rval;
  if(obj === null) {
    rval = api.removeItem(id);
  } else {
    // json-encode and base64-encode object
    obj = util.encode64(JSON.stringify(obj));
    rval = api.setItem(id, obj);
  }

  // handle potential flash error
  if(typeof(rval) !== 'undefined' && rval.rval !== true) {
    var error = new Error(rval.error.message);
    error.id = rval.error.id;
    error.name = rval.error.name;
    throw error;
  }
};

/**
 * Gets a storage object.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 *
 * @return the storage object entry or null if none exists.
 */
var _getStorageObject = function(api, id) {
  if(!api) {
    throw new Error('WebStorage not available.');
  }

  // get the existing entry
  var rval = api.getItem(id);

  /* Note: We check api.init because we can't do (api == localStorage)
    on IE because of "Class doesn't support Automation" exception. Only
    the flash api has an init method so this works too, but we need a
    better solution in the future. */

  // flash returns item wrapped in an object, handle special case
  if(api.init) {
    if(rval.rval === null) {
      if(rval.error) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
      // no error, but also no item
      rval = null;
    } else {
      rval = rval.rval;
    }
  }

  // handle decoding
  if(rval !== null) {
    // base64-decode and json-decode data
    rval = JSON.parse(util.decode64(rval));
  }

  return rval;
};

/**
 * Stores an item in local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 */
var _setItem = function(api, id, key, data) {
  // get storage object
  var obj = _getStorageObject(api, id);
  if(obj === null) {
    // create a new storage object
    obj = {};
  }
  // update key
  obj[key] = data;

  // set storage object
  _setStorageObject(api, id, obj);
};

/**
 * Gets an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 *
 * @return the item.
 */
var _getItem = function(api, id, key) {
  // get storage object
  var rval = _getStorageObject(api, id);
  if(rval !== null) {
    // return data at key
    rval = (key in rval) ? rval[key] : null;
  }

  return rval;
};

/**
 * Removes an item from local storage.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 */
var _removeItem = function(api, id, key) {
  // get storage object
  var obj = _getStorageObject(api, id);
  if(obj !== null && key in obj) {
    // remove key
    delete obj[key];

    // see if entry has no keys remaining
    var empty = true;
    for(var prop in obj) {
      empty = false;
      break;
    }
    if(empty) {
      // remove entry entirely if no keys are left
      obj = null;
    }

    // set storage object
    _setStorageObject(api, id, obj);
  }
};

/**
 * Clears the local disk storage identified by the given ID.
 *
 * @param api the storage interface.
 * @param id the storage ID to use.
 */
var _clearItems = function(api, id) {
  _setStorageObject(api, id, null);
};

/**
 * Calls a storage function.
 *
 * @param func the function to call.
 * @param args the arguments for the function.
 * @param location the location argument.
 *
 * @return the return value from the function.
 */
var _callStorageFunction = function(func, args, location) {
  var rval = null;

  // default storage types
  if(typeof(location) === 'undefined') {
    location = ['web', 'flash'];
  }

  // apply storage types in order of preference
  var type;
  var done = false;
  var exception = null;
  for(var idx in location) {
    type = location[idx];
    try {
      if(type === 'flash' || type === 'both') {
        if(args[0] === null) {
          throw new Error('Flash local storage not available.');
        }
        rval = func.apply(this, args);
        done = (type === 'flash');
      }
      if(type === 'web' || type === 'both') {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch(ex) {
      exception = ex;
    }
    if(done) {
      break;
    }
  }

  if(!done) {
    throw exception;
  }

  return rval;
};

/**
 * Stores an item on local disk.
 *
 * The available types of local storage include 'flash', 'web', and 'both'.
 *
 * The type 'flash' refers to flash local storage (SharedObject). In order
 * to use flash local storage, the 'api' parameter must be valid. The type
 * 'web' refers to WebStorage, if supported by the browser. The type 'both'
 * refers to storing using both 'flash' and 'web', not just one or the
 * other.
 *
 * The location array should list the storage types to use in order of
 * preference:
 *
 * ['flash']: flash only storage
 * ['web']: web only storage
 * ['both']: try to store in both
 * ['flash','web']: store in flash first, but if not available, 'web'
 * ['web','flash']: store in web first, but if not available, 'flash'
 *
 * The location array defaults to: ['web', 'flash']
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param data the data for the item (any javascript object/primitive).
 * @param location an array with the preferred types of storage to use.
 */
util.setItem = function(api, id, key, data, location) {
  _callStorageFunction(_setItem, arguments, location);
};

/**
 * Gets an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface, null to use only WebStorage.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 *
 * @return the item.
 */
util.getItem = function(api, id, key, location) {
  return _callStorageFunction(_getItem, arguments, location);
};

/**
 * Removes an item on local disk.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface.
 * @param id the storage ID to use.
 * @param key the key for the item.
 * @param location an array with the preferred types of storage to use.
 */
util.removeItem = function(api, id, key, location) {
  _callStorageFunction(_removeItem, arguments, location);
};

/**
 * Clears the local disk storage identified by the given ID.
 *
 * Set setItem() for details on storage types.
 *
 * @param api the flash interface if flash is available.
 * @param id the storage ID to use.
 * @param location an array with the preferred types of storage to use.
 */
util.clearItems = function(api, id, location) {
  _callStorageFunction(_clearItems, arguments, location);
};

/**
 * Parses the scheme, host, and port from an http(s) url.
 *
 * @param str the url string.
 *
 * @return the parsed url object or null if the url is invalid.
 */
util.parseUrl = function(str) {
  // FIXME: this regex looks a bit broken
  var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
  regex.lastIndex = 0;
  var m = regex.exec(str);
  var url = (m === null) ? null : {
    full: str,
    scheme: m[1],
    host: m[2],
    port: m[3],
    path: m[4]
  };
  if(url) {
    url.fullHost = url.host;
    if(url.port) {
      if(url.port !== 80 && url.scheme === 'http') {
        url.fullHost += ':' + url.port;
      } else if(url.port !== 443 && url.scheme === 'https') {
        url.fullHost += ':' + url.port;
      }
    } else if(url.scheme === 'http') {
      url.port = 80;
    } else if(url.scheme === 'https') {
      url.port = 443;
    }
    url.full = url.scheme + '://' + url.fullHost;
  }
  return url;
};

/* Storage for query variables */
var _queryVariables = null;

/**
 * Returns the window location query variables. Query is parsed on the first
 * call and the same object is returned on subsequent calls. The mapping
 * is from keys to an array of values. Parameters without values will have
 * an object key set but no value added to the value array. Values are
 * unescaped.
 *
 * ...?k1=v1&k2=v2:
 * {
 *   "k1": ["v1"],
 *   "k2": ["v2"]
 * }
 *
 * ...?k1=v1&k1=v2:
 * {
 *   "k1": ["v1", "v2"]
 * }
 *
 * ...?k1=v1&k2:
 * {
 *   "k1": ["v1"],
 *   "k2": []
 * }
 *
 * ...?k1=v1&k1:
 * {
 *   "k1": ["v1"]
 * }
 *
 * ...?k1&k1:
 * {
 *   "k1": []
 * }
 *
 * @param query the query string to parse (optional, default to cached
 *          results from parsing window location search query).
 *
 * @return object mapping keys to variables.
 */
util.getQueryVariables = function(query) {
  var parse = function(q) {
    var rval = {};
    var kvpairs = q.split('&');
    for(var i = 0; i < kvpairs.length; i++) {
      var pos = kvpairs[i].indexOf('=');
      var key;
      var val;
      if(pos > 0) {
        key = kvpairs[i].substring(0, pos);
        val = kvpairs[i].substring(pos + 1);
      } else {
        key = kvpairs[i];
        val = null;
      }
      if(!(key in rval)) {
        rval[key] = [];
      }
      // disallow overriding object prototype keys
      if(!(key in Object.prototype) && val !== null) {
        rval[key].push(unescape(val));
      }
    }
    return rval;
  };

   var rval;
   if(typeof(query) === 'undefined') {
     // set cached variables if needed
     if(_queryVariables === null) {
       if(typeof(window) !== 'undefined' && window.location && window.location.search) {
          // parse window search query
          _queryVariables = parse(window.location.search.substring(1));
       } else {
          // no query variables available
          _queryVariables = {};
       }
     }
     rval = _queryVariables;
   } else {
     // parse given query
     rval = parse(query);
   }
   return rval;
};

/**
 * Parses a fragment into a path and query. This method will take a URI
 * fragment and break it up as if it were the main URI. For example:
 *    /bar/baz?a=1&b=2
 * results in:
 *    {
 *       path: ["bar", "baz"],
 *       query: {"k1": ["v1"], "k2": ["v2"]}
 *    }
 *
 * @return object with a path array and query object.
 */
util.parseFragment = function(fragment) {
  // default to whole fragment
  var fp = fragment;
  var fq = '';
  // split into path and query if possible at the first '?'
  var pos = fragment.indexOf('?');
  if(pos > 0) {
    fp = fragment.substring(0, pos);
    fq = fragment.substring(pos + 1);
  }
  // split path based on '/' and ignore first element if empty
  var path = fp.split('/');
  if(path.length > 0 && path[0] === '') {
    path.shift();
  }
  // convert query into object
  var query = (fq === '') ? {} : util.getQueryVariables(fq);

  return {
    pathString: fp,
    queryString: fq,
    path: path,
    query: query
  };
};

/**
 * Makes a request out of a URI-like request string. This is intended to
 * be used where a fragment id (after a URI '#') is parsed as a URI with
 * path and query parts. The string should have a path beginning and
 * delimited by '/' and optional query parameters following a '?'. The
 * query should be a standard URL set of key value pairs delimited by
 * '&'. For backwards compatibility the initial '/' on the path is not
 * required. The request object has the following API, (fully described
 * in the method code):
 *    {
 *       path: <the path string part>.
 *       query: <the query string part>,
 *       getPath(i): get part or all of the split path array,
 *       getQuery(k, i): get part or all of a query key array,
 *       getQueryLast(k, _default): get last element of a query key array.
 *    }
 *
 * @return object with request parameters.
 */
util.makeRequest = function(reqString) {
  var frag = util.parseFragment(reqString);
  var req = {
    // full path string
    path: frag.pathString,
    // full query string
    query: frag.queryString,
    /**
     * Get path or element in path.
     *
     * @param i optional path index.
     *
     * @return path or part of path if i provided.
     */
    getPath: function(i) {
      return (typeof(i) === 'undefined') ? frag.path : frag.path[i];
    },
    /**
     * Get query, values for a key, or value for a key index.
     *
     * @param k optional query key.
     * @param i optional query key index.
     *
     * @return query, values for a key, or value for a key index.
     */
    getQuery: function(k, i) {
      var rval;
      if(typeof(k) === 'undefined') {
        rval = frag.query;
      } else {
        rval = frag.query[k];
        if(rval && typeof(i) !== 'undefined') {
           rval = rval[i];
        }
      }
      return rval;
    },
    getQueryLast: function(k, _default) {
      var rval;
      var vals = req.getQuery(k);
      if(vals) {
        rval = vals[vals.length - 1];
      } else {
        rval = _default;
      }
      return rval;
    }
  };
  return req;
};

/**
 * Makes a URI out of a path, an object with query parameters, and a
 * fragment. Uses jQuery.param() internally for query string creation.
 * If the path is an array, it will be joined with '/'.
 *
 * @param path string path or array of strings.
 * @param query object with query parameters. (optional)
 * @param fragment fragment string. (optional)
 *
 * @return string object with request parameters.
 */
util.makeLink = function(path, query, fragment) {
  // join path parts if needed
  path = jQuery.isArray(path) ? path.join('/') : path;

  var qstr = jQuery.param(query || {});
  fragment = fragment || '';
  return path +
    ((qstr.length > 0) ? ('?' + qstr) : '') +
    ((fragment.length > 0) ? ('#' + fragment) : '');
};

/**
 * Follows a path of keys deep into an object hierarchy and set a value.
 * If a key does not exist or it's value is not an object, create an
 * object in it's place. This can be destructive to a object tree if
 * leaf nodes are given as non-final path keys.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param value the value to set.
 */
util.setPath = function(object, keys, value) {
  // need to start at an object
  if(typeof(object) === 'object' && object !== null) {
    var i = 0;
    var len = keys.length;
    while(i < len) {
      var next = keys[i++];
      if(i == len) {
        // last
        object[next] = value;
      } else {
        // more
        var hasNext = (next in object);
        if(!hasNext ||
          (hasNext && typeof(object[next]) !== 'object') ||
          (hasNext && object[next] === null)) {
          object[next] = {};
        }
        object = object[next];
      }
    }
  }
};

/**
 * Follows a path of keys deep into an object hierarchy and return a value.
 * If a key does not exist, create an object in it's place.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 * @param _default value to return if path not found.
 *
 * @return the value at the path if found, else default if given, else
 *         undefined.
 */
util.getPath = function(object, keys, _default) {
  var i = 0;
  var len = keys.length;
  var hasNext = true;
  while(hasNext && i < len &&
    typeof(object) === 'object' && object !== null) {
    var next = keys[i++];
    hasNext = next in object;
    if(hasNext) {
      object = object[next];
    }
  }
  return (hasNext ? object : _default);
};

/**
 * Follow a path of keys deep into an object hierarchy and delete the
 * last one. If a key does not exist, do nothing.
 * Used to avoid exceptions from missing parts of the path.
 *
 * @param object the starting object.
 * @param keys an array of string keys.
 */
util.deletePath = function(object, keys) {
  // need to start at an object
  if(typeof(object) === 'object' && object !== null) {
    var i = 0;
    var len = keys.length;
    while(i < len) {
      var next = keys[i++];
      if(i == len) {
        // last
        delete object[next];
      } else {
        // more
        if(!(next in object) ||
          (typeof(object[next]) !== 'object') ||
          (object[next] === null)) {
           break;
        }
        object = object[next];
      }
    }
  }
};

/**
 * Check if an object is empty.
 *
 * Taken from:
 * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
 *
 * @param object the object to check.
 */
util.isEmpty = function(obj) {
  for(var prop in obj) {
    if(obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};

/**
 * Format with simple printf-style interpolation.
 *
 * %%: literal '%'
 * %s,%o: convert next argument into a string.
 *
 * @param format the string to format.
 * @param ... arguments to interpolate into the format string.
 */
util.format = function(format) {
  var re = /%./g;
  // current match
  var match;
  // current part
  var part;
  // current arg index
  var argi = 0;
  // collected parts to recombine later
  var parts = [];
  // last index found
  var last = 0;
  // loop while matches remain
  while((match = re.exec(format))) {
    part = format.substring(last, re.lastIndex - 2);
    // don't add empty strings (ie, parts between %s%s)
    if(part.length > 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    // switch on % code
    var code = match[0][1];
    switch(code) {
    case 's':
    case 'o':
      // check if enough arguments were given
      if(argi < arguments.length) {
        parts.push(arguments[argi++ + 1]);
      } else {
        parts.push('<?>');
      }
      break;
    // FIXME: do proper formating for numbers, etc
    //case 'f':
    //case 'd':
    case '%':
      parts.push('%');
      break;
    default:
      parts.push('<%' + code + '?>');
    }
  }
  // add trailing part of format string
  parts.push(format.substring(last));
  return parts.join('');
};

/**
 * Formats a number.
 *
 * http://snipplr.com/view/5945/javascript-numberformat--ported-from-php/
 */
util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  // http://kevin.vanzonneveld.net
  // +   original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
  // +     bugfix by: Michael White (http://crestidg.com)
  // +     bugfix by: Benjamin Lupton
  // +     bugfix by: Allan Jensen (http://www.winternet.no)
  // +    revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
  // *     example 1: number_format(1234.5678, 2, '.', '');
  // *     returns 1: 1234.57

  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d = dec_point === undefined ? ',' : dec_point;
  var t = thousands_sep === undefined ?
   '.' : thousands_sep, s = n < 0 ? '-' : '';
  var i = parseInt((n = Math.abs(+n || 0).toFixed(c)), 10) + '';
  var j = (i.length > 3) ? i.length % 3 : 0;
  return s + (j ? i.substr(0, j) + t : '') +
    i.substr(j).replace(/(\d{3})(?=\d)/g, '$1' + t) +
    (c ? d + Math.abs(n - i).toFixed(c).slice(2) : '');
};

/**
 * Formats a byte size.
 *
 * http://snipplr.com/view/5949/format-humanize-file-byte-size-presentation-in-javascript/
 */
util.formatSize = function(size) {
  if(size >= 1073741824) {
    size = util.formatNumber(size / 1073741824, 2, '.', '') + ' GiB';
  } else if(size >= 1048576) {
    size = util.formatNumber(size / 1048576, 2, '.', '') + ' MiB';
  } else if(size >= 1024) {
    size = util.formatNumber(size / 1024, 0) + ' KiB';
  } else {
    size = util.formatNumber(size, 0) + ' bytes';
  }
  return size;
};

/**
 * Converts an IPv4 or IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv4 or IPv6 address to convert.
 *
 * @return the 4-byte IPv6 or 16-byte IPv6 address or null if the address can't
 *         be parsed.
 */
util.bytesFromIP = function(ip) {
  if(ip.indexOf('.') !== -1) {
    return util.bytesFromIPv4(ip);
  }
  if(ip.indexOf(':') !== -1) {
    return util.bytesFromIPv6(ip);
  }
  return null;
};

/**
 * Converts an IPv4 string representation into bytes (in network order).
 *
 * @param ip the IPv4 address to convert.
 *
 * @return the 4-byte address or null if the address can't be parsed.
 */
util.bytesFromIPv4 = function(ip) {
  ip = ip.split('.');
  if(ip.length !== 4) {
    return null;
  }
  var b = util.createBuffer();
  for(var i = 0; i < ip.length; ++i) {
    var num = parseInt(ip[i], 10);
    if(isNaN(num)) {
      return null;
    }
    b.putByte(num);
  }
  return b.getBytes();
};

/**
 * Converts an IPv6 string representation into bytes (in network order).
 *
 * @param ip the IPv6 address to convert.
 *
 * @return the 16-byte address or null if the address can't be parsed.
 */
util.bytesFromIPv6 = function(ip) {
  var blanks = 0;
  ip = ip.split(':').filter(function(e) {
    if(e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip.length + blanks) * 2;
  var b = util.createBuffer();
  for(var i = 0; i < 8; ++i) {
    if(!ip[i] || ip[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes = util.hexToBytes(ip[i]);
    if(bytes.length < 2) {
      b.putByte(0);
    }
    b.putBytes(bytes);
  }
  return b.getBytes();
};

/**
 * Converts 4-bytes into an IPv4 string representation or 16-bytes into
 * an IPv6 string representation. The bytes must be in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 or IPv6 string representation if 4 or 16 bytes,
 *         respectively, are given, otherwise null.
 */
util.bytesToIP = function(bytes) {
  if(bytes.length === 4) {
    return util.bytesToIPv4(bytes);
  }
  if(bytes.length === 16) {
    return util.bytesToIPv6(bytes);
  }
  return null;
};

/**
 * Converts 4-bytes into an IPv4 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv4 string representation or null for an invalid # of bytes.
 */
util.bytesToIPv4 = function(bytes) {
  if(bytes.length !== 4) {
    return null;
  }
  var ip = [];
  for(var i = 0; i < bytes.length; ++i) {
    ip.push(bytes.charCodeAt(i));
  }
  return ip.join('.');
};

/**
 * Converts 16-bytes into an IPv16 string representation. The bytes must be
 * in network order.
 *
 * @param bytes the bytes to convert.
 *
 * @return the IPv16 string representation or null for an invalid # of bytes.
 */
util.bytesToIPv6 = function(bytes) {
  if(bytes.length !== 16) {
    return null;
  }
  var ip = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for(var i = 0; i < bytes.length; i += 2) {
    var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
    // canonicalize zero representation
    while(hex[0] === '0' && hex !== '0') {
      hex = hex.substr(1);
    }
    if(hex === '0') {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip.length;
      if(!last || idx !== last.end + 1) {
        zeroGroups.push({start: idx, end: idx});
      } else {
        last.end = idx;
        if((last.end - last.start) >
          (zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start)) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip.push(hex);
  }
  if(zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    // only shorten group of length > 0
    if(group.end - group.start > 0) {
      ip.splice(group.start, group.end - group.start + 1, '');
      if(group.start === 0) {
        ip.unshift('');
      }
      if(group.end === 7) {
        ip.push('');
      }
    }
  }
  return ip.join(':');
};

/**
 * Estimates the number of processes that can be run concurrently. If
 * creating Web Workers, keep in mind that the main JavaScript process needs
 * its own core.
 *
 * @param options the options to use:
 *          update true to force an update (not use the cached value).
 * @param callback(err, max) called once the operation completes.
 */
util.estimateCores = function(options, callback) {
  if(typeof options === 'function') {
    callback = options;
    options = {};
  }
  options = options || {};
  if('cores' in util && !options.update) {
    return callback(null, util.cores);
  }
  if(typeof navigator !== 'undefined' &&
    'hardwareConcurrency' in navigator &&
    navigator.hardwareConcurrency > 0) {
    util.cores = navigator.hardwareConcurrency;
    return callback(null, util.cores);
  }
  if(typeof Worker === 'undefined') {
    // workers not available
    util.cores = 1;
    return callback(null, util.cores);
  }
  if(typeof Blob === 'undefined') {
    // can't estimate, default to 2
    util.cores = 2;
    return callback(null, util.cores);
  }

  // create worker concurrency estimation code as blob
  var blobUrl = URL.createObjectURL(new Blob(['(',
    function() {
      self.addEventListener('message', function(e) {
        // run worker for 4 ms
        var st = Date.now();
        var et = st + 4;
        while(Date.now() < et);
        self.postMessage({st: st, et: et});
      });
    }.toString(),
  ')()'], {type: 'application/javascript'}));

  // take 5 samples using 16 workers
  sample([], 5, 16);

  function sample(max, samples, numWorkers) {
    if(samples === 0) {
      // get overlap average
      var avg = Math.floor(max.reduce(function(avg, x) {
        return avg + x;
      }, 0) / max.length);
      util.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util.cores);
    }
    map(numWorkers, function(err, results) {
      max.push(reduce(numWorkers, results));
      sample(max, samples - 1, numWorkers);
    });
  }

  function map(numWorkers, callback) {
    var workers = [];
    var results = [];
    for(var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener('message', function(e) {
        results.push(e.data);
        if(results.length === numWorkers) {
          for(var i = 0; i < numWorkers; ++i) {
            workers[i].terminate();
          }
          callback(null, results);
        }
      });
      workers.push(worker);
    }
    for(var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }

  function reduce(numWorkers, results) {
    // find overlapping time windows
    var overlaps = [];
    for(var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for(var i = 0; i < numWorkers; ++i) {
        if(n === i) {
          continue;
        }
        var r2 = results[i];
        if((r1.st > r2.st && r1.st < r2.et) ||
          (r2.st > r1.st && r2.st < r1.et)) {
          overlap.push(i);
        }
      }
    }
    // get maximum overlaps ... don't include overlapping worker itself
    // as the main JS process was also being scheduled during the work and
    // would have to be subtracted from the estimate anyway
    return overlaps.reduce(function(max, overlap) {
      return Math.max(max, overlap.length);
    }, 0);
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/node-forge/lib/x509.js":
/*!*********************************************!*\
  !*** ./node_modules/node-forge/lib/x509.js ***!
  \*********************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Javascript implementation of X.509 and related components (such as
 * Certification Signing Requests) of a Public Key Infrastructure.
 *
 * @author Dave Longley
 *
 * Copyright (c) 2010-2014 Digital Bazaar, Inc.
 *
 * The ASN.1 representation of an X.509v3 certificate is as follows
 * (see RFC 2459):
 *
 * Certificate ::= SEQUENCE {
 *   tbsCertificate       TBSCertificate,
 *   signatureAlgorithm   AlgorithmIdentifier,
 *   signatureValue       BIT STRING
 * }
 *
 * TBSCertificate ::= SEQUENCE {
 *   version         [0]  EXPLICIT Version DEFAULT v1,
 *   serialNumber         CertificateSerialNumber,
 *   signature            AlgorithmIdentifier,
 *   issuer               Name,
 *   validity             Validity,
 *   subject              Name,
 *   subjectPublicKeyInfo SubjectPublicKeyInfo,
 *   issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
 *                        -- If present, version shall be v2 or v3
 *   extensions      [3]  EXPLICIT Extensions OPTIONAL
 *                        -- If present, version shall be v3
 * }
 *
 * Version ::= INTEGER  { v1(0), v2(1), v3(2) }
 *
 * CertificateSerialNumber ::= INTEGER
 *
 * Name ::= CHOICE {
 *   // only one possible choice for now
 *   RDNSequence
 * }
 *
 * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 *
 * RelativeDistinguishedName ::= SET OF AttributeTypeAndValue
 *
 * AttributeTypeAndValue ::= SEQUENCE {
 *   type     AttributeType,
 *   value    AttributeValue
 * }
 * AttributeType ::= OBJECT IDENTIFIER
 * AttributeValue ::= ANY DEFINED BY AttributeType
 *
 * Validity ::= SEQUENCE {
 *   notBefore      Time,
 *   notAfter       Time
 * }
 *
 * Time ::= CHOICE {
 *   utcTime        UTCTime,
 *   generalTime    GeneralizedTime
 * }
 *
 * UniqueIdentifier ::= BIT STRING
 *
 * SubjectPublicKeyInfo ::= SEQUENCE {
 *   algorithm            AlgorithmIdentifier,
 *   subjectPublicKey     BIT STRING
 * }
 *
 * Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension
 *
 * Extension ::= SEQUENCE {
 *   extnID      OBJECT IDENTIFIER,
 *   critical    BOOLEAN DEFAULT FALSE,
 *   extnValue   OCTET STRING
 * }
 *
 * The only key algorithm currently supported for PKI is RSA.
 *
 * RSASSA-PSS signatures are described in RFC 3447 and RFC 4055.
 *
 * PKCS#10 v1.7 describes certificate signing requests:
 *
 * CertificationRequestInfo:
 *
 * CertificationRequestInfo ::= SEQUENCE {
 *   version       INTEGER { v1(0) } (v1,...),
 *   subject       Name,
 *   subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
 *   attributes    [0] Attributes{{ CRIAttributes }}
 * }
 *
 * Attributes { ATTRIBUTE:IOSet } ::= SET OF Attribute{{ IOSet }}
 *
 * CRIAttributes  ATTRIBUTE  ::= {
 *   ... -- add any locally defined attributes here -- }
 *
 * Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE {
 *   type   ATTRIBUTE.&id({IOSet}),
 *   values SET SIZE(1..MAX) OF ATTRIBUTE.&Type({IOSet}{@type})
 * }
 *
 * CertificationRequest ::= SEQUENCE {
 *   certificationRequestInfo CertificationRequestInfo,
 *   signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }},
 *   signature          BIT STRING
 * }
 */
var forge = __webpack_require__(/*! ./forge */ "./node_modules/node-forge/lib/forge.js");
__webpack_require__(/*! ./aes */ "./node_modules/node-forge/lib/aes.js");
__webpack_require__(/*! ./asn1 */ "./node_modules/node-forge/lib/asn1.js");
__webpack_require__(/*! ./des */ "./node_modules/node-forge/lib/des.js");
__webpack_require__(/*! ./md */ "./node_modules/node-forge/lib/md.js");
__webpack_require__(/*! ./mgf */ "./node_modules/node-forge/lib/mgf.js");
__webpack_require__(/*! ./oids */ "./node_modules/node-forge/lib/oids.js");
__webpack_require__(/*! ./pem */ "./node_modules/node-forge/lib/pem.js");
__webpack_require__(/*! ./pss */ "./node_modules/node-forge/lib/pss.js");
__webpack_require__(/*! ./rsa */ "./node_modules/node-forge/lib/rsa.js");
__webpack_require__(/*! ./util */ "./node_modules/node-forge/lib/util.js");

// shortcut for asn.1 API
var asn1 = forge.asn1;

/* Public Key Infrastructure (PKI) implementation. */
var pki = module.exports = forge.pki = forge.pki || {};
var oids = pki.oids;

// short name OID mappings
var _shortNames = {};
_shortNames['CN'] = oids['commonName'];
_shortNames['commonName'] = 'CN';
_shortNames['C'] = oids['countryName'];
_shortNames['countryName'] = 'C';
_shortNames['L'] = oids['localityName'];
_shortNames['localityName'] = 'L';
_shortNames['ST'] = oids['stateOrProvinceName'];
_shortNames['stateOrProvinceName'] = 'ST';
_shortNames['O'] = oids['organizationName'];
_shortNames['organizationName'] = 'O';
_shortNames['OU'] = oids['organizationalUnitName'];
_shortNames['organizationalUnitName'] = 'OU';
_shortNames['E'] = oids['emailAddress'];
_shortNames['emailAddress'] = 'E';

// validator for an SubjectPublicKeyInfo structure
// Note: Currently only works with an RSA public key
var publicKeyValidator = forge.pki.rsa.publicKeyValidator;

// validator for an X.509v3 certificate
var x509CertificateValidator = {
  name: 'Certificate',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'Certificate.TBSCertificate',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'tbsCertificate',
    value: [{
      name: 'Certificate.TBSCertificate.version',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.version.integer',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: 'certVersion'
      }]
    }, {
      name: 'Certificate.TBSCertificate.serialNumber',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: 'certSerialNumber'
    }, {
      name: 'Certificate.TBSCertificate.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'Certificate.TBSCertificate.signature.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'certinfoSignatureOid'
      }, {
        name: 'Certificate.TBSCertificate.signature.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'certinfoSignatureParams'
      }]
    }, {
      name: 'Certificate.TBSCertificate.issuer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certIssuer'
    }, {
      name: 'Certificate.TBSCertificate.validity',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      // Note: UTC and generalized times may both appear so the capture
      // names are based on their detected order, the names used below
      // are only for the common case, which validity time really means
      // "notBefore" and which means "notAfter" will be determined by order
      value: [{
        // notBefore (Time) (UTC time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity1UTCTime'
      }, {
        // notBefore (Time) (generalized time case)
        name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity2GeneralizedTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.UTCTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity3UTCTime'
      }, {
        // notAfter (Time) (only UTC time is supported)
        name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.GENERALIZEDTIME,
        constructed: false,
        optional: true,
        capture: 'certValidity4GeneralizedTime'
      }]
    }, {
      // Name (subject) (RDNSequence)
      name: 'Certificate.TBSCertificate.subject',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: 'certSubject'
    },
    // SubjectPublicKeyInfo
    publicKeyValidator,
    {
      // issuerUniqueID (optional)
      name: 'Certificate.TBSCertificate.issuerUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.issuerUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certIssuerUniqueId'
      }]
    }, {
      // subjectUniqueID (optional)
      name: 'Certificate.TBSCertificate.subjectUniqueID',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      constructed: true,
      optional: true,
      value: [{
        name: 'Certificate.TBSCertificate.subjectUniqueID.id',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        // TODO: support arbitrary bit length ids
        captureBitStringValue: 'certSubjectUniqueId'
      }]
    }, {
      // Extensions (optional)
      name: 'Certificate.TBSCertificate.extensions',
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      constructed: true,
      captureAsn1: 'certExtensions',
      optional: true
    }]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: 'Certificate.signatureAlgorithm',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: 'Certificate.signatureAlgorithm.algorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: 'certSignatureOid'
    }, {
      name: 'Certificate.TBSCertificate.signature.parameters',
      tagClass: asn1.Class.UNIVERSAL,
      optional: true,
      captureAsn1: 'certSignatureParams'
    }]
  }, {
    // SignatureValue
    name: 'Certificate.signatureValue',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: 'certSignature'
  }]
};

var rsassaPssParameterValidator = {
  name: 'rsapss',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: 'rsapss.hashAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'hashOid'
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: 'rsapss.maskGenAlgorithm',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'maskGenOid'
      }, {
        name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: 'maskGenHashOid'
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: 'rsapss.saltLength',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: 'rsapss.saltLength.saltLength',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'saltLength'
    }]
  }, {
    name: 'rsapss.trailerField',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: 'rsapss.trailer.trailer',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Class.INTEGER,
      constructed: false,
      capture: 'trailer'
    }]
  }]
};

// validator for a CertificationRequestInfo structure
var certificationRequestInfoValidator = {
  name: 'CertificationRequestInfo',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'certificationRequestInfo',
  value: [{
    name: 'CertificationRequestInfo.integer',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.INTEGER,
    constructed: false,
    capture: 'certificationRequestInfoVersion'
  }, {
    // Name (subject) (RDNSequence)
    name: 'CertificationRequestInfo.subject',
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: 'certificationRequestInfoSubject'
  },
  // SubjectPublicKeyInfo
  publicKeyValidator,
  {
    name: 'CertificationRequestInfo.attributes',
    tagClass: asn1.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: 'certificationRequestInfoAttributes',
    value: [{
      name: 'CertificationRequestInfo.attributes',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: 'CertificationRequestInfo.attributes.type',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false
      }, {
        name: 'CertificationRequestInfo.attributes.value',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true
      }]
    }]
  }]
};

// validator for a CertificationRequest structure
var certificationRequestValidator = {
  name: 'CertificationRequest',
  tagClass: asn1.Class.UNIVERSAL,
  type: asn1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: 'csr',
  value: [
    certificationRequestInfoValidator, {
      // AlgorithmIdentifier (signature algorithm)
      name: 'CertificationRequest.signatureAlgorithm',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // algorithm
        name: 'CertificationRequest.signatureAlgorithm.algorithm',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: 'csrSignatureOid'
      }, {
        name: 'CertificationRequest.signatureAlgorithm.parameters',
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: 'csrSignatureParams'
      }]
    }, {
      // signature
      name: 'CertificationRequest.signature',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: 'csrSignature'
    }
  ]
};

/**
 * Converts an RDNSequence of ASN.1 DER-encoded RelativeDistinguishedName
 * sets into an array with objects that have type and value properties.
 *
 * @param rdn the RDNSequence to convert.
 * @param md a message digest to append type and value to if provided.
 */
pki.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];

  // each value in 'rdn' in is a SET of RelativeDistinguishedName
  var set, attr, obj;
  for(var si = 0; si < rdn.value.length; ++si) {
    // get the RelativeDistinguishedName set
    set = rdn.value[si];

    // each value in the SET is an AttributeTypeAndValue sequence
    // containing first a type (an OID) and second a value (defined by
    // the OID)
    for(var i = 0; i < set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if(md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Converts ASN.1 CRIAttributes into an array with objects that have type and
 * value properties.
 *
 * @param attributes the CRIAttributes to convert.
 */
pki.CRIAttributesAsArray = function(attributes) {
  var rval = [];

  // each value in 'attributes' in is a SEQUENCE with an OID and a SET
  for(var si = 0; si < attributes.length; ++si) {
    // get the attribute sequence
    var seq = attributes[si];

    // each value in the SEQUENCE containing first a type (an OID) and
    // second a set of values (defined by the OID)
    var type = asn1.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for(var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      // if the OID is known, get its name and short name
      if(obj.type in oids) {
        obj.name = oids[obj.type];
        if(obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      // parse extensions
      if(obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for(var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }

  return rval;
};

/**
 * Gets an issuer or subject attribute from its name, type, or short name.
 *
 * @param obj the issuer or subject object.
 * @param options a short name string or an object with:
 *          shortName the short name for the attribute.
 *          name the name for the attribute.
 *          type the type for the attribute.
 *
 * @return the attribute.
 */
function _getAttribute(obj, options) {
  if(typeof options === 'string') {
    options = {shortName: options};
  }

  var rval = null;
  var attr;
  for(var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];
    if(options.type && options.type === attr.type) {
      rval = attr;
    } else if(options.name && options.name === attr.name) {
      rval = attr;
    } else if(options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}

/**
 * Converts signature parameters from ASN.1 structure.
 *
 * Currently only RSASSA-PSS supported.  The PKCS#1 v1.5 signature scheme had
 * no parameters.
 *
 * RSASSA-PSS-params  ::=  SEQUENCE  {
 *   hashAlgorithm      [0] HashAlgorithm DEFAULT
 *                             sha1Identifier,
 *   maskGenAlgorithm   [1] MaskGenAlgorithm DEFAULT
 *                             mgf1SHA1Identifier,
 *   saltLength         [2] INTEGER DEFAULT 20,
 *   trailerField       [3] INTEGER DEFAULT 1
 * }
 *
 * HashAlgorithm  ::=  AlgorithmIdentifier
 *
 * MaskGenAlgorithm  ::=  AlgorithmIdentifier
 *
 * AlgorithmIdentifer ::= SEQUENCE {
 *   algorithm OBJECT IDENTIFIER,
 *   parameters ANY DEFINED BY algorithm OPTIONAL
 * }
 *
 * @param oid The OID specifying the signature algorithm
 * @param obj The ASN.1 structure holding the parameters
 * @param fillDefaults Whether to use return default values where omitted
 * @return signature parameter object
 */
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};

  if(oid !== oids['RSASSA-PSS']) {
    return params;
  }

  if(fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids['sha1']
      },
      mgf: {
        algorithmOid: oids['mgf1'],
        hash: {
          algorithmOid: oids['sha1']
        }
      },
      saltLength: 20
    };
  }

  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
    var error = new Error('Cannot read RSASSA-PSS parameter block.');
    error.errors = errors;
    throw error;
  }

  if(capture.hashOid !== undefined) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
  }

  if(capture.maskGenOid !== undefined) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
  }

  if(capture.saltLength !== undefined) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }

  return params;
};

/**
 * Converts an X.509 certificate from PEM format.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. This will scan the TBSCertificate part of the ASN.1
 * object while it is converted so it doesn't need to be converted back
 * to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certificate.
 */
pki.certificateFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE' &&
    msg.type !== 'X509 CERTIFICATE' &&
    msg.type !== 'TRUSTED CERTIFICATE') {
    var error = new Error(
      'Could not convert certificate from PEM; PEM header type ' +
      'is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error(
      'Could not convert certificate from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificateFromAsn1(obj, computeHash);
};

/**
 * Converts an X.509 certificate to PEM format.
 *
 * @param cert the certificate.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certificate.
 */
pki.certificateToPem = function(cert, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE',
    body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key from PEM format.
 *
 * @param pem the PEM-formatted public key.
 *
 * @return the public key.
 */
pki.publicKeyFromPem = function(pem) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'PUBLIC KEY' && msg.type !== 'RSA PUBLIC KEY') {
    var error = new Error('Could not convert public key from PEM; PEM header ' +
      'type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert public key from PEM; PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body);

  return pki.publicKeyFromAsn1(obj);
};

/**
 * Converts an RSA public key to PEM format (using a SubjectPublicKeyInfo).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Converts an RSA public key to PEM format (using an RSAPublicKey).
 *
 * @param key the public key.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted public key.
 */
pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'RSA PUBLIC KEY',
    body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Gets a fingerprint for the given public key.
 *
 * @param options the options to use.
 *          [md] the message digest object to use (defaults to forge.md.sha1).
 *          [type] the type of fingerprint, such as 'RSAPublicKey',
 *            'SubjectPublicKeyInfo' (defaults to 'RSAPublicKey').
 *          [encoding] an alternative output encoding, such as 'hex'
 *            (defaults to none, outputs a byte buffer).
 *          [delimiter] the delimiter to use between bytes for 'hex' encoded
 *            output, eg: ':' (defaults to none).
 *
 * @return the fingerprint as a byte buffer or other encoding based on options.
 */
pki.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge.md.sha1.create();
  var type = options.type || 'RSAPublicKey';

  var bytes;
  switch(type) {
    case 'RSAPublicKey':
      bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case 'SubjectPublicKeyInfo':
      bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  }

  // hash public key bytes
  md.start();
  md.update(bytes);
  var digest = md.digest();
  if(options.encoding === 'hex') {
    var hex = digest.toHex();
    if(options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if(options.encoding === 'binary') {
    return digest.getBytes();
  } else if(options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
};

/**
 * Converts a PKCS#10 certification request (CSR) from PEM format.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. This will scan the CertificationRequestInfo part of
 * the ASN.1 object while it is converted so it doesn't need to be converted
 * back to ASN.1-DER-encoding later.
 *
 * @param pem the PEM-formatted certificate.
 * @param computeHash true to compute the hash for verification.
 * @param strict true to be strict when checking ASN.1 value lengths, false to
 *          allow truncated values (default: true).
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromPem = function(pem, computeHash, strict) {
  var msg = forge.pem.decode(pem)[0];

  if(msg.type !== 'CERTIFICATE REQUEST') {
    var error = new Error('Could not convert certification request from PEM; ' +
      'PEM header type is not "CERTIFICATE REQUEST".');
    error.headerType = msg.type;
    throw error;
  }
  if(msg.procType && msg.procType.type === 'ENCRYPTED') {
    throw new Error('Could not convert certification request from PEM; ' +
      'PEM is encrypted.');
  }

  // convert DER to ASN.1 object
  var obj = asn1.fromDer(msg.body, strict);

  return pki.certificationRequestFromAsn1(obj, computeHash);
};

/**
 * Converts a PKCS#10 certification request (CSR) to PEM format.
 *
 * @param csr the certification request.
 * @param maxline the maximum characters per line, defaults to 64.
 *
 * @return the PEM-formatted certification request.
 */
pki.certificationRequestToPem = function(csr, maxline) {
  // convert to ASN.1, then DER, then PEM-encode
  var msg = {
    type: 'CERTIFICATE REQUEST',
    body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge.pem.encode(msg, {maxline: maxline});
};

/**
 * Creates an empty X.509v3 RSA certificate.
 *
 * @return the certificate.
 */
pki.createCertificate = function() {
  var cert = {};
  cert.version = 0x02;
  cert.serialNumber = '00';
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = new Date();

  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;

  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;

  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;

  /**
   * Sets the subject of this certificate.
   *
   * @param attrs the array of subject attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setSubject = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };

  /**
   * Sets the issuer of this certificate.
   *
   * @param attrs the array of issuer attributes to use.
   * @param uniqueId an optional a unique ID to use.
   */
  cert.setIssuer = function(attrs, uniqueId) {
    // set new attributes, clear hash
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if(uniqueId) {
      // TODO: support arbitrary bit length ids
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };

  /**
   * Sets the extensions of this certificate.
   *
   * @param exts the array of extensions to use.
   */
  cert.setExtensions = function(exts) {
    for(var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], {cert: cert});
    }
    // set new extensions
    cert.extensions = exts;
  };

  /**
   * Gets an extension by its name or id.
   *
   * @param options the name to use or an object with:
   *          name the name to use.
   *          id the id to use.
   *
   * @return the extension or null if not found.
   */
  cert.getExtension = function(options) {
    if(typeof options === 'string') {
      options = {name: options};
    }

    var rval = null;
    var ext;
    for(var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if(options.id && ext.id === options.id) {
        rval = ext;
      } else if(options.name && ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };

  /**
   * Signs this certificate using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  cert.sign = function(key, md) {
    // TODO: get signature OID from private key
    cert.md = md || forge.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = cert.md.algorithm;
      throw error;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;

    // get TBSCertificate, convert to DER
    cert.tbsCertificate = pki.getTBSCertificate(cert);
    var bytes = asn1.toDer(cert.tbsCertificate);

    // digest and sign
    cert.md.update(bytes.getBytes());
    cert.signature = key.sign(cert.md);
  };

  /**
   * Attempts verify the signature on the passed certificate using this
   * certificate's public key.
   *
   * @param child the certificate to verify.
   *
   * @return true if verified, false if not.
   */
  cert.verify = function(child) {
    var rval = false;

    if(!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error = new Error(
        'The parent certificate did not issue the given child ' +
        'certificate; the child certificate\'s issuer does not match the ' +
        'parent\'s subject.');
      error.expectedIssuer = issuer.attributes;
      error.actualIssuer = subject.attributes;
      throw error;
    }

    var md = child.md;
    if(md === null) {
      // check signature OID for supported signature types
      if(child.signatureOid in oids) {
        var oid = oids[child.signatureOid];
        switch(oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;
          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;
          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;
          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;
          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;
          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }
      if(md === null) {
        var error = new Error('Could not compute certificate digest. ' +
          'Unknown signature OID.');
        error.signatureOid = child.signatureOid;
        throw error;
      }

      // produce DER formatted TBSCertificate and digest it
      var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
      var bytes = asn1.toDer(tbsCertificate);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      var scheme;

      switch(child.signatureOid) {
        case oids.sha1WithRSAEncryption:
          scheme = undefined; /* use PKCS#1 v1.5 padding scheme */
          break;
        case oids['RSASSA-PSS']:
          var hash, mgf;

          /* initialize mgf */
          hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = child.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[child.signatureParameters.mgf.algorithmOid];
          if(mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = child.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());

          /* initialize hash function */
          hash = oids[child.signatureParameters.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            throw {
              message: 'Unsupported RSASSA-PSS hash function.',
              oid: child.signatureParameters.hash.algorithmOid,
              name: hash
            };
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf,
            child.signatureParameters.saltLength);
          break;
      }

      // verify signature on cert using public key
      rval = cert.publicKey.verify(
        md.digest().getBytes(), child.signature, scheme);
    }

    return rval;
  };

  /**
   * Returns true if this certificate's issuer matches the passed
   * certificate's subject. Note that no signature check is performed.
   *
   * @param parent the certificate to check.
   *
   * @return true if this certificate's issuer matches the passed certificate's
   *         subject.
   */
  cert.isIssuer = function(parent) {
    var rval = false;

    var i = cert.issuer;
    var s = parent.subject;

    // compare hashes if present
    if(i.hash && s.hash) {
      rval = (i.hash === s.hash);
    } else if(i.attributes.length === s.attributes.length) {
      // all attributes are the same so issuer matches subject
      rval = true;
      var iattr, sattr;
      for(var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s.attributes[n];
        if(iattr.type !== sattr.type || iattr.value !== sattr.value) {
          // attribute mismatch
          rval = false;
        }
      }
    }

    return rval;
  };

  /**
   * Returns true if this certificate's subject matches the issuer of the
   * given certificate). Note that not signature check is performed.
   *
   * @param child the certificate to check.
   *
   * @return true if this certificate's subject matches the passed
   *         certificate's issuer.
   */
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };

  /**
   * Generates the subjectKeyIdentifier for this certificate as byte buffer.
   *
   * @return the subjectKeyIdentifier for this certificate as byte buffer.
   */
  cert.generateSubjectKeyIdentifier = function() {
    /* See: 4.2.1.2 section of the the RFC3280, keyIdentifier is either:

      (1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
        value of the BIT STRING subjectPublicKey (excluding the tag,
        length, and number of unused bits).

      (2) The keyIdentifier is composed of a four bit type field with
        the value 0100 followed by the least significant 60 bits of the
        SHA-1 hash of the value of the BIT STRING subjectPublicKey
        (excluding the tag, length, and number of unused bit string bits).
    */

    // skipping the tag, length, and number of unused bits is the same
    // as just using the RSAPublicKey (for RSA keys, which are the
    // only ones supported)
    return pki.getPublicKeyFingerprint(cert.publicKey, {type: 'RSAPublicKey'});
  };

  /**
   * Verifies the subjectKeyIdentifier extension value for this certificate
   * against its public key. If no extension is found, false will be
   * returned.
   *
   * @return true if verified, false if not.
   */
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids['subjectKeyIdentifier'];
    for(var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];
      if(ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return (forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski);
      }
    }
    return false;
  };

  return cert;
};

/**
 * Converts an X.509v3 RSA certificate from an ASN.1 object.
 *
 * Note: If the certificate is to be verified then compute hash should
 * be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the TBSCertificate part of the ASN.1
 * object needs to be scanned before the cert object is created.
 *
 * @param obj the asn1 representation of an X.509v3 RSA certificate.
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certificate.
 */
pki.certificateFromAsn1 = function(obj, computeHash) {
  // validate certificate and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
    var error = new Error('Cannot read X.509 certificate. ' +
      'ASN.1 object is not an X509v3 Certificate.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certificate
  var cert = pki.createCertificate();
  cert.version = capture.certVersion ?
    capture.certVersion.charCodeAt(0) : 0;
  var serial = forge.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial.toHex();
  cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid, capture.certSignatureParams, true);
  cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams, false);
  cert.signature = capture.certSignature;

  var validity = [];
  if(capture.certValidity1UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if(capture.certValidity2GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime));
  }
  if(capture.certValidity3UTCTime !== undefined) {
    validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if(capture.certValidity4GeneralizedTime !== undefined) {
    validity.push(asn1.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime));
  }
  if(validity.length > 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; more ' +
      'than two times were provided in the certificate.');
  }
  if(validity.length < 2) {
    throw new Error('Cannot read notBefore/notAfter validity times; they ' +
      'were not provided as either UTCTime or GeneralizedTime.');
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];

  // keep TBSCertificate to preserve signature when exporting
  cert.tbsCertificate = capture.tbsCertificate;

  if(computeHash) {
    // check signature OID for supported signature types
    cert.md = null;
    if(cert.signatureOid in oids) {
      var oid = oids[cert.signatureOid];
      switch(oid) {
        case 'sha1WithRSAEncryption':
          cert.md = forge.md.sha1.create();
          break;
        case 'md5WithRSAEncryption':
          cert.md = forge.md.md5.create();
          break;
        case 'sha256WithRSAEncryption':
          cert.md = forge.md.sha256.create();
          break;
        case 'sha384WithRSAEncryption':
          cert.md = forge.md.sha384.create();
          break;
        case 'sha512WithRSAEncryption':
          cert.md = forge.md.sha512.create();
          break;
        case 'RSASSA-PSS':
          cert.md = forge.md.sha256.create();
          break;
      }
    }
    if(cert.md === null) {
      var error = new Error('Could not compute certificate digest. ' +
        'Unknown signature OID.');
      error.signatureOid = cert.signatureOid;
      throw error;
    }

    // produce DER formatted TBSCertificate and digest it
    var bytes = asn1.toDer(cert.tbsCertificate);
    cert.md.update(bytes.getBytes());
  }

  // handle issuer, build issuer message digest
  var imd = forge.md.sha1.create();
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
  if(capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
  if(capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();

  // handle extensions
  if(capture.certExtensions) {
    cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }

  // convert RSA public key from ASN.1
  cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  return cert;
};

/**
 * Converts an ASN.1 extensions object (with extension sequences as its
 * values) into an array of extension objects with types and values.
 *
 * Supported extensions:
 *
 * id-ce-keyUsage OBJECT IDENTIFIER ::=  { id-ce 15 }
 * KeyUsage ::= BIT STRING {
 *   digitalSignature        (0),
 *   nonRepudiation          (1),
 *   keyEncipherment         (2),
 *   dataEncipherment        (3),
 *   keyAgreement            (4),
 *   keyCertSign             (5),
 *   cRLSign                 (6),
 *   encipherOnly            (7),
 *   decipherOnly            (8)
 * }
 *
 * id-ce-basicConstraints OBJECT IDENTIFIER ::=  { id-ce 19 }
 * BasicConstraints ::= SEQUENCE {
 *   cA                      BOOLEAN DEFAULT FALSE,
 *   pathLenConstraint       INTEGER (0..MAX) OPTIONAL
 * }
 *
 * subjectAltName EXTENSION ::= {
 *   SYNTAX GeneralNames
 *   IDENTIFIED BY id-ce-subjectAltName
 * }
 *
 * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
 *
 * GeneralName ::= CHOICE {
 *   otherName      [0] INSTANCE OF OTHER-NAME,
 *   rfc822Name     [1] IA5String,
 *   dNSName        [2] IA5String,
 *   x400Address    [3] ORAddress,
 *   directoryName  [4] Name,
 *   ediPartyName   [5] EDIPartyName,
 *   uniformResourceIdentifier [6] IA5String,
 *   IPAddress      [7] OCTET STRING,
 *   registeredID   [8] OBJECT IDENTIFIER
 * }
 *
 * OTHER-NAME ::= TYPE-IDENTIFIER
 *
 * EDIPartyName ::= SEQUENCE {
 *   nameAssigner [0] DirectoryString {ub-name} OPTIONAL,
 *   partyName    [1] DirectoryString {ub-name}
 * }
 *
 * @param exts the extensions ASN.1 with extension sequences to parse.
 *
 * @return the array.
 */
pki.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for(var i = 0; i < exts.value.length; ++i) {
    // get extension sequence
    var extseq = exts.value[i];
    for(var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }

  return rval;
};

/**
 * Parses a single certificate extension from ASN.1.
 *
 * @param ext the extension in ASN.1 format.
 *
 * @return the parsed extension as an object.
 */
pki.certificateExtensionFromAsn1 = function(ext) {
  // an extension has:
  // [0] extnID      OBJECT IDENTIFIER
  // [1] critical    BOOLEAN DEFAULT FALSE
  // [2] extnValue   OCTET STRING
  var e = {};
  e.id = asn1.derToOid(ext.value[0].value);
  e.critical = false;
  if(ext.value[1].type === asn1.Type.BOOLEAN) {
    e.critical = (ext.value[1].value.charCodeAt(0) !== 0x00);
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  // if the oid is known, get its name
  if(e.id in oids) {
    e.name = oids[e.id];

    // handle key usage
    if(e.name === 'keyUsage') {
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      var b3 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      // set flags
      e.digitalSignature = (b2 & 0x80) === 0x80;
      e.nonRepudiation = (b2 & 0x40) === 0x40;
      e.keyEncipherment = (b2 & 0x20) === 0x20;
      e.dataEncipherment = (b2 & 0x10) === 0x10;
      e.keyAgreement = (b2 & 0x08) === 0x08;
      e.keyCertSign = (b2 & 0x04) === 0x04;
      e.cRLSign = (b2 & 0x02) === 0x02;
      e.encipherOnly = (b2 & 0x01) === 0x01;
      e.decipherOnly = (b3 & 0x80) === 0x80;
    } else if(e.name === 'basicConstraints') {
      // handle basic constraints
      // get value as SEQUENCE
      var ev = asn1.fromDer(e.value);
      // get cA BOOLEAN flag (defaults to false)
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
        e.cA = (ev.value[0].value.charCodeAt(0) !== 0x00);
      } else {
        e.cA = false;
      }
      // get path length constraint
      var value = null;
      if(ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
        value = ev.value[0].value;
      } else if(ev.value.length > 1) {
        value = ev.value[1].value;
      }
      if(value !== null) {
        e.pathLenConstraint = asn1.derToInteger(value);
      }
    } else if(e.name === 'extKeyUsage') {
      // handle extKeyUsage
      // value is a SEQUENCE of OIDs
      var ev = asn1.fromDer(e.value);
      for(var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1.derToOid(ev.value[vi].value);
        if(oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if(e.name === 'nsCertType') {
      // handle nsCertType
      // get value as BIT STRING
      var ev = asn1.fromDer(e.value);
      var b2 = 0x00;
      if(ev.value.length > 1) {
        // skip first byte, just indicates unused bits which
        // will be padded with 0s anyway
        // get bytes with flag bits
        b2 = ev.value.charCodeAt(1);
      }
      // set flags
      e.client = (b2 & 0x80) === 0x80;
      e.server = (b2 & 0x40) === 0x40;
      e.email = (b2 & 0x20) === 0x20;
      e.objsign = (b2 & 0x10) === 0x10;
      e.reserved = (b2 & 0x08) === 0x08;
      e.sslCA = (b2 & 0x04) === 0x04;
      e.emailCA = (b2 & 0x02) === 0x02;
      e.objCA = (b2 & 0x01) === 0x01;
    } else if(
      e.name === 'subjectAltName' ||
      e.name === 'issuerAltName') {
      // handle subjectAltName/issuerAltName
      e.altNames = [];

      // ev is a SYNTAX SEQUENCE
      var gn;
      var ev = asn1.fromDer(e.value);
      for(var n = 0; n < ev.value.length; ++n) {
        // get GeneralName
        gn = ev.value[n];

        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);

        // Note: Support for types 1,2,6,7,8
        switch(gn.type) {
          // rfc822Name
          case 1:
          // dNSName
          case 2:
          // uniformResourceIdentifier (URI)
          case 6:
            break;
          // IPAddress
          case 7:
            // convert to IPv4/IPv6 string representation
            altName.ip = forge.util.bytesToIP(gn.value);
            break;
          // registeredID
          case 8:
            altName.oid = asn1.derToOid(gn.value);
            break;
          default:
            // unsupported
        }
      }
    } else if(e.name === 'subjectKeyIdentifier') {
      // value is an OCTETSTRING w/the hash of the key-type specific
      // public key structure (eg: RSAPublicKey)
      var ev = asn1.fromDer(e.value);
      e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
    }
  }
  return e;
};

/**
 * Converts a PKCS#10 certification request (CSR) from an ASN.1 object.
 *
 * Note: If the certification request is to be verified then compute hash
 * should be set to true. There is currently no implementation for converting
 * a certificate back to ASN.1 so the CertificationRequestInfo part of the
 * ASN.1 object needs to be scanned before the csr object is created.
 *
 * @param obj the asn1 representation of a PKCS#10 certification request (CSR).
 * @param computeHash true to compute the hash for verification.
 *
 * @return the certification request (CSR).
 */
pki.certificationRequestFromAsn1 = function(obj, computeHash) {
  // validate certification request and capture data
  var capture = {};
  var errors = [];
  if(!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
    var error = new Error('Cannot read PKCS#10 certificate request. ' +
      'ASN.1 object is not a PKCS#10 CertificationRequest.');
    error.errors = errors;
    throw error;
  }

  // get oid
  var oid = asn1.derToOid(capture.publicKeyOid);
  if(oid !== pki.oids.rsaEncryption) {
    throw new Error('Cannot read public key. OID is not RSA.');
  }

  // create certification request
  var csr = pki.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid, capture.csrSignatureParams, true);
  csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
  csr.signature = capture.csrSignature;

  // keep CertificationRequestInfo to preserve signature when exporting
  csr.certificationRequestInfo = capture.certificationRequestInfo;

  if(computeHash) {
    // check signature OID for supported signature types
    csr.md = null;
    if(csr.signatureOid in oids) {
      var oid = oids[csr.signatureOid];
      switch(oid) {
        case 'sha1WithRSAEncryption':
          csr.md = forge.md.sha1.create();
          break;
        case 'md5WithRSAEncryption':
          csr.md = forge.md.md5.create();
          break;
        case 'sha256WithRSAEncryption':
          csr.md = forge.md.sha256.create();
          break;
        case 'sha384WithRSAEncryption':
          csr.md = forge.md.sha384.create();
          break;
        case 'sha512WithRSAEncryption':
          csr.md = forge.md.sha512.create();
          break;
        case 'RSASSA-PSS':
          csr.md = forge.md.sha256.create();
          break;
      }
    }
    if(csr.md === null) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown signature OID.');
      error.signatureOid = csr.signatureOid;
      throw error;
    }

    // produce DER formatted CertificationRequestInfo and digest it
    var bytes = asn1.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes.getBytes());
  }

  // handle subject, build subject message digest
  var smd = forge.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject, smd);
  csr.subject.hash = smd.digest().toHex();

  // convert RSA public key from ASN.1
  csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);

  // convert attributes from ASN.1
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []);

  return csr;
};

/**
 * Creates an empty certification request (a CSR or certificate signing
 * request). Once created, its public key and attributes can be set and then
 * it can be signed.
 *
 * @return the empty certification request.
 */
pki.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0x00;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;

  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;

  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;

  /**
   * Sets the subject of this certification request.
   *
   * @param attrs the array of subject attributes to use.
   */
  csr.setSubject = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };

  /**
   * Sets the attributes of this certification request.
   *
   * @param attrs the array of attributes to use.
   */
  csr.setAttributes = function(attrs) {
    // set new attributes
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };

  /**
   * Signs this certification request using the given private key.
   *
   * @param key the private key to sign with.
   * @param md the message digest object to use (defaults to forge.md.sha1).
   */
  csr.sign = function(key, md) {
    // TODO: get signature OID from private key
    csr.md = md || forge.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + 'WithRSAEncryption'];
    if(!algorithmOid) {
      var error = new Error('Could not compute certification request digest. ' +
        'Unknown message digest algorithm OID.');
      error.algorithm = csr.md.algorithm;
      throw error;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;

    // get CertificationRequestInfo, convert to DER
    csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
    var bytes = asn1.toDer(csr.certificationRequestInfo);

    // digest and sign
    csr.md.update(bytes.getBytes());
    csr.signature = key.sign(csr.md);
  };

  /**
   * Attempts verify the signature on the passed certification request using
   * its public key.
   *
   * A CSR that has been exported to a file in PEM format can be verified using
   * OpenSSL using this command:
   *
   * openssl req -in <the-csr-pem-file> -verify -noout -text
   *
   * @return true if verified, false if not.
   */
  csr.verify = function() {
    var rval = false;

    var md = csr.md;
    if(md === null) {
      // check signature OID for supported signature types
      if(csr.signatureOid in oids) {
        // TODO: create DRY `OID to md` function
        var oid = oids[csr.signatureOid];
        switch(oid) {
          case 'sha1WithRSAEncryption':
            md = forge.md.sha1.create();
            break;
          case 'md5WithRSAEncryption':
            md = forge.md.md5.create();
            break;
          case 'sha256WithRSAEncryption':
            md = forge.md.sha256.create();
            break;
          case 'sha384WithRSAEncryption':
            md = forge.md.sha384.create();
            break;
          case 'sha512WithRSAEncryption':
            md = forge.md.sha512.create();
            break;
          case 'RSASSA-PSS':
            md = forge.md.sha256.create();
            break;
        }
      }
      if(md === null) {
        var error = new Error(
          'Could not compute certification request digest. ' +
          'Unknown signature OID.');
        error.signatureOid = csr.signatureOid;
        throw error;
      }

      // produce DER formatted CertificationRequestInfo and digest it
      var cri = csr.certificationRequestInfo ||
        pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(cri);
      md.update(bytes.getBytes());
    }

    if(md !== null) {
      var scheme;

      switch(csr.signatureOid) {
        case oids.sha1WithRSAEncryption:
          /* use PKCS#1 v1.5 padding scheme */
          break;
        case oids['RSASSA-PSS']:
          var hash, mgf;

          /* initialize mgf */
          hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported MGF hash function.');
            error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          mgf = oids[csr.signatureParameters.mgf.algorithmOid];
          if(mgf === undefined || forge.mgf[mgf] === undefined) {
            var error = new Error('Unsupported MGF function.');
            error.oid = csr.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }

          mgf = forge.mgf[mgf].create(forge.md[hash].create());

          /* initialize hash function */
          hash = oids[csr.signatureParameters.hash.algorithmOid];
          if(hash === undefined || forge.md[hash] === undefined) {
            var error = new Error('Unsupported RSASSA-PSS hash function.');
            error.oid = csr.signatureParameters.hash.algorithmOid;
            error.name = hash;
            throw error;
          }

          scheme = forge.pss.create(forge.md[hash].create(), mgf,
            csr.signatureParameters.saltLength);
          break;
      }

      // verify signature on csr using its public key
      rval = csr.publicKey.verify(
        md.digest().getBytes(), csr.signature, scheme);
    }

    return rval;
  };

  return csr;
};

/**
 * Converts an X.509 subject or issuer to an ASN.1 RDNSequence.
 *
 * @param obj the subject or issuer (distinguished name).
 *
 * @return the ASN.1 RDNSequence.
 */
function _dnToAsn1(obj) {
  // create an empty RDNSequence
  var rval = asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // iterate over attributes
  var attr, set;
  var attrs = obj.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.PRINTABLESTRING;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;

      if(valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      }
      // FIXME: handle more encodings
    }

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
          asn1.oidToDer(attr.type).getBytes()),
        // AttributeValue
        asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
      ])
    ]);
    rval.value.push(set);
  }

  return rval;
}

/**
 * Gets all printable attributes (typically of an issuer or subject) in a
 * simplified JSON format for display.
 *
 * @param attrs the attributes.
 *
 * @return the JSON for display.
 */
function _getAttributesAsJson(attrs) {
  var rval = {};
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    if(attr.shortName && (
      attr.valueTagClass === asn1.Type.UTF8 ||
      attr.valueTagClass === asn1.Type.PRINTABLESTRING ||
      attr.valueTagClass === asn1.Type.IA5STRING)) {
      var value = attr.value;
      if(attr.valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(attr.value);
      }
      if(!(attr.shortName in rval)) {
        rval[attr.shortName] = value;
      } else if(forge.util.isArray(rval[attr.shortName])) {
        rval[attr.shortName].push(value);
      } else {
        rval[attr.shortName] = [rval[attr.shortName], value];
      }
    }
  }
  return rval;
}

/**
 * Fills in missing fields in attributes.
 *
 * @param attrs the attributes to fill missing fields in.
 */
function _fillMissingFields(attrs) {
  var attr;
  for(var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];

    // populate missing name
    if(typeof attr.name === 'undefined') {
      if(attr.type && attr.type in pki.oids) {
        attr.name = pki.oids[attr.type];
      } else if(attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki.oids[_shortNames[attr.shortName]];
      }
    }

    // populate missing type (OID)
    if(typeof attr.type === 'undefined') {
      if(attr.name && attr.name in pki.oids) {
        attr.type = pki.oids[attr.name];
      } else {
        var error = new Error('Attribute type not specified.');
        error.attribute = attr;
        throw error;
      }
    }

    // populate missing shortname
    if(typeof attr.shortName === 'undefined') {
      if(attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }

    // convert extensions to value
    if(attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1.Type.SEQUENCE;
      if(!attr.value && attr.extensions) {
        attr.value = [];
        for(var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])));
        }
      }
    }

    if(typeof attr.value === 'undefined') {
      var error = new Error('Attribute value not specified.');
      error.attribute = attr;
      throw error;
    }
  }
}

/**
 * Fills in missing fields in certificate extensions.
 *
 * @param e the extension.
 * @param [options] the options to use.
 *          [cert] the certificate the extensions are for.
 *
 * @return the extension.
 */
function _fillMissingExtensionFields(e, options) {
  options = options || {};

  // populate missing name
  if(typeof e.name === 'undefined') {
    if(e.id && e.id in pki.oids) {
      e.name = pki.oids[e.id];
    }
  }

  // populate missing id
  if(typeof e.id === 'undefined') {
    if(e.name && e.name in pki.oids) {
      e.id = pki.oids[e.name];
    } else {
      var error = new Error('Extension ID not specified.');
      error.extension = e;
      throw error;
    }
  }

  if(typeof e.value !== 'undefined') {
    return e;
  }

  // handle missing value:

  // value is a BIT STRING
  if(e.name === 'keyUsage') {
    // build flags
    var unused = 0;
    var b2 = 0x00;
    var b3 = 0x00;
    if(e.digitalSignature) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.nonRepudiation) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.keyEncipherment) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.dataEncipherment) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.keyAgreement) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.keyCertSign) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.cRLSign) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.encipherOnly) {
      b2 |= 0x01;
      unused = 0;
    }
    if(e.decipherOnly) {
      b3 |= 0x80;
      unused = 7;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b3 !== 0) {
      value += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'basicConstraints') {
    // basicConstraints is a SEQUENCE
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    // cA BOOLEAN flag defaults to false
    if(e.cA) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
        String.fromCharCode(0xFF)));
    }
    if('pathLenConstraint' in e) {
      e.value.value.push(asn1.create(
        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(e.pathLenConstraint).getBytes()));
    }
  } else if(e.name === 'extKeyUsage') {
    // extKeyUsage is a SEQUENCE of OIDs
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    for(var key in e) {
      if(e[key] !== true) {
        continue;
      }
      // key is name in OID map
      if(key in oids) {
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(oids[key]).getBytes()));
      } else if(key.indexOf('.') !== -1) {
        // assume key is an OID
        seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID,
          false, asn1.oidToDer(key).getBytes()));
      }
    }
  } else if(e.name === 'nsCertType') {
    // nsCertType is a BIT STRING
    // build flags
    var unused = 0;
    var b2 = 0x00;

    if(e.client) {
      b2 |= 0x80;
      unused = 7;
    }
    if(e.server) {
      b2 |= 0x40;
      unused = 6;
    }
    if(e.email) {
      b2 |= 0x20;
      unused = 5;
    }
    if(e.objsign) {
      b2 |= 0x10;
      unused = 4;
    }
    if(e.reserved) {
      b2 |= 0x08;
      unused = 3;
    }
    if(e.sslCA) {
      b2 |= 0x04;
      unused = 2;
    }
    if(e.emailCA) {
      b2 |= 0x02;
      unused = 1;
    }
    if(e.objCA) {
      b2 |= 0x01;
      unused = 0;
    }

    // create bit string
    var value = String.fromCharCode(unused);
    if(b2 !== 0) {
      value += String.fromCharCode(b2);
    }
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
  } else if(e.name === 'subjectAltName' || e.name === 'issuerAltName') {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      e.value.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }
  } else if(e.name === 'nsComment' && options.cert) {
    // sanity check value is ASCII (req'd) and not too big
    if(!(/^[\x00-\x7F]*$/.test(e.comment)) ||
      (e.comment.length < 1) || (e.comment.length > 128)) {
      throw new Error('Invalid "nsComment" content.');
    }
    // IA5STRING opaque comment
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
  } else if(e.name === 'subjectKeyIdentifier' && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    // OCTETSTRING w/digest
    e.value = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
  } else if(e.name === 'authorityKeyIdentifier' && options.cert) {
    // SYNTAX SEQUENCE
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    if(e.keyIdentifier) {
      var keyIdentifier = (e.keyIdentifier === true ?
        options.cert.generateSubjectKeyIdentifier().getBytes() :
        e.keyIdentifier);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
    }

    if(e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ?
            options.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
    }

    if(e.serialNumber) {
      var serialNumber = forge.util.hexToBytes(e.serialNumber === true ?
        options.cert.serialNumber : e.serialNumber);
      seq.push(
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
    }
  } else if(e.name === 'cRLDistributionPoints') {
    e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var seq = e.value.value;

    // Create sub SEQUENCE of DistributionPointName
    var subSeq = asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

    // Create fullName CHOICE
    var fullNameGeneralNames = asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    var altName;
    for(var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value = altName.value;
      // handle IP
      if(altName.type === 7 && altName.ip) {
        value = forge.util.bytesFromIP(altName.ip);
        if(value === null) {
          var error = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.');
          error.extension = e;
          throw error;
        }
      } else if(altName.type === 8) {
        // handle OID
        if(altName.oid) {
          value = asn1.oidToDer(asn1.oidToDer(altName.oid));
        } else {
          // deprecated ... convert value to OID
          value = asn1.oidToDer(value);
        }
      }
      fullNameGeneralNames.value.push(asn1.create(
        asn1.Class.CONTEXT_SPECIFIC, altName.type, false,
        value));
    }

    // Add to the parent SEQUENCE
    subSeq.value.push(asn1.create(
      asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
    seq.push(subSeq);
  }

  // ensure value has been defined by now
  if(typeof e.value === 'undefined') {
    var error = new Error('Extension value not specified.');
    error.extension = e;
    throw error;
  }

  return e;
}

/**
 * Convert signature parameters object to ASN.1
 *
 * @param {String} oid Signature algorithm OID
 * @param params The signature parametrs object
 * @return ASN.1 object representing signature parameters
 */
function _signatureParametersToAsn1(oid, params) {
  switch(oid) {
    case oids['RSASSA-PSS']:
      var parts = [];

      if(params.hash.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.hash.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
          ])
        ]));
      }

      if(params.mgf.algorithmOid !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
              asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
                asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
            ])
          ])
        ]));
      }

      if(params.saltLength !== undefined) {
        parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
            asn1.integerToDer(params.saltLength).getBytes())
        ]));
      }

      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);

    default:
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '');
  }
}

/**
 * Converts a certification request's attributes to an ASN.1 set of
 * CRIAttributes.
 *
 * @param csr certification request.
 *
 * @return the ASN.1 set of CRIAttributes.
 */
function _CRIAttributesToAsn1(csr) {
  // create an empty context-specific container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);

  // no attributes, return empty container
  if(csr.attributes.length === 0) {
    return rval;
  }

  // each attribute has a sequence with a type and a set of values
  var attrs = csr.attributes;
  for(var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value = attr.value;

    // reuse tag class for attribute value if available
    var valueTagClass = asn1.Type.UTF8;
    if('valueTagClass' in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if(valueTagClass === asn1.Type.UTF8) {
      value = forge.util.encodeUtf8(value);
    }
    var valueConstructed = false;
    if('valueConstructed' in attr) {
      valueConstructed = attr.valueConstructed;
    }
    // FIXME: handle more encodings

    // create a RelativeDistinguishedName set
    // each value in the set is an AttributeTypeAndValue first
    // containing the type (an OID) and second the value
    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // AttributeType
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(attr.type).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        // AttributeValue
        asn1.create(
          asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
      ])
    ]);
    rval.value.push(seq);
  }

  return rval;
}

var jan_1_1950 = new Date('1950-01-01T00:00:00Z');
var jan_1_2050 = new Date('2050-01-01T00:00:00Z');

/**
 * Converts a Date object to ASN.1
 * Handles the different format before and after 1st January 2050
 *
 * @param date date object.
 *
 * @return the ASN.1 object representing the date.
 */
function _dateToAsn1(date) {
  if(date >= jan_1_1950 && date < jan_1_2050) {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false,
      asn1.dateToUtcTime(date));
  } else {
    return asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false,
      asn1.dateToGeneralizedTime(date));
  }
}

/**
 * Gets the ASN.1 TBSCertificate part of an X.509v3 certificate.
 *
 * @param cert the certificate.
 *
 * @return the asn1 TBSCertificate.
 */
pki.getTBSCertificate = function(cert) {
  // TBSCertificate
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
        asn1.integerToDer(cert.version).getBytes())
    ]),
    // serialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      forge.util.hexToBytes(cert.serialNumber)),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid, cert.siginfo.parameters)
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(cert.publicKey)
  ]);

  if(cert.issuer.uniqueId) {
    // issuerUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.issuer.uniqueId
        )
      ])
    );
  }
  if(cert.subject.uniqueId) {
    // subjectUniqueID (optional)
    tbs.value.push(
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0x00) +
          cert.subject.uniqueId
        )
      ])
    );
  }

  if(cert.extensions.length > 0) {
    // extensions (optional)
    tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
  }

  return tbs;
};

/**
 * Gets the ASN.1 CertificationRequestInfo part of a
 * PKCS#10 CertificationRequest.
 *
 * @param csr the certification request.
 *
 * @return the asn1 CertificationRequestInfo.
 */
pki.getCertificationRequestInfo = function(csr) {
  // CertificationRequestInfo
  var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,
      asn1.integerToDer(csr.version).getBytes()),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);

  return cri;
};

/**
 * Converts a DistinguishedName (subject or issuer) to an ASN.1 object.
 *
 * @param dn the DistinguishedName.
 *
 * @return the asn1 representation of a DistinguishedName.
 */
pki.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};

/**
 * Converts an X.509v3 RSA certificate to an ASN.1 object.
 *
 * @param cert the certificate.
 *
 * @return the asn1 representation of an X.509v3 RSA certificate.
 */
pki.certificateToAsn1 = function(cert) {
  // prefer cached TBSCertificate over generating one
  var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(cert.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + cert.signature)
  ]);
};

/**
 * Converts X.509v3 certificate extensions to ASN.1.
 *
 * @param exts the extensions to convert.
 *
 * @return the extensions in ASN.1 format.
 */
pki.certificateExtensionsToAsn1 = function(exts) {
  // create top-level extension container
  var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);

  // create extension sequence (stores a sequence for each extension)
  var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
  rval.value.push(seq);

  for(var i = 0; i < exts.length; ++i) {
    seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
  }

  return rval;
};

/**
 * Converts a single certificate extension to ASN.1.
 *
 * @param ext the extension to convert.
 *
 * @return the extension in ASN.1 format.
 */
pki.certificateExtensionToAsn1 = function(ext) {
  // create a sequence for each extension
  var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);

  // extnID (OID)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OID, false,
    asn1.oidToDer(ext.id).getBytes()));

  // critical defaults to false
  if(ext.critical) {
    // critical BOOLEAN DEFAULT FALSE
    extseq.value.push(asn1.create(
      asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false,
      String.fromCharCode(0xFF)));
  }

  var value = ext.value;
  if(typeof ext.value !== 'string') {
    // value is asn.1
    value = asn1.toDer(value).getBytes();
  }

  // extnValue (OCTET STRING)
  extseq.value.push(asn1.create(
    asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));

  return extseq;
};

/**
 * Converts a PKCS#10 certification request to an ASN.1 object.
 *
 * @param csr the certification request.
 *
 * @return the asn1 representation of a certification request.
 */
pki.certificationRequestToAsn1 = function(csr) {
  // prefer cached CertificationRequestInfo over generating one
  var cri = csr.certificationRequestInfo ||
    pki.getCertificationRequestInfo(csr);

  // Certificate
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,
        asn1.oidToDer(csr.signatureOid).getBytes()),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,
      String.fromCharCode(0x00) + csr.signature)
  ]);
};

/**
 * Creates a CA store.
 *
 * @param certs an optional array of certificate objects or PEM-formatted
 *          certificate strings to add to the CA store.
 *
 * @return the CA store.
 */
pki.createCaStore = function(certs) {
  // create CA store
  var caStore = {
    // stored certificates
    certs: {}
  };

  /**
   * Gets the certificate that issued the passed certificate or its
   * 'parent'.
   *
   * @param cert the certificate to get the parent for.
   *
   * @return the parent certificate or null if none was found.
   */
  caStore.getIssuer = function(cert) {
    var rval = getBySubject(cert.issuer);

    // see if there are multiple matches
    /*if(forge.util.isArray(rval)) {
      // TODO: resolve multiple matches by checking
      // authorityKey/subjectKey/issuerUniqueID/other identifiers, etc.
      // FIXME: or alternatively do authority key mapping
      // if possible (X.509v1 certs can't work?)
      throw new Error('Resolving multiple issuer matches not implemented yet.');
    }*/

    return rval;
  };

  /**
   * Adds a trusted certificate to the store.
   *
   * @param cert the certificate to add as a trusted certificate (either a
   *          pki.certificate object or a PEM-formatted certificate).
   */
  caStore.addCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    ensureSubjectHasHash(cert.subject);

    if(!caStore.hasCertificate(cert)) { // avoid duplicate certificates in store
      if(cert.subject.hash in caStore.certs) {
        // subject hash already exists, append to array
        var tmp = caStore.certs[cert.subject.hash];
        if(!forge.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert);
        caStore.certs[cert.subject.hash] = tmp;
      } else {
        caStore.certs[cert.subject.hash] = cert;
      }
    }
  };

  /**
   * Checks to see if the given certificate is in the store.
   *
   * @param cert the certificate to check (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return true if the certificate is in the store, false if not.
   */
  caStore.hasCertificate = function(cert) {
    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }

    var match = getBySubject(cert.subject);
    if(!match) {
      return false;
    }
    if(!forge.util.isArray(match)) {
      match = [match];
    }
    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        return true;
      }
    }
    return false;
  };

  /**
   * Lists all of the certificates kept in the store.
   *
   * @return an array of all of the pki.certificate objects in the store.
   */
  caStore.listAllCertificates = function() {
    var certList = [];

    for(var hash in caStore.certs) {
      if(caStore.certs.hasOwnProperty(hash)) {
        var value = caStore.certs[hash];
        if(!forge.util.isArray(value)) {
          certList.push(value);
        } else {
          for(var i = 0; i < value.length; ++i) {
            certList.push(value[i]);
          }
        }
      }
    }

    return certList;
  };

  /**
   * Removes a certificate from the store.
   *
   * @param cert the certificate to remove (either a pki.certificate or a
   *          PEM-formatted certificate).
   *
   * @return the certificate that was removed or null if the certificate
   *           wasn't in store.
   */
  caStore.removeCertificate = function(cert) {
    var result;

    // convert from pem if necessary
    if(typeof cert === 'string') {
      cert = forge.pki.certificateFromPem(cert);
    }
    ensureSubjectHasHash(cert.subject);
    if(!caStore.hasCertificate(cert)) {
      return null;
    }

    var match = getBySubject(cert.subject);

    if(!forge.util.isArray(match)) {
      result = caStore.certs[cert.subject.hash];
      delete caStore.certs[cert.subject.hash];
      return result;
    }

    // compare DER-encoding of certificates
    var der1 = asn1.toDer(pki.certificateToAsn1(cert)).getBytes();
    for(var i = 0; i < match.length; ++i) {
      var der2 = asn1.toDer(pki.certificateToAsn1(match[i])).getBytes();
      if(der1 === der2) {
        result = match[i];
        match.splice(i, 1);
      }
    }
    if(match.length === 0) {
      delete caStore.certs[cert.subject.hash];
    }

    return result;
  };

  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }

  function ensureSubjectHasHash(subject) {
    // produce subject hash if it doesn't exist
    if(!subject.hash) {
      var md = forge.md.sha1.create();
      subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }

  // auto-add passed in certs
  if(certs) {
    // parse PEM-formatted certificates as necessary
    for(var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }

  return caStore;
};

/**
 * Certificate verification errors, based on TLS.
 */
pki.certificateError = {
  bad_certificate: 'forge.pki.BadCertificate',
  unsupported_certificate: 'forge.pki.UnsupportedCertificate',
  certificate_revoked: 'forge.pki.CertificateRevoked',
  certificate_expired: 'forge.pki.CertificateExpired',
  certificate_unknown: 'forge.pki.CertificateUnknown',
  unknown_ca: 'forge.pki.UnknownCertificateAuthority'
};

/**
 * Verifies a certificate chain against the given Certificate Authority store
 * with an optional custom verify callback.
 *
 * @param caStore a certificate store to verify against.
 * @param chain the certificate chain to verify, with the root or highest
 *          authority at the end (an array of certificates).
 * @param options a callback to be called for every certificate in the chain or
 *                  an object with:
 *                  verify a callback to be called for every certificate in the
 *                    chain
 *                  validityCheckDate the date against which the certificate
 *                    validity period should be checked. Pass null to not check
 *                    the validity period. By default, the current date is used.
 *
 * The verify callback has the following signature:
 *
 * verified - Set to true if certificate was verified, otherwise the
 *   pki.certificateError for why the certificate failed.
 * depth - The current index in the chain, where 0 is the end point's cert.
 * certs - The certificate chain, *NOTE* an empty chain indicates an anonymous
 *   end point.
 *
 * The function returns true on success and on failure either the appropriate
 * pki.certificateError or an object with 'error' set to the appropriate
 * pki.certificateError and 'message' set to a custom error message.
 *
 * @return true if successful, error thrown if not.
 */
pki.verifyCertificateChain = function(caStore, chain, options) {
  /* From: RFC3280 - Internet X.509 Public Key Infrastructure Certificate
    Section 6: Certification Path Validation
    See inline parentheticals related to this particular implementation.

    The primary goal of path validation is to verify the binding between
    a subject distinguished name or a subject alternative name and subject
    public key, as represented in the end entity certificate, based on the
    public key of the trust anchor. This requires obtaining a sequence of
    certificates that support that binding. That sequence should be provided
    in the passed 'chain'. The trust anchor should be in the given CA
    store. The 'end entity' certificate is the certificate provided by the
    end point (typically a server) and is the first in the chain.

    To meet this goal, the path validation process verifies, among other
    things, that a prospective certification path (a sequence of n
    certificates or a 'chain') satisfies the following conditions:

    (a) for all x in {1, ..., n-1}, the subject of certificate x is
          the issuer of certificate x+1;

    (b) certificate 1 is issued by the trust anchor;

    (c) certificate n is the certificate to be validated; and

    (d) for all x in {1, ..., n}, the certificate was valid at the
          time in question.

    Note that here 'n' is index 0 in the chain and 1 is the last certificate
    in the chain and it must be signed by a certificate in the connection's
    CA store.

    The path validation process also determines the set of certificate
    policies that are valid for this path, based on the certificate policies
    extension, policy mapping extension, policy constraints extension, and
    inhibit any-policy extension.

    Note: Policy mapping extension not supported (Not Required).

    Note: If the certificate has an unsupported critical extension, then it
    must be rejected.

    Note: A certificate is self-issued if the DNs that appear in the subject
    and issuer fields are identical and are not empty.

    The path validation algorithm assumes the following seven inputs are
    provided to the path processing logic. What this specific implementation
    will use is provided parenthetically:

    (a) a prospective certification path of length n (the 'chain')
    (b) the current date/time: ('now').
    (c) user-initial-policy-set: A set of certificate policy identifiers
          naming the policies that are acceptable to the certificate user.
          The user-initial-policy-set contains the special value any-policy
          if the user is not concerned about certificate policy
          (Not implemented. Any policy is accepted).
    (d) trust anchor information, describing a CA that serves as a trust
          anchor for the certification path. The trust anchor information
          includes:

      (1)  the trusted issuer name,
      (2)  the trusted public key algorithm,
      (3)  the trusted public key, and
      (4)  optionally, the trusted public key parameters associated
             with the public key.

      (Trust anchors are provided via certificates in the CA store).

      The trust anchor information may be provided to the path processing
      procedure in the form of a self-signed certificate. The trusted anchor
      information is trusted because it was delivered to the path processing
      procedure by some trustworthy out-of-band procedure. If the trusted
      public key algorithm requires parameters, then the parameters are
      provided along with the trusted public key (No parameters used in this
      implementation).

    (e) initial-policy-mapping-inhibit, which indicates if policy mapping is
          allowed in the certification path.
          (Not implemented, no policy checking)

    (f) initial-explicit-policy, which indicates if the path must be valid
          for at least one of the certificate policies in the user-initial-
          policy-set.
          (Not implemented, no policy checking)

    (g) initial-any-policy-inhibit, which indicates whether the
          anyPolicy OID should be processed if it is included in a
          certificate.
          (Not implemented, so any policy is valid provided that it is
          not marked as critical) */

  /* Basic Path Processing:

    For each certificate in the 'chain', the following is checked:

    1. The certificate validity period includes the current time.
    2. The certificate was signed by its parent (where the parent is either
       the next in the chain or from the CA store). Allow processing to
       continue to the next step if no parent is found but the certificate is
       in the CA store.
    3. TODO: The certificate has not been revoked.
    4. The certificate issuer name matches the parent's subject name.
    5. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is within one of the permitted subtrees of X.500 distinguished names
       and that each of the alternative names in the subjectAltName extension
       (critical or non-critical) is within one of the permitted subtrees for
       that name type.
    6. TODO: If the certificate is self-issued and not the final certificate
       in the chain, skip this step, otherwise verify that the subject name
       is not within one of the excluded subtrees for X.500 distinguished
       names and none of the subjectAltName extension names are excluded for
       that name type.
    7. The other steps in the algorithm for basic path processing involve
       handling the policy extension which is not presently supported in this
       implementation. Instead, if a critical policy extension is found, the
       certificate is rejected as not supported.
    8. If the certificate is not the first or if its the only certificate in
       the chain (having no parent from the CA store or is self-signed) and it
       has a critical key usage extension, verify that the keyCertSign bit is
       set. If the key usage extension exists, verify that the basic
       constraints extension exists. If the basic constraints extension exists,
       verify that the cA flag is set. If pathLenConstraint is set, ensure that
       the number of certificates that precede in the chain (come earlier
       in the chain as implemented below), excluding the very first in the
       chain (typically the end-entity one), isn't greater than the
       pathLenConstraint. This constraint limits the number of intermediate
       CAs that may appear below a CA before only end-entity certificates
       may be issued. */

  // if a verify callback is passed as the third parameter, package it within
  // the options object. This is to support a legacy function signature that
  // expected the verify callback as the third parameter.
  if(typeof options === 'function') {
    options = {verify: options};
  }
  options = options || {};

  // copy cert chain references to another array to protect against changes
  // in verify callback
  chain = chain.slice(0);
  var certs = chain.slice(0);

  var validityCheckDate = options.validityCheckDate;
  // if no validityCheckDate is specified, default to the current date. Make
  // sure to maintain the value null because it indicates that the validity
  // period should not be checked.
  if(typeof validityCheckDate === 'undefined') {
    validityCheckDate = new Date();
  }

  // verify each cert in the chain using its parent, where the parent
  // is either the next in the chain or from the CA store
  var first = true;
  var error = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;

    if(validityCheckDate) {
      // 1. check valid time
      if(validityCheckDate < cert.validity.notBefore ||
         validityCheckDate > cert.validity.notAfter) {
        error = {
          message: 'Certificate is not valid yet or has expired.',
          error: pki.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    }

    // 2. verify with parent from chain or CA store
    if(error === null) {
      parent = chain[0] || caStore.getIssuer(cert);
      if(parent === null) {
        // check for self-signed cert
        if(cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }

      if(parent) {
        // FIXME: current CA store implementation might have multiple
        // certificates where the issuer can't be determined from the
        // certificate (happens rarely with, eg: old certificates) so normalize
        // by always putting parents into an array
        // TODO: there's may be an extreme degenerate case currently uncovered
        // where an old intermediate certificate seems to have a matching parent
        // but none of the parents actually verify ... but the intermediate
        // is in the CA and it should pass this check; needs investigation
        var parents = parent;
        if(!forge.util.isArray(parents)) {
          parents = [parents];
        }

        // try to verify with each possible parent (typically only one)
        var verified = false;
        while(!verified && parents.length > 0) {
          parent = parents.shift();
          try {
            verified = parent.verify(cert);
          } catch(ex) {
            // failure to verify, don't care why, try next one
          }
        }

        if(!verified) {
          error = {
            message: 'Certificate signature is invalid.',
            error: pki.certificateError.bad_certificate
          };
        }
      }

      if(error === null && (!parent || selfSigned) &&
        !caStore.hasCertificate(cert)) {
        // no parent issuer and certificate itself is not trusted
        error = {
          message: 'Certificate is not trusted.',
          error: pki.certificateError.unknown_ca
        };
      }
    }

    // TODO: 3. check revoked

    // 4. check for matching issuer/subject
    if(error === null && parent && !cert.isIssuer(parent)) {
      // parent is not issuer
      error = {
        message: 'Certificate issuer is invalid.',
        error: pki.certificateError.bad_certificate
      };
    }

    // 5. TODO: check names with permitted names tree

    // 6. TODO: check names against excluded names tree

    // 7. check for unsupported critical extensions
    if(error === null) {
      // supported extensions
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for(var i = 0; error === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if(ext.critical && !(ext.name in se)) {
          error = {
            message:
              'Certificate has an unsupported critical extension.',
            error: pki.certificateError.unsupported_certificate
          };
        }
      }
    }

    // 8. check for CA if cert is not first or is the only certificate
    // remaining in chain with no parent or is self-signed
    if(error === null &&
      (!first || (chain.length === 0 && (!parent || selfSigned)))) {
      // first check keyUsage extension and then basic constraints
      var bcExt = cert.getExtension('basicConstraints');
      var keyUsageExt = cert.getExtension('keyUsage');
      if(keyUsageExt !== null) {
        // keyCertSign must be true and there must be a basic
        // constraints extension
        if(!keyUsageExt.keyCertSign || bcExt === null) {
          // bad certificate
          error = {
            message:
              'Certificate keyUsage or basicConstraints conflict ' +
              'or indicate that the certificate is not a CA. ' +
              'If the certificate is the only one in the chain or ' +
              'isn\'t the first then the certificate must be a ' +
              'valid CA.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
      // basic constraints cA flag must be set
      if(error === null && bcExt !== null && !bcExt.cA) {
        // bad certificate
        error = {
          message:
            'Certificate basicConstraints indicates the certificate ' +
            'is not a CA.',
          error: pki.certificateError.bad_certificate
        };
      }
      // if error is not null and keyUsage is available, then we know it
      // has keyCertSign and there is a basic constraints extension too,
      // which means we can check pathLenConstraint (if it exists)
      if(error === null && keyUsageExt !== null &&
        'pathLenConstraint' in bcExt) {
        // pathLen is the maximum # of intermediate CA certs that can be
        // found between the current certificate and the end-entity (depth 0)
        // certificate; this number does not include the end-entity (depth 0,
        // last in the chain) even if it happens to be a CA certificate itself
        var pathLen = depth - 1;
        if(pathLen > bcExt.pathLenConstraint) {
          // pathLenConstraint violated, bad certificate
          error = {
            message:
              'Certificate basicConstraints pathLenConstraint violated.',
            error: pki.certificateError.bad_certificate
          };
        }
      }
    }

    // call application callback
    var vfd = (error === null) ? true : error.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
    if(ret === true) {
      // clear any set error
      error = null;
    } else {
      // if passed basic tests, set default message and alert
      if(vfd === true) {
        error = {
          message: 'The application rejected the certificate.',
          error: pki.certificateError.bad_certificate
        };
      }

      // check for custom error info
      if(ret || ret === 0) {
        // set custom message and error
        if(typeof ret === 'object' && !forge.util.isArray(ret)) {
          if(ret.message) {
            error.message = ret.message;
          }
          if(ret.error) {
            error.error = ret.error;
          }
        } else if(typeof ret === 'string') {
          // set custom error
          error.error = ret;
        }
      }

      // throw error
      throw error;
    }

    // no longer first cert in chain
    first = false;
    ++depth;
  } while(chain.length > 0);

  return true;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/ramda/src/always.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/always.js ***!
  \******************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");
/**
 * Returns a function that always returns the given value. Note that for
 * non-primitives the value returned is a reference to the original value.
 *
 * This function is known as `const`, `constant`, or `K` (for K combinator) in
 * other languages and libraries.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig a -> (* -> a)
 * @param {*} val The value to wrap in a function
 * @return {Function} A Function :: * -> val.
 * @example
 *
 *      const t = R.always('Tee');
 *      t(); //=> 'Tee'
 */


var always =
/*#__PURE__*/
_curry1(function always(val) {
  return function () {
    return val;
  };
});

module.exports = always;

/***/ }),

/***/ "./node_modules/ramda/src/bind.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/bind.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _arity =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      const log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
 */


var bind =
/*#__PURE__*/
_curry2(function bind(fn, thisObj) {
  return _arity(fn.length, function () {
    return fn.apply(thisObj, arguments);
  });
});

module.exports = bind;

/***/ }),

/***/ "./node_modules/ramda/src/curryN.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/curryN.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _arity =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _curryN =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curryN */ "./node_modules/ramda/src/internal/_curryN.js");
/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */


var curryN =
/*#__PURE__*/
_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }

  return _arity(length, _curryN(length, [], fn));
});

module.exports = curryN;

/***/ }),

/***/ "./node_modules/ramda/src/defaultTo.js":
/*!*********************************************!*\
  !*** ./node_modules/ramda/src/defaultTo.js ***!
  \*********************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`;
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} default The default value.
 * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
 * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
 * @example
 *
 *      const defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42(false);  //=> false
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      // parseInt('string') results in NaN
 *      defaultTo42(parseInt('string')); //=> 42
 */


var defaultTo =
/*#__PURE__*/
_curry2(function defaultTo(d, v) {
  return v == null || v !== v ? d : v;
});

module.exports = defaultTo;

/***/ }),

/***/ "./node_modules/ramda/src/equals.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/equals.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _equals =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_equals */ "./node_modules/ramda/src/internal/_equals.js");
/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      const a = {}; a.v = a;
 *      const b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */


var equals =
/*#__PURE__*/
_curry2(function equals(a, b) {
  return _equals(a, b, [], []);
});

module.exports = equals;

/***/ }),

/***/ "./node_modules/ramda/src/flip.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/flip.js ***!
  \****************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var curryN =
/*#__PURE__*/
__webpack_require__(/*! ./curryN */ "./node_modules/ramda/src/curryN.js");
/**
 * Returns a new function much like the supplied one, except that the first two
 * arguments' order is reversed.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
 * @param {Function} fn The function to invoke with its first two parameters reversed.
 * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
 * @example
 *
 *      const mergeThree = (a, b, c) => [].concat(a, b, c);
 *
 *      mergeThree(1, 2, 3); //=> [1, 2, 3]
 *
 *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
 * @symb R.flip(f)(a, b, c) = f(b, a, c)
 */


var flip =
/*#__PURE__*/
_curry1(function flip(fn) {
  return curryN(fn.length, function (a, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a;
    return fn.apply(this, args);
  });
});

module.exports = flip;

/***/ }),

/***/ "./node_modules/ramda/src/gte.js":
/*!***************************************!*\
  !*** ./node_modules/ramda/src/gte.js ***!
  \***************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * Returns `true` if the first argument is greater than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.lte
 * @example
 *
 *      R.gte(2, 1); //=> true
 *      R.gte(2, 2); //=> true
 *      R.gte(2, 3); //=> false
 *      R.gte('a', 'z'); //=> false
 *      R.gte('z', 'a'); //=> true
 */


var gte =
/*#__PURE__*/
_curry2(function gte(a, b) {
  return a >= b;
});

module.exports = gte;

/***/ }),

/***/ "./node_modules/ramda/src/ifElse.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/ifElse.js ***!
  \******************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry3 */ "./node_modules/ramda/src/internal/_curry3.js");

var curryN =
/*#__PURE__*/
__webpack_require__(/*! ./curryN */ "./node_modules/ramda/src/curryN.js");
/**
 * Creates a function that will process either the `onTrue` or the `onFalse`
 * function depending upon the result of the `condition` predicate.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Logic
 * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
 * @param {Function} condition A predicate function
 * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
 * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
 * @return {Function} A new function that will process either the `onTrue` or the `onFalse`
 *                    function depending upon the result of the `condition` predicate.
 * @see R.unless, R.when, R.cond
 * @example
 *
 *      const incCount = R.ifElse(
 *        R.has('count'),
 *        R.over(R.lensProp('count'), R.inc),
 *        R.assoc('count', 1)
 *      );
 *      incCount({});           //=> { count: 1 }
 *      incCount({ count: 1 }); //=> { count: 2 }
 */


var ifElse =
/*#__PURE__*/
_curry3(function ifElse(condition, onTrue, onFalse) {
  return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});

module.exports = ifElse;

/***/ }),

/***/ "./node_modules/ramda/src/includes.js":
/*!********************************************!*\
  !*** ./node_modules/ramda/src/includes.js ***!
  \********************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _includes =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_includes */ "./node_modules/ramda/src/internal/_includes.js");

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
 * terms, to at least one element of the given list; `false` otherwise.
 * Works also with strings.
 *
 * @func
 * @memberOf R
 * @since v0.26.0
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
 * @see R.any
 * @example
 *
 *      R.includes(3, [1, 2, 3]); //=> true
 *      R.includes(4, [1, 2, 3]); //=> false
 *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
 *      R.includes([42], [[42]]); //=> true
 *      R.includes('ba', 'banana'); //=>true
 */


var includes =
/*#__PURE__*/
_curry2(_includes);

module.exports = includes;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arity.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arity.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };

    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };

    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };

    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };

    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };

    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };

    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };

    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };

    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };

    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };

    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };

    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

module.exports = _arity;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_arrayFromIterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/ramda/src/internal/_arrayFromIterator.js ***!
  \***************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _arrayFromIterator(iter) {
  var list = [];
  var next;

  while (!(next = iter.next()).done) {
    list.push(next.value);
  }

  return list;
}

module.exports = _arrayFromIterator;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_checkForMethod.js":
/*!************************************************************!*\
  !*** ./node_modules/ramda/src/internal/_checkForMethod.js ***!
  \************************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _isArray =
/*#__PURE__*/
__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");
/**
 * This checks whether a function has a [methodname] function. If it isn't an
 * array it will execute that function otherwise it will default to the ramda
 * implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */


function _checkForMethod(methodname, fn) {
  return function () {
    var length = arguments.length;

    if (length === 0) {
      return fn();
    }

    var obj = arguments[length - 1];
    return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
  };
}

module.exports = _checkForMethod;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_concat.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_concat.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Private `concat` function to merge two array-like objects.
 *
 * @private
 * @param {Array|Arguments} [set1=[]] An array-like object.
 * @param {Array|Arguments} [set2=[]] An array-like object.
 * @return {Array} A new, merged array.
 * @example
 *
 *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 */
function _concat(set1, set2) {
  set1 = set1 || [];
  set2 = set2 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set2.length;
  var result = [];
  idx = 0;

  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }

  idx = 0;

  while (idx < len2) {
    result[result.length] = set2[idx];
    idx += 1;
  }

  return result;
}

module.exports = _concat;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry1.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry1.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");
/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

module.exports = _curry1;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry2.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry2.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;

      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

module.exports = _curry2;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curry3.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curry3.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");
/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curry3(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;

      case 1:
        return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        });

      case 2:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _curry1(function (_c) {
          return fn(a, b, _c);
        });

      default:
        return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
          return fn(_a, _b, c);
        }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
          return fn(_a, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
          return fn(a, _b, _c);
        }) : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b, c);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b, c);
        }) : _isPlaceholder(c) ? _curry1(function (_c) {
          return fn(a, b, _c);
        }) : fn(a, b, c);
    }
  };
}

module.exports = _curry3;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_curryN.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_curryN.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _arity =
/*#__PURE__*/
__webpack_require__(/*! ./_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _isPlaceholder =
/*#__PURE__*/
__webpack_require__(/*! ./_isPlaceholder */ "./node_modules/ramda/src/internal/_isPlaceholder.js");
/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */


function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;

    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;

      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }

      combined[combinedIdx] = result;

      if (!_isPlaceholder(result)) {
        left -= 1;
      }

      combinedIdx += 1;
    }

    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}

module.exports = _curryN;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_dispatchable.js":
/*!**********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_dispatchable.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _isArray =
/*#__PURE__*/
__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");

var _isTransformer =
/*#__PURE__*/
__webpack_require__(/*! ./_isTransformer */ "./node_modules/ramda/src/internal/_isTransformer.js");
/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with one of the given method names, it will
 * execute that function (functor case). Otherwise, if it is a transformer,
 * uses transducer [xf] to return a new transformer (transducer case).
 * Otherwise, it will default to executing [fn].
 *
 * @private
 * @param {Array} methodNames properties to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */


function _dispatchable(methodNames, xf, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn();
    }

    var args = Array.prototype.slice.call(arguments, 0);
    var obj = args.pop();

    if (!_isArray(obj)) {
      var idx = 0;

      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, args);
        }

        idx += 1;
      }

      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }

    return fn.apply(this, arguments);
  };
}

module.exports = _dispatchable;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_equals.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_equals.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _arrayFromIterator =
/*#__PURE__*/
__webpack_require__(/*! ./_arrayFromIterator */ "./node_modules/ramda/src/internal/_arrayFromIterator.js");

var _includesWith =
/*#__PURE__*/
__webpack_require__(/*! ./_includesWith */ "./node_modules/ramda/src/internal/_includesWith.js");

var _functionName =
/*#__PURE__*/
__webpack_require__(/*! ./_functionName */ "./node_modules/ramda/src/internal/_functionName.js");

var _has =
/*#__PURE__*/
__webpack_require__(/*! ./_has */ "./node_modules/ramda/src/internal/_has.js");

var _objectIs =
/*#__PURE__*/
__webpack_require__(/*! ./_objectIs */ "./node_modules/ramda/src/internal/_objectIs.js");

var keys =
/*#__PURE__*/
__webpack_require__(/*! ../keys */ "./node_modules/ramda/src/keys.js");

var type =
/*#__PURE__*/
__webpack_require__(/*! ../type */ "./node_modules/ramda/src/type.js");
/**
 * private _uniqContentEquals function.
 * That function is checking equality of 2 iterator contents with 2 assumptions
 * - iterators lengths are the same
 * - iterators values are unique
 *
 * false-positive result will be returned for comparision of, e.g.
 * - [1,2,3] and [1,2,3,4]
 * - [1,1,1] and [1,2,3]
 * */


function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a = _arrayFromIterator(aIterator);

  var b = _arrayFromIterator(bIterator);

  function eq(_a, _b) {
    return _equals(_a, _b, stackA.slice(), stackB.slice());
  } // if *a* array contains any element that is not included in *b*


  return !_includesWith(function (b, aItem) {
    return !_includesWith(eq, aItem, b);
  }, b, a);
}

function _equals(a, b, stackA, stackB) {
  if (_objectIs(a, b)) {
    return true;
  }

  var typeA = type(a);

  if (typeA !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
    return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
  }

  switch (typeA) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
        return a === b;
      }

      break;

    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && _objectIs(a.valueOf(), b.valueOf()))) {
        return false;
      }

      break;

    case 'Date':
      if (!_objectIs(a.valueOf(), b.valueOf())) {
        return false;
      }

      break;

    case 'Error':
      return a.name === b.name && a.message === b.message;

    case 'RegExp':
      if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
        return false;
      }

      break;
  }

  var idx = stackA.length - 1;

  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }

    idx -= 1;
  }

  switch (typeA) {
    case 'Map':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

    case 'Set':
      if (a.size !== b.size) {
        return false;
      }

      return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

    case 'Arguments':
    case 'Array':
    case 'Object':
    case 'Boolean':
    case 'Number':
    case 'String':
    case 'Date':
    case 'Error':
    case 'RegExp':
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
    case 'ArrayBuffer':
      break;

    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys(a);

  if (keysA.length !== keys(b).length) {
    return false;
  }

  var extendedStackA = stackA.concat([a]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;

  while (idx >= 0) {
    var key = keysA[idx];

    if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
      return false;
    }

    idx -= 1;
  }

  return true;
}

module.exports = _equals;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_functionName.js":
/*!**********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_functionName.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _functionName(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
}

module.exports = _functionName;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_has.js":
/*!*************************************************!*\
  !*** ./node_modules/ramda/src/internal/_has.js ***!
  \*************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = _has;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_includes.js":
/*!******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_includes.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _indexOf =
/*#__PURE__*/
__webpack_require__(/*! ./_indexOf */ "./node_modules/ramda/src/internal/_indexOf.js");

function _includes(a, list) {
  return _indexOf(list, a, 0) >= 0;
}

module.exports = _includes;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_includesWith.js":
/*!**********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_includesWith.js ***!
  \**********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _includesWith(pred, x, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    if (pred(x, list[idx])) {
      return true;
    }

    idx += 1;
  }

  return false;
}

module.exports = _includesWith;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_indexOf.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_indexOf.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var equals =
/*#__PURE__*/
__webpack_require__(/*! ../equals */ "./node_modules/ramda/src/equals.js");

function _indexOf(list, a, idx) {
  var inf, item; // Array.prototype.indexOf doesn't exist below IE9

  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;

          while (idx < list.length) {
            item = list[idx];

            if (item === 0 && 1 / item === inf) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];

            if (typeof item === 'number' && item !== item) {
              return idx;
            }

            idx += 1;
          }

          return -1;
        } // non-zero numbers can utilise Set


        return list.indexOf(a, idx);
      // all these types can utilise Set

      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }

    }
  } // anything else not covered above, defer to R.equals


  while (idx < list.length) {
    if (equals(list[idx], a)) {
      return idx;
    }

    idx += 1;
  }

  return -1;
}

module.exports = _indexOf;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArguments.js":
/*!*********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArguments.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _has =
/*#__PURE__*/
__webpack_require__(/*! ./_has */ "./node_modules/ramda/src/internal/_has.js");

var toString = Object.prototype.toString;

var _isArguments =
/*#__PURE__*/
function () {
  return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
    return toString.call(x) === '[object Arguments]';
  } : function _isArguments(x) {
    return _has('callee', x);
  };
}();

module.exports = _isArguments;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArray.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isArrayLike.js":
/*!*********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isArrayLike.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _isArray =
/*#__PURE__*/
__webpack_require__(/*! ./_isArray */ "./node_modules/ramda/src/internal/_isArray.js");

var _isString =
/*#__PURE__*/
__webpack_require__(/*! ./_isString */ "./node_modules/ramda/src/internal/_isString.js");
/**
 * Tests whether or not an object is similar to an array.
 *
 * @private
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      _isArrayLike([]); //=> true
 *      _isArrayLike(true); //=> false
 *      _isArrayLike({}); //=> false
 *      _isArrayLike({length: 10}); //=> false
 *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */


var _isArrayLike =
/*#__PURE__*/
_curry1(function isArrayLike(x) {
  if (_isArray(x)) {
    return true;
  }

  if (!x) {
    return false;
  }

  if (typeof x !== 'object') {
    return false;
  }

  if (_isString(x)) {
    return false;
  }

  if (x.nodeType === 1) {
    return !!x.length;
  }

  if (x.length === 0) {
    return true;
  }

  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }

  return false;
});

module.exports = _isArrayLike;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isInteger.js":
/*!*******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isInteger.js ***!
  \*******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/**
 * Determine if the passed argument is an integer.
 *
 * @private
 * @param {*} n
 * @category Type
 * @return {Boolean}
 */
module.exports = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isPlaceholder.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isPlaceholder.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

module.exports = _isPlaceholder;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isString.js":
/*!******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isString.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _isString(x) {
  return Object.prototype.toString.call(x) === '[object String]';
}

module.exports = _isString;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_isTransformer.js":
/*!***********************************************************!*\
  !*** ./node_modules/ramda/src/internal/_isTransformer.js ***!
  \***********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _isTransformer(obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function';
}

module.exports = _isTransformer;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_objectIs.js":
/*!******************************************************!*\
  !*** ./node_modules/ramda/src/internal/_objectIs.js ***!
  \******************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
function _objectIs(a, b) {
  // SameValue algorithm
  if (a === b) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
}

module.exports = typeof Object.is === 'function' ? Object.is : _objectIs;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_pipe.js":
/*!**************************************************!*\
  !*** ./node_modules/ramda/src/internal/_pipe.js ***!
  \**************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _pipe(f, g) {
  return function () {
    return g.call(this, f.apply(this, arguments));
  };
}

module.exports = _pipe;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_reduce.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_reduce.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _isArrayLike =
/*#__PURE__*/
__webpack_require__(/*! ./_isArrayLike */ "./node_modules/ramda/src/internal/_isArrayLike.js");

var _xwrap =
/*#__PURE__*/
__webpack_require__(/*! ./_xwrap */ "./node_modules/ramda/src/internal/_xwrap.js");

var bind =
/*#__PURE__*/
__webpack_require__(/*! ../bind */ "./node_modules/ramda/src/bind.js");

function _arrayReduce(xf, acc, list) {
  var idx = 0;
  var len = list.length;

  while (idx < len) {
    acc = xf['@@transducer/step'](acc, list[idx]);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    idx += 1;
  }

  return xf['@@transducer/result'](acc);
}

function _iterableReduce(xf, acc, iter) {
  var step = iter.next();

  while (!step.done) {
    acc = xf['@@transducer/step'](acc, step.value);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break;
    }

    step = iter.next();
  }

  return xf['@@transducer/result'](acc);
}

function _methodReduce(xf, acc, obj, methodName) {
  return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
}

var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';

function _reduce(fn, acc, list) {
  if (typeof fn === 'function') {
    fn = _xwrap(fn);
  }

  if (_isArrayLike(list)) {
    return _arrayReduce(fn, acc, list);
  }

  if (typeof list['fantasy-land/reduce'] === 'function') {
    return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
  }

  if (list[symIterator] != null) {
    return _iterableReduce(fn, acc, list[symIterator]());
  }

  if (typeof list.next === 'function') {
    return _iterableReduce(fn, acc, list);
  }

  if (typeof list.reduce === 'function') {
    return _methodReduce(fn, acc, list, 'reduce');
  }

  throw new TypeError('reduce: list must be array or iterable');
}

module.exports = _reduce;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_reduced.js":
/*!*****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_reduced.js ***!
  \*****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x : {
    '@@transducer/value': x,
    '@@transducer/reduced': true
  };
}

module.exports = _reduced;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xfBase.js":
/*!****************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xfBase.js ***!
  \****************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = {
  init: function () {
    return this.xf['@@transducer/init']();
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result);
  }
};

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xtake.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xtake.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _reduced =
/*#__PURE__*/
__webpack_require__(/*! ./_reduced */ "./node_modules/ramda/src/internal/_reduced.js");

var _xfBase =
/*#__PURE__*/
__webpack_require__(/*! ./_xfBase */ "./node_modules/ramda/src/internal/_xfBase.js");

var XTake =
/*#__PURE__*/
function () {
  function XTake(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }

  XTake.prototype['@@transducer/init'] = _xfBase.init;
  XTake.prototype['@@transducer/result'] = _xfBase.result;

  XTake.prototype['@@transducer/step'] = function (result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
  };

  return XTake;
}();

var _xtake =
/*#__PURE__*/
_curry2(function _xtake(n, xf) {
  return new XTake(n, xf);
});

module.exports = _xtake;

/***/ }),

/***/ "./node_modules/ramda/src/internal/_xwrap.js":
/*!***************************************************!*\
  !*** ./node_modules/ramda/src/internal/_xwrap.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var XWrap =
/*#__PURE__*/
function () {
  function XWrap(fn) {
    this.f = fn;
  }

  XWrap.prototype['@@transducer/init'] = function () {
    throw new Error('init not implemented on XWrap');
  };

  XWrap.prototype['@@transducer/result'] = function (acc) {
    return acc;
  };

  XWrap.prototype['@@transducer/step'] = function (acc, x) {
    return this.f(acc, x);
  };

  return XWrap;
}();

function _xwrap(fn) {
  return new XWrap(fn);
}

module.exports = _xwrap;

/***/ }),

/***/ "./node_modules/ramda/src/isNil.js":
/*!*****************************************!*\
  !*** ./node_modules/ramda/src/isNil.js ***!
  \*****************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");
/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */


var isNil =
/*#__PURE__*/
_curry1(function isNil(x) {
  return x == null;
});

module.exports = isNil;

/***/ }),

/***/ "./node_modules/ramda/src/keys.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/keys.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var _has =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_has */ "./node_modules/ramda/src/internal/_has.js");

var _isArguments =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_isArguments */ "./node_modules/ramda/src/internal/_isArguments.js"); // cover IE < 9 keys issues


var hasEnumBug = !
/*#__PURE__*/
{
  toString: null
}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

var hasArgsEnumBug =
/*#__PURE__*/
function () {
  'use strict';

  return arguments.propertyIsEnumerable('length');
}();

var contains = function contains(list, item) {
  var idx = 0;

  while (idx < list.length) {
    if (list[idx] === item) {
      return true;
    }

    idx += 1;
  }

  return false;
};
/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @see R.keysIn, R.values
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */


var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
/*#__PURE__*/
_curry1(function keys(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) :
/*#__PURE__*/
_curry1(function keys(obj) {
  if (Object(obj) !== obj) {
    return [];
  }

  var prop, nIdx;
  var ks = [];

  var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

  for (prop in obj) {
    if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
      ks[ks.length] = prop;
    }
  }

  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;

    while (nIdx >= 0) {
      prop = nonEnumerableProps[nIdx];

      if (_has(prop, obj) && !contains(ks, prop)) {
        ks[ks.length] = prop;
      }

      nIdx -= 1;
    }
  }

  return ks;
});
module.exports = keys;

/***/ }),

/***/ "./node_modules/ramda/src/lte.js":
/*!***************************************!*\
  !*** ./node_modules/ramda/src/lte.js ***!
  \***************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * Returns `true` if the first argument is less than or equal to the second;
 * `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean}
 * @see R.gte
 * @example
 *
 *      R.lte(2, 1); //=> false
 *      R.lte(2, 2); //=> true
 *      R.lte(2, 3); //=> true
 *      R.lte('a', 'z'); //=> true
 *      R.lte('z', 'a'); //=> false
 */


var lte =
/*#__PURE__*/
_curry2(function lte(a, b) {
  return a <= b;
});

module.exports = lte;

/***/ }),

/***/ "./node_modules/ramda/src/not.js":
/*!***************************************!*\
  !*** ./node_modules/ramda/src/not.js ***!
  \***************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");
/**
 * A function that returns the `!` of its argument. It will return `true` when
 * passed false-y value, and `false` when passed a truth-y one.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Logic
 * @sig * -> Boolean
 * @param {*} a any value
 * @return {Boolean} the logical inverse of passed argument.
 * @see R.complement
 * @example
 *
 *      R.not(true); //=> false
 *      R.not(false); //=> true
 *      R.not(0); //=> true
 *      R.not(1); //=> false
 */


var not =
/*#__PURE__*/
_curry1(function not(a) {
  return !a;
});

module.exports = not;

/***/ }),

/***/ "./node_modules/ramda/src/nth.js":
/*!***************************************!*\
  !*** ./node_modules/ramda/src/nth.js ***!
  \***************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _isString =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_isString */ "./node_modules/ramda/src/internal/_isString.js");
/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      const list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 * @symb R.nth(-1, [a, b, c]) = c
 * @symb R.nth(0, [a, b, c]) = a
 * @symb R.nth(1, [a, b, c]) = b
 */


var nth =
/*#__PURE__*/
_curry2(function nth(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString(list) ? list.charAt(idx) : list[idx];
});

module.exports = nth;

/***/ }),

/***/ "./node_modules/ramda/src/path.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/path.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var paths =
/*#__PURE__*/
__webpack_require__(/*! ./paths */ "./node_modules/ramda/src/paths.js");
/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig [Idx] -> {a} -> a | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop, R.nth
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
 *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
 */


var path =
/*#__PURE__*/
_curry2(function path(pathAr, obj) {
  return paths([pathAr], obj)[0];
});

module.exports = path;

/***/ }),

/***/ "./node_modules/ramda/src/paths.js":
/*!*****************************************!*\
  !*** ./node_modules/ramda/src/paths.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _isInteger =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_isInteger */ "./node_modules/ramda/src/internal/_isInteger.js");

var nth =
/*#__PURE__*/
__webpack_require__(/*! ./nth */ "./node_modules/ramda/src/nth.js");
/**
 * Retrieves the values at given paths of an object.
 *
 * @func
 * @memberOf R
 * @since v0.27.1
 * @category Object
 * @typedefn Idx = [String | Int]
 * @sig [Idx] -> {a} -> [a | Undefined]
 * @param {Array} pathsArray The array of paths to be fetched.
 * @param {Object} obj The object to retrieve the nested properties from.
 * @return {Array} A list consisting of values at paths specified by "pathsArray".
 * @see R.path
 * @example
 *
 *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
 *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
 */


var paths =
/*#__PURE__*/
_curry2(function paths(pathsArray, obj) {
  return pathsArray.map(function (paths) {
    var val = obj;
    var idx = 0;
    var p;

    while (idx < paths.length) {
      if (val == null) {
        return;
      }

      p = paths[idx];
      val = _isInteger(p) ? nth(p, val) : val[p];
      idx += 1;
    }

    return val;
  });
});

module.exports = paths;

/***/ }),

/***/ "./node_modules/ramda/src/pipe.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/pipe.js ***!
  \****************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _arity =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _pipe =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_pipe */ "./node_modules/ramda/src/internal/_pipe.js");

var reduce =
/*#__PURE__*/
__webpack_require__(/*! ./reduce */ "./node_modules/ramda/src/reduce.js");

var tail =
/*#__PURE__*/
__webpack_require__(/*! ./tail */ "./node_modules/ramda/src/tail.js");
/**
 * Performs left-to-right function composition. The first argument may have
 * any arity; the remaining arguments must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      const f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
 */


function pipe() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }

  return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
}

module.exports = pipe;

/***/ }),

/***/ "./node_modules/ramda/src/prop.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/prop.js ***!
  \****************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var path =
/*#__PURE__*/
__webpack_require__(/*! ./path */ "./node_modules/ramda/src/path.js");
/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @typedefn Idx = String | Int
 * @sig Idx -> {s: a} -> a | Undefined
 * @param {String|Number} p The property name or array index
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path, R.nth
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 *      R.prop(0, [100]); //=> 100
 *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
 */


var prop =
/*#__PURE__*/
_curry2(function prop(p, obj) {
  return path([p], obj);
});

module.exports = prop;

/***/ }),

/***/ "./node_modules/ramda/src/reduce.js":
/*!******************************************!*\
  !*** ./node_modules/ramda/src/reduce.js ***!
  \******************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry3 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry3 */ "./node_modules/ramda/src/internal/_curry3.js");

var _reduce =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_reduce */ "./node_modules/ramda/src/internal/_reduce.js");
/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * [`R.reduced`](#reduced) to shortcut the iteration.
 *
 * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
 * is *(value, acc)*.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present. When
 * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
 * shortcuting, as this is not implemented by `reduce`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex, R.reduceRight
 * @example
 *
 *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
 *      //          -               -10
 *      //         / \              / \
 *      //        -   4           -6   4
 *      //       / \              / \
 *      //      -   3   ==>     -3   3
 *      //     / \              / \
 *      //    -   2           -1   2
 *      //   / \              / \
 *      //  0   1            0   1
 *
 * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
 */


var reduce =
/*#__PURE__*/
_curry3(_reduce);

module.exports = reduce;

/***/ }),

/***/ "./node_modules/ramda/src/slice.js":
/*!*****************************************!*\
  !*** ./node_modules/ramda/src/slice.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/ramda/src/internal/_checkForMethod.js");

var _curry3 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry3 */ "./node_modules/ramda/src/internal/_curry3.js");
/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */


var slice =
/*#__PURE__*/
_curry3(
/*#__PURE__*/
_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

module.exports = slice;

/***/ }),

/***/ "./node_modules/ramda/src/startsWith.js":
/*!**********************************************!*\
  !*** ./node_modules/ramda/src/startsWith.js ***!
  \**********************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var equals =
/*#__PURE__*/
__webpack_require__(/*! ./equals */ "./node_modules/ramda/src/equals.js");

var take =
/*#__PURE__*/
__webpack_require__(/*! ./take */ "./node_modules/ramda/src/take.js");
/**
 * Checks if a list starts with the provided sublist.
 *
 * Similarly, checks if a string starts with the provided substring.
 *
 * @func
 * @memberOf R
 * @since v0.24.0
 * @category List
 * @sig [a] -> [a] -> Boolean
 * @sig String -> String -> Boolean
 * @param {*} prefix
 * @param {*} list
 * @return {Boolean}
 * @see R.endsWith
 * @example
 *
 *      R.startsWith('a', 'abc')                //=> true
 *      R.startsWith('b', 'abc')                //=> false
 *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
 *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
 */


var startsWith =
/*#__PURE__*/
_curry2(function (prefix, list) {
  return equals(take(prefix.length, list), prefix);
});

module.exports = startsWith;

/***/ }),

/***/ "./node_modules/ramda/src/tail.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/tail.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _checkForMethod =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_checkForMethod */ "./node_modules/ramda/src/internal/_checkForMethod.js");

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");

var slice =
/*#__PURE__*/
__webpack_require__(/*! ./slice */ "./node_modules/ramda/src/slice.js");
/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */


var tail =
/*#__PURE__*/
_curry1(
/*#__PURE__*/
_checkForMethod('tail',
/*#__PURE__*/
slice(1, Infinity)));

module.exports = tail;

/***/ }),

/***/ "./node_modules/ramda/src/take.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/take.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");

var _dispatchable =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_dispatchable */ "./node_modules/ramda/src/internal/_dispatchable.js");

var _xtake =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_xtake */ "./node_modules/ramda/src/internal/_xtake.js");

var slice =
/*#__PURE__*/
__webpack_require__(/*! ./slice */ "./node_modules/ramda/src/slice.js");
/**
 * Returns the first `n` elements of the given list, string, or
 * transducer/transformer (or object with a `take` method).
 *
 * Dispatches to the `take` method of the second argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> [a]
 * @sig Number -> String -> String
 * @param {Number} n
 * @param {*} list
 * @return {*}
 * @see R.drop
 * @example
 *
 *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
 *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
 *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
 *      R.take(3, 'ramda');               //=> 'ram'
 *
 *      const personnel = [
 *        'Dave Brubeck',
 *        'Paul Desmond',
 *        'Eugene Wright',
 *        'Joe Morello',
 *        'Gerry Mulligan',
 *        'Bob Bates',
 *        'Joe Dodge',
 *        'Ron Crotty'
 *      ];
 *
 *      const takeFive = R.take(5);
 *      takeFive(personnel);
 *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
 * @symb R.take(-1, [a, b]) = [a, b]
 * @symb R.take(0, [a, b]) = []
 * @symb R.take(1, [a, b]) = [a]
 * @symb R.take(2, [a, b]) = [a, b]
 */


var take =
/*#__PURE__*/
_curry2(
/*#__PURE__*/
_dispatchable(['take'], _xtake, function take(n, xs) {
  return slice(0, n < 0 ? Infinity : n, xs);
}));

module.exports = take;

/***/ }),

/***/ "./node_modules/ramda/src/tryCatch.js":
/*!********************************************!*\
  !*** ./node_modules/ramda/src/tryCatch.js ***!
  \********************************************/
/*! no static exports found */
/*! exports used: default */
/***/ (function(module, exports, __webpack_require__) {

var _arity =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_arity */ "./node_modules/ramda/src/internal/_arity.js");

var _concat =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_concat */ "./node_modules/ramda/src/internal/_concat.js");

var _curry2 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry2 */ "./node_modules/ramda/src/internal/_curry2.js");
/**
 * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
 * function evaluates the `tryer`; if it does not throw, it simply returns the
 * result. If the `tryer` *does* throw, the returned function evaluates the
 * `catcher` function and returns its result. Note that for effective
 * composition with this function, both the `tryer` and `catcher` functions
 * must return the same type of results.
 *
 * @func
 * @memberOf R
 * @since v0.20.0
 * @category Function
 * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
 * @param {Function} tryer The function that may throw.
 * @param {Function} catcher The function that will be evaluated if `tryer` throws.
 * @return {Function} A new function that will catch exceptions and send then to the catcher.
 * @example
 *
 *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
 *      R.tryCatch(() => { throw 'foo'}, R.always('catched'))('bar') // => 'catched'
 *      R.tryCatch(R.times(R.identity), R.always([]))('s') // => []
 *      R.tryCatch(() => { throw 'this is not a valid value'}, (err, value)=>({error : err,  value }))('bar') // => {'error': 'this is not a valid value', 'value': 'bar'}
 */


var tryCatch =
/*#__PURE__*/
_curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function () {
    try {
      return tryer.apply(this, arguments);
    } catch (e) {
      return catcher.apply(this, _concat([e], arguments));
    }
  });
});

module.exports = tryCatch;

/***/ }),

/***/ "./node_modules/ramda/src/type.js":
/*!****************************************!*\
  !*** ./node_modules/ramda/src/type.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

var _curry1 =
/*#__PURE__*/
__webpack_require__(/*! ./internal/_curry1 */ "./node_modules/ramda/src/internal/_curry1.js");
/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 *      R.type(() => {}); //=> "Function"
 *      R.type(undefined); //=> "Undefined"
 */


var type =
/*#__PURE__*/
_curry1(function type(val) {
  return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
});

module.exports = type;

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/*! exports used: __assign, __awaiter, __decorate, __extends, __generator, __spreadArrays */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __assign; });
/* unused harmony export __rest */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __decorate; });
/* unused harmony export __param */
/* unused harmony export __metadata */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __generator; });
/* unused harmony export __createBinding */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __spreadArrays; });
/* unused harmony export __spreadArray */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/* unused harmony export __classPrivateFieldGet */
/* unused harmony export __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ }),

/***/ "./node_modules/typed-ts-events/dist/events.min.js":
/*!*********************************************************!*\
  !*** ./node_modules/typed-ts-events/dist/events.min.js ***!
  \*********************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?module.exports=e():undefined}(this,(function(){return(()=>{"use strict";var t={660:(t,e)=>{e.__esModule=!0,e.EventEmitter=void 0;var n=function(){function t(t){this._events=Object.create(null),this.catchHandler=t||function(){}}return t.prototype.hasListeners=function(t){return!(!this._events[t]||!this._events[t].length)},t.prototype.getActiveEvents=function(){var t=this;return Object.keys(this._events).filter((function(e){return t.hasListeners(e)}))},t.prototype.trigger=function(t,e){var n=this;this._events[t]&&(this._events[t].slice().forEach((function(o){try{o.handler.call(o.context,e)}catch(t){n.catchHandler(t)}o.once&&n.off(t,o.handler)})),this._events[t].length||delete this._events[t])},t.prototype.on=function(t,e,n){this._on(t,e,n,!1)},t.prototype.once=function(t,e,n){this._on(t,e,n,!0)},t.prototype.off=function(t,e){var n=this,o="string"==typeof t?t:null,i="function"==typeof e?e:"function"==typeof t?t:null;if(o)if(i){if(o in this._events){var r=this._events[o].map((function(t){return t.handler})).indexOf(i);this._events[o].splice(r,1)}}else delete this._events[o];else Object.keys(this._events).forEach((function(t){n.off(t,i)}))},t.prototype._on=function(t,e,n,o){this._events[t]||(this._events[t]=[]),this._events[t].push({handler:e,context:n,once:o})},t}();e.EventEmitter=n},607:function(t,e,n){var o=this&&this.__createBinding||(Object.create?function(t,e,n,o){void 0===o&&(o=n),Object.defineProperty(t,o,{enumerable:!0,get:function(){return e[n]}})}:function(t,e,n,o){void 0===o&&(o=n),t[o]=e[n]}),i=this&&this.__exportStar||function(t,e){for(var n in t)"default"===n||Object.prototype.hasOwnProperty.call(e,n)||o(e,t,n)};e.__esModule=!0;var r=n(660);i(n(660),e),e.default=r.EventEmitter}},e={};return function n(o){if(e[o])return e[o].exports;var i=e[o]={exports:{}};return t[o].call(i.exports,i,i.exports,n),i.exports}(607)})()}));
//# sourceMappingURL=events.min.js.map

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _waves_signer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @waves/signer */ "./node_modules/@waves/signer/dist/es/index.js");
/* harmony import */ var _waves_exchange_provider_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @waves.exchange/provider-web */ "./node_modules/@waves.exchange/provider-web/dist/provider-web.es.js");
/* harmony import */ var _waves_provider_seed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @waves/provider-seed */ "./node_modules/@waves/provider-seed/dist/provider-seed.js");
/* harmony import */ var _waves_provider_seed__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_waves_provider_seed__WEBPACK_IMPORTED_MODULE_2__);




const seed = "ritual tornado rich autumn sketch creek output hospital question need crazy color pilot hamster note";//libs.crypto.randomSeed(15);
const signer  = new _waves_signer__WEBPACK_IMPORTED_MODULE_0__["Signer"]({NODE_URL: 'https://nodes-testnet.wavesnodes.com'});
const provider = new _waves_exchange_provider_web__WEBPACK_IMPORTED_MODULE_1__[/* ProviderWeb */ "a"]('https://testnet.waves.exchange/signer/');

signer.setProvider(new _waves_provider_seed__WEBPACK_IMPORTED_MODULE_2__["ProviderSeed"](seed));
//signer.setProvider(provider);


document.querySelector(".js-login").addEventListener("click", async function (event) {
    try {
        const userData = await signer.login();
        event.target.classList.add("clicked");
        event.target.innerHTML = `
            authorized as <br>
            ${userData.address}`;
        document.querySelector(".explorer-link").innerHTML = `<a href="https://wavesexplorer.com/testnet/address/${userData.address}" target="_blank">Check the Explorer</a>`;
    } catch (e) {
        console.error('login rejected')
    }
});


// calling a "faucet" script wavesexplorer.com/tesnet/address/3MuN7D8r19zdvSpAd1L91Gs88bcgwUFy2mn/script
// this will top up the account balance, but only once
/*
document.querySelector(".js-invoke").addEventListener("click", function () {
    signer.invoke({
        dApp: "3MuN7D8r19zdvSpAd1L91Gs88bcgwUFy2mn",
        call: {
            function: "faucet"
        }
    }).broadcast().then(console.log)
});
*/


// just putting some data into account storage
/*
document.querySelector(".js-data").addEventListener("click", function () {
    const date = new Date();
    signer.data({
        data: [
            {
                key: "lastCall",
                value: `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`,
                type: 'string'
            }
        ]
    }).broadcast().then(console.log)
});
*/

// just transferring some WAVES token to Alice
/*
document.querySelector(".js-transfer").addEventListener("click", function () {
    signer.transfer({
        recipient: "3MuN7D8r19zdvSpAd1L91Gs88bcgwUFy2mn",
        amount: 1
    }).broadcast().then(console.log)
});
*/

/***/ }),

/***/ 0:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy5leGNoYW5nZS9wcm92aWRlci13ZWIvZGlzdC9wcm92aWRlci13ZWIuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9iaWdudW1iZXIvZGlzdC9iaWdudW1iZXIudW1kLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL2NsaWVudC1sb2dzL2Rpc3QvY2xpZW50LWxvZ3MubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL2FwaS1ub2RlL2FkZHJlc3Nlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy9hcGktbm9kZS9hc3NldHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9ub2RlLWFwaS1qcy9janMvYXBpLW5vZGUvYmxvY2tzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL2FwaS1ub2RlL3RyYW5zYWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9ub2RlLWFwaS1qcy9janMvdG9vbHMvYmxvY2tzL2dldE5ldHdvcmtCeXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL3Rvb2xzL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL3Rvb2xzL3F1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL3Rvb2xzL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9ub2RlLWFwaS1qcy9janMvdG9vbHMvcmVzb2x2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy90b29scy9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9ub2RlLWFwaS1qcy9janMvdG9vbHMvdHJhbnNhY3Rpb25zL2Jyb2FkY2FzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy90b29scy90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL3Rvb2xzL3RyYW5zYWN0aW9ucy93YWl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvbm9kZS1hcGktanMvY2pzL3Rvb2xzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvcHJvdmlkZXItc2VlZC9kaXN0L3Byb3ZpZGVyLXNlZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9zaWduZXIvZGlzdC9lcy9TaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9zaWduZXIvZGlzdC9lcy9TaWduZXJFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3NpZ25lci9kaXN0L2VzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3NpZ25lci9kaXN0L2VzL2RlY29yYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9zaWduZXIvZGlzdC9lcy9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvc2lnbmVyL2Rpc3QvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy9zaWduZXIvZGlzdC9lcy92YWxpZGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvc2lnbmVyL2Rpc3QvZXMvdmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vY29udmVyc2lvbnMvYmFzZS14eC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vY29udmVyc2lvbnMvcGFyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2NvbnZlcnNpb25zL3N0cmluZy1ieXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vY3J5cHRvL2FkZHJlc3Mta2V5cy1zZWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vY29uY2F0LXNwbGl0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vY3J5cHRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vZW5jcnlwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vY3J5cHRvL2hhc2hpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2NyeXB0by9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2NyeXB0by9tZXJrbGUtdmVyaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vcmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vcnNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vc2VlZC1lY3J5cHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2NyeXB0by9zZWVkLXdvcmRzLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2NyeXB0by9zaWduLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9jcnlwdG8vdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vY3J5cHRvL3ZlcmlmaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vZXh0ZW5zaW9ucy9jaGFpbi1pZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vZXh0ZW5zaW9ucy9zZWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLWxpYi1jcnlwdG8vbGlicy9VdGY4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9saWJzL2F4bHNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2xpYnMvYmFzZTU4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtbGliLWNyeXB0by9saWJzL2JsYWtlMmIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy1saWItY3J5cHRvL2xpYnMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3RzLXR5cGVzL2Rpc3Qvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvdHMtdHlwZXMvZGlzdC9zcmMvcGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy90cy10eXBlcy9kaXN0L3RyYW5zYWN0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvYWRhcHRlcnMvQWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvYWRhcHRlcnMvV2luZG93QWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvYnVzL0J1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvY29uZmlnL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvd2F2ZXMtYnJvd3Nlci1idXMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvcHJvdG9jb2xzL1dpbmRvd1Byb3RvY29sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2F2ZXMvd2F2ZXMtYnJvd3Nlci1idXMvZGlzdC91dGlscy9VbmlxUHJpbWl0aXZlQ29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvdXRpbHMvY29uc29sZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdhdmVzL3dhdmVzLWJyb3dzZXItYnVzL2Rpc3QvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3YXZlcy93YXZlcy1icm93c2VyLWJ1cy9kaXN0L3V0aWxzL3V0aWxzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9hZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2FzbjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2Jhc2VOLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9jaXBoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2NpcGhlck1vZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL2ZvcmdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9obWFjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9qc2JuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvbWQ1LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9tZ2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL21nZjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL29pZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BiZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGJrZGYyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3MxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wa2NzMTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3BrY3M3YXNuMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcGtpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9wcmltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHJuZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcHNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3JjMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWIvcnNhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYi9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGliL3g1MDkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2Fsd2F5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jdXJyeU4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9kZWZhdWx0VG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9mbGlwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvZ3RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaWZFbHNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJyYXlGcm9tSXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY29uY2F0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5MS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fY3VycnkzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Ti5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19kaXNwYXRjaGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fZXF1YWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Z1bmN0aW9uTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faW5jbHVkZXNXaXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNQbGFjZWhvbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX29iamVjdElzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3BpcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3JlZHVjZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feGZCYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3h0YWtlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3h3cmFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaXNOaWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbHRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbm90LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbnRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhdGhzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcGlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3Byb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3N0YXJ0c1dpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy90YWlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdGFrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3RyeUNhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlZC10cy1ldmVudHMvZGlzdC9ldmVudHMubWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLDhEQUE4RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRTtBQUN2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzRUFBYTtBQUN4QixzQkFBc0IsNERBQUc7QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFZO0FBQ25DLDRFQUE0RSw2QkFBNkI7QUFDekc7QUFDQTtBQUNBLE1BQU0sK0RBQU0sb0JBQW9CLCtEQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7Ozs7Ozs7O0FDN0RhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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T0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxHQUFHLEtBQUssU0FBUzs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx1REFBUztBQUM3QixtQkFBTyxDQUFDLHFEQUFRO0FBQ2hCLG1CQUFPLENBQUMscURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5L0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDampDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHVEQUFTO0FBQzdCLG1CQUFPLENBQUMscURBQVE7QUFDaEIsbUJBQU8sQ0FBQyxxREFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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Q3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVELENBQUM7Ozs7Ozs7Ozs7Ozs7QUM5TEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVM7QUFDN0IsbUJBQU8sQ0FBQyxxREFBUTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDelpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx1REFBUztBQUM3QixtQkFBTyxDQUFDLHFEQUFRO0FBQ2hCLG1CQUFPLENBQUMscURBQVE7QUFDaEIsbUJBQU8sQ0FBQyxxREFBUTtBQUNoQixtQkFBTyxDQUFDLHVEQUFTO0FBQ2pCLG1CQUFPLENBQUMsdURBQVM7QUFDakIsbUJBQU8sQ0FBQyx5REFBVTtBQUNsQixtQkFBTyxDQUFDLHFEQUFROztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLG1CQUFPLENBQUMsZUFBUTs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0MsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixxQkFBcUI7QUFDckMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixxQkFBcUI7QUFDckMsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUs7QUFDTCxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUMsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2owREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsdURBQVM7QUFDN0IsbUJBQU8sQ0FBQyxpREFBTTtBQUNkLG1CQUFPLENBQUMscURBQVE7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyx1REFBUztBQUM3QixtQkFBTyxDQUFDLGlEQUFNO0FBQ2QsbUJBQU8sQ0FBQyxxREFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQ0FBcUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLFNBQVMsUUFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHVEQUFTO0FBQzdCLFlBQVksbUJBQU8sQ0FBQyx1REFBUzs7QUFFN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsaURBQWlEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxnQkFBZ0IsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdCQUFnQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUztBQUNULFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkMsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUE2QztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQzs7QUFFQTs7QUFFQSx5REFBeUQ7O0FBRXpELHNCQUFzQixVQUFVO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBOEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcHdHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FB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b0g7QUFDcEgsb0JBQW9CLG9EQUFNLEVBQUUsaURBQWlEO0FBQzdFLHFCQUFxQixnRkFBVzs7QUFFaEMsdUJBQXVCLGlFQUFZO0FBQ25DOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQixtSEFBbUgsaUJBQWlCO0FBQ3BJLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ25KO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRCxFOzs7Ozs7Ozs7Ozs7QUNoRUEsZSIsImZpbGUiOiJkYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmltcG9ydCB7IFdpbmRvd0FkYXB0ZXIsIEJ1cywgY29uZmlnIH0gZnJvbSBcIkB3YXZlcy93YXZlcy1icm93c2VyLWJ1c1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcInR5cGVkLXRzLWV2ZW50c1wiO1xuY2xhc3MgUXVldWUge1xuICBjb25zdHJ1Y3RvcihtYXhMZW5ndGgpIHtcbiAgICB0aGlzLl9hY3Rpb25zID0gW107XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMubGVuZ3RoICsgKHRoaXMuX2FjdGl2ZSA9PSBudWxsID8gMCA6IDEpO1xuICB9XG4gIHB1c2goYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2FjdGlvbnMubGVuZ3RoID49IHRoaXMuX21heExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudCd0IHB1c2ggYWN0aW9uISBRdWV1ZSBpcyBmdWxsIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWN0aW9ucy5tYXAoKHgpID0+IHguYWN0aW9uKS5pbmRleE9mKGFjdGlvbkNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX2FjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGFjdGlvbkNhbGxiYWNrID0gKCkgPT4gYWN0aW9uKCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIG9uRW5kKCk7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgb25FbmQoKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2FjdGlvbnMucHVzaCh7IGFjdGlvbjogYWN0aW9uQ2FsbGJhY2ssIHJlamVjdCB9KTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsZWFyKGVycm9yKSB7XG4gICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgRXJyb3IoXCJSZWplY3Rpb24gd2l0aCBjbGVhciBxdWV1ZSFcIik7XG4gICAgY29uc3QgZSA9IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IG5ldyBFcnJvcihlcnJvcikgOiBlcnJvcjtcbiAgICB0aGlzLl9hY3Rpb25zLnNwbGljZSgwLCB0aGlzLl9hY3Rpb25zLmxlbmd0aCkuZm9yRWFjaCgoaXRlbSkgPT4gaXRlbS5yZWplY3QoZSkpO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHZvaWQgMDtcbiAgfVxuICBjYW5QdXNoKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA8IHRoaXMuX21heExlbmd0aDtcbiAgfVxuICBydW4oKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2FjdGlvbnMuc2hpZnQoKTtcbiAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSBpdGVtLmFjdGlvbigpO1xuICB9XG59XG5jb25zdCBjcmVhdGVFcnJvciA9IChlcnJvcikgPT4ge1xuICBjb25zdCBjb21tb25FcnJvciA9IHtcbiAgICBjb2RlOiAwLFxuICAgIG1lc3NhZ2U6IChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgfHwgZXJyb3JcbiAgfTtcbiAgc3dpdGNoIChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkge1xuICAgIGNhc2UgXCJTZWN1cml0eUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2xvY2FsU3RvcmFnZScgcHJvcGVydHkgZnJvbSAnV2luZG93JzogQWNjZXNzIGlzIGRlbmllZCBmb3IgdGhpcyBkb2N1bWVudC5cIjpcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb21tb25FcnJvciksIHtcbiAgICAgICAgbWVzc2FnZTogXCJMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUhIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIEJyb3dzZXIgaXMgaW4gaW5jb2duaXRvIG1vZGUhXCJcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29tbW9uRXJyb3I7XG4gIH1cbn07XG5jbGFzcyBUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvcihxdWV1ZUxlbmd0aCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgIHRoaXMuX3RvUnVuRXZlbnRzID0gW107XG4gICAgdGhpcy5fcXVldWUgPSBuZXcgUXVldWUocXVldWVMZW5ndGgpO1xuICB9XG4gIGRyb3BDb25uZWN0aW9uKCkge1xuICAgIHRoaXMuX3F1ZXVlLmNsZWFyKG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0aW9uIVwiKSk7XG4gICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aGlzLl90b1J1bkV2ZW50cy5wdXNoKGV2ZW50KSk7XG4gICAgdGhpcy5fZHJvcFRyYW5zcG9ydENvbm5lY3QoKTtcbiAgfVxuICBzZW5kRXZlbnQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudHMucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fdG9SdW5FdmVudHMucHVzaChjYWxsYmFjayk7XG4gIH1cbiAgZGlhbG9nKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnVuQmVmb3JlU2hvdygpO1xuICAgIHJldHVybiB0aGlzLl9nZXRCdXMoKS50aGVuKChidXMpID0+IHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuX3dyYXBBY3Rpb24oKCkgPT4gY2FsbGJhY2soYnVzKSk7XG4gICAgICB0aGlzLl9ydW5FdmVudHMoYnVzKTtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5jYW5QdXNoKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLnB1c2goYWN0aW9uKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICB0aGlzLl9ydW5BZnRlclNob3coKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICB0aGlzLl9ydW5BZnRlclNob3coKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY3JlYXRlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUXVldWUgaXMgZnVsbCFcIikpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9ydW5CZWZvcmVTaG93KCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2JlZm9yZVNob3coKTtcbiAgICB9XG4gIH1cbiAgX3J1bkFmdGVyU2hvdygpIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9hZnRlclNob3coKTtcbiAgICB9XG4gIH1cbiAgX3J1bkV2ZW50cyhidXMpIHtcbiAgICB0aGlzLl90b1J1bkV2ZW50cy5zcGxpY2UoMCwgdGhpcy5fZXZlbnRzLmxlbmd0aCkuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGJ1cykpO1xuICB9XG4gIF93cmFwQWN0aW9uKGFjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl90b1J1bkV2ZW50cyA/ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjdGlvbigpO1xuICAgICAgcmVzdWx0LmNhdGNoKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aGlzLl90b1J1bkV2ZW50cy5wdXNoKGV2ZW50KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSA6IGFjdGlvbjtcbiAgfVxufVxuY29uc3QgX1RyYW5zcG9ydElmcmFtZSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IodXJsLCBxdWV1ZUxlbmd0aCkge1xuICAgIHN1cGVyKHF1ZXVlTGVuZ3RoKTtcbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5faW5pdElmcmFtZSgpO1xuICB9XG4gIGdldCgpIHtcbiAgICBpZiAoIXRoaXMuX2lmcmFtZSkge1xuICAgICAgdGhpcy5faW5pdElmcmFtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faWZyYW1lO1xuICB9XG4gIF9kcm9wVHJhbnNwb3J0Q29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5faWZyYW1lICE9IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5faWZyYW1lKTtcbiAgICAgIHRoaXMuX2luaXRJZnJhbWUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2J1cykge1xuICAgICAgdGhpcy5fYnVzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2J1cyA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgX2dldEJ1cygpIHtcbiAgICBpZiAodGhpcy5fYnVzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2J1cyk7XG4gICAgfVxuICAgIHJldHVybiBXaW5kb3dBZGFwdGVyLmNyZWF0ZVNpbXBsZVdpbmRvd0FkYXB0ZXIodGhpcy5faWZyYW1lKS50aGVuKChhZGFwdGVyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fYnVzID0gbmV3IEJ1cyhhZGFwdGVyLCAtMSk7XG4gICAgICB0aGlzLl9idXMub25jZShcInJlYWR5XCIsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLl9idXMpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG4gIF9iZWZvcmVTaG93KCkge1xuICAgIHRoaXMuX3Nob3dJZnJhbWUoKTtcbiAgfVxuICBfYWZ0ZXJTaG93KCkge1xuICAgIHRoaXMuX2hpZGVJZnJhbWUoKTtcbiAgfVxuICBfaW5pdElmcmFtZSgpIHtcbiAgICB0aGlzLl9pZnJhbWUgPSB0aGlzLl9jcmVhdGVJZnJhbWUoKTtcbiAgICB0aGlzLl9hZGRJZnJhbWVUb0RvbSh0aGlzLl9pZnJhbWUpO1xuICAgIHRoaXMuX2xpc3RlbkZldGNoVVJMRXJyb3IodGhpcy5faWZyYW1lKTtcbiAgICB0aGlzLl9oaWRlSWZyYW1lKCk7XG4gIH1cbiAgX2FkZElmcmFtZVRvRG9tKGlmcmFtZSkge1xuICAgIGlmIChkb2N1bWVudC5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUlmcmFtZSgpIHtcbiAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgIGlmcmFtZS5zdHlsZS50cmFuc2l0aW9uID0gXCJvcGFjaXR5IC4yc1wiO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBpZnJhbWUuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIGlmcmFtZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICBpZnJhbWUuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgIGlmcmFtZS5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gXCJub25lXCI7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbiAgX3Nob3dJZnJhbWUoKSB7XG4gICAgY29uc3Qgc2hvd25TdHlsZXMgPSB7XG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICB0b3A6IFwiMFwiLFxuICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICBvcGFjaXR5OiBcIjBcIixcbiAgICAgIHpJbmRleDogXCI5OTk5OTk5OVwiXG4gICAgfTtcbiAgICB0aGlzLl9hcHBseVN0eWxlKHNob3duU3R5bGVzKTtcbiAgICBpZiAoX1RyYW5zcG9ydElmcmFtZS5fdGltZXIgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF9UcmFuc3BvcnRJZnJhbWUuX3RpbWVyKTtcbiAgICB9XG4gICAgX1RyYW5zcG9ydElmcmFtZS5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2FwcGx5U3R5bGUoeyBvcGFjaXR5OiBcIjFcIiB9KTtcbiAgICB9LCAwKTtcbiAgfVxuICBfaGlkZUlmcmFtZSgpIHtcbiAgICBjb25zdCBoaWRkZW5TdHlsZSA9IHtcbiAgICAgIG9wYWNpdHk6IFwiMFwiXG4gICAgfTtcbiAgICB0aGlzLl9hcHBseVN0eWxlKGhpZGRlblN0eWxlKTtcbiAgICBpZiAoX1RyYW5zcG9ydElmcmFtZS5fdGltZXIgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF9UcmFuc3BvcnRJZnJhbWUuX3RpbWVyKTtcbiAgICB9XG4gICAgX1RyYW5zcG9ydElmcmFtZS5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2FwcGx5U3R5bGUoe1xuICAgICAgICB3aWR0aDogXCIxMHB4XCIsXG4gICAgICAgIGhlaWdodDogXCIxMHB4XCIsXG4gICAgICAgIGxlZnQ6IFwiLTEwMHB4XCIsXG4gICAgICAgIHRvcDogXCItMTAwcHhcIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgb3BhY2l0eTogXCIwXCIsXG4gICAgICAgIHpJbmRleDogXCIwXCIsXG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgICB9KTtcbiAgICB9LCAyMDApO1xuICB9XG4gIF9hcHBseVN0eWxlKHN0eWxlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKHN0eWxlcykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lmcmFtZSkge1xuICAgICAgICAgIHRoaXMuX2lmcmFtZS5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX3JlbmRlckVycm9yUGFnZShib2R5RWxlbWVudCwgb25DbG9zZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKGJvZHlFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGJvZHlFbGVtZW50LnBhcmVudEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oYm9keUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgbWFyZ2luOiBcIjBweFwiXG4gICAgfSk7XG4gICAgY29uc3QgYmFja2Ryb3BFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBPYmplY3QuYXNzaWduKGJhY2tkcm9wRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgIHpJbmRleDogXCItMVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMwMDBcIixcbiAgICAgIG9wYWNpdHk6IFwiMC42XCJcbiAgICB9KTtcbiAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVyRWxlbWVudC5zdHlsZSwge1xuICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzI5MkYzQ1wiLFxuICAgICAgd2lkdGg6IFwiNTIwcHhcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCI2cHhcIixcbiAgICAgIHBhZGRpbmc6IFwiNDBweFwiLFxuICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0pO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVycm9yTWVzc2FnZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlcnJvck1lc3NhZ2U7XG4gICAgT2JqZWN0LmFzc2lnbihlcnJvck1lc3NhZ2VFbGVtZW50LnN0eWxlLCB7XG4gICAgICBmb250U2l6ZTogXCIxNXB4XCIsXG4gICAgICBsaW5lSGVpZ2h0OiBcIjIwcHhcIixcbiAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgIG1hcmdpbkJvdHRvbTogXCI0MHB4XCIsXG4gICAgICBmb250RmFtaWx5OiBcIlJvYm90bywgc2Fucy1zZXJpZlwiXG4gICAgfSk7XG4gICAgY29uc3QgYnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uRWxlbWVudC50ZXh0Q29udGVudCA9IFwiT0tcIjtcbiAgICBidXR0b25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiBvbkNsb3NlKCkpO1xuICAgIE9iamVjdC5hc3NpZ24oYnV0dG9uRWxlbWVudC5zdHlsZSwge1xuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgZm9udFNpemU6IFwiMTVweFwiLFxuICAgICAgbGluZUhlaWdodDogXCI0OHB4XCIsXG4gICAgICBwYWRkaW5nOiBcIiAwIDQwcHhcIixcbiAgICAgIGNvbG9yOiBcIiNmZmZcIixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNUE4MUVBXCIsXG4gICAgICBvdXRsaW5lOiBcIm5vbmVcIixcbiAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgZm9udEZhbWlseTogXCJSb2JvdG8sIHNhbnMtc2VyaWZcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCI0cHhcIlxuICAgIH0pO1xuICAgIHdyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGVycm9yTWVzc2FnZUVsZW1lbnQpO1xuICAgIHdyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICAgIGJvZHlFbGVtZW50LmFwcGVuZENoaWxkKGJhY2tkcm9wRWxlbWVudCk7XG4gICAgYm9keUVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckVsZW1lbnQpO1xuICB9XG4gIF9saXN0ZW5GZXRjaFVSTEVycm9yKGlmcmFtZSkge1xuICAgIGZldGNoKHRoaXMuX3VybCkuY2F0Y2goKCkgPT4ge1xuICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCFpZnJhbWUuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlckVycm9yUGFnZShpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHksICgpID0+IHRoaXMuZHJvcENvbm5lY3Rpb24oKSwgXCJUaGUgcmVxdWVzdCBjb3VsZCBub3QgYmUgcHJvY2Vzc2VkLiBUbyByZXN1bWUgeW91ciBmdXJ0aGVyIHdvcmssIGRpc2FibGUgdGhlIGluc3RhbGxlZCBwbHVnaW5zLlwiKTtcbiAgICAgICAgdGhpcy5fc2hvd0lmcmFtZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5sZXQgVHJhbnNwb3J0SWZyYW1lID0gX1RyYW5zcG9ydElmcmFtZTtcblRyYW5zcG9ydElmcmFtZS5fdGltZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNCcmF2ZSgpIHtcbiAgdmFyIF9hO1xuICByZXR1cm4gISEoKF9hID0gbmF2aWdhdG9yLmJyYXZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaXNCcmF2ZSk7XG59XG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc1NhZmFyaVVBID0gdXNlckFnZW50LmluY2x1ZGVzKFwic2FmYXJpXCIpICYmICF1c2VyQWdlbnQuaW5jbHVkZXMoXCJjaHJvbWVcIik7XG4gIGNvbnN0IGlPUyA9IG5hdmlnYXRvci5wbGF0Zm9ybSAhPSBudWxsICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG4gIHJldHVybiBpT1MgfHwgaXNTYWZhcmlVQTtcbn1cbmNsYXNzIFByb3ZpZGVyV2ViIHtcbiAgY29uc3RydWN0b3IoY2xpZW50VXJsLCBsb2dzKSB7XG4gICAgdGhpcy51c2VyID0gbnVsbDtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5fY2xpZW50VXJsID0gKGNsaWVudFVybCB8fCBcImh0dHBzOi8vd2F2ZXMuZXhjaGFuZ2Uvc2lnbmVyL1wiKSArIGA/JHtQcm92aWRlcldlYi5fZ2V0Q2FjaGVDbGVhbigpfWA7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFRyYW5zcG9ydElmcmFtZSh0aGlzLl9jbGllbnRVcmwsIDMpO1xuICAgIGlmIChsb2dzID09PSB0cnVlKSB7XG4gICAgICBjb25maWcuY29uc29sZS5sb2dMZXZlbCA9IGNvbmZpZy5jb25zb2xlLkxPR19MRVZFTC5WRVJCT1NFO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2dldENhY2hlQ2xlYW4oKSB7XG4gICAgcmV0dXJuIFN0cmluZyhEYXRlLm5vdygpICUgKDFlMyAqIDYwKSk7XG4gIH1cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmVtaXR0ZXIub25jZShldmVudCwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNvbm5lY3Qob3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fdHJhbnNwb3J0LnNlbmRFdmVudCgoYnVzKSA9PiBidXMuZGlzcGF0Y2hFdmVudChcImNvbm5lY3RcIiwgb3B0aW9ucykpKTtcbiAgfVxuICBsb2dvdXQoKSB7XG4gICAgdGhpcy51c2VyID0gbnVsbDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3RyYW5zcG9ydC5kcm9wQ29ubmVjdGlvbigpKTtcbiAgfVxuICBsb2dpbigpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnVzZXIpO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSB0aGlzLl90cmFuc3BvcnQuZ2V0KCk7XG4gICAgaWYgKGlzU2FmYXJpKCkgfHwgaXNCcmF2ZSgpKSB7XG4gICAgICBjb25zdCB3aW4gPSAoX2EgPSBpZnJhbWUuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9wZW4odGhpcy5fY2xpZW50VXJsKTtcbiAgICAgIGlmICghd2luKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyB3YXMgYmxvY2tlZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWZyYW1lLnNyYyA9IHRoaXMuX2NsaWVudFVybDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRpYWxvZygoYnVzKSA9PiBidXMucmVxdWVzdChcImxvZ2luXCIpLnRoZW4oKHVzZXJEYXRhKSA9PiB7XG4gICAgICB0aGlzLnVzZXIgPSB1c2VyRGF0YTtcbiAgICAgIHJldHVybiB1c2VyRGF0YTtcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuZHJvcENvbm5lY3Rpb24oKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChjcmVhdGVFcnJvcihlcnIpKTtcbiAgICB9KSk7XG4gIH1cbiAgc2lnbk1lc3NhZ2UoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLmxvZ2luKCkudGhlbigoKSA9PiB0aGlzLl90cmFuc3BvcnQuZGlhbG9nKChidXMpID0+IGJ1cy5yZXF1ZXN0KFwic2lnbi1tZXNzYWdlXCIsIGRhdGEpKSk7XG4gIH1cbiAgc2lnblR5cGVkRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMubG9naW4oKS50aGVuKCgpID0+IHRoaXMuX3RyYW5zcG9ydC5kaWFsb2coKGJ1cykgPT4gYnVzLnJlcXVlc3QoXCJzaWduLXR5cGVkLWRhdGFcIiwgZGF0YSkpKTtcbiAgfVxuICBzaWduKHRvU2lnbikge1xuICAgIHJldHVybiB0aGlzLmxvZ2luKCkudGhlbigoKSA9PiB0aGlzLl90cmFuc3BvcnQuZGlhbG9nKChidXMpID0+IGJ1cy5yZXF1ZXN0KFwic2lnblwiLCB0b1NpZ24pKSk7XG4gIH1cbn1cbmV4cG9ydCB7IFByb3ZpZGVyV2ViIH07XG4iLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT90KGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSx0KTp0KChlPWV8fHNlbGYpLkJpZ051bWJlcj17fSl9KHRoaXMsZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9L14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksbj1NYXRoLmNlaWwscj1NYXRoLmZsb29yLGk9XCJbQmlnTnVtYmVyIEVycm9yXSBcIixvPWkrXCJOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiBcIix1PTFlMTQscz0xNCxmPTkwMDcxOTkyNTQ3NDA5OTEsYz1bMSwxMCwxMDAsMWUzLDFlNCwxZTUsMWU2LDFlNywxZTgsMWU5LDFlMTAsMWUxMSwxZTEyLDFlMTNdLGw9MWU3LGE9MWU5O2Z1bmN0aW9uIGgoZSl7dmFyIHQ9MHxlO3JldHVybiBlPjB8fGU9PT10P3Q6dC0xfWZ1bmN0aW9uIHAoZSl7Zm9yKHZhciB0LG4scj0xLGk9ZS5sZW5ndGgsbz1lWzBdK1wiXCI7cjxpOyl7Zm9yKHQ9ZVtyKytdK1wiXCIsbj1zLXQubGVuZ3RoO24tLTt0PVwiMFwiK3QpO28rPXR9Zm9yKGk9by5sZW5ndGg7NDg9PT1vLmNoYXJDb2RlQXQoLS1pKTspO3JldHVybiBvLnNsaWNlKDAsaSsxfHwxKX1mdW5jdGlvbiBnKGUsdCl7dmFyIG4scixpPWUuYyxvPXQuYyx1PWUucyxzPXQucyxmPWUuZSxjPXQuZTtpZighdXx8IXMpcmV0dXJuIG51bGw7aWYobj1pJiYhaVswXSxyPW8mJiFvWzBdLG58fHIpcmV0dXJuIG4/cj8wOi1zOnU7aWYodSE9cylyZXR1cm4gdTtpZihuPXU8MCxyPWY9PWMsIWl8fCFvKXJldHVybiByPzA6IWlebj8xOi0xO2lmKCFyKXJldHVybiBmPmNebj8xOi0xO2ZvcihzPShmPWkubGVuZ3RoKTwoYz1vLmxlbmd0aCk/ZjpjLHU9MDt1PHM7dSsrKWlmKGlbdV0hPW9bdV0pcmV0dXJuIGlbdV0+b1t1XV5uPzE6LTE7cmV0dXJuIGY9PWM/MDpmPmNebj8xOi0xfWZ1bmN0aW9uIG0oZSx0LG4sbyl7aWYoZTx0fHxlPm58fGUhPT1yKGUpKXRocm93IEVycm9yKGkrKG98fFwiQXJndW1lbnRcIikrKFwibnVtYmVyXCI9PXR5cGVvZiBlP2U8dHx8ZT5uP1wiIG91dCBvZiByYW5nZTogXCI6XCIgbm90IGFuIGludGVnZXI6IFwiOlwiIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6IFwiKStTdHJpbmcoZSkpfWZ1bmN0aW9uIE4oZSl7dmFyIHQ9ZS5jLmxlbmd0aC0xO3JldHVybiBoKGUuZS9zKT09dCYmZS5jW3RdJTIhPTB9ZnVuY3Rpb24gYihlLHQpe3JldHVybihlLmxlbmd0aD4xP2UuY2hhckF0KDApK1wiLlwiK2Uuc2xpY2UoMSk6ZSkrKHQ8MD9cImVcIjpcImUrXCIpK3R9ZnVuY3Rpb24gdyhlLHQsbil7dmFyIHIsaTtpZih0PDApe2ZvcihpPW4rXCIuXCI7Kyt0O2krPW4pO2U9aStlfWVsc2UgaWYoKyt0PihyPWUubGVuZ3RoKSl7Zm9yKGk9bix0LT1yOy0tdDtpKz1uKTtlKz1pfWVsc2UgdDxyJiYoZT1lLnNsaWNlKDAsdCkrXCIuXCIrZS5zbGljZSh0KSk7cmV0dXJuIGV9dmFyIGQ9ZnVuY3Rpb24gZShkKXt2YXIgeSxPLHYsRSxBLF8sVSxSLEQsTD1ILnByb3RvdHlwZT17Y29uc3RydWN0b3I6SCx0b1N0cmluZzpudWxsLHZhbHVlT2Y6bnVsbH0sQj1uZXcgSCgxKSxTPTIwLEY9NCxJPS03LE09MjEseD0tMWU3LFA9MWU3LFQ9ITEsQz0xLEc9MCxqPXtwcmVmaXg6XCJcIixncm91cFNpemU6MyxzZWNvbmRhcnlHcm91cFNpemU6MCxncm91cFNlcGFyYXRvcjpcIixcIixkZWNpbWFsU2VwYXJhdG9yOlwiLlwiLGZyYWN0aW9uR3JvdXBTaXplOjAsZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjpcIsKgXCIsc3VmZml4OlwiXCJ9LHE9XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtmdW5jdGlvbiBIKGUsbil7dmFyIGksdSxjLGwsYSxoLHAsZyxOPXRoaXM7aWYoIShOIGluc3RhbmNlb2YgSCkpcmV0dXJuIG5ldyBIKGUsbik7aWYobnVsbD09bil7aWYoZSYmITA9PT1lLl9pc0JpZ051bWJlcilyZXR1cm4gTi5zPWUucyx2b2lkKCFlLmN8fGUuZT5QP04uYz1OLmU9bnVsbDplLmU8eD9OLmM9W04uZT0wXTooTi5lPWUuZSxOLmM9ZS5jLnNsaWNlKCkpKTtpZigoaD1cIm51bWJlclwiPT10eXBlb2YgZSkmJjAqZT09MCl7aWYoTi5zPTEvZTwwPyhlPS1lLC0xKToxLGU9PT1+fmUpe2ZvcihsPTAsYT1lO2E+PTEwO2EvPTEwLGwrKyk7cmV0dXJuIHZvaWQobD5QP04uYz1OLmU9bnVsbDooTi5lPWwsTi5jPVtlXSkpfWc9U3RyaW5nKGUpfWVsc2V7aWYoIXQudGVzdChnPVN0cmluZyhlKSkpcmV0dXJuIHYoTixnLGgpO04ucz00NT09Zy5jaGFyQ29kZUF0KDApPyhnPWcuc2xpY2UoMSksLTEpOjF9KGw9Zy5pbmRleE9mKFwiLlwiKSk+LTEmJihnPWcucmVwbGFjZShcIi5cIixcIlwiKSksKGE9Zy5zZWFyY2goL2UvaSkpPjA/KGw8MCYmKGw9YSksbCs9K2cuc2xpY2UoYSsxKSxnPWcuc3Vic3RyaW5nKDAsYSkpOmw8MCYmKGw9Zy5sZW5ndGgpfWVsc2V7aWYobShuLDIscS5sZW5ndGgsXCJCYXNlXCIpLDEwPT1uKXJldHVybiB6KE49bmV3IEgoZSksUytOLmUrMSxGKTtpZihnPVN0cmluZyhlKSxoPVwibnVtYmVyXCI9PXR5cGVvZiBlKXtpZigwKmUhPTApcmV0dXJuIHYoTixnLGgsbik7aWYoTi5zPTEvZTwwPyhnPWcuc2xpY2UoMSksLTEpOjEsSC5ERUJVRyYmZy5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sXCJcIikubGVuZ3RoPjE1KXRocm93IEVycm9yKG8rZSl9ZWxzZSBOLnM9NDU9PT1nLmNoYXJDb2RlQXQoMCk/KGc9Zy5zbGljZSgxKSwtMSk6MTtmb3IoaT1xLnNsaWNlKDAsbiksbD1hPTAscD1nLmxlbmd0aDthPHA7YSsrKWlmKGkuaW5kZXhPZih1PWcuY2hhckF0KGEpKTwwKXtpZihcIi5cIj09dSl7aWYoYT5sKXtsPXA7Y29udGludWV9fWVsc2UgaWYoIWMmJihnPT1nLnRvVXBwZXJDYXNlKCkmJihnPWcudG9Mb3dlckNhc2UoKSl8fGc9PWcudG9Mb3dlckNhc2UoKSYmKGc9Zy50b1VwcGVyQ2FzZSgpKSkpe2M9ITAsYT0tMSxsPTA7Y29udGludWV9cmV0dXJuIHYoTixTdHJpbmcoZSksaCxuKX1oPSExLChsPShnPU8oZyxuLDEwLE4ucykpLmluZGV4T2YoXCIuXCIpKT4tMT9nPWcucmVwbGFjZShcIi5cIixcIlwiKTpsPWcubGVuZ3RofWZvcihhPTA7NDg9PT1nLmNoYXJDb2RlQXQoYSk7YSsrKTtmb3IocD1nLmxlbmd0aDs0OD09PWcuY2hhckNvZGVBdCgtLXApOyk7aWYoZz1nLnNsaWNlKGEsKytwKSl7aWYocC09YSxoJiZILkRFQlVHJiZwPjE1JiYoZT5mfHxlIT09cihlKSkpdGhyb3cgRXJyb3IobytOLnMqZSk7aWYoKGw9bC1hLTEpPlApTi5jPU4uZT1udWxsO2Vsc2UgaWYobDx4KU4uYz1bTi5lPTBdO2Vsc2V7aWYoTi5lPWwsTi5jPVtdLGE9KGwrMSklcyxsPDAmJihhKz1zKSxhPHApe2ZvcihhJiZOLmMucHVzaCgrZy5zbGljZSgwLGEpKSxwLT1zO2E8cDspTi5jLnB1c2goK2cuc2xpY2UoYSxhKz1zKSk7YT1zLShnPWcuc2xpY2UoYSkpLmxlbmd0aH1lbHNlIGEtPXA7Zm9yKDthLS07Zys9XCIwXCIpO04uYy5wdXNoKCtnKX19ZWxzZSBOLmM9W04uZT0wXX1mdW5jdGlvbiBWKGUsdCxuLHIpe3ZhciBpLG8sdSxzLGY7aWYobnVsbD09bj9uPUY6bShuLDAsOCksIWUuYylyZXR1cm4gZS50b1N0cmluZygpO2lmKGk9ZS5jWzBdLHU9ZS5lLG51bGw9PXQpZj1wKGUuYyksZj0xPT1yfHwyPT1yJiYodTw9SXx8dT49TSk/YihmLHUpOncoZix1LFwiMFwiKTtlbHNlIGlmKG89KGU9eihuZXcgSChlKSx0LG4pKS5lLHM9KGY9cChlLmMpKS5sZW5ndGgsMT09cnx8Mj09ciYmKHQ8PW98fG88PUkpKXtmb3IoO3M8dDtmKz1cIjBcIixzKyspO2Y9YihmLG8pfWVsc2UgaWYodC09dSxmPXcoZixvLFwiMFwiKSxvKzE+cyl7aWYoLS10PjApZm9yKGYrPVwiLlwiO3QtLTtmKz1cIjBcIik7fWVsc2UgaWYoKHQrPW8tcyk+MClmb3IobysxPT1zJiYoZis9XCIuXCIpO3QtLTtmKz1cIjBcIik7cmV0dXJuIGUuczwwJiZpP1wiLVwiK2Y6Zn1mdW5jdGlvbiBKKGUsdCl7Zm9yKHZhciBuLHI9MSxpPW5ldyBIKGVbMF0pO3I8ZS5sZW5ndGg7cisrKXtpZighKG49bmV3IEgoZVtyXSkpLnMpe2k9bjticmVha310LmNhbGwoaSxuKSYmKGk9bil9cmV0dXJuIGl9ZnVuY3Rpb24gayhlLHQsbil7Zm9yKHZhciByPTEsaT10Lmxlbmd0aDshdFstLWldO3QucG9wKCkpO2ZvcihpPXRbMF07aT49MTA7aS89MTAscisrKTtyZXR1cm4obj1yK24qcy0xKT5QP2UuYz1lLmU9bnVsbDpuPHg/ZS5jPVtlLmU9MF06KGUuZT1uLGUuYz10KSxlfWZ1bmN0aW9uIHooZSx0LGksbyl7dmFyIGYsbCxhLGgscCxnLG0sTj1lLmMsYj1jO2lmKE4pe2U6e2ZvcihmPTEsaD1OWzBdO2g+PTEwO2gvPTEwLGYrKyk7aWYoKGw9dC1mKTwwKWwrPXMsYT10LG09KHA9TltnPTBdKS9iW2YtYS0xXSUxMHwwO2Vsc2UgaWYoKGc9bigobCsxKS9zKSk+PU4ubGVuZ3RoKXtpZighbylicmVhayBlO2Zvcig7Ti5sZW5ndGg8PWc7Ti5wdXNoKDApKTtwPW09MCxmPTEsYT0obCU9cyktcysxfWVsc2V7Zm9yKHA9aD1OW2ddLGY9MTtoPj0xMDtoLz0xMCxmKyspO209KGE9KGwlPXMpLXMrZik8MD8wOnAvYltmLWEtMV0lMTB8MH1pZihvPW98fHQ8MHx8bnVsbCE9TltnKzFdfHwoYTwwP3A6cCViW2YtYS0xXSksbz1pPDQ/KG18fG8pJiYoMD09aXx8aT09KGUuczwwPzM6MikpOm0+NXx8NT09bSYmKDQ9PWl8fG98fDY9PWkmJihsPjA/YT4wP3AvYltmLWFdOjA6TltnLTFdKSUxMCYxfHxpPT0oZS5zPDA/ODo3KSksdDwxfHwhTlswXSlyZXR1cm4gTi5sZW5ndGg9MCxvPyh0LT1lLmUrMSxOWzBdPWJbKHMtdCVzKSVzXSxlLmU9LXR8fDApOk5bMF09ZS5lPTAsZTtpZigwPT1sPyhOLmxlbmd0aD1nLGg9MSxnLS0pOihOLmxlbmd0aD1nKzEsaD1iW3MtbF0sTltnXT1hPjA/cihwL2JbZi1hXSViW2FdKSpoOjApLG8pZm9yKDs7KXtpZigwPT1nKXtmb3IobD0xLGE9TlswXTthPj0xMDthLz0xMCxsKyspO2ZvcihhPU5bMF0rPWgsaD0xO2E+PTEwO2EvPTEwLGgrKyk7bCE9aCYmKGUuZSsrLE5bMF09PXUmJihOWzBdPTEpKTticmVha31pZihOW2ddKz1oLE5bZ10hPXUpYnJlYWs7TltnLS1dPTAsaD0xfWZvcihsPU4ubGVuZ3RoOzA9PT1OWy0tbF07Ti5wb3AoKSk7fWUuZT5QP2UuYz1lLmU9bnVsbDplLmU8eCYmKGUuYz1bZS5lPTBdKX1yZXR1cm4gZX1mdW5jdGlvbiAkKGUpe3ZhciB0LG49ZS5lO3JldHVybiBudWxsPT09bj9lLnRvU3RyaW5nKCk6KHQ9cChlLmMpLHQ9bjw9SXx8bj49TT9iKHQsbik6dyh0LG4sXCIwXCIpLGUuczwwP1wiLVwiK3Q6dCl9cmV0dXJuIEguY2xvbmU9ZSxILlJPVU5EX1VQPTAsSC5ST1VORF9ET1dOPTEsSC5ST1VORF9DRUlMPTIsSC5ST1VORF9GTE9PUj0zLEguUk9VTkRfSEFMRl9VUD00LEguUk9VTkRfSEFMRl9ET1dOPTUsSC5ST1VORF9IQUxGX0VWRU49NixILlJPVU5EX0hBTEZfQ0VJTD03LEguUk9VTkRfSEFMRl9GTE9PUj04LEguRVVDTElEPTksSC5jb25maWc9SC5zZXQ9ZnVuY3Rpb24oZSl7dmFyIHQsbjtpZihudWxsIT1lKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBFcnJvcihpK1wiT2JqZWN0IGV4cGVjdGVkOiBcIitlKTtpZihlLmhhc093blByb3BlcnR5KHQ9XCJERUNJTUFMX1BMQUNFU1wiKSYmKG0obj1lW3RdLDAsYSx0KSxTPW4pLGUuaGFzT3duUHJvcGVydHkodD1cIlJPVU5ESU5HX01PREVcIikmJihtKG49ZVt0XSwwLDgsdCksRj1uKSxlLmhhc093blByb3BlcnR5KHQ9XCJFWFBPTkVOVElBTF9BVFwiKSYmKChuPWVbdF0pJiZuLnBvcD8obShuWzBdLC1hLDAsdCksbShuWzFdLDAsYSx0KSxJPW5bMF0sTT1uWzFdKToobShuLC1hLGEsdCksST0tKE09bjwwPy1uOm4pKSksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiUkFOR0VcIikpaWYoKG49ZVt0XSkmJm4ucG9wKW0oblswXSwtYSwtMSx0KSxtKG5bMV0sMSxhLHQpLHg9blswXSxQPW5bMV07ZWxzZXtpZihtKG4sLWEsYSx0KSwhbil0aHJvdyBFcnJvcihpK3QrXCIgY2Fubm90IGJlIHplcm86IFwiK24pO3g9LShQPW48MD8tbjpuKX1pZihlLmhhc093blByb3BlcnR5KHQ9XCJDUllQVE9cIikpe2lmKChuPWVbdF0pIT09ISFuKXRocm93IEVycm9yKGkrdCtcIiBub3QgdHJ1ZSBvciBmYWxzZTogXCIrbik7aWYobil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNyeXB0b3x8IWNyeXB0b3x8IWNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJiFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgVD0hbixFcnJvcihpK1wiY3J5cHRvIHVuYXZhaWxhYmxlXCIpO1Q9bn1lbHNlIFQ9bn1pZihlLmhhc093blByb3BlcnR5KHQ9XCJNT0RVTE9fTU9ERVwiKSYmKG0obj1lW3RdLDAsOSx0KSxDPW4pLGUuaGFzT3duUHJvcGVydHkodD1cIlBPV19QUkVDSVNJT05cIikmJihtKG49ZVt0XSwwLGEsdCksRz1uKSxlLmhhc093blByb3BlcnR5KHQ9XCJGT1JNQVRcIikpe2lmKFwib2JqZWN0XCIhPXR5cGVvZihuPWVbdF0pKXRocm93IEVycm9yKGkrdCtcIiBub3QgYW4gb2JqZWN0OiBcIituKTtqPW59aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiQUxQSEFCRVRcIikpe2lmKFwic3RyaW5nXCIhPXR5cGVvZihuPWVbdF0pfHwvXi4kfFsrLS5cXHNdfCguKS4qXFwxLy50ZXN0KG4pKXRocm93IEVycm9yKGkrdCtcIiBpbnZhbGlkOiBcIituKTtxPW59fXJldHVybntERUNJTUFMX1BMQUNFUzpTLFJPVU5ESU5HX01PREU6RixFWFBPTkVOVElBTF9BVDpbSSxNXSxSQU5HRTpbeCxQXSxDUllQVE86VCxNT0RVTE9fTU9ERTpDLFBPV19QUkVDSVNJT046RyxGT1JNQVQ6aixBTFBIQUJFVDpxfX0sSC5pc0JpZ051bWJlcj1mdW5jdGlvbihlKXtpZighZXx8ITAhPT1lLl9pc0JpZ051bWJlcilyZXR1cm4hMTtpZighSC5ERUJVRylyZXR1cm4hMDt2YXIgdCxuLG89ZS5jLGY9ZS5lLGM9ZS5zO2U6aWYoXCJbb2JqZWN0IEFycmF5XVwiPT17fS50b1N0cmluZy5jYWxsKG8pKXtpZigoMT09PWN8fC0xPT09YykmJmY+PS1hJiZmPD1hJiZmPT09cihmKSl7aWYoMD09PW9bMF0pe2lmKDA9PT1mJiYxPT09by5sZW5ndGgpcmV0dXJuITA7YnJlYWsgZX1pZigodD0oZisxKSVzKTwxJiYodCs9cyksU3RyaW5nKG9bMF0pLmxlbmd0aD09dCl7Zm9yKHQ9MDt0PG8ubGVuZ3RoO3QrKylpZigobj1vW3RdKTwwfHxuPj11fHxuIT09cihuKSlicmVhayBlO2lmKDAhPT1uKXJldHVybiEwfX19ZWxzZSBpZihudWxsPT09byYmbnVsbD09PWYmJihudWxsPT09Y3x8MT09PWN8fC0xPT09YykpcmV0dXJuITA7dGhyb3cgRXJyb3IoaStcIkludmFsaWQgQmlnTnVtYmVyOiBcIitlKX0sSC5tYXhpbXVtPUgubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIEooYXJndW1lbnRzLEwubHQpfSxILm1pbmltdW09SC5taW49ZnVuY3Rpb24oKXtyZXR1cm4gSihhcmd1bWVudHMsTC5ndCl9LEgucmFuZG9tPShFPTkwMDcxOTkyNTQ3NDA5OTIqTWF0aC5yYW5kb20oKSYyMDk3MTUxP2Z1bmN0aW9uKCl7cmV0dXJuIHIoOTAwNzE5OTI1NDc0MDk5MipNYXRoLnJhbmRvbSgpKX06ZnVuY3Rpb24oKXtyZXR1cm4gODM4ODYwOCooMTA3Mzc0MTgyNCpNYXRoLnJhbmRvbSgpfDApKyg4Mzg4NjA4Kk1hdGgucmFuZG9tKCl8MCl9LGZ1bmN0aW9uKGUpe3ZhciB0LG8sdSxmLGwsaD0wLHA9W10sZz1uZXcgSChCKTtpZihudWxsPT1lP2U9UzptKGUsMCxhKSxmPW4oZS9zKSxUKWlmKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpe2Zvcih0PWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGYqPTIpKTtoPGY7KShsPTEzMTA3Mip0W2hdKyh0W2grMV0+Pj4xMSkpPj05ZTE1PyhvPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKSx0W2hdPW9bMF0sdFtoKzFdPW9bMV0pOihwLnB1c2gobCUxZTE0KSxoKz0yKTtoPWYvMn1lbHNle2lmKCFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgVD0hMSxFcnJvcihpK1wiY3J5cHRvIHVuYXZhaWxhYmxlXCIpO2Zvcih0PWNyeXB0by5yYW5kb21CeXRlcyhmKj03KTtoPGY7KShsPTI4MTQ3NDk3NjcxMDY1NiooMzEmdFtoXSkrMTA5OTUxMTYyNzc3Nip0W2grMV0rNDI5NDk2NzI5Nip0W2grMl0rMTY3NzcyMTYqdFtoKzNdKyh0W2grNF08PDE2KSsodFtoKzVdPDw4KSt0W2grNl0pPj05ZTE1P2NyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KHQsaCk6KHAucHVzaChsJTFlMTQpLGgrPTcpO2g9Zi83fWlmKCFUKWZvcig7aDxmOykobD1FKCkpPDllMTUmJihwW2grK109bCUxZTE0KTtmb3IoZj1wWy0taF0sZSU9cyxmJiZlJiYobD1jW3MtZV0scFtoXT1yKGYvbCkqbCk7MD09PXBbaF07cC5wb3AoKSxoLS0pO2lmKGg8MClwPVt1PTBdO2Vsc2V7Zm9yKHU9LTE7MD09PXBbMF07cC5zcGxpY2UoMCwxKSx1LT1zKTtmb3IoaD0xLGw9cFswXTtsPj0xMDtsLz0xMCxoKyspO2g8cyYmKHUtPXMtaCl9cmV0dXJuIGcuZT11LGcuYz1wLGd9KSxILnN1bT1mdW5jdGlvbigpe2Zvcih2YXIgZT0xLHQ9YXJndW1lbnRzLG49bmV3IEgodFswXSk7ZTx0Lmxlbmd0aDspbj1uLnBsdXModFtlKytdKTtyZXR1cm4gbn0sTz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0LG4scil7Zm9yKHZhciBpLG8sdT1bMF0scz0wLGY9ZS5sZW5ndGg7czxmOyl7Zm9yKG89dS5sZW5ndGg7by0tO3Vbb10qPXQpO2Zvcih1WzBdKz1yLmluZGV4T2YoZS5jaGFyQXQocysrKSksaT0wO2k8dS5sZW5ndGg7aSsrKXVbaV0+bi0xJiYobnVsbD09dVtpKzFdJiYodVtpKzFdPTApLHVbaSsxXSs9dVtpXS9ufDAsdVtpXSU9bil9cmV0dXJuIHUucmV2ZXJzZSgpfXJldHVybiBmdW5jdGlvbih0LG4scixpLG8pe3ZhciB1LHMsZixjLGwsYSxoLGcsbT10LmluZGV4T2YoXCIuXCIpLE49UyxiPUY7Zm9yKG0+PTAmJihjPUcsRz0wLHQ9dC5yZXBsYWNlKFwiLlwiLFwiXCIpLGE9KGc9bmV3IEgobikpLnBvdyh0Lmxlbmd0aC1tKSxHPWMsZy5jPWUodyhwKGEuYyksYS5lLFwiMFwiKSwxMCxyLFwiMDEyMzQ1Njc4OVwiKSxnLmU9Zy5jLmxlbmd0aCksZj1jPShoPWUodCxuLHIsbz8odT1xLFwiMDEyMzQ1Njc4OVwiKToodT1cIjAxMjM0NTY3ODlcIixxKSkpLmxlbmd0aDswPT1oWy0tY107aC5wb3AoKSk7aWYoIWhbMF0pcmV0dXJuIHUuY2hhckF0KDApO2lmKG08MD8tLWY6KGEuYz1oLGEuZT1mLGEucz1pLGg9KGE9eShhLGcsTixiLHIpKS5jLGw9YS5yLGY9YS5lKSxtPWhbcz1mK04rMV0sYz1yLzIsbD1sfHxzPDB8fG51bGwhPWhbcysxXSxsPWI8ND8obnVsbCE9bXx8bCkmJigwPT1ifHxiPT0oYS5zPDA/MzoyKSk6bT5jfHxtPT1jJiYoND09Ynx8bHx8Nj09YiYmMSZoW3MtMV18fGI9PShhLnM8MD84OjcpKSxzPDF8fCFoWzBdKXQ9bD93KHUuY2hhckF0KDEpLC1OLHUuY2hhckF0KDApKTp1LmNoYXJBdCgwKTtlbHNle2lmKGgubGVuZ3RoPXMsbClmb3IoLS1yOysraFstLXNdPnI7KWhbc109MCxzfHwoKytmLGg9WzFdLmNvbmNhdChoKSk7Zm9yKGM9aC5sZW5ndGg7IWhbLS1jXTspO2ZvcihtPTAsdD1cIlwiO208PWM7dCs9dS5jaGFyQXQoaFttKytdKSk7dD13KHQsZix1LmNoYXJBdCgwKSl9cmV0dXJuIHR9fSgpLHk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxuKXt2YXIgcixpLG8sdSxzPTAsZj1lLmxlbmd0aCxjPXQlbCxhPXQvbHwwO2ZvcihlPWUuc2xpY2UoKTtmLS07KXM9KChpPWMqKG89ZVtmXSVsKSsocj1hKm8rKHU9ZVtmXS9sfDApKmMpJWwqbCtzKS9ufDApKyhyL2x8MCkrYSp1LGVbZl09aSVuO3JldHVybiBzJiYoZT1bc10uY29uY2F0KGUpKSxlfWZ1bmN0aW9uIHQoZSx0LG4scil7dmFyIGksbztpZihuIT1yKW89bj5yPzE6LTE7ZWxzZSBmb3IoaT1vPTA7aTxuO2krKylpZihlW2ldIT10W2ldKXtvPWVbaV0+dFtpXT8xOi0xO2JyZWFrfXJldHVybiBvfWZ1bmN0aW9uIG4oZSx0LG4scil7Zm9yKHZhciBpPTA7bi0tOyllW25dLT1pLGk9ZVtuXTx0W25dPzE6MCxlW25dPWkqcitlW25dLXRbbl07Zm9yKDshZVswXSYmZS5sZW5ndGg+MTtlLnNwbGljZSgwLDEpKTt9cmV0dXJuIGZ1bmN0aW9uKGksbyxmLGMsbCl7dmFyIGEscCxnLG0sTixiLHcsZCx5LE8sdixFLEEsXyxVLFIsRCxMPWkucz09by5zPzE6LTEsQj1pLmMsUz1vLmM7aWYoIShCJiZCWzBdJiZTJiZTWzBdKSlyZXR1cm4gbmV3IEgoaS5zJiZvLnMmJihCPyFTfHxCWzBdIT1TWzBdOlMpP0ImJjA9PUJbMF18fCFTPzAqTDpMLzA6TmFOKTtmb3IoeT0oZD1uZXcgSChMKSkuYz1bXSxMPWYrKHA9aS5lLW8uZSkrMSxsfHwobD11LHA9aChpLmUvcyktaChvLmUvcyksTD1ML3N8MCksZz0wO1NbZ109PShCW2ddfHwwKTtnKyspO2lmKFNbZ10+KEJbZ118fDApJiZwLS0sTDwwKXkucHVzaCgxKSxtPSEwO2Vsc2V7Zm9yKF89Qi5sZW5ndGgsUj1TLmxlbmd0aCxnPTAsTCs9MiwoTj1yKGwvKFNbMF0rMSkpKT4xJiYoUz1lKFMsTixsKSxCPWUoQixOLGwpLFI9Uy5sZW5ndGgsXz1CLmxlbmd0aCksQT1SLHY9KE89Qi5zbGljZSgwLFIpKS5sZW5ndGg7djxSO09bdisrXT0wKTtEPVMuc2xpY2UoKSxEPVswXS5jb25jYXQoRCksVT1TWzBdLFNbMV0+PWwvMiYmVSsrO2Rve2lmKE49MCwoYT10KFMsTyxSLHYpKTwwKXtpZihFPU9bMF0sUiE9diYmKEU9RSpsKyhPWzFdfHwwKSksKE49cihFL1UpKT4xKWZvcihOPj1sJiYoTj1sLTEpLHc9KGI9ZShTLE4sbCkpLmxlbmd0aCx2PU8ubGVuZ3RoOzE9PXQoYixPLHcsdik7KU4tLSxuKGIsUjx3P0Q6Uyx3LGwpLHc9Yi5sZW5ndGgsYT0xO2Vsc2UgMD09TiYmKGE9Tj0xKSx3PShiPVMuc2xpY2UoKSkubGVuZ3RoO2lmKHc8diYmKGI9WzBdLmNvbmNhdChiKSksbihPLGIsdixsKSx2PU8ubGVuZ3RoLC0xPT1hKWZvcig7dChTLE8sUix2KTwxOylOKyssbihPLFI8dj9EOlMsdixsKSx2PU8ubGVuZ3RofWVsc2UgMD09PWEmJihOKyssTz1bMF0pO3lbZysrXT1OLE9bMF0/T1t2KytdPUJbQV18fDA6KE89W0JbQV1dLHY9MSl9d2hpbGUoKEErKzxffHxudWxsIT1PWzBdKSYmTC0tKTttPW51bGwhPU9bMF0seVswXXx8eS5zcGxpY2UoMCwxKX1pZihsPT11KXtmb3IoZz0xLEw9eVswXTtMPj0xMDtMLz0xMCxnKyspO3ooZCxmKyhkLmU9ZytwKnMtMSkrMSxjLG0pfWVsc2UgZC5lPXAsZC5yPSttO3JldHVybiBkfX0oKSxBPS9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXz0vXihbXi5dKylcXC4kLyxVPS9eXFwuKFteLl0rKSQvLFI9L14tPyhJbmZpbml0eXxOYU4pJC8sRD0vXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2csdj1mdW5jdGlvbihlLHQsbixyKXt2YXIgbyx1PW4/dDp0LnJlcGxhY2UoRCxcIlwiKTtpZihSLnRlc3QodSkpZS5zPWlzTmFOKHUpP251bGw6dTwwPy0xOjE7ZWxzZXtpZighbiYmKHU9dS5yZXBsYWNlKEEsZnVuY3Rpb24oZSx0LG4pe3JldHVybiBvPVwieFwiPT0obj1uLnRvTG93ZXJDYXNlKCkpPzE2OlwiYlwiPT1uPzI6OCxyJiZyIT1vP2U6dH0pLHImJihvPXIsdT11LnJlcGxhY2UoXyxcIiQxXCIpLnJlcGxhY2UoVSxcIjAuJDFcIikpLHQhPXUpKXJldHVybiBuZXcgSCh1LG8pO2lmKEguREVCVUcpdGhyb3cgRXJyb3IoaStcIk5vdCBhXCIrKHI/XCIgYmFzZSBcIityOlwiXCIpK1wiIG51bWJlcjogXCIrdCk7ZS5zPW51bGx9ZS5jPWUuZT1udWxsfSxMLmFic29sdXRlVmFsdWU9TC5hYnM9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgSCh0aGlzKTtyZXR1cm4gZS5zPDAmJihlLnM9MSksZX0sTC5jb21wYXJlZFRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGcodGhpcyxuZXcgSChlLHQpKX0sTC5kZWNpbWFsUGxhY2VzPUwuZHA9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbz10aGlzO2lmKG51bGwhPWUpcmV0dXJuIG0oZSwwLGEpLG51bGw9PXQ/dD1GOm0odCwwLDgpLHoobmV3IEgobyksZStvLmUrMSx0KTtpZighKG49by5jKSlyZXR1cm4gbnVsbDtpZihyPSgoaT1uLmxlbmd0aC0xKS1oKHRoaXMuZS9zKSkqcyxpPW5baV0pZm9yKDtpJTEwPT0wO2kvPTEwLHItLSk7cmV0dXJuIHI8MCYmKHI9MCkscn0sTC5kaXZpZGVkQnk9TC5kaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4geSh0aGlzLG5ldyBIKGUsdCksUyxGKX0sTC5kaXZpZGVkVG9JbnRlZ2VyQnk9TC5pZGl2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHkodGhpcyxuZXcgSChlLHQpLDAsMSl9LEwuZXhwb25lbnRpYXRlZEJ5PUwucG93PWZ1bmN0aW9uKGUsdCl7dmFyIG8sdSxmLGMsbCxhLGgscCxnPXRoaXM7aWYoKGU9bmV3IEgoZSkpLmMmJiFlLmlzSW50ZWdlcigpKXRocm93IEVycm9yKGkrXCJFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogXCIrJChlKSk7aWYobnVsbCE9dCYmKHQ9bmV3IEgodCkpLGw9ZS5lPjE0LCFnLmN8fCFnLmNbMF18fDE9PWcuY1swXSYmIWcuZSYmMT09Zy5jLmxlbmd0aHx8IWUuY3x8IWUuY1swXSlyZXR1cm4gcD1uZXcgSChNYXRoLnBvdygrJChnKSxsPzItTihlKTorJChlKSkpLHQ/cC5tb2QodCk6cDtpZihhPWUuczwwLHQpe2lmKHQuYz8hdC5jWzBdOiF0LnMpcmV0dXJuIG5ldyBIKE5hTik7KHU9IWEmJmcuaXNJbnRlZ2VyKCkmJnQuaXNJbnRlZ2VyKCkpJiYoZz1nLm1vZCh0KSl9ZWxzZXtpZihlLmU+OSYmKGcuZT4wfHxnLmU8LTF8fCgwPT1nLmU/Zy5jWzBdPjF8fGwmJmcuY1sxXT49MjRlNzpnLmNbMF08OGUxM3x8bCYmZy5jWzBdPD05OTk5OTc1ZTcpKSlyZXR1cm4gYz1nLnM8MCYmTihlKT8tMDowLGcuZT4tMSYmKGM9MS9jKSxuZXcgSChhPzEvYzpjKTtHJiYoYz1uKEcvcysyKSl9Zm9yKGw/KG89bmV3IEgoLjUpLGEmJihlLnM9MSksaD1OKGUpKTpoPShmPU1hdGguYWJzKCskKGUpKSklMixwPW5ldyBIKEIpOzspe2lmKGgpe2lmKCEocD1wLnRpbWVzKGcpKS5jKWJyZWFrO2M/cC5jLmxlbmd0aD5jJiYocC5jLmxlbmd0aD1jKTp1JiYocD1wLm1vZCh0KSl9aWYoZil7aWYoMD09PShmPXIoZi8yKSkpYnJlYWs7aD1mJTJ9ZWxzZSBpZih6KGU9ZS50aW1lcyhvKSxlLmUrMSwxKSxlLmU+MTQpaD1OKGUpO2Vsc2V7aWYoMD09KGY9KyQoZSkpKWJyZWFrO2g9ZiUyfWc9Zy50aW1lcyhnKSxjP2cuYyYmZy5jLmxlbmd0aD5jJiYoZy5jLmxlbmd0aD1jKTp1JiYoZz1nLm1vZCh0KSl9cmV0dXJuIHU/cDooYSYmKHA9Qi5kaXYocCkpLHQ/cC5tb2QodCk6Yz96KHAsRyxGLHZvaWQgMCk6cCl9LEwuaW50ZWdlclZhbHVlPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBIKHRoaXMpO3JldHVybiBudWxsPT1lP2U9RjptKGUsMCw4KSx6KHQsdC5lKzEsZSl9LEwuaXNFcXVhbFRvPUwuZXE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PWcodGhpcyxuZXcgSChlLHQpKX0sTC5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jfSxMLmlzR3JlYXRlclRoYW49TC5ndD1mdW5jdGlvbihlLHQpe3JldHVybiBnKHRoaXMsbmV3IEgoZSx0KSk+MH0sTC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvPUwuZ3RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT0odD1nKHRoaXMsbmV3IEgoZSx0KSkpfHwwPT09dH0sTC5pc0ludGVnZXI9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmaCh0aGlzLmUvcyk+dGhpcy5jLmxlbmd0aC0yfSxMLmlzTGVzc1RoYW49TC5sdD1mdW5jdGlvbihlLHQpe3JldHVybiBnKHRoaXMsbmV3IEgoZSx0KSk8MH0sTC5pc0xlc3NUaGFuT3JFcXVhbFRvPUwubHRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT0odD1nKHRoaXMsbmV3IEgoZSx0KSkpfHwwPT09dH0sTC5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LEwuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MH0sTC5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucz4wfSxMLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiYwPT10aGlzLmNbMF19LEwubWludXM9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbyxmPXRoaXMsYz1mLnM7aWYodD0oZT1uZXcgSChlLHQpKS5zLCFjfHwhdClyZXR1cm4gbmV3IEgoTmFOKTtpZihjIT10KXJldHVybiBlLnM9LXQsZi5wbHVzKGUpO3ZhciBsPWYuZS9zLGE9ZS5lL3MscD1mLmMsZz1lLmM7aWYoIWx8fCFhKXtpZighcHx8IWcpcmV0dXJuIHA/KGUucz0tdCxlKTpuZXcgSChnP2Y6TmFOKTtpZighcFswXXx8IWdbMF0pcmV0dXJuIGdbMF0/KGUucz0tdCxlKTpuZXcgSChwWzBdP2Y6Mz09Rj8tMDowKX1pZihsPWgobCksYT1oKGEpLHA9cC5zbGljZSgpLGM9bC1hKXtmb3IoKG89YzwwKT8oYz0tYyxpPXApOihhPWwsaT1nKSxpLnJldmVyc2UoKSx0PWM7dC0tO2kucHVzaCgwKSk7aS5yZXZlcnNlKCl9ZWxzZSBmb3Iocj0obz0oYz1wLmxlbmd0aCk8KHQ9Zy5sZW5ndGgpKT9jOnQsYz10PTA7dDxyO3QrKylpZihwW3RdIT1nW3RdKXtvPXBbdF08Z1t0XTticmVha31pZihvJiYoaT1wLHA9ZyxnPWksZS5zPS1lLnMpLCh0PShyPWcubGVuZ3RoKS0obj1wLmxlbmd0aCkpPjApZm9yKDt0LS07cFtuKytdPTApO2Zvcih0PXUtMTtyPmM7KXtpZihwWy0tcl08Z1tyXSl7Zm9yKG49cjtuJiYhcFstLW5dO3Bbbl09dCk7LS1wW25dLHBbcl0rPXV9cFtyXS09Z1tyXX1mb3IoOzA9PXBbMF07cC5zcGxpY2UoMCwxKSwtLWEpO3JldHVybiBwWzBdP2soZSxwLGEpOihlLnM9Mz09Rj8tMToxLGUuYz1bZS5lPTBdLGUpfSxMLm1vZHVsbz1MLm1vZD1mdW5jdGlvbihlLHQpe3ZhciBuLHIsaT10aGlzO3JldHVybiBlPW5ldyBIKGUsdCksIWkuY3x8IWUuc3x8ZS5jJiYhZS5jWzBdP25ldyBIKE5hTik6IWUuY3x8aS5jJiYhaS5jWzBdP25ldyBIKGkpOig5PT1DPyhyPWUucyxlLnM9MSxuPXkoaSxlLDAsMyksZS5zPXIsbi5zKj1yKTpuPXkoaSxlLDAsQyksKGU9aS5taW51cyhuLnRpbWVzKGUpKSkuY1swXXx8MSE9Q3x8KGUucz1pLnMpLGUpfSxMLm11bHRpcGxpZWRCeT1MLnRpbWVzPWZ1bmN0aW9uKGUsdCl7dmFyIG4scixpLG8sZixjLGEscCxnLG0sTixiLHcsZCx5LE89dGhpcyx2PU8uYyxFPShlPW5ldyBIKGUsdCkpLmM7aWYoISh2JiZFJiZ2WzBdJiZFWzBdKSlyZXR1cm4hTy5zfHwhZS5zfHx2JiYhdlswXSYmIUV8fEUmJiFFWzBdJiYhdj9lLmM9ZS5lPWUucz1udWxsOihlLnMqPU8ucyx2JiZFPyhlLmM9WzBdLGUuZT0wKTplLmM9ZS5lPW51bGwpLGU7Zm9yKHI9aChPLmUvcykraChlLmUvcyksZS5zKj1PLnMsKGE9di5sZW5ndGgpPChtPUUubGVuZ3RoKSYmKHc9dix2PUUsRT13LGk9YSxhPW0sbT1pKSxpPWErbSx3PVtdO2ktLTt3LnB1c2goMCkpO2ZvcihkPXUseT1sLGk9bTstLWk+PTA7KXtmb3Iobj0wLE49RVtpXSV5LGI9RVtpXS95fDAsbz1pKyhmPWEpO28+aTspbj0oKHA9TioocD12Wy0tZl0leSkrKGM9YipwKyhnPXZbZl0veXwwKSpOKSV5Knkrd1tvXStuKS9kfDApKyhjL3l8MCkrYipnLHdbby0tXT1wJWQ7d1tvXT1ufXJldHVybiBuPysrcjp3LnNwbGljZSgwLDEpLGsoZSx3LHIpfSxMLm5lZ2F0ZWQ9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgSCh0aGlzKTtyZXR1cm4gZS5zPS1lLnN8fG51bGwsZX0sTC5wbHVzPWZ1bmN0aW9uKGUsdCl7dmFyIG4scj10aGlzLGk9ci5zO2lmKHQ9KGU9bmV3IEgoZSx0KSkucywhaXx8IXQpcmV0dXJuIG5ldyBIKE5hTik7aWYoaSE9dClyZXR1cm4gZS5zPS10LHIubWludXMoZSk7dmFyIG89ci5lL3MsZj1lLmUvcyxjPXIuYyxsPWUuYztpZighb3x8IWYpe2lmKCFjfHwhbClyZXR1cm4gbmV3IEgoaS8wKTtpZighY1swXXx8IWxbMF0pcmV0dXJuIGxbMF0/ZTpuZXcgSChjWzBdP3I6MCppKX1pZihvPWgobyksZj1oKGYpLGM9Yy5zbGljZSgpLGk9by1mKXtmb3IoaT4wPyhmPW8sbj1sKTooaT0taSxuPWMpLG4ucmV2ZXJzZSgpO2ktLTtuLnB1c2goMCkpO24ucmV2ZXJzZSgpfWZvcigoaT1jLmxlbmd0aCktKHQ9bC5sZW5ndGgpPDAmJihuPWwsbD1jLGM9bix0PWkpLGk9MDt0OylpPShjWy0tdF09Y1t0XStsW3RdK2kpL3V8MCxjW3RdPXU9PT1jW3RdPzA6Y1t0XSV1O3JldHVybiBpJiYoYz1baV0uY29uY2F0KGMpLCsrZiksayhlLGMsZil9LEwucHJlY2lzaW9uPUwuc2Q9ZnVuY3Rpb24oZSx0KXt2YXIgbixyLGksbz10aGlzO2lmKG51bGwhPWUmJmUhPT0hIWUpcmV0dXJuIG0oZSwxLGEpLG51bGw9PXQ/dD1GOm0odCwwLDgpLHoobmV3IEgobyksZSx0KTtpZighKG49by5jKSlyZXR1cm4gbnVsbDtpZihyPShpPW4ubGVuZ3RoLTEpKnMrMSxpPW5baV0pe2Zvcig7aSUxMD09MDtpLz0xMCxyLS0pO2ZvcihpPW5bMF07aT49MTA7aS89MTAscisrKTt9cmV0dXJuIGUmJm8uZSsxPnImJihyPW8uZSsxKSxyfSxMLnNoaWZ0ZWRCeT1mdW5jdGlvbihlKXtyZXR1cm4gbShlLC1mLGYpLHRoaXMudGltZXMoXCIxZVwiK2UpfSxMLnNxdWFyZVJvb3Q9TC5zcXJ0PWZ1bmN0aW9uKCl7dmFyIGUsdCxuLHIsaSxvPXRoaXMsdT1vLmMscz1vLnMsZj1vLmUsYz1TKzQsbD1uZXcgSChcIjAuNVwiKTtpZigxIT09c3x8IXV8fCF1WzBdKXJldHVybiBuZXcgSCghc3x8czwwJiYoIXV8fHVbMF0pP05hTjp1P286MS8wKTtpZigwPT0ocz1NYXRoLnNxcnQoKyQobykpKXx8cz09MS8wPygoKHQ9cCh1KSkubGVuZ3RoK2YpJTI9PTAmJih0Kz1cIjBcIikscz1NYXRoLnNxcnQoK3QpLGY9aCgoZisxKS8yKS0oZjwwfHxmJTIpLG49bmV3IEgodD1zPT0xLzA/XCI1ZVwiK2Y6KHQ9cy50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsdC5pbmRleE9mKFwiZVwiKSsxKStmKSk6bj1uZXcgSChzK1wiXCIpLG4uY1swXSlmb3IoKHM9KGY9bi5lKStjKTwzJiYocz0wKTs7KWlmKGk9bixuPWwudGltZXMoaS5wbHVzKHkobyxpLGMsMSkpKSxwKGkuYykuc2xpY2UoMCxzKT09PSh0PXAobi5jKSkuc2xpY2UoMCxzKSl7aWYobi5lPGYmJi0tcyxcIjk5OTlcIiE9KHQ9dC5zbGljZShzLTMscysxKSkmJihyfHxcIjQ5OTlcIiE9dCkpeyt0JiYoK3Quc2xpY2UoMSl8fFwiNVwiIT10LmNoYXJBdCgwKSl8fCh6KG4sbi5lK1MrMiwxKSxlPSFuLnRpbWVzKG4pLmVxKG8pKTticmVha31pZighciYmKHooaSxpLmUrUysyLDApLGkudGltZXMoaSkuZXEobykpKXtuPWk7YnJlYWt9Yys9NCxzKz00LHI9MX1yZXR1cm4geihuLG4uZStTKzEsRixlKX0sTC50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJihtKGUsMCxhKSxlKyspLFYodGhpcyxlLHQsMSl9LEwudG9GaXhlZD1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiYobShlLDAsYSksZT1lK3RoaXMuZSsxKSxWKHRoaXMsZSx0KX0sTC50b0Zvcm1hdD1mdW5jdGlvbihlLHQsbil7dmFyIHIsbz10aGlzO2lmKG51bGw9PW4pbnVsbCE9ZSYmdCYmXCJvYmplY3RcIj09dHlwZW9mIHQ/KG49dCx0PW51bGwpOmUmJlwib2JqZWN0XCI9PXR5cGVvZiBlPyhuPWUsZT10PW51bGwpOm49ajtlbHNlIGlmKFwib2JqZWN0XCIhPXR5cGVvZiBuKXRocm93IEVycm9yKGkrXCJBcmd1bWVudCBub3QgYW4gb2JqZWN0OiBcIituKTtpZihyPW8udG9GaXhlZChlLHQpLG8uYyl7dmFyIHUscz1yLnNwbGl0KFwiLlwiKSxmPStuLmdyb3VwU2l6ZSxjPStuLnNlY29uZGFyeUdyb3VwU2l6ZSxsPW4uZ3JvdXBTZXBhcmF0b3J8fFwiXCIsYT1zWzBdLGg9c1sxXSxwPW8uczwwLGc9cD9hLnNsaWNlKDEpOmEsbT1nLmxlbmd0aDtpZihjJiYodT1mLGY9YyxjPXUsbS09dSksZj4wJiZtPjApe2Zvcih1PW0lZnx8ZixhPWcuc3Vic3RyKDAsdSk7dTxtO3UrPWYpYSs9bCtnLnN1YnN0cih1LGYpO2M+MCYmKGErPWwrZy5zbGljZSh1KSkscCYmKGE9XCItXCIrYSl9cj1oP2ErKG4uZGVjaW1hbFNlcGFyYXRvcnx8XCJcIikrKChjPStuLmZyYWN0aW9uR3JvdXBTaXplKT9oLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxke1wiK2MrXCJ9XFxcXEJcIixcImdcIiksXCIkJlwiKyhuLmZyYWN0aW9uR3JvdXBTZXBhcmF0b3J8fFwiXCIpKTpoKTphfXJldHVybihuLnByZWZpeHx8XCJcIikrcisobi5zdWZmaXh8fFwiXCIpfSxMLnRvRnJhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQsbixyLG8sdSxmLGwsYSxoLGcsbSxOLGI9dGhpcyx3PWIuYztpZihudWxsIT1lJiYoIShsPW5ldyBIKGUpKS5pc0ludGVnZXIoKSYmKGwuY3x8MSE9PWwucyl8fGwubHQoQikpKXRocm93IEVycm9yKGkrXCJBcmd1bWVudCBcIisobC5pc0ludGVnZXIoKT9cIm91dCBvZiByYW5nZTogXCI6XCJub3QgYW4gaW50ZWdlcjogXCIpKyQobCkpO2lmKCF3KXJldHVybiBuZXcgSChiKTtmb3IodD1uZXcgSChCKSxoPW49bmV3IEgoQikscj1hPW5ldyBIKEIpLE49cCh3KSx1PXQuZT1OLmxlbmd0aC1iLmUtMSx0LmNbMF09Y1soZj11JXMpPDA/cytmOmZdLGU9IWV8fGwuY29tcGFyZWRUbyh0KT4wP3U+MD90Omg6bCxmPVAsUD0xLzAsbD1uZXcgSChOKSxhLmNbMF09MDtnPXkobCx0LDAsMSksMSE9KG89bi5wbHVzKGcudGltZXMocikpKS5jb21wYXJlZFRvKGUpOyluPXIscj1vLGg9YS5wbHVzKGcudGltZXMobz1oKSksYT1vLHQ9bC5taW51cyhnLnRpbWVzKG89dCkpLGw9bztyZXR1cm4gbz15KGUubWludXMobiksciwwLDEpLGE9YS5wbHVzKG8udGltZXMoaCkpLG49bi5wbHVzKG8udGltZXMocikpLGEucz1oLnM9Yi5zLG09eShoLHIsdSo9MixGKS5taW51cyhiKS5hYnMoKS5jb21wYXJlZFRvKHkoYSxuLHUsRikubWludXMoYikuYWJzKCkpPDE/W2gscl06W2Esbl0sUD1mLG19LEwudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4rJCh0aGlzKX0sTC50b1ByZWNpc2lvbj1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiZtKGUsMSxhKSxWKHRoaXMsZSx0LDIpfSxMLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LG49dGhpcyxyPW4ucyxpPW4uZTtyZXR1cm4gbnVsbD09PWk/cj8odD1cIkluZmluaXR5XCIscjwwJiYodD1cIi1cIit0KSk6dD1cIk5hTlwiOihudWxsPT1lP3Q9aTw9SXx8aT49TT9iKHAobi5jKSxpKTp3KHAobi5jKSxpLFwiMFwiKToxMD09PWU/dD13KHAoKG49eihuZXcgSChuKSxTK2krMSxGKSkuYyksbi5lLFwiMFwiKToobShlLDIscS5sZW5ndGgsXCJCYXNlXCIpLHQ9Tyh3KHAobi5jKSxpLFwiMFwiKSwxMCxlLHIsITApKSxyPDAmJm4uY1swXSYmKHQ9XCItXCIrdCkpLHR9LEwudmFsdWVPZj1MLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiAkKHRoaXMpfSxMLl9pc0JpZ051bWJlcj0hMCxMW1N5bWJvbC50b1N0cmluZ1RhZ109XCJCaWdOdW1iZXJcIixMW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV09TC52YWx1ZU9mLG51bGwhPWQmJkguc2V0KGQpLEh9KCkseT1mdW5jdGlvbigpe3JldHVybih5PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPTEscj1hcmd1bWVudHMubGVuZ3RoO248cjtuKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW25dKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sTz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLmZvcm1hdD1lLkRFRkFVTFRfRk9STUFULGQuY29uZmlnKHtGT1JNQVQ6dGhpcy5mb3JtYXR9KX1yZXR1cm4gZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUpe1wiRk9STUFUXCJpbiBlJiYodGhpcy5mb3JtYXQ9eSh7fSx0aGlzLmZvcm1hdCxlLkZPUk1BVCksZS5GT1JNQVQ9dGhpcy5mb3JtYXQpLGQuY29uZmlnKGUpfSxlLkRFRkFVTFRfRk9STUFUPXtwcmVmaXg6XCJcIixkZWNpbWFsU2VwYXJhdG9yOlwiLlwiLGdyb3VwU2VwYXJhdG9yOlwiLFwiLGdyb3VwU2l6ZTozLHNlY29uZGFyeUdyb3VwU2l6ZTowLGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6XCIgXCIsZnJhY3Rpb25Hcm91cFNpemU6MCxzdWZmaXg6XCJcIn0sZX0oKTtlLkJpZ051bWJlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7XCJvYmplY3RcIj09dHlwZW9mIHQmJmUuaXNCaWdOdW1iZXIodCk/dGhpcy5ibj10LmJuLnBsdXMoMCk6dGhpcy5ibj1lLnRvQmlnTnVtYmVySnModCl9cmV0dXJuIGUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlKHRoaXMpfSxlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHRoaXMuYm4ucGx1cyhlLnRvQmlnTnVtYmVySnModCkpKX0sZS5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0aGlzLmJuLm1pbnVzKGUudG9CaWdOdW1iZXJKcyh0KSkpfSxlLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHRoaXMuYm4udGltZXMoZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLmRpdj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodGhpcy5ibi5kaXYoZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodGhpcy5ibi5wb3coZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUodGhpcy5ibi5zcXJ0KCkpfSxlLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUodGhpcy5ibi5hYnMoKSl9LGUucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodGhpcy5ibi5tb2QoZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLnJvdW5kVG89ZnVuY3Rpb24odCxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCksdm9pZCAwPT09biYmKG49NCksbmV3IGUodGhpcy5ibi5kcCh0fHwwLG4pKX0sZS5wcm90b3R5cGUuZXE9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYm4uZXEoZS50b0JpZ051bWJlckpzKHQpKX0sZS5wcm90b3R5cGUubHQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYm4ubHQoZS50b0JpZ051bWJlckpzKHQpKX0sZS5wcm90b3R5cGUuZ3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYm4uZ3QoZS50b0JpZ051bWJlckpzKHQpKX0sZS5wcm90b3R5cGUubHRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmJuLmx0ZShlLnRvQmlnTnVtYmVySnModCkpfSxlLnByb3RvdHlwZS5ndGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYm4uZ3RlKGUudG9CaWdOdW1iZXJKcyh0KSl9LGUucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4uaXNOYU4oKX0sZS5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibi5pc0Zpbml0ZSgpfSxlLnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcSgwKX0sZS5wcm90b3R5cGUuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmd0KDApfSxlLnByb3RvdHlwZS5pc05lZ2F0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHQoMCl9LGUucHJvdG90eXBlLmlzSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4uaXNJbnRlZ2VyKCl9LGUucHJvdG90eXBlLmdldERlY2ltYWxzQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibi5kcCgpfSxlLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2QoMikuZXEoMCl9LGUucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNFdmVuKCl9LGUucHJvdG90eXBlLmlzSW5TaWduZWRSYW5nZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmd0ZShlLk1JTl9WQUxVRSkmJnRoaXMubHRlKGUuTUFYX1ZBTFVFKX0sZS5wcm90b3R5cGUuaXNJblVuc2lnbmVkUmFuZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ndGUoZS5NSU5fVU5TSUdORURfVkFMVUUpJiZ0aGlzLmx0ZShlLk1BWF9VTlNJR05FRF9WQUxVRSl9LGUucHJvdG90eXBlLnRvRm9ybWF0PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5ibi50b0Zvcm1hdChlLHQsbil9LGUucHJvdG90eXBlLnRvRml4ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09ZT90aGlzLmJuLnRvRml4ZWQoKTp0aGlzLmJuLnRvRml4ZWQoZSx0KX0sZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0ZpeGVkKCl9LGUucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udG9OdW1iZXIoKX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udG9GaXhlZCgpfSxlLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udmFsdWVPZigpfSxlLnByb3RvdHlwZS50b0J5dGVzPWZ1bmN0aW9uKHQpe3ZhciBuPXZvaWQgMD09PXQ/e306dCxyPW4uaXNTaWduZWQsaT12b2lkIDA9PT1yfHxyLG89bi5pc0xvbmcsdT12b2lkIDA9PT1vfHxvO2lmKCF0aGlzLmlzSW50KCkpdGhyb3cgbmV3IEVycm9yKFwiQ2FudCBjcmVhdGUgYnl0ZXMgZnJvbSBudW1iZXIgd2l0aCBkZWNpbWFscyFcIik7aWYoIWkmJnRoaXMuaXNOZWdhdGl2ZSgpKXRocm93IG5ldyBFcnJvcihcIkNhbnQgY3JlYXRlIGJ5dGVzIGZyb20gbmVnYXRpdmUgbnVtYmVyIGluIHNpZ25lZCBtb2RlIVwiKTtpZih1JiZpJiYhdGhpcy5pc0luU2lnbmVkUmFuZ2UoKSl0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgaXMgbm90IGZyb20gc2lnbmVkIG51bWJlcnMgcmFuZ2VcIik7aWYodSYmIWkmJiF0aGlzLmlzSW5VbnNpZ25lZFJhbmdlKCkpdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIGlzIG5vdCBmcm9tIHVuc2lnbmVkIG51bWJlcnMgcmFuZ2VcIik7dmFyIHM9aSYmdGhpcy5pc05lZ2F0aXZlKCksZj1zP1wiMVwiOlwiMFwiLGM9dGhpcy5ibi5wbHVzKGYpLnRvU3RyaW5nKDIpLnJlcGxhY2UoXCItXCIsXCJcIiksbD11PzY0OjgqTWF0aC5jZWlsKGMubGVuZ3RoLzgpLGE9ZS5fdG9MZW5ndGgobCxjKS5zcGxpdChcIlwiKSxoPVtdO2Rve2gucHVzaChwYXJzZUludChhLnNwbGljZSgwLDgpLmpvaW4oXCJcIiksMikpfXdoaWxlKGEubGVuZ3RoKTtyZXR1cm4gcz9VaW50OEFycmF5LmZyb20oaC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIDI1NS1lfSkpOlVpbnQ4QXJyYXkuZnJvbShoKX0sZS5mcm9tQnl0ZXM9ZnVuY3Rpb24odCxuKXt2YXIgcj12b2lkIDA9PT1uP3t9Om4saT1yLmlzU2lnbmVkLG89dm9pZCAwPT09aXx8aSx1PXIuaXNMb25nLHM9dm9pZCAwPT09dXx8dTtpZihzJiY4IT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnl0ZXMgbGVuZ3RoISBNaW5pbWFsIGxlbmd0aCBpcyA4IGJ5dGUhXCIpO3Q9IXMmJnQubGVuZ3RoPjB8fHM/dDpbMF07dmFyIGY9ISFvJiZ0WzBdPjEyNyxjPUFycmF5LmZyb20odCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBmPzI1NS1lOmV9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuX3RvTGVuZ3RoKDgsdC50b1N0cmluZygyKSl9KS5qb2luKFwiXCIpLGw9bmV3IGUobmV3IGQoYywyKSk7cmV0dXJuIGY/bC5tdWwoLTEpLnN1YigxKTpsfSxlLm1heD1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl0W25dPWFyZ3VtZW50c1tuXTtyZXR1cm4gZS50b0JpZ051bWJlcih0KS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5ndGUodCk/ZTp0fSl9LGUubWluPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXRbbl09YXJndW1lbnRzW25dO3JldHVybiBlLnRvQmlnTnVtYmVyKHQpLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlLmx0ZSh0KT9lOnR9KX0sZS5zdW09ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07cmV0dXJuIGUudG9CaWdOdW1iZXIodCkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuYWRkKHQpfSl9LGUuaXNCaWdOdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYodCBpbnN0YW5jZW9mIGV8fE9iamVjdC5lbnRyaWVzKGUucHJvdG90eXBlKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJfXCIhPT1lWzBdLmNoYXJBdCgwKX0pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybiBuIGluIHQmJnR5cGVvZiByPT10eXBlb2YgdFtuXX0pKX0sZS50b0JpZ051bWJlcj1mdW5jdGlvbih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9KTpuZXcgZSh0KX0sZS50b0JpZ051bWJlckpzPWZ1bmN0aW9uKHQpe3JldHVybiBkLmlzQmlnTnVtYmVyKHQpP3Q6dCBpbnN0YW5jZW9mIGU/dC5ibjpuZXcgZCh0KX0sZS5fdG9MZW5ndGg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IEFycmF5KGUpLmZpbGwoXCIwXCIsMCxlKS5jb25jYXQodC5zcGxpdChcIlwiKSkuc2xpY2UoLWUpLmpvaW4oXCJcIil9LGUuTUlOX1ZBTFVFPW5ldyBlKFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksZS5NQVhfVkFMVUU9bmV3IGUoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpLGUuTUlOX1VOU0lHTkVEX1ZBTFVFPW5ldyBlKFwiMFwiKSxlLk1BWF9VTlNJR05FRF9WQUxVRT1uZXcgZShcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpLGUuY29uZmlnPW5ldyBPLGV9KCksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpe2VbZS5ST1VORF9VUD0wXT1cIlJPVU5EX1VQXCIsZVtlLlJPVU5EX0RPV049MV09XCJST1VORF9ET1dOXCIsZVtlLlJPVU5EX0NFSUw9Ml09XCJST1VORF9DRUlMXCIsZVtlLlJPVU5EX0ZMT09SPTNdPVwiUk9VTkRfRkxPT1JcIixlW2UuUk9VTkRfSEFMRl9VUD00XT1cIlJPVU5EX0hBTEZfVVBcIixlW2UuUk9VTkRfSEFMRl9ET1dOPTVdPVwiUk9VTkRfSEFMRl9ET1dOXCIsZVtlLlJPVU5EX0hBTEZfRVZFTj02XT1cIlJPVU5EX0hBTEZfRVZFTlwiLGVbZS5ST1VORF9IQUxGX0NFSUw9N109XCJST1VORF9IQUxGX0NFSUxcIixlW2UuUk9VTkRfSEFMRl9GTE9PUj04XT1cIlJPVU5EX0hBTEZfRkxPT1JcIn0oZS5ST1VORF9NT0RFfHwoZS5ST1VORF9NT0RFPXt9KSl9KGUuQmlnTnVtYmVyfHwoZS5CaWdOdW1iZXI9e30pKTt2YXIgdj1lLkJpZ051bWJlcjtlLmRlZmF1bHQ9dixPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pO1xuIiwiIWZ1bmN0aW9uKGUsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sbik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5jbGllbnRMb2dzPW4oKTplLmNsaWVudExvZ3M9bigpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj17fTtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgbz1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmw9ITAsby5leHBvcnRzfXJldHVybiB0Lm09ZSx0LmM9bix0LmQ9ZnVuY3Rpb24oZSxuLHIpe3QubyhlLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDpyfSl9LHQucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSx0LnQ9ZnVuY3Rpb24oZSxuKXtpZigxJm4mJihlPXQoZSkpLDgmbilyZXR1cm4gZTtpZig0Jm4mJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHI9T2JqZWN0LmNyZWF0ZShudWxsKTtpZih0LnIociksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImbiYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpdC5kKHIsbyxmdW5jdGlvbihuKXtyZXR1cm4gZVtuXX0uYmluZChudWxsLG8pKTtyZXR1cm4gcn0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSxuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbil9LHQucD1cIlwiLHQodC5zPTApfShbZnVuY3Rpb24oZSxuLHQpe1widXNlIHN0cmljdFwiO3QucihuKTt2YXIgcj1bXCJpbmZvXCIsXCJsb2dcIixcIndhcm5cIixcImVycm9yXCJdLG89e2tlZXBNZXNzYWdlQ291bnQ6MTAwLGtlZXBNZXNzYWdlVHlwZXM6W1wiZXJyb3JcIl0sbG9nTWVzc2FnZVR5cGVzOltcImVycm9yXCJdLG5hbWVzcGFjZTp2b2lkIDB9LHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLG4pe3JldHVybiBlW25dPSEwLGV9KSxPYmplY3QuY3JlYXRlKG51bGwpKX0sdT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7dGhpcy5fbWVzc2FnZXM9W10sdGhpcy5fbWF4TGVuZ3RoPWV9cmV0dXJuIGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSl7dGhpcy5fbWVzc2FnZXMucHVzaChlKSx0aGlzLl9tZXNzYWdlcy5sZW5ndGg+dGhpcy5fbWF4TGVuZ3RoJiZ0aGlzLl9tZXNzYWdlcy5zcGxpY2UoMCx0aGlzLl9tZXNzYWdlcy5sZW5ndGgtdGhpcy5fbWF4TGVuZ3RoKX0sZS5wcm90b3R5cGUuZ2V0TWVzc2FnZXM9ZnVuY3Rpb24oZSl7dmFyIG4sdCxvPXMobnVsbCE9KHQ9bnVsbD09PShuPWUpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLm1lc3NhZ2VUeXBlcyk/dDpyKTtyZXR1cm4gdGhpcy5fbWVzc2FnZXMuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gb1tlLnR5cGVdfSkpfSxlfSgpO2Z1bmN0aW9uIGEoZSl7cmV0dXJuIGV9dC5kKG4sXCJtYWtlQ29uc29sZVwiLChmdW5jdGlvbigpe3JldHVybiBwfSkpLHQuZChuLFwidmVyc2lvblwiLChmdW5jdGlvbigpe3JldHVybiBmfSkpLHQuZChuLFwibWFrZU9wdGlvbnNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbH0pKTt2YXIgaT1mdW5jdGlvbigpe3JldHVybihpPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgbix0PTEscj1hcmd1bWVudHMubGVuZ3RoO3Q8cjt0KyspZm9yKHZhciBvIGluIG49YXJndW1lbnRzW3RdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLG8pJiYoZVtvXT1uW29dKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sYz1mdW5jdGlvbigpe2Zvcih2YXIgZT0wLG49MCx0PWFyZ3VtZW50cy5sZW5ndGg7bjx0O24rKyllKz1hcmd1bWVudHNbbl0ubGVuZ3RoO3ZhciByPUFycmF5KGUpLG89MDtmb3Iobj0wO248dDtuKyspZm9yKHZhciBzPWFyZ3VtZW50c1tuXSx1PTAsYT1zLmxlbmd0aDt1PGE7dSsrLG8rKylyW29dPXNbdV07cmV0dXJuIHJ9LHA9ZnVuY3Rpb24oZSl7dmFyIG49aShpKHt9LG8pLG51bGwhPWU/ZTp7fSksdD1uZXcgdShuLmtlZXBNZXNzYWdlQ291bnQpLHA9cyhuLmxvZ01lc3NhZ2VUeXBlcyksZj1zKG4ua2VlcE1lc3NhZ2VUeXBlcyk7cmV0dXJuIHIucmVkdWNlKChmdW5jdGlvbihlLHIpe3ZhciBvPW51bGwhPW4ubmFtZXNwYWNlP2Z1bmN0aW9uKGUpe3JldHVybiBjKFtuLm5hbWVzcGFjZV0sZSl9OmEscz1wW3JdP2NvbnNvbGVbcl06YSx1PWZbcl0/ZnVuY3Rpb24oZSl7cmV0dXJuIHQucHVzaCh7dHlwZTpyLGFyZ3M6ZX0pfTphO3JldHVybiBlW3JdPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKWVbbl09YXJndW1lbnRzW25dO3ZhciB0PW8oZSk7cy5hcHBseSh2b2lkIDAsdCksdSh0KX0sZX0pLHtnZXRNZXNzYWdlczpmdW5jdGlvbihlKXtyZXR1cm4gdC5nZXRNZXNzYWdlcyhlKX19KX0sZj1cIjEuMC4wXCI7ZnVuY3Rpb24gbChlLG4pe3N3aXRjaChlKXtjYXNlXCJwcm9kdWN0aW9uXCI6cmV0dXJuIGkoaSh7fSxvKSx7a2VlcE1lc3NhZ2VUeXBlczpbXCJlcnJvclwiXSxsb2dNZXNzYWdlVHlwZXM6W10sbmFtZXNwYWNlOm59KTtjYXNlXCJlcnJvclwiOnJldHVybiBpKGkoe30sbykse2tlZXBNZXNzYWdlVHlwZXM6W1wid2FyblwiLFwiZXJyb3JcIl0sbG9nTWVzc2FnZVR5cGVzOltcImVycm9yXCJdLG5hbWVzcGFjZTpufSk7Y2FzZVwidmVyYm9zZVwiOnJldHVybiBpKGkoe30sbykse2tlZXBNZXNzYWdlVHlwZXM6W10sbG9nTWVzc2FnZVR5cGVzOnIuc2xpY2UoKSxuYW1lc3BhY2U6bn0pfX1uLmRlZmF1bHQ9cH1dKX0pKTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hBZGRyZXNzZXMgPSBleHBvcnRzLmZldGNoUHVibGljS2V5ID0gZXhwb3J0cy5mZXRjaFNlZWQgPSBleHBvcnRzLmZldGNoU2VxID0gZXhwb3J0cy5mZXRjaEVmZmVjdGl2ZUJhbGFuY2UgPSBleHBvcnRzLmZldGNoRWZmZWN0aXZlQmFsYW5jZUNvbmZpcm1hdGlvbnMgPSBleHBvcnRzLmZldGNoQmFsYW5jZSA9IGV4cG9ydHMuZmV0Y2hWYWxpZGF0ZSA9IGV4cG9ydHMuZGF0YSA9IGV4cG9ydHMuZmV0Y2hTY3JpcHRJbmZvID0gZXhwb3J0cy5mZXRjaEJhbGFuY2VDb25maXJtYXRpb25zID0gZXhwb3J0cy5mZXRjaEJhbGFuY2VEZXRhaWxzID0gZXhwb3J0cy5mZXRjaFNjcmlwdEluZm9NZXRhID0gZXhwb3J0cy5mZXRjaERhdGFLZXkgPSB2b2lkIDA7XG52YXIgcmVxdWVzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b29scy9yZXF1ZXN0XCIpKTtcbnZhciBxdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b29scy9xdWVyeVwiKSk7XG5mdW5jdGlvbiBmZXRjaERhdGFLZXkoYmFzZSwgYWRkcmVzcywga2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvYWRkcmVzc2VzL2RhdGEvXCIgKyBhZGRyZXNzICsgXCIvXCIgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaERhdGFLZXkgPSBmZXRjaERhdGFLZXk7XG5mdW5jdGlvbiBmZXRjaFNjcmlwdEluZm9NZXRhKGJhc2UsIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9zY3JpcHRJbmZvL1wiICsgYWRkcmVzcyArIFwiL21ldGFcIlxuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFNjcmlwdEluZm9NZXRhID0gZmV0Y2hTY3JpcHRJbmZvTWV0YTtcbmZ1bmN0aW9uIGZldGNoQmFsYW5jZURldGFpbHMoYmFzZSwgYWRkcmVzcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9iYWxhbmNlL2RldGFpbHMvXCIgKyBhZGRyZXNzLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoQmFsYW5jZURldGFpbHMgPSBmZXRjaEJhbGFuY2VEZXRhaWxzO1xuZnVuY3Rpb24gZmV0Y2hCYWxhbmNlQ29uZmlybWF0aW9ucyhiYXNlLCBhZGRyZXNzLCBjb25maXJtYXRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvYWRkcmVzc2VzL2JhbGFuY2UvXCIgKyBhZGRyZXNzICsgXCIvXCIgKyBjb25maXJtYXRpb25zLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoQmFsYW5jZUNvbmZpcm1hdGlvbnMgPSBmZXRjaEJhbGFuY2VDb25maXJtYXRpb25zO1xuZnVuY3Rpb24gZmV0Y2hTY3JpcHRJbmZvKGJhc2UsIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9hZGRyZXNzZXMvc2NyaXB0SW5mby9cIiArIGFkZHJlc3MsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hTY3JpcHRJbmZvID0gZmV0Y2hTY3JpcHRJbmZvO1xuZnVuY3Rpb24gZGF0YShiYXNlLCBhZGRyZXNzLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9kYXRhL1wiICsgYWRkcmVzcyArIHF1ZXJ5XzEuZGVmYXVsdChwYXJhbXMpLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmRhdGEgPSBkYXRhO1xuZnVuY3Rpb24gZmV0Y2hWYWxpZGF0ZShiYXNlLCBhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9hZGRyZXNzZXMvdmFsaWRhdGUvXCIgKyBhZGRyZXNzXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoVmFsaWRhdGUgPSBmZXRjaFZhbGlkYXRlO1xuZnVuY3Rpb24gZmV0Y2hCYWxhbmNlKGJhc2UsIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9hZGRyZXNzZXMvYmFsYW5jZS9cIiArIGFkZHJlc3MsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hCYWxhbmNlID0gZmV0Y2hCYWxhbmNlO1xuZnVuY3Rpb24gZmV0Y2hFZmZlY3RpdmVCYWxhbmNlQ29uZmlybWF0aW9ucyhiYXNlLCBhZGRyZXNzLCBjb25maXJtYXRpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvYWRkcmVzc2VzL2VmZmVjdGl2ZUJhbGFuY2UvXCIgKyBhZGRyZXNzICsgXCIvXCIgKyBjb25maXJtYXRpb25zLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoRWZmZWN0aXZlQmFsYW5jZUNvbmZpcm1hdGlvbnMgPSBmZXRjaEVmZmVjdGl2ZUJhbGFuY2VDb25maXJtYXRpb25zO1xuZnVuY3Rpb24gZmV0Y2hFZmZlY3RpdmVCYWxhbmNlKGJhc2UsIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9hZGRyZXNzZXMvZWZmZWN0aXZlQmFsYW5jZS9cIiArIGFkZHJlc3MsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hFZmZlY3RpdmVCYWxhbmNlID0gZmV0Y2hFZmZlY3RpdmVCYWxhbmNlO1xuZnVuY3Rpb24gZmV0Y2hTZXEoYmFzZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9zZXEvXCIgKyBmcm9tICsgXCIvXCIgKyB0b1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFNlcSA9IGZldGNoU2VxO1xuZnVuY3Rpb24gZmV0Y2hTZWVkKGJhc2UsIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9zZWVkL1wiICsgYWRkcmVzc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFNlZWQgPSBmZXRjaFNlZWQ7XG5mdW5jdGlvbiBmZXRjaFB1YmxpY0tleShiYXNlLCBwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2FkZHJlc3Nlcy9wdWJsaWNLZXkvXCIgKyBwdWJsaWNLZXlcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hQdWJsaWNLZXkgPSBmZXRjaFB1YmxpY0tleTtcbmZ1bmN0aW9uIGZldGNoQWRkcmVzc2VzKGJhc2UpIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6ICcvYWRkcmVzc2VzJ1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEFkZHJlc3NlcyA9IGZldGNoQWRkcmVzc2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaEJhbGFuY2VBZGRyZXNzQXNzZXRJZCA9IGV4cG9ydHMuZmV0Y2hBc3NldHNCYWxhbmNlID0gZXhwb3J0cy5mZXRjaEFzc2V0c0FkZHJlc3NMaW1pdCA9IGV4cG9ydHMuZmV0Y2hBc3NldERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMuZmV0Y2hBc3NldHNEZXRhaWxzID0gZXhwb3J0cy5mZXRjaERldGFpbHMgPSB2b2lkIDA7XG52YXIgdHNfdHlwZXNfMSA9IHJlcXVpcmUoXCJAd2F2ZXMvdHMtdHlwZXNcIik7XG52YXIgcmVxdWVzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b29scy9yZXF1ZXN0XCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzL3V0aWxzXCIpO1xuZnVuY3Rpb24gZmV0Y2hEZXRhaWxzKGJhc2UsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgdmFyIGlzT25jZSA9ICFBcnJheS5pc0FycmF5KGFzc2V0SWQpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh1dGlsc18xLnRvQXJyYXkoYXNzZXRJZCkubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2Fzc2V0cy9kZXRhaWxzL1wiICsgaWQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTsgfSkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBpc09uY2UgPyBsaXN0WzBdIDogbGlzdDsgfSk7XG59XG5leHBvcnRzLmZldGNoRGV0YWlscyA9IGZldGNoRGV0YWlscztcbi8qKlxuICogR0VUIC9hc3NldHMvZGV0YWlsc1xuICogUHJvdmlkZXMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdpdmVuIGFzc2V0c1xuICovXG5mdW5jdGlvbiBmZXRjaEFzc2V0c0RldGFpbHMoYmFzZSwgYXNzZXRJZHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgdmFyIHBhcmFtcyA9IGFzc2V0SWRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGFzc2V0SWQpIHsgcmV0dXJuIFwiaWQ9XCIgKyBhc3NldElkOyB9KVxuICAgICAgICAuam9pbignJicpO1xuICAgIHZhciBxdWVyeSA9IGFzc2V0SWRzLmxlbmd0aCA/IFwiP1wiICsgcGFyYW1zIDogJyc7XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHsgYmFzZTogYmFzZSwgdXJsOiBcIi9hc3NldHMvZGV0YWlsc1wiICsgcXVlcnksIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG59XG5leHBvcnRzLmZldGNoQXNzZXRzRGV0YWlscyA9IGZldGNoQXNzZXRzRGV0YWlscztcbmZ1bmN0aW9uIGZldGNoQXNzZXREaXN0cmlidXRpb24oYmFzZSwgYXNzZXRJZCwgaGVpZ2h0LCBsaW1pdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoeyBiYXNlOiBiYXNlLCB1cmw6IFwiL2Fzc2V0cy9cIiArIGFzc2V0SWQgKyBcIi9kaXN0cmlidXRpb24vXCIgKyBoZWlnaHQgKyBcIi9saW1pdC9cIiArIGxpbWl0LCBvcHRpb25zOiBvcHRpb25zIH0pO1xufVxuZXhwb3J0cy5mZXRjaEFzc2V0RGlzdHJpYnV0aW9uID0gZmV0Y2hBc3NldERpc3RyaWJ1dGlvbjtcbi8qKlxuICogVE9ET1xuICogR0VUIC9hc3NldHMve2Fzc2V0SWR9L2Rpc3RyaWJ1dGlvblxuICogQXNzZXQgYmFsYW5jZSBkaXN0cmlidXRpb25cbiAqL1xuZnVuY3Rpb24gZmV0Y2hBc3NldHNBZGRyZXNzTGltaXQoYmFzZSwgYWRkcmVzcywgbGltaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHsgYmFzZTogYmFzZSwgdXJsOiBcImFzc2V0cy9uZnQvXCIgKyBhZGRyZXNzICsgXCIvbGltaXQvXCIgKyBsaW1pdCwgb3B0aW9uczogb3B0aW9ucyB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hBc3NldHNBZGRyZXNzTGltaXQgPSBmZXRjaEFzc2V0c0FkZHJlc3NMaW1pdDtcbmZ1bmN0aW9uIGZldGNoQXNzZXRzQmFsYW5jZShiYXNlLCBhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhbGFuY2VzUmVzcG9uc2UsIGFzc2V0c1dpdGhvdXRJc3N1ZVRyYW5zYWN0aW9uLCBhc3NldHNEZXRhaWxzUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcXVlc3RfMS5kZWZhdWx0KHsgYmFzZTogYmFzZSwgdXJsOiBcIi9hc3NldHMvYmFsYW5jZS9cIiArIGFkZHJlc3MsIG9wdGlvbnM6IG9wdGlvbnMgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZXNSZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXRzV2l0aG91dElzc3VlVHJhbnNhY3Rpb24gPSBiYWxhbmNlc1Jlc3BvbnNlLmJhbGFuY2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBiYWxhbmNlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYWxhbmNlLmlzc3VlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NbYmFsYW5jZS5hc3NldElkXSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaEFzc2V0c0RldGFpbHMoYmFzZSwgT2JqZWN0LmtleXMoYXNzZXRzV2l0aG91dElzc3VlVHJhbnNhY3Rpb24pLCBvcHRpb25zKV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBhc3NldHNEZXRhaWxzUmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0c0RldGFpbHNSZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIChhc3NldERldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFzc2V0RGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhc3NldEluZGV4ID0gYXNzZXRzV2l0aG91dElzc3VlVHJhbnNhY3Rpb25bYXNzZXREZXRhaWxzLmFzc2V0SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2V0QmFsYW5jZSA9IGJhbGFuY2VzUmVzcG9uc2UuYmFsYW5jZXNbYXNzZXRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFzc2V0QmFsYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0QmFsYW5jZS5pc3N1ZVRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBhc3NldERldGFpbHMub3JpZ2luVHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhc3NldERldGFpbHMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogYXNzZXREZXRhaWxzLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBhc3NldERldGFpbHMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhbnRpdHk6IGFzc2V0RGV0YWlscy5xdWFudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWlzc3VhYmxlOiBhc3NldERldGFpbHMucmVpc3N1YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IGFzc2V0RGV0YWlscy5pc3N1ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyUHVibGljS2V5OiBhc3NldERldGFpbHMuaXNzdWVyUHVibGljS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogYXNzZXREZXRhaWxzLmlzc3VlVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYXNzZXREZXRhaWxzLmlzc3VlSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdDogYXNzZXREZXRhaWxzLnNjcmlwdGVkID8gJy0nIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9vZnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogTWF0aC5wb3coMTAsIDgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZUFzc2V0SWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0c190eXBlc18xLlRSQU5TQUNUSU9OX1RZUEUuSVNTVUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBiYWxhbmNlc1Jlc3BvbnNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoQXNzZXRzQmFsYW5jZSA9IGZldGNoQXNzZXRzQmFsYW5jZTtcbmZ1bmN0aW9uIGZldGNoQmFsYW5jZUFkZHJlc3NBc3NldElkKGJhc2UsIGFkZHJlc3MsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHsgYmFzZTogYmFzZSwgdXJsOiBcIi9hc3NldHMvYmFsYW5jZS9cIiArIGFkZHJlc3MgKyBcIi9cIiArIGFzc2V0SWQsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG59XG5leHBvcnRzLmZldGNoQmFsYW5jZUFkZHJlc3NBc3NldElkID0gZmV0Y2hCYWxhbmNlQWRkcmVzc0Fzc2V0SWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZmV0Y2hIZWlnaHRCeVRpbWVzdGFtcCA9IGV4cG9ydHMuZmV0Y2hIZWlnaHQgPSBleHBvcnRzLmZldGNoRGVsYXkgPSBleHBvcnRzLmZldGNoTGFzdCA9IGV4cG9ydHMuZmV0Y2hCbG9ja3NCeUFkZHJlc3MgPSBleHBvcnRzLmZldGNoRmlyc3QgPSBleHBvcnRzLmZldGNoQmxvY2tCeUlkID0gZXhwb3J0cy5mZXRjaFNlcSA9IGV4cG9ydHMuZmV0Y2hCbG9ja0F0ID0gZXhwb3J0cy5mZXRjaEhlYWRlcnNCeUlkID0gZXhwb3J0cy5mZXRjaEhlYWRlcnNBdCA9IGV4cG9ydHMuZmV0Y2hIZWlnaHRCeUlkID0gZXhwb3J0cy5mZXRjaEhlYWRlcnNMYXN0ID0gZXhwb3J0cy5mZXRjaEhlYWRlcnNTZXEgPSB2b2lkIDA7XG52YXIgcmVxdWVzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b29scy9yZXF1ZXN0XCIpKTtcbi8qKlxuICogR0VUIC9ibG9ja3MvaGVhZGVycy9zZXEve2Zyb219L3t0b31cbiAqIEdldCBibG9jayBoZWFkZXJzIGF0IHNwZWNpZmllZCBoZWlnaHRzXG4gKiBAcGFyYW0gYmFzZVxuICogQHBhcmFtIGZyb21cbiAqIEBwYXJhbSB0b1xuICovXG5mdW5jdGlvbiBmZXRjaEhlYWRlcnNTZXEoYmFzZSwgZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvaGVhZGVycy9zZXEvXCIgKyBmcm9tICsgXCIvXCIgKyB0byxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEhlYWRlcnNTZXEgPSBmZXRjaEhlYWRlcnNTZXE7XG4vKipcbiAqIEdFVCAvYmxvY2tzL2hlYWRlcnMvbGFzdFxuICogTGFzdCBibG9jayBoZWFkZXJcbiAqIEBwYXJhbSBiYXNlXG4gKi9cbmZ1bmN0aW9uIGZldGNoSGVhZGVyc0xhc3QoYmFzZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2Jsb2Nrcy9oZWFkZXJzL2xhc3RcIixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEhlYWRlcnNMYXN0ID0gZmV0Y2hIZWFkZXJzTGFzdDtcbi8qKlxuICogR0VUIC9ibG9ja3MvaGVpZ2h0L3tpZH1cbiAqIEhlaWdodCBvZiBhIGJsb2NrIGJ5IGl0cyBpZFxuICogQHBhcmFtIGJhc2VcbiAqIEBwYXJhbSBpZFxuICovXG5mdW5jdGlvbiBmZXRjaEhlaWdodEJ5SWQoYmFzZSwgaWQpIHtcbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2Jsb2Nrcy9oZWlnaHQvXCIgKyBpZFxuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEhlaWdodEJ5SWQgPSBmZXRjaEhlaWdodEJ5SWQ7XG4vKipcbiAqIEdFVCAvYmxvY2tzL2hlYWRlcnMvYXQve2hlaWdodH1cbiAqIEJsb2NrIGhlYWRlciBhdCBoZWlnaHRcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcGFyYW0gaGVpZ2h0XG4gKi9cbmZ1bmN0aW9uIGZldGNoSGVhZGVyc0F0KGJhc2UsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2Jsb2Nrcy9oZWFkZXJzL2F0L1wiICsgaGVpZ2h0LFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoSGVhZGVyc0F0ID0gZmV0Y2hIZWFkZXJzQXQ7XG4vKipcbiAqIEdFVCAvYmxvY2tzL2hlYWRlcnMve2lkfVxuICogR2V0IGJsb2NrIGF0IHNwZWNpZmllZCBoZWlnaHRcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcGFyYW0gaGVpZ2h0XG4gKi9cbmZ1bmN0aW9uIGZldGNoSGVhZGVyc0J5SWQoYmFzZSwgaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvaGVhZGVycy9cIiArIGlkLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoSGVhZGVyc0J5SWQgPSBmZXRjaEhlYWRlcnNCeUlkO1xuLyoqXG4gKiBHRVQgL2Jsb2Nrcy9hdC97aGVpZ2h0fVxuICogR2V0IGJsb2NrIGF0IHNwZWNpZmllZCBoZWlnaHRcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcGFyYW0gaGVpZ2h0XG4gKi9cbmZ1bmN0aW9uIGZldGNoQmxvY2tBdChiYXNlLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvYXQvXCIgKyBoZWlnaHQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hCbG9ja0F0ID0gZmV0Y2hCbG9ja0F0O1xuLyoqXG4gKiBHRVQgL2Jsb2Nrcy9zZXEve2Zyb219L3t0b31cbiAqIEJsb2NrIHJhbmdlXG4gKiBAcGFyYW0gYmFzZVxuICogQHBhcmFtIGZyb21cbiAqIEBwYXJhbSB0b1xuICovXG5mdW5jdGlvbiBmZXRjaFNlcShiYXNlLCBmcm9tLCB0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6IFwiL2Jsb2Nrcy9zZXEvXCIgKyBmcm9tICsgXCIvXCIgKyB0byxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFNlcSA9IGZldGNoU2VxO1xuLyoqXG4gKiBHRVQgL2Jsb2Nrcy97aWR9XG4gKiBHZXQgYmxvY2sgYnkgaXRzIGlkXG4gKiBAcGFyYW0gYmFzZVxuICogQHBhcmFtIGlkXG4gKi9cbmZ1bmN0aW9uIGZldGNoQmxvY2tCeUlkKGJhc2UsIGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvYmxvY2tzL1wiICsgaWQsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hCbG9ja0J5SWQgPSBmZXRjaEJsb2NrQnlJZDtcbi8qKlxuICogR0VUIC9ibG9ja3MvZmlyc3RcbiAqIEdldCBnZW5lc2lzIGJsb2NrXG4gKiBAcGFyYW0gYmFzZVxuICovXG5mdW5jdGlvbiBmZXRjaEZpcnN0KGJhc2UsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvZmlyc3RcIixcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEZpcnN0ID0gZmV0Y2hGaXJzdDtcbi8qKlxuICogL2Jsb2Nrcy9hZGRyZXNzL3thZGRyZXNzfS97ZnJvbX0ve3RvfVxuICogR2V0IGxpc3Qgb2YgYmxvY2tzIGdlbmVyYXRlZCBieSBzcGVjaWZpZWQgYWRkcmVzc1xuICogQHBhcmFtIGJhc2VcbiAqIEBwYXJhbSBhZGRyZXNzXG4gKiBAcGFyYW0gZnJvbVxuICogQHBhcmFtIHRvXG4gKi9cbmZ1bmN0aW9uIGZldGNoQmxvY2tzQnlBZGRyZXNzKGJhc2UsIGFkZHJlc3MsIGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvYmxvY2tzL2FkZHJlc3MvXCIgKyBhZGRyZXNzICsgXCIvXCIgKyBmcm9tICsgXCIvXCIgKyB0byxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEJsb2Nrc0J5QWRkcmVzcyA9IGZldGNoQmxvY2tzQnlBZGRyZXNzO1xuLyoqXG4gKiBHRVQgL2Jsb2Nrcy9sYXN0XG4gKiBMYXN0IGJsb2NrXG4gKiBAcGFyYW0gYmFzZVxuICovXG5mdW5jdGlvbiBmZXRjaExhc3QoYmFzZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6ICcvYmxvY2tzL2xhc3QnLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoTGFzdCA9IGZldGNoTGFzdDtcbi8qKlxuICogR0VUIC9ibG9ja3MvZGVsYXkve2lkfS97YmxvY2tOdW19XG4gKiBBdmVyYWdlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGxhc3QgYmxvY2tOdW0gYmxvY2tzIHN0YXJ0aW5nIGZyb20gYmxvY2sgd2l0aCBpZFxuICogQHBhcmFtIGJhc2VcbiAqIEBwYXJhbSBpZFxuICogQHBhcmFtIGJsb2NrTnVtXG4gKi9cbmZ1bmN0aW9uIGZldGNoRGVsYXkoYmFzZSwgaWQsIGJsb2NrTnVtKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvZGVsYXkvXCIgKyBpZCArIFwiL1wiICsgYmxvY2tOdW1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hEZWxheSA9IGZldGNoRGVsYXk7XG4vKipcbiAqIEdFVCAvYmxvY2tzL2hlaWdodFxuICogQHBhcmFtIGJhc2VcbiAqL1xuZnVuY3Rpb24gZmV0Y2hIZWlnaHQoYmFzZSkge1xuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogJy9ibG9ja3MvaGVpZ2h0J1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEhlaWdodCA9IGZldGNoSGVpZ2h0O1xuLyoqXG4gKiBHRVQgL2Jsb2Nrcy9oZWlnaHRCeVRpbWVzdGFtcFxuICogQHBhcmFtIGJhc2VcbiAqL1xuZnVuY3Rpb24gZmV0Y2hIZWlnaHRCeVRpbWVzdGFtcChiYXNlLCB0aW1lc3RhbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi9ibG9ja3MvaGVpZ2h0QnlUaW1lc3RhbXAvXCIgKyB0aW1lc3RhbXAsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hIZWlnaHRCeVRpbWVzdGFtcCA9IGZldGNoSGVpZ2h0QnlUaW1lc3RhbXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJyb2FkY2FzdCA9IGV4cG9ydHMuZmV0Y2hTdGF0dXMgPSBleHBvcnRzLmZldGNoSW5mbyA9IGV4cG9ydHMuZmV0Y2hVbmNvbmZpcm1lZEluZm8gPSBleHBvcnRzLmZldGNoVHJhbnNhY3Rpb25zID0gZXhwb3J0cy5mZXRjaFVuY29uZmlybWVkID0gZXhwb3J0cy5mZXRjaENhbGN1bGF0ZUZlZSA9IGV4cG9ydHMuZmV0Y2hVbmNvbmZpcm1lZFNpemUgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xudmFyIGJsb2Nrc18xID0gcmVxdWlyZShcIi4uL2Jsb2Nrc1wiKTtcbnZhciByZXF1ZXN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL3Rvb2xzL3JlcXVlc3RcIikpO1xudmFyIHF1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL3Rvb2xzL3F1ZXJ5XCIpKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzL3V0aWxzXCIpO1xudmFyIHN0cmluZ2lmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi90b29scy9zdHJpbmdpZnlcIikpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL3Rvb2xzL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbnNcIik7XG4vKipcbiAqIEdFVCAvdHJhbnNhY3Rpb25zL3VuY29uZmlybWVkL3NpemVcbiAqIE51bWJlciBvZiB1bmNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmV0Y2hVbmNvbmZpcm1lZFNpemUoYmFzZSkge1xuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogJy90cmFuc2FjdGlvbnMvdW5jb25maXJtZWQvc2l6ZSdcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hVbmNvbmZpcm1lZFNpemUgPSBmZXRjaFVuY29uZmlybWVkU2l6ZTtcbi8vIEBUT0RPOiB3aGVuIGNvcnJlY3QgQVBJIGtleSBpcyByZWNlaXZlZFxuLyoqXG4gKiBQT1NUIC90cmFuc2FjdGlvbnMvc2lnbi97c2lnbmVyQWRkcmVzc31cbiAqIFNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIGEgbm9uLWRlZmF1bHQgcHJpdmF0ZSBrZXlcbiAqL1xuLyoqXG4gKiBQT1NUIC90cmFuc2FjdGlvbnMvY2FsY3VsYXRlRmVlXG4gKiBDYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlXG4gKi9cbmZ1bmN0aW9uIGZldGNoQ2FsY3VsYXRlRmVlKGJhc2UsIHR4LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogJy90cmFuc2FjdGlvbnMvY2FsY3VsYXRlRmVlJyxcbiAgICAgICAgb3B0aW9uczogdXRpbHNfMS5kZWVwQXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBzdHJpbmdpZnlfMS5kZWZhdWx0KHR4KSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoQ2FsY3VsYXRlRmVlID0gZmV0Y2hDYWxjdWxhdGVGZWU7XG4vKipcbiAqIEdFVCAvdHJhbnNhY3Rpb25zL3VuY29uZmlybWVkXG4gKiBVbmNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmV0Y2hVbmNvbmZpcm1lZChiYXNlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogJy90cmFuc2FjdGlvbnMvdW5jb25maXJtZWQnLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoVW5jb25maXJtZWQgPSBmZXRjaFVuY29uZmlybWVkO1xuLyoqXG4gKiDQodC/0LjRgdC+0Log0YLRgNCw0L3Qt9Cw0LrRhtC40Lkg0L/QviDQsNC00YDQtdGB0YNcbiAqIEBwYXJhbSBhZGRyZXNzXG4gKiBAcGFyYW0gbGltaXQgICAgICDQvNCw0LrRgdC40LzQsNC70YzQvdC+0LUg0LrQvtC70LjRh9C10YHRgtCy0L4g0YLRgNCw0L3Qt9Cw0LrRhtC40Lkg0LIg0YDQtdC30YPQu9GM0YLQsNGC0LVcbiAqIEBwYXJhbSBhZnRlciAgICAgINC40YHQutCw0YLRjCDRgtGA0LDQvdC30LDQutGG0LjQuCDQv9C+0YHQu9C1IElEINGD0LrQsNC30LDQvdC90L7Qs9C+INCyIGFmdGVyXG4gKiBAcGFyYW0gcmV0cnkgICAgICDQutC+0LvQuNGH0LXRgdGC0LLQviDQv9C+0L/Ri9GC0L7QuiDQvdCwINCy0YvQv9C+0LvQvdC10L3QuNC1INC30LDQv9GA0L7RgdCwXG4gKi9cbmZ1bmN0aW9uIGZldGNoVHJhbnNhY3Rpb25zKGJhc2UsIGFkZHJlc3MsIGxpbWl0LCBhZnRlciwgcmV0cnksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi90cmFuc2FjdGlvbnMvYWRkcmVzcy9cIiArIGFkZHJlc3MgKyBcIi9saW1pdC9cIiArIGxpbWl0ICsgcXVlcnlfMS5kZWZhdWx0KHsgYWZ0ZXI6IGFmdGVyIH0pLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBfYVswXTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2FjdGlvbikgeyByZXR1cm4gdHJhbnNhY3Rpb25zXzEuYWRkU3RhdGVVcGRhdGVGaWVsZCh0cmFuc2FjdGlvbik7IH0pO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hUcmFuc2FjdGlvbnMgPSBmZXRjaFRyYW5zYWN0aW9ucztcbi8qKlxuICogR0VUIC90cmFuc2FjdGlvbnMvdW5jb25maXJtZWQvaW5mby97aWR9XG4gKiBVbmNvbmZpcm1lZCB0cmFuc2FjdGlvbiBpbmZvXG4gKi9cbmZ1bmN0aW9uIGZldGNoVW5jb25maXJtZWRJbmZvKGJhc2UsIGlkLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgIHJldHVybiByZXF1ZXN0XzEuZGVmYXVsdCh7XG4gICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgIHVybDogXCIvdHJhbnNhY3Rpb25zL3VuY29uZmlybWVkL2luZm8vXCIgKyBpZCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFVuY29uZmlybWVkSW5mbyA9IGZldGNoVW5jb25maXJtZWRJbmZvO1xuLy8gQFRPRE8gd2hlbiBjb3JyZWN0IEFQSSBrZXkgaXMgcmVjZWl2ZWRcbi8qKlxuICogUE9TVCAvdHJhbnNhY3Rpb25zL3NpZ25cbiAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICovXG4vKipcbiAqIEdFVCAvdHJhbnNhY3Rpb25zL2luZm8ve2lkfVxuICogVHJhbnNhY3Rpb24gaW5mb1xuICovXG5mdW5jdGlvbiBmZXRjaEluZm8oYmFzZSwgaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIHJlcXVlc3RfMS5kZWZhdWx0KHtcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgdXJsOiBcIi90cmFuc2FjdGlvbnMvaW5mby9cIiArIGlkLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSkudGhlbihmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHsgcmV0dXJuIHRyYW5zYWN0aW9uc18xLmFkZFN0YXRlVXBkYXRlRmllbGQodHJhbnNhY3Rpb24pOyB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hJbmZvID0gZmV0Y2hJbmZvO1xuZnVuY3Rpb24gZmV0Y2hTdGF0dXMoYmFzZSwgbGlzdCkge1xuICAgIHZhciBERUZBVUxUX1NUQVRVUyA9IHtcbiAgICAgICAgaWQ6ICcnLFxuICAgICAgICBjb25maXJtYXRpb25zOiAtMSxcbiAgICAgICAgaGVpZ2h0OiAtMSxcbiAgICAgICAgaW5VVFg6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlRSQU5TQUNUSU9OX1NUQVRVU0VTLk5PVF9GT1VORFxuICAgIH07XG4gICAgdmFyIGxvYWRBbGxUeEluZm8gPSBsaXN0Lm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoVW5jb25maXJtZWRJbmZvKGJhc2UsIGlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBERUZBVUxUX1NUQVRVUyksIHsgaWQ6IGlkLCBzdGF0dXM6IGNvbnN0YW50c18xLlRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQ09ORklSTUVELCBpblVUWDogdHJ1ZSB9KSk7IH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gZmV0Y2hJbmZvKGJhc2UsIGlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHR4KSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfU1RBVFVTKSwgeyBpZDogaWQsIHN0YXR1czogY29uc3RhbnRzXzEuVFJBTlNBQ1RJT05fU1RBVFVTRVMuSU5fQkxPQ0tDSEFJTiwgaGVpZ2h0OiB0eC5oZWlnaHQsIGFwcGxpY2F0aW9uU3RhdHVzOiB0eC5hcHBsaWNhdGlvblN0YXR1cyB9KSk7IH0pOyB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9TVEFUVVMpLCB7IGlkOiBpZCB9KSk7IH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGJsb2Nrc18xLmZldGNoSGVpZ2h0KGJhc2UpLFxuICAgICAgICBQcm9taXNlLmFsbChsb2FkQWxsVHhJbmZvKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBfYVswXS5oZWlnaHQsIHN0YXR1c2VzID0gX2FbMV07XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBzdGF0dXNlczogc3RhdHVzZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCB7IGNvbmZpcm1hdGlvbnM6IGl0ZW0uc3RhdHVzID09PSBjb25zdGFudHNfMS5UUkFOU0FDVElPTl9TVEFUVVNFUy5JTl9CTE9DS0NIQUlOID8gaGVpZ2h0IC0gaXRlbS5oZWlnaHQgOiBpdGVtLmNvbmZpcm1hdGlvbnMgfSkpOyB9KVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hTdGF0dXMgPSBmZXRjaFN0YXR1cztcbmZ1bmN0aW9uIGJyb2FkY2FzdChiYXNlLCB0eCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gcmVxdWVzdF8xLmRlZmF1bHQoe1xuICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICB1cmw6ICcvdHJhbnNhY3Rpb25zL2Jyb2FkY2FzdCcsXG4gICAgICAgIG9wdGlvbnM6IHV0aWxzXzEuZGVlcEFzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogc3RyaW5naWZ5XzEuZGVmYXVsdCh0eCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pO1xufVxuZXhwb3J0cy5icm9hZGNhc3QgPSBicm9hZGNhc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSBleHBvcnRzLk5BTUVfTUFQID0gZXhwb3J0cy5UWVBFX01BUCA9IHZvaWQgMDtcbmV4cG9ydHMuVFlQRV9NQVAgPSB7XG4gICAgMzogJ2lzc3VlJyxcbiAgICA0OiAndHJhbnNmZXInLFxuICAgIDU6ICdyZWlzc3VlJyxcbiAgICA2OiAnYnVybicsXG4gICAgNzogJ2V4Y2hhbmdlJyxcbiAgICA4OiAnbGVhc2UnLFxuICAgIDk6ICdjYW5jZWxMZWFzZScsXG4gICAgMTA6ICdhbGlhcycsXG4gICAgMTE6ICdtYXNzVHJhbnNmZXInLFxuICAgIDEyOiAnZGF0YScsXG4gICAgMTM6ICdzZXRTY3JpcHQnLFxuICAgIDE0OiAnc3BvbnNvcnNoaXAnLFxuICAgIDE1OiAnc2V0QXNzZXRTY3JpcHQnLFxuICAgIDE2OiAnaW52b2tlJyxcbiAgICAxNzogJ3VwZGF0ZUFzc2V0J1xufTtcbmV4cG9ydHMuTkFNRV9NQVAgPSB7XG4gICAgJ2lzc3VlJzogMyxcbiAgICAndHJhbnNmZXInOiA0LFxuICAgICdyZWlzc3VlJzogNSxcbiAgICAnYnVybic6IDYsXG4gICAgJ2V4Y2hhbmdlJzogNyxcbiAgICAnbGVhc2UnOiA4LFxuICAgICdjYW5jZWxMZWFzZSc6IDksXG4gICAgJ2FsaWFzJzogMTAsXG4gICAgJ21hc3NUcmFuc2Zlcic6IDExLFxuICAgICdkYXRhJzogMTIsXG4gICAgJ3NldFNjcmlwdCc6IDEzLFxuICAgICdzcG9uc29yc2hpcCc6IDE0LFxuICAgICdzZXRBc3NldFNjcmlwdCc6IDE1LFxuICAgICdpbnZva2UnOiAxNixcbiAgICAndXBkYXRlQXNzZXQnOiAxN1xufTtcbmV4cG9ydHMuVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSB7XG4gICAgSU5fQkxPQ0tDSEFJTjogJ2luX2Jsb2NrY2hhaW4nLFxuICAgIFVOQ09ORklSTUVEOiAndW5jb25maXJtZWQnLFxuICAgIE5PVF9GT1VORDogJ25vdF9mb3VuZCdcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmxvY2tzXzEgPSByZXF1aXJlKFwiLi4vLi4vYXBpLW5vZGUvYmxvY2tzXCIpO1xuZnVuY3Rpb24gZGVmYXVsdF8xKGJhc2UpIHtcbiAgICByZXR1cm4gYmxvY2tzXzEuZmV0Y2hIZWFkZXJzTGFzdChiYXNlKS50aGVuKGZ1bmN0aW9uIChoZWFkZXIpIHsgcmV0dXJuIGJhc2U1OERlY29kZShoZWFkZXIuZ2VuZXJhdG9yKVsxXTsgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG52YXIgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eic7XG52YXIgQUxQSEFCRVRfTUFQID0ge307XG5mb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgQUxQSEFCRVRfTUFQW0FMUEhBQkVULmNoYXJBdChpKV0gPSBpO1xufVxuZnVuY3Rpb24gYmFzZTU4RGVjb2RlKHN0cmluZykge1xuICAgIHZhciBieXRlcywgYywgY2FycnksIGosIGk7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cbiAgICBpID0gdm9pZCAwO1xuICAgIGogPSB2b2lkIDA7XG4gICAgYnl0ZXMgPSBbMF07XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBzdHJpbmdbaV07XG4gICAgICAgIGlmICghKGMgaW4gQUxQSEFCRVRfTUFQKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0Jhc2U1OC5kZWNvZGUgcmVjZWl2ZWQgdW5hY2NlcHRhYmxlIGlucHV0LiBDaGFyYWN0ZXIgXFwnJyArIGMgKyAnXFwnIGlzIG5vdCBpbiB0aGUgQmFzZTU4IGFscGhhYmV0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaiA9IDA7XG4gICAgICAgIHdoaWxlIChqIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBieXRlc1tqXSAqPSA1ODtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBieXRlc1swXSArPSBBTFBIQUJFVF9NQVBbY107XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIHdoaWxlIChqIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBieXRlc1tqXSArPSBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gYnl0ZXNbal0gPj4gODtcbiAgICAgICAgICAgIGJ5dGVzW2pdICY9IDB4ZmY7XG4gICAgICAgICAgICArK2o7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNhcnJ5KSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIGkgPSAwO1xuICAgIHdoaWxlIChzdHJpbmdbaV0gPT09ICcxJyAmJiBpIDwgc3RyaW5nLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE5ldHdvcmtCeXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlZyA9IG5ldyBSZWdFeHAoJygoPyFcXFxcXFxcXClcIlxcXFx3K1wiKTpcXFxccyooLT9bXFxcXGR8XFxcXC5dezE0LH0pJywgJ2cnKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShqc29uKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbi5yZXBsYWNlKHJlZywgXCIkMTpcXFwiJDJcXFwiXCIpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVmYXVsdF8xKHBhcmFtcywgZXZvbHZlcikge1xuICAgIGlmIChldm9sdmVyID09PSB2b2lkIDApIHsgZXZvbHZlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICB2YXIgcXVlcnkgPSBPYmplY3Qua2V5cyhwYXJhbXMpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gW2tleSwgcGFyYW1zW2tleV1dOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIHJldHVybiBba2V5LCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXZvbHZlciwga2V5KSA/IGV2b2x2ZXJba2V5XSh2YWx1ZSkgOiB2YWx1ZV07XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWx1ZSA9IF9hWzFdO1xuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIHJldHVybiBrZXkgKyBcIj1cIiArIHZhbHVlO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcmJyk7XG4gICAgcmV0dXJuIHF1ZXJ5Lmxlbmd0aCA/IFwiP1wiICsgcXVlcnkgOiAnJztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZXNvbHZlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzb2x2ZVwiKSk7XG52YXIgcGFyc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZVwiKSk7XG52YXIgcmVxdWVzdCA9IHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyA/IGZldGNoIDogcmVxdWlyZSgnbm9kZS1mZXRjaCcpO1xuZnVuY3Rpb24gZGVmYXVsdF8xKHBhcmFtcykge1xuICAgIHJldHVybiByZXF1ZXN0KHJlc29sdmVfMS5kZWZhdWx0KHBhcmFtcy51cmwsIHBhcmFtcy5iYXNlKSwgdXBkYXRlSGVhZGVycyhwYXJhbXMub3B0aW9ucykpXG4gICAgICAgIC50aGVuKHBhcnNlUmVzcG9uc2UpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShyKSB7XG4gICAgcmV0dXJuIHIudGV4dCgpLnRoZW4oZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIHIub2sgPyBwYXJzZV8xLmRlZmF1bHQobWVzc2FnZSkgOiBQcm9taXNlLnJlamVjdCh0cnlQYXJzZShtZXNzYWdlKSk7IH0pO1xufVxuZnVuY3Rpb24gdHJ5UGFyc2UobWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVIZWFkZXJzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgcmV0dXJuIF9fYXNzaWduKHsgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyB9LCBvcHRpb25zKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZhdWx0XzEocGF0aCwgYmFzZSkge1xuICAgIHJldHVybiBuZXcgVVJMKHBhdGgsIGJhc2UpLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZJRUxEUyA9IFsnYW1vdW50JywgJ21hdGNoZXJGZWUnLCAncHJpY2UnLCAnZmVlJywgJ21pblNwb25zb3JlZEFzc2V0RmVlJywgJ3F1YW50aXR5JywgJ3NlbGxNYXRjaGVyRmVlJywgJ2J1eU1hdGNoZXJGZWUnXTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChGSUVMRFMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiIVwiICsgdmFsdWUgKyBcIiFcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgdGhpc1sndHlwZSddID09PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBcIiFcIiArIHZhbHVlICsgXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCAwKS5yZXBsYWNlKC9cIlxcISgtP1xcZCspXFwhXCIvZywgJyQxJyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uLy4uL2FwaS1ub2RlL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHdhaXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93YWl0XCIpKTtcbnZhciBERUZBVUxUX0JST0FEQ0FTVF9PUFRJT05TID0ge1xuICAgIGNoYWluOiBmYWxzZSxcbiAgICBjb25maXJtYXRpb25zOiAtMSxcbiAgICBtYXhXYWl0VGltZTogMCxcbiAgICByZXF1ZXN0SW50ZXJ2YWw6IDBcbn07XG5mdW5jdGlvbiBkZWZhdWx0XzEoYmFzZSwgbGlzdCwgb3B0aW9ucykge1xuICAgIHZhciBvcHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgREVGQVVMVF9CUk9BRENBU1RfT1BUSU9OUyksIChvcHRpb25zIHx8IHt9KSk7XG4gICAgdmFyIGlzT25jZSA9ICFBcnJheS5pc0FycmF5KGxpc3QpO1xuICAgIHZhciBjb25maXJtYXRpb25zID0gb3B0LmNvbmZpcm1hdGlvbnMgPiAwID8gMSA6IDA7XG4gICAgcmV0dXJuIChvcHQuY2hhaW5cbiAgICAgICAgPyBjaGFpbkJyb2FkY2FzdChiYXNlLCB1dGlsc18xLnRvQXJyYXkobGlzdCksIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHQpLCB7IGNvbmZpcm1hdGlvbnM6IGNvbmZpcm1hdGlvbnMgfSkpXG4gICAgICAgIDogc2ltcGxlQnJvYWRjYXN0KGJhc2UsIHV0aWxzXzEudG9BcnJheShsaXN0KSkpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBvcHQuY29uZmlybWF0aW9ucyA8PSAwID8gbGlzdCA6IHdhaXRfMS5kZWZhdWx0KGJhc2UsIGxpc3QsIG9wdCk7IH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBpc09uY2UgPyB1dGlsc18xLmhlYWQobGlzdCkgOiBsaXN0OyB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbmZ1bmN0aW9uIHNpbXBsZUJyb2FkY2FzdChiYXNlLCBsaXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGxpc3QubWFwKGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gdHJhbnNhY3Rpb25zXzEuYnJvYWRjYXN0KGJhc2UsIHR4KTsgfSkpO1xufVxuZnVuY3Rpb24gY2hhaW5Ccm9hZGNhc3QoYmFzZSwgbGlzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0b0Jyb2FkY2FzdCA9IGxpc3Quc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRvQnJvYWRjYXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eCA9IHRvQnJvYWRjYXN0LnBvcCgpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zXzEuYnJvYWRjYXN0KGJhc2UsIHR4KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gd2FpdF8xLmRlZmF1bHQoYmFzZSwgdHgsIG9wdGlvbnMpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR4KTtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBsb29wKCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm9hZGNhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYWtlU3RhdGVVcGRhdGUgPSBleHBvcnRzLmFkZFN0YXRlVXBkYXRlRmllbGQgPSB2b2lkIDA7XG52YXIgYmlnbnVtYmVyXzEgPSByZXF1aXJlKFwiQHdhdmVzL2JpZ251bWJlclwiKTtcbnZhciB0c190eXBlc18xID0gcmVxdWlyZShcIkB3YXZlcy90cy10eXBlc1wiKTtcbmZ1bmN0aW9uIGFkZFN0YXRlVXBkYXRlRmllbGQodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PT0gdHNfdHlwZXNfMS5UUkFOU0FDVElPTl9UWVBFLklOVk9LRV9TQ1JJUFQgJiYgdHJhbnNhY3Rpb24uc3RhdGVDaGFuZ2VzLmludm9rZXMgJiYgdHJhbnNhY3Rpb24uc3RhdGVDaGFuZ2VzLmludm9rZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXltZW50c18xID0gdHJhbnNhY3Rpb24ucGF5bWVudCA/IHRyYW5zYWN0aW9uLnBheW1lbnQubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgYXNzZXRJZDogcC5hc3NldElkLFxuICAgICAgICAgICAgYW1vdW50OiBwLmFtb3VudFxuICAgICAgICB9KTsgfSkgOiBbXTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFuc2FjdGlvbiwgJ3N0YXRlVXBkYXRlJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VTdGF0ZVVwZGF0ZSh0cmFuc2FjdGlvbi5zdGF0ZUNoYW5nZXMsIHBheW1lbnRzXzEsIHRyYW5zYWN0aW9uLmRBcHAsIHRyYW5zYWN0aW9uLnNlbmRlcik7IH0gfSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xufVxuZXhwb3J0cy5hZGRTdGF0ZVVwZGF0ZUZpZWxkID0gYWRkU3RhdGVVcGRhdGVGaWVsZDtcbmZ1bmN0aW9uIG1ha2VTdGF0ZVVwZGF0ZShzdGF0ZUNoYW5nZXMsIHBheW1lbnQsIGRBcHAsIHNlbmRlcikge1xuICAgIHZhciBwYXltZW50cyA9IHBheW1lbnQubWFwKGZ1bmN0aW9uIChwYXltZW50KSB7IHJldHVybiAoeyBwYXltZW50OiBwYXltZW50LCBkQXBwOiBkQXBwLCBzZW5kZXI6IHNlbmRlciB9KTsgfSk7XG4gICAgdmFyIGFkZEZpZWxkID0gZnVuY3Rpb24gKGFycmF5LCBmaWVsZE5hbWUpIHsgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0pLCAoX2EgPSB7fSwgX2FbZmllbGROYW1lXSA9IGRBcHAsIF9hKSkpO1xuICAgIH0pOyB9O1xuICAgIHZhciB0cmFuc2ZlcnMgPSBhZGRGaWVsZChzdGF0ZUNoYW5nZXMudHJhbnNmZXJzLCAnc2VuZGVyJyk7XG4gICAgdmFyIGxlYXNlcyA9IGFkZEZpZWxkKHN0YXRlQ2hhbmdlcy5sZWFzZXMsICdzZW5kZXInKTtcbiAgICB2YXIgaXNzdWVzID0gYWRkRmllbGQoc3RhdGVDaGFuZ2VzLmlzc3VlcywgJ2FkZHJlc3MnKTtcbiAgICB2YXIgZGF0YSA9IGFkZEZpZWxkKHN0YXRlQ2hhbmdlcy5kYXRhLCAnYWRkcmVzcycpO1xuICAgIHZhciByZWlzc3VlcyA9IGFkZEZpZWxkKHN0YXRlQ2hhbmdlcy5yZWlzc3VlcywgJ2FkZHJlc3MnKTtcbiAgICB2YXIgYnVybnMgPSBhZGRGaWVsZChzdGF0ZUNoYW5nZXMuYnVybnMsICdhZGRyZXNzJyk7XG4gICAgdmFyIHNwb25zb3JGZWVzID0gYWRkRmllbGQoc3RhdGVDaGFuZ2VzLnNwb25zb3JGZWVzLCAnYWRkcmVzcycpO1xuICAgIHZhciBsZWFzZUNhbmNlbHMgPSBhZGRGaWVsZChzdGF0ZUNoYW5nZXMubGVhc2VDYW5jZWxzLCAnYWRkcmVzcycpO1xuICAgIHZhciBzdGF0ZVVwZGF0ZSA9IHtcbiAgICAgICAgcGF5bWVudHM6IHBheW1lbnRzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB0cmFuc2ZlcnM6IHRyYW5zZmVycyxcbiAgICAgICAgcmVpc3N1ZXM6IHJlaXNzdWVzLFxuICAgICAgICBpc3N1ZXM6IGlzc3VlcyxcbiAgICAgICAgYnVybnM6IGJ1cm5zLFxuICAgICAgICBzcG9uc29yRmVlczogc3BvbnNvckZlZXMsXG4gICAgICAgIGxlYXNlczogbGVhc2VzLFxuICAgICAgICBsZWFzZUNhbmNlbHM6IGxlYXNlQ2FuY2VscyxcbiAgICB9O1xuICAgIHZhciByZWN1cnNpdmVGdW5jdGlvbiA9IGZ1bmN0aW9uIChzdGF0ZUNoYW5nZXMsIHNlbmRlcikge1xuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VzLmludm9rZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZUNoYW5nZXMuaW52b2tlcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgLy9wYXltZW50c1xuICAgICAgICAgICAgICAgIGlmICh4LnBheW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHgucGF5bWVudC5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXltZW50cy5maW5kSW5kZXgoZnVuY3Rpb24gKHopIHsgcmV0dXJuICh6LnBheW1lbnQuYXNzZXRJZCA9PT0geS5hc3NldElkKSAmJiAoei5kQXBwID09PSB4LmRBcHApICYmIChzZW5kZXIgPT09IHguZEFwcCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggIT09IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXltZW50c1tpbmRleF0ucGF5bWVudC5hbW91bnQgPSAobmV3IGJpZ251bWJlcl8xLkJpZ051bWJlcihwYXltZW50c1tpbmRleF0ucGF5bWVudC5hbW91bnQpKS5hZGQoeS5hbW91bnQpLnRvTnVtYmVyKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHBheW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50OiB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IHNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZEFwcDogeC5kQXBwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vZGF0YVxuICAgICAgICAgICAgICAgIHguc3RhdGVDaGFuZ2VzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZVVwZGF0ZS5kYXRhLmZpbmRJbmRleChmdW5jdGlvbiAoeikgeyByZXR1cm4gei5rZXkgPT09IHkua2V5ICYmIHouYWRkcmVzcyA9PT0geC5kQXBwOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggIT09IC0xID8gc3RhdGVVcGRhdGUuZGF0YVtpbmRleF0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgeSksIHsgYWRkcmVzczogeC5kQXBwIH0pIDogc3RhdGVVcGRhdGUuZGF0YS5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCB5KSwgeyBhZGRyZXNzOiB4LmRBcHAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vYnVybnNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy5idXJucy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXRlVXBkYXRlLmJ1cm5zLmZpbmRJbmRleChmdW5jdGlvbiAoeikgeyByZXR1cm4gei5hc3NldElkID09PSB5LmFzc2V0SWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAhPT0gLTEgPyBzdGF0ZVVwZGF0ZS5idXJuc1tpbmRleF0ucXVhbnRpdHkgKz0geS5xdWFudGl0eSA6IHN0YXRlVXBkYXRlLmJ1cm5zLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHkpLCB7IGFkZHJlc3M6IHguZEFwcCB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy9pc3N1ZXNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy5pc3N1ZXMuZm9yRWFjaChmdW5jdGlvbiAoeSkgeyByZXR1cm4gc3RhdGVVcGRhdGUuaXNzdWVzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHkpLCB7IGFkZHJlc3M6IHguZEFwcCB9KSk7IH0pO1xuICAgICAgICAgICAgICAgIC8vcmVpc3N1ZXNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy5yZWlzc3Vlcy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXRlVXBkYXRlLnJlaXNzdWVzLmZpbmRJbmRleChmdW5jdGlvbiAoeikgeyByZXR1cm4gei5hc3NldElkID09PSB5LmFzc2V0SWQ7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAhPT0gLTEgPyBzdGF0ZVVwZGF0ZS5yZWlzc3Vlc1tpbmRleF0ucXVhbnRpdHkgKz0geS5xdWFudGl0eSA6IHN0YXRlVXBkYXRlLnJlaXNzdWVzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHkpLCB7IGFkZHJlc3M6IHguZEFwcCB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy90cmFuc2ZlcnNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy50cmFuc2ZlcnMuZm9yRWFjaChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZVVwZGF0ZS50cmFuc2ZlcnMuZmluZEluZGV4KGZ1bmN0aW9uICh6KSB7IHJldHVybiAoei5hc3NldCA9PT0geS5hc3NldCkgJiYgKHouYWRkcmVzcyA9PT0geS5hZGRyZXNzKSAmJiAoeC5kQXBwID09PSB6LnNlbmRlcik7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAhPT0gLTFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3RhdGVVcGRhdGUudHJhbnNmZXJzW2luZGV4XS5hbW91bnQgPSAobmV3IGJpZ251bWJlcl8xLkJpZ051bWJlcihzdGF0ZVVwZGF0ZS50cmFuc2ZlcnNbaW5kZXhdLmFtb3VudCkpLmFkZCh5LmFtb3VudCkudG9OdW1iZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGF0ZVVwZGF0ZS50cmFuc2ZlcnMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgeSksIHsgc2VuZGVyOiB4LmRBcHAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vc3BvbnNvckZlZXNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy5zcG9uc29yRmVlcy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHN0YXRlVXBkYXRlLnNwb25zb3JGZWVzLmZpbmRJbmRleChmdW5jdGlvbiAoeikgeyByZXR1cm4gKHouYXNzZXRJZCA9PT0geS5hc3NldElkKSAmJiAoei5hZGRyZXNzID09PSB4LmRBcHApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggIT09IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0YXRlVXBkYXRlLnNwb25zb3JGZWVzW2luZGV4XSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB5KSwgeyBhZGRyZXNzOiB4LmRBcHAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhdGVVcGRhdGUuc3BvbnNvckZlZXMucHVzaChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgeSksIHsgYWRkcmVzczogeC5kQXBwIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvL2xlYXNlIGFuZCBsZWFzZUNhbmNlbHNcbiAgICAgICAgICAgICAgICB4LnN0YXRlQ2hhbmdlcy5sZWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoeSkgeyByZXR1cm4gc3RhdGVVcGRhdGUubGVhc2VzLnB1c2goX19hc3NpZ24oX19hc3NpZ24oe30sIHkpLCB7IHNlbmRlcjogeC5kQXBwIH0pKTsgfSk7XG4gICAgICAgICAgICAgICAgeC5zdGF0ZUNoYW5nZXMubGVhc2VDYW5jZWxzLmZvckVhY2goZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHN0YXRlVXBkYXRlLmxlYXNlQ2FuY2Vscy5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCB5KSwgeyBhZGRyZXNzOiB4LmRBcHAgfSkpOyB9KTtcbiAgICAgICAgICAgICAgICByZWN1cnNpdmVGdW5jdGlvbih4LnN0YXRlQ2hhbmdlcywgeC5kQXBwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZWN1cnNpdmVGdW5jdGlvbihzdGF0ZUNoYW5nZXMsIHNlbmRlcik7XG4gICAgcmV0dXJuIHN0YXRlVXBkYXRlO1xufVxuZXhwb3J0cy5tYWtlU3RhdGVVcGRhdGUgPSBtYWtlU3RhdGVVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9hcGktbm9kZS90cmFuc2FjdGlvbnNcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xuZnVuY3Rpb24gZGVmYXVsdF8xKGJhc2UsIHR4LCBvcHRpb25zKSB7XG4gICAgdmFyIGlzT25jZSA9ICFBcnJheS5pc0FycmF5KHR4KTtcbiAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHZhciBjb25maXJtZWQgPSBbXTtcbiAgICB2YXIgY29uZmlybWF0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb25maXJtYXRpb25zIHx8IDA7XG4gICAgdmFyIG1heFdhaXRUaW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLm1heFdhaXRUaW1lIHx8IDA7XG4gICAgdmFyIHJlcXVlc3RJbnRlcnZhbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXF1ZXN0SW50ZXJ2YWwgfHwgMjUwO1xuICAgIHZhciB3YWl0VHggPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25zXzEuZmV0Y2hTdGF0dXMoYmFzZSwgbGlzdC5tYXAodXRpbHNfMS5wcm9wKCdpZCcpKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gdXRpbHNfMS5pbmRleEJ5KHV0aWxzXzEucHJvcCgnaWQnKSwgc3RhdHVzLnN0YXR1c2VzKTtcbiAgICAgICAgICAgIHZhciBoYXNFcnJvciA9IGxpc3Quc29tZShmdW5jdGlvbiAodHgpIHsgcmV0dXJuIGhhc2hbdHguaWRdLnN0YXR1cyA9PT0gY29uc3RhbnRzXzEuVFJBTlNBQ1RJT05fU1RBVFVTRVMuTk9UX0ZPVU5EOyB9KTtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIHRyYW5zYWN0aW9uIGlzIG5vdCBpbiBibG9ja2NoYWluIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvUmVxdWVzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNoW3R4LmlkXS5jb25maXJtYXRpb25zID49IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlybWVkLnB1c2godHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghdG9SZXF1ZXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4V2FpdFRpbWUgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0ID4gbWF4V2FpdFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1RpbWVvdXQgZXJyb3IhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXRpbHNfMS53YWl0KHJlcXVlc3RJbnRlcnZhbCkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB3YWl0VHgodG9SZXF1ZXN0KTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHdhaXRUeCh1dGlsc18xLnRvQXJyYXkodHgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzT25jZSA/IHV0aWxzXzEuaGVhZChjb25maXJtZWQpIDogY29uZmlybWVkOyB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpcGUgPSBleHBvcnRzLnN3aXRjaFRyYW5zYWN0aW9uQnlUeXBlID0gZXhwb3J0cy51bmlxID0gZXhwb3J0cy5pbmRleEJ5ID0gZXhwb3J0cy5maWx0ZXIgPSBleHBvcnRzLm1hcCA9IGV4cG9ydHMuZGVlcEFzc2lnbiA9IGV4cG9ydHMuYXNzaWduID0gZXhwb3J0cy52YWx1ZXMgPSBleHBvcnRzLmVudHJpZXMgPSBleHBvcnRzLmtleXMgPSBleHBvcnRzLnByb3AgPSBleHBvcnRzLndhaXQgPSBleHBvcnRzLmhlYWQgPSBleHBvcnRzLnRvQXJyYXkgPSBleHBvcnRzLmlzT2JqZWN0ID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldFByb3RvdHlwZU9mID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgICAgIHJldHVybiBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHwgcHJvdG90eXBlID09PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZnVuY3Rpb24gdG9BcnJheShkYXRhKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGF0YSkgPyBkYXRhIDogW2RhdGFdO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcbmZ1bmN0aW9uIGhlYWQoZGF0YSkge1xuICAgIHJldHVybiBkYXRhWzBdO1xufVxuZXhwb3J0cy5oZWFkID0gaGVhZDtcbmZ1bmN0aW9uIHdhaXQodGltZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy53YWl0ID0gd2FpdDtcbmZ1bmN0aW9uIHByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBkYXRhW2tleV07IH07XG59XG5leHBvcnRzLnByb3AgPSBwcm9wO1xuZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xufTtcbmV4cG9ydHMuZW50cmllcyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbbmFtZSwgb2JqW25hbWVdXTsgfSk7XG59O1xuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XTsgfSk7XG59O1xuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0LCBtZXJnZSkge1xuICAgIHJldHVybiBleHBvcnRzLmVudHJpZXMobWVyZ2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5leHBvcnRzLmRlZXBBc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLnJlZHVjZShmdW5jdGlvbiAodGFyZ2V0LCBtZXJnZSkge1xuICAgICAgICBleHBvcnRzLmtleXMobWVyZ2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pICYmIEFycmF5LmlzQXJyYXkobWVyZ2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IEFycmF5LmZyb20obmV3IFNldCh0YXJnZXRba2V5XS5jb25jYXQobWVyZ2Vba2V5XSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc09iamVjdChtZXJnZVtrZXldKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5kZWVwQXNzaWduKHRhcmdldFtrZXldLCBtZXJnZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSwgb2JqZWN0c1swXSB8fCB7fSk7XG59O1xuZnVuY3Rpb24gbWFwKHByb2Nlc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QubWFwKHByb2Nlc3MpOyB9O1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG5mdW5jdGlvbiBmaWx0ZXIocHJvY2Vzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5maWx0ZXIocHJvY2Vzcyk7IH07XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmZ1bmN0aW9uIGluZGV4QnkocHJvY2VzcywgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICAgIGFjY1twcm9jZXNzKGl0ZW0pXSA9IGl0ZW07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5pbmRleEJ5ID0gaW5kZXhCeTtcbmV4cG9ydHMudW5pcSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMua2V5cyhsaXN0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtICE9IG51bGwpXG4gICAgICAgICAgICBhY2NbaXRlbV0gPSBpdGVtO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbn07XG5mdW5jdGlvbiBzd2l0Y2hUcmFuc2FjdGlvbkJ5VHlwZShjaG9pY2VzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gY2hvaWNlc1t0eC50eXBlXSAmJiB0eXBlb2YgY2hvaWNlc1t0eC50eXBlXSA9PT0gJ2Z1bmN0aW9uJyA/IGNob2ljZXNbdHgudHlwZV0odHgpIDogdW5kZWZpbmVkOyB9O1xufVxuZXhwb3J0cy5zd2l0Y2hUcmFuc2FjdGlvbkJ5VHlwZSA9IHN3aXRjaFRyYW5zYWN0aW9uQnlUeXBlO1xuZXhwb3J0cy5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGl0ZW0pIHsgcmV0dXJuIGl0ZW0oYWNjKTsgfSwgZGF0YSk7IH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5wcm92aWRlclNlZWQ9dCgpOmUucHJvdmlkZXJTZWVkPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz04Mil9KFtmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5UUkFOU0FDVElPTl9UWVBFPXtJU1NVRTozLFRSQU5TRkVSOjQsUkVJU1NVRTo1LEJVUk46NixFWENIQU5HRTo3LExFQVNFOjgsQ0FOQ0VMX0xFQVNFOjksQUxJQVM6MTAsTUFTU19UUkFOU0ZFUjoxMSxEQVRBOjEyLFNFVF9TQ1JJUFQ6MTMsU1BPTlNPUlNISVA6MTQsU0VUX0FTU0VUX1NDUklQVDoxNSxJTlZPS0VfU0NSSVBUOjE2fSx0LkRBVEFfRklFTERfVFlQRT17SU5URUdFUjpcImludGVnZXJcIixCT09MRUFOOlwiYm9vbGVhblwiLEJJTkFSWTpcImJpbmFyeVwiLFNUUklORzpcInN0cmluZ1wifX0sZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9e29wdGlvbnM6e3VzZVB1cmVKYXZhU2NyaXB0OiExfX19LGZ1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24odCxuLGksYSl7dmFyIHM9cigxKSxvPXIoODkpLHU9ZS5leHBvcnRzPXMudXRpbD1zLnV0aWx8fHt9O2Z1bmN0aW9uIGMoZSl7aWYoOCE9PWUmJjE2IT09ZSYmMjQhPT1lJiYzMiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiT25seSA4LCAxNiwgMjQsIG9yIDMyIGJpdHMgc3VwcG9ydGVkOiBcIitlKX1mdW5jdGlvbiBsKGUpe2lmKHRoaXMuZGF0YT1cIlwiLHRoaXMucmVhZD0wLFwic3RyaW5nXCI9PXR5cGVvZiBlKXRoaXMuZGF0YT1lO2Vsc2UgaWYodS5pc0FycmF5QnVmZmVyKGUpfHx1LmlzQXJyYXlCdWZmZXJWaWV3KGUpKWlmKHZvaWQgMCE9PWEmJmUgaW5zdGFuY2VvZiBhKXRoaXMuZGF0YT1lLnRvU3RyaW5nKFwiYmluYXJ5XCIpO2Vsc2V7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoZSk7dHJ5e3RoaXMuZGF0YT1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsdCl9Y2F0Y2goZSl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpdGhpcy5wdXRCeXRlKHRbcl0pfX1lbHNlKGUgaW5zdGFuY2VvZiBsfHxcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJzdHJpbmdcIj09dHlwZW9mIGUuZGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmVhZCkmJih0aGlzLmRhdGE9ZS5kYXRhLHRoaXMucmVhZD1lLnJlYWQpO3RoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoPTB9IWZ1bmN0aW9uKCl7aWYodm9pZCAwIT09dCYmdC5uZXh0VGljayYmIXQuYnJvd3NlcilyZXR1cm4gdS5uZXh0VGljaz10Lm5leHRUaWNrLHZvaWQodS5zZXRJbW1lZGlhdGU9XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uOnUubmV4dFRpY2spO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIHUuc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG4uYXBwbHkodm9pZCAwLGFyZ3VtZW50cyl9LHZvaWQodS5uZXh0VGljaz1mdW5jdGlvbihlKXtyZXR1cm4gbihlKX0pO2lmKHUuc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZSwwKX0sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlKXt2YXIgZT1cImZvcmdlLnNldEltbWVkaWF0ZVwiLHI9W107dS5zZXRJbW1lZGlhdGU9ZnVuY3Rpb24odCl7ci5wdXNoKHQpLDE9PT1yLmxlbmd0aCYmd2luZG93LnBvc3RNZXNzYWdlKGUsXCIqXCIpfSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24odCl7aWYodC5zb3VyY2U9PT13aW5kb3cmJnQuZGF0YT09PWUpe3Quc3RvcFByb3BhZ2F0aW9uKCk7dmFyIG49ci5zbGljZSgpO3IubGVuZ3RoPTAsbi5mb3JFYWNoKChmdW5jdGlvbihlKXtlKCl9KSl9fSksITApfWlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNdXRhdGlvbk9ic2VydmVyKXt2YXIgaT1EYXRlLm5vdygpLGE9ITAscz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3I9W107bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGZ1bmN0aW9uKCl7dmFyIGU9ci5zbGljZSgpO3IubGVuZ3RoPTAsZS5mb3JFYWNoKChmdW5jdGlvbihlKXtlKCl9KSl9KSkub2JzZXJ2ZShzLHthdHRyaWJ1dGVzOiEwfSk7dmFyIG89dS5zZXRJbW1lZGlhdGU7dS5zZXRJbW1lZGlhdGU9ZnVuY3Rpb24oZSl7RGF0ZS5ub3coKS1pPjE1PyhpPURhdGUubm93KCksbyhlKSk6KHIucHVzaChlKSwxPT09ci5sZW5ndGgmJnMuc2V0QXR0cmlidXRlKFwiYVwiLGE9IWEpKX19dS5uZXh0VGljaz11LnNldEltbWVkaWF0ZX0oKSx1LmlzTm9kZWpzPXZvaWQgMCE9PXQmJnQudmVyc2lvbnMmJnQudmVyc2lvbnMubm9kZSx1Lmdsb2JhbFNjb3BlPXUuaXNOb2RlanM/aTpcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj93aW5kb3c6c2VsZix1LmlzQXJyYXk9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfSx1LmlzQXJyYXlCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9LHUuaXNBcnJheUJ1ZmZlclZpZXc9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJnUuaXNBcnJheUJ1ZmZlcihlLmJ1ZmZlcikmJnZvaWQgMCE9PWUuYnl0ZUxlbmd0aH0sdS5CeXRlQnVmZmVyPWwsdS5CeXRlU3RyaW5nQnVmZmVyPWw7dS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZz1mdW5jdGlvbihlKXt0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aCs9ZSx0aGlzLl9jb25zdHJ1Y3RlZFN0cmluZ0xlbmd0aD40MDk2JiYodGhpcy5kYXRhLnN1YnN0cigwLDEpLHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoPTApfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGEubGVuZ3RoLXRoaXMucmVhZH0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RoKCk8PTB9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGU9ZnVuY3Rpb24oZSx0KXtlPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk7Zm9yKHZhciByPXRoaXMuZGF0YTt0PjA7KTEmdCYmKHIrPWUpLCh0Pj4+PTEpPjAmJihlKz1lKTtyZXR1cm4gdGhpcy5kYXRhPXIsdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyh0KSx0aGlzfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRhdGErPWUsdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhlLmxlbmd0aCksdGhpc30sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHV0Qnl0ZXModS5lbmNvZGVVdGY4KGUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjgmMjU1KStTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZlKSl9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MjQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucHV0Qnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShlPj4xNiYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjI0JjI1NSkrU3RyaW5nLmZyb21DaGFyQ29kZShlPj4xNiYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNExlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+MTYmMjU1KSl9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXRCeXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZlKStTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjgmMjU1KStTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjE2JjI1NSkrU3RyaW5nLmZyb21DaGFyQ29kZShlPj4yNCYyNTUpKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQ9ZnVuY3Rpb24oZSx0KXtjKHQpO3ZhciByPVwiXCI7ZG97dC09OCxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGU+PnQmMjU1KX13aGlsZSh0PjApO3JldHVybiB0aGlzLnB1dEJ5dGVzKHIpfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludD1mdW5jdGlvbihlLHQpe3JldHVybiBlPDAmJihlKz0yPDx0LTEpLHRoaXMucHV0SW50KGUsdCl9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1dEJ5dGVzKGUuZ2V0Qnl0ZXMoKSl9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyl9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTY9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpPDw4XnRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsxKTtyZXR1cm4gdGhpcy5yZWFkKz0yLGV9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpPDwxNl50aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrMSk8PDhedGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzIpO3JldHVybiB0aGlzLnJlYWQrPTMsZX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCk8PDI0XnRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsxKTw8MTZedGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzIpPDw4XnRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCszKTtyZXR1cm4gdGhpcy5yZWFkKz00LGV9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCledGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzEpPDw4O3JldHVybiB0aGlzLnJlYWQrPTIsZX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKV50aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrMSk8PDhedGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzIpPDwxNjtyZXR1cm4gdGhpcy5yZWFkKz0zLGV9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCledGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzEpPDw4XnRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCsyKTw8MTZedGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKzMpPDwyNDtyZXR1cm4gdGhpcy5yZWFkKz00LGV9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50PWZ1bmN0aW9uKGUpe2MoZSk7dmFyIHQ9MDtkb3t0PSh0PDw4KSt0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyksZS09OH13aGlsZShlPjApO3JldHVybiB0fSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldEludChlKSxyPTI8PGUtMjtyZXR1cm4gdD49ciYmKHQtPXI8PDEpLHR9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIGU/KGU9TWF0aC5taW4odGhpcy5sZW5ndGgoKSxlKSx0PXRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsdGhpcy5yZWFkK2UpLHRoaXMucmVhZCs9ZSk6MD09PWU/dD1cIlwiOih0PTA9PT10aGlzLnJlYWQ/dGhpcy5kYXRhOnRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpLHRoaXMuY2xlYXIoKSksdH0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZT90aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTp0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLHRoaXMucmVhZCtlKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkK2UpfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldEF0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZGF0YT10aGlzLmRhdGEuc3Vic3RyKDAsdGhpcy5yZWFkK2UpK1N0cmluZy5mcm9tQ2hhckNvZGUodCkrdGhpcy5kYXRhLnN1YnN0cih0aGlzLnJlYWQrZSsxKSx0aGlzfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxhc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5kYXRhLmxlbmd0aC0xKX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKCl7dmFyIGU9dS5jcmVhdGVCdWZmZXIodGhpcy5kYXRhKTtyZXR1cm4gZS5yZWFkPXRoaXMucmVhZCxlfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmNvbXBhY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkPjAmJih0aGlzLmRhdGE9dGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCksdGhpcy5yZWFkPTApLHRoaXN9LHUuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhPVwiXCIsdGhpcy5yZWFkPTAsdGhpc30sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZT1mdW5jdGlvbihlKXt2YXIgdD1NYXRoLm1heCgwLHRoaXMubGVuZ3RoKCktZSk7cmV0dXJuIHRoaXMuZGF0YT10aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCx0KSx0aGlzLnJlYWQ9MCx0aGlzfSx1LkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvSGV4PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVwiXCIsdD10aGlzLnJlYWQ7dDx0aGlzLmRhdGEubGVuZ3RoOysrdCl7dmFyIHI9dGhpcy5kYXRhLmNoYXJDb2RlQXQodCk7cjwxNiYmKGUrPVwiMFwiKSxlKz1yLnRvU3RyaW5nKDE2KX1yZXR1cm4gZX0sdS5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB1LmRlY29kZVV0ZjgodGhpcy5ieXRlcygpKX0sdS5EYXRhQnVmZmVyPWZ1bmN0aW9uKGUsdCl7dD10fHx7fSx0aGlzLnJlYWQ9dC5yZWFkT2Zmc2V0fHwwLHRoaXMuZ3Jvd1NpemU9dC5ncm93U2l6ZXx8MTAyNDt2YXIgcj11LmlzQXJyYXlCdWZmZXIoZSksbj11LmlzQXJyYXlCdWZmZXJWaWV3KGUpO2lmKHJ8fG4pcmV0dXJuIHRoaXMuZGF0YT1yP25ldyBEYXRhVmlldyhlKTpuZXcgRGF0YVZpZXcoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCksdm9pZCh0aGlzLndyaXRlPVwid3JpdGVPZmZzZXRcImluIHQ/dC53cml0ZU9mZnNldDp0aGlzLmRhdGEuYnl0ZUxlbmd0aCk7dGhpcy5kYXRhPW5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpLHRoaXMud3JpdGU9MCxudWxsIT1lJiZ0aGlzLnB1dEJ5dGVzKGUpLFwid3JpdGVPZmZzZXRcImluIHQmJih0aGlzLndyaXRlPXQud3JpdGVPZmZzZXQpfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmxlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLndyaXRlLXRoaXMucmVhZH0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RoKCk8PTB9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYWNjb21tb2RhdGU9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmxlbmd0aCgpPj1lKXJldHVybiB0aGlzO3Q9TWF0aC5tYXgodHx8dGhpcy5ncm93U2l6ZSxlKTt2YXIgcj1uZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLHRoaXMuZGF0YS5ieXRlT2Zmc2V0LHRoaXMuZGF0YS5ieXRlTGVuZ3RoKSxuPW5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKCkrdCk7cmV0dXJuIG4uc2V0KHIpLHRoaXMuZGF0YT1uZXcgRGF0YVZpZXcobi5idWZmZXIpLHRoaXN9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hY2NvbW1vZGF0ZSgxKSx0aGlzLmRhdGEuc2V0VWludDgodGhpcy53cml0ZSsrLGUpLHRoaXN9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlPWZ1bmN0aW9uKGUsdCl7dGhpcy5hY2NvbW1vZGF0ZSh0KTtmb3IodmFyIHI9MDtyPHQ7KytyKXRoaXMuZGF0YS5zZXRVaW50OChlKTtyZXR1cm4gdGhpc30sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcz1mdW5jdGlvbihlLHQpe2lmKHUuaXNBcnJheUJ1ZmZlclZpZXcoZSkpe3ZhciByPShuPW5ldyBVaW50OEFycmF5KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpKS5ieXRlTGVuZ3RoLW4uYnl0ZU9mZnNldDtyZXR1cm4gdGhpcy5hY2NvbW1vZGF0ZShyKSxuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLHRoaXMud3JpdGUpLnNldChuKSx0aGlzLndyaXRlKz1yLHRoaXN9aWYodS5pc0FycmF5QnVmZmVyKGUpKXt2YXIgbj1uZXcgVWludDhBcnJheShlKTtyZXR1cm4gdGhpcy5hY2NvbW1vZGF0ZShuLmJ5dGVMZW5ndGgpLG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIpLnNldChuLHRoaXMud3JpdGUpLHRoaXMud3JpdGUrPW4uYnl0ZUxlbmd0aCx0aGlzfWlmKGUgaW5zdGFuY2VvZiB1LkRhdGFCdWZmZXJ8fFwib2JqZWN0XCI9PXR5cGVvZiBlJiZcIm51bWJlclwiPT10eXBlb2YgZS5yZWFkJiZcIm51bWJlclwiPT10eXBlb2YgZS53cml0ZSYmdS5pc0FycmF5QnVmZmVyVmlldyhlLmRhdGEpKXtuPW5ldyBVaW50OEFycmF5KGUuZGF0YS5ieXRlTGVuZ3RoLGUucmVhZCxlLmxlbmd0aCgpKTtyZXR1cm4gdGhpcy5hY2NvbW1vZGF0ZShuLmJ5dGVMZW5ndGgpLG5ldyBVaW50OEFycmF5KGUuZGF0YS5ieXRlTGVuZ3RoLHRoaXMud3JpdGUpLnNldChuKSx0aGlzLndyaXRlKz1uLmJ5dGVMZW5ndGgsdGhpc31pZihlIGluc3RhbmNlb2YgdS5CeXRlU3RyaW5nQnVmZmVyJiYoZT1lLmRhdGEsdD1cImJpbmFyeVwiKSx0PXR8fFwiYmluYXJ5XCIsXCJzdHJpbmdcIj09dHlwZW9mIGUpe3ZhciBpO2lmKFwiaGV4XCI9PT10KXJldHVybiB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChlLmxlbmd0aC8yKSksaT1uZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLHRoaXMud3JpdGUpLHRoaXMud3JpdGUrPXUuYmluYXJ5LmhleC5kZWNvZGUoZSxpLHRoaXMud3JpdGUpLHRoaXM7aWYoXCJiYXNlNjRcIj09PXQpcmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMypNYXRoLmNlaWwoZS5sZW5ndGgvNCkpLGk9bmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcix0aGlzLndyaXRlKSx0aGlzLndyaXRlKz11LmJpbmFyeS5iYXNlNjQuZGVjb2RlKGUsaSx0aGlzLndyaXRlKSx0aGlzO2lmKFwidXRmOFwiPT09dCYmKGU9dS5lbmNvZGVVdGY4KGUpLHQ9XCJiaW5hcnlcIiksXCJiaW5hcnlcIj09PXR8fFwicmF3XCI9PT10KXJldHVybiB0aGlzLmFjY29tbW9kYXRlKGUubGVuZ3RoKSxpPW5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsdGhpcy53cml0ZSksdGhpcy53cml0ZSs9dS5iaW5hcnkucmF3LmRlY29kZShpKSx0aGlzO2lmKFwidXRmMTZcIj09PXQpcmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMiplLmxlbmd0aCksaT1uZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcix0aGlzLndyaXRlKSx0aGlzLndyaXRlKz11LnRleHQudXRmMTYuZW5jb2RlKGkpLHRoaXM7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbmNvZGluZzogXCIrdCl9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcjogXCIrZSl9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnB1dEJ5dGVzKGUpLGUuY2xlYXIoKSx0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFN0cmluZz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wdXRCeXRlcyhlLFwidXRmMTZcIil9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMiksdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsZSksdGhpcy53cml0ZSs9Mix0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFjY29tbW9kYXRlKDMpLHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLGU+PjgmNjU1MzUpLHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsZT4+MTYmMjU1KSx0aGlzLndyaXRlKz0zLHRoaXN9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoNCksdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsZSksdGhpcy53cml0ZSs9NCx0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2TGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMiksdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsZSwhMCksdGhpcy53cml0ZSs9Mix0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWNjb21tb2RhdGUoMyksdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSxlPj4xNiYyNTUpLHRoaXMuZGF0YS5zZXRJbnQxNih0aGlzLndyaXRlLGU+PjgmNjU1MzUsITApLHRoaXMud3JpdGUrPTMsdGhpc30sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFjY29tbW9kYXRlKDQpLHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLGUsITApLHRoaXMud3JpdGUrPTQsdGhpc30sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQ9ZnVuY3Rpb24oZSx0KXtjKHQpLHRoaXMuYWNjb21tb2RhdGUodC84KTtkb3t0LT04LHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUrKyxlPj50JjI1NSl9d2hpbGUodD4wKTtyZXR1cm4gdGhpc30sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYyh0KSx0aGlzLmFjY29tbW9kYXRlKHQvOCksZTwwJiYoZSs9Mjw8dC0xKSx0aGlzLnB1dEludChlLHQpfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKyspfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCk7cmV0dXJuIHRoaXMucmVhZCs9MixlfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCk8PDhedGhpcy5kYXRhLmdldEludDgodGhpcy5yZWFkKzIpO3JldHVybiB0aGlzLnJlYWQrPTMsZX0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuZGF0YS5nZXRJbnQzMih0aGlzLnJlYWQpO3JldHVybiB0aGlzLnJlYWQrPTQsZX0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCwhMCk7cmV0dXJuIHRoaXMucmVhZCs9MixlfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQpXnRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQrMSwhMCk8PDg7cmV0dXJuIHRoaXMucmVhZCs9MyxlfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmRhdGEuZ2V0SW50MzIodGhpcy5yZWFkLCEwKTtyZXR1cm4gdGhpcy5yZWFkKz00LGV9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50PWZ1bmN0aW9uKGUpe2MoZSk7dmFyIHQ9MDtkb3t0PSh0PDw4KSt0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQrKyksZS09OH13aGlsZShlPjApO3JldHVybiB0fSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldEludChlKSxyPTI8PGUtMjtyZXR1cm4gdD49ciYmKHQtPXI8PDEpLHR9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXM9ZnVuY3Rpb24oZSl7dmFyIHQ7cmV0dXJuIGU/KGU9TWF0aC5taW4odGhpcy5sZW5ndGgoKSxlKSx0PXRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsdGhpcy5yZWFkK2UpLHRoaXMucmVhZCs9ZSk6MD09PWU/dD1cIlwiOih0PTA9PT10aGlzLnJlYWQ/dGhpcy5kYXRhOnRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpLHRoaXMuY2xlYXIoKSksdH0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZT90aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTp0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLHRoaXMucmVhZCtlKX0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMucmVhZCtlKX0sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmRhdGEuc2V0VWludDgoZSx0KSx0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmxhc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMud3JpdGUtMSl9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weT1mdW5jdGlvbigpe3JldHVybiBuZXcgdS5EYXRhQnVmZmVyKHRoaXMpfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3Q9ZnVuY3Rpb24oKXtpZih0aGlzLnJlYWQ+MCl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcix0aGlzLnJlYWQpLHQ9bmV3IFVpbnQ4QXJyYXkoZS5ieXRlTGVuZ3RoKTt0LnNldChlKSx0aGlzLmRhdGE9bmV3IERhdGFWaWV3KHQpLHRoaXMud3JpdGUtPXRoaXMucmVhZCx0aGlzLnJlYWQ9MH1yZXR1cm4gdGhpc30sdS5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGE9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksdGhpcy5yZWFkPXRoaXMud3JpdGU9MCx0aGlzfSx1LkRhdGFCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLndyaXRlPU1hdGgubWF4KDAsdGhpcy5sZW5ndGgoKS1lKSx0aGlzLnJlYWQ9TWF0aC5taW4odGhpcy5yZWFkLHRoaXMud3JpdGUpLHRoaXN9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXg9ZnVuY3Rpb24oKXtmb3IodmFyIGU9XCJcIix0PXRoaXMucmVhZDt0PHRoaXMuZGF0YS5ieXRlTGVuZ3RoOysrdCl7dmFyIHI9dGhpcy5kYXRhLmdldFVpbnQ4KHQpO3I8MTYmJihlKz1cIjBcIiksZSs9ci50b1N0cmluZygxNil9cmV0dXJuIGV9LHUuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLHRoaXMucmVhZCx0aGlzLmxlbmd0aCgpKTtpZihcImJpbmFyeVwiPT09KGU9ZXx8XCJ1dGY4XCIpfHxcInJhd1wiPT09ZSlyZXR1cm4gdS5iaW5hcnkucmF3LmVuY29kZSh0KTtpZihcImhleFwiPT09ZSlyZXR1cm4gdS5iaW5hcnkuaGV4LmVuY29kZSh0KTtpZihcImJhc2U2NFwiPT09ZSlyZXR1cm4gdS5iaW5hcnkuYmFzZTY0LmVuY29kZSh0KTtpZihcInV0ZjhcIj09PWUpcmV0dXJuIHUudGV4dC51dGY4LmRlY29kZSh0KTtpZihcInV0ZjE2XCI9PT1lKXJldHVybiB1LnRleHQudXRmMTYuZGVjb2RlKHQpO3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgZW5jb2Rpbmc6IFwiK2UpfSx1LmNyZWF0ZUJ1ZmZlcj1mdW5jdGlvbihlLHQpe3JldHVybiB0PXR8fFwicmF3XCIsdm9pZCAwIT09ZSYmXCJ1dGY4XCI9PT10JiYoZT11LmVuY29kZVV0ZjgoZSkpLG5ldyB1LkJ5dGVCdWZmZXIoZSl9LHUuZmlsbFN0cmluZz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1cIlwiO3Q+MDspMSZ0JiYocis9ZSksKHQ+Pj49MSk+MCYmKGUrPWUpO3JldHVybiByfSx1LnhvckJ5dGVzPWZ1bmN0aW9uKGUsdCxyKXtmb3IodmFyIG49XCJcIixpPVwiXCIsYT1cIlwiLHM9MCxvPTA7cj4wOy0tciwrK3MpaT1lLmNoYXJDb2RlQXQocyledC5jaGFyQ29kZUF0KHMpLG8+PTEwJiYobis9YSxhPVwiXCIsbz0wKSxhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpLCsrbztyZXR1cm4gbis9YX0sdS5oZXhUb0J5dGVzPWZ1bmN0aW9uKGUpe3ZhciB0PVwiXCIscj0wO2ZvcighMCZlLmxlbmd0aCYmKHI9MSx0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGVbMF0sMTYpKSk7cjxlLmxlbmd0aDtyKz0yKXQrPVN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZS5zdWJzdHIociwyKSwxNikpO3JldHVybiB0fSx1LmJ5dGVzVG9IZXg9ZnVuY3Rpb24oZSl7cmV0dXJuIHUuY3JlYXRlQnVmZmVyKGUpLnRvSGV4KCl9LHUuaW50MzJUb0J5dGVzPWZ1bmN0aW9uKGUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjI0JjI1NSkrU3RyaW5nLmZyb21DaGFyQ29kZShlPj4xNiYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUpK1N0cmluZy5mcm9tQ2hhckNvZGUoMjU1JmUpfTt2YXIgZj1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsaD1bNjIsLTEsLTEsLTEsNjMsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsLTEsLTEsLTEsNjQsLTEsLTEsLTEsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwtMSwtMSwtMSwtMSwtMSwtMSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MV0scD1cIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjt1LmVuY29kZTY0PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG4saSxhPVwiXCIscz1cIlwiLG89MDtvPGUubGVuZ3RoOylyPWUuY2hhckNvZGVBdChvKyspLG49ZS5jaGFyQ29kZUF0KG8rKyksaT1lLmNoYXJDb2RlQXQobysrKSxhKz1mLmNoYXJBdChyPj4yKSxhKz1mLmNoYXJBdCgoMyZyKTw8NHxuPj40KSxpc05hTihuKT9hKz1cIj09XCI6KGErPWYuY2hhckF0KCgxNSZuKTw8MnxpPj42KSxhKz1pc05hTihpKT9cIj1cIjpmLmNoYXJBdCg2MyZpKSksdCYmYS5sZW5ndGg+dCYmKHMrPWEuc3Vic3RyKDAsdCkrXCJcXHJcXG5cIixhPWEuc3Vic3RyKHQpKTtyZXR1cm4gcys9YX0sdS5kZWNvZGU2ND1mdW5jdGlvbihlKXtlPWUucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9cXD1dL2csXCJcIik7Zm9yKHZhciB0LHIsbixpLGE9XCJcIixzPTA7czxlLmxlbmd0aDspdD1oW2UuY2hhckNvZGVBdChzKyspLTQzXSxyPWhbZS5jaGFyQ29kZUF0KHMrKyktNDNdLG49aFtlLmNoYXJDb2RlQXQocysrKS00M10saT1oW2UuY2hhckNvZGVBdChzKyspLTQzXSxhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQ8PDJ8cj4+NCksNjQhPT1uJiYoYSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMTUmcik8PDR8bj4+MiksNjQhPT1pJiYoYSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMyZuKTw8NnxpKSkpO3JldHVybiBhfSx1LmVuY29kZVV0Zjg9ZnVuY3Rpb24oZSl7cmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChlKSl9LHUuZGVjb2RlVXRmOD1mdW5jdGlvbihlKXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlKSl9LHUuYmluYXJ5PXtyYXc6e30saGV4Ont9LGJhc2U2NDp7fSxiYXNlNTg6e30sYmFzZU46e2VuY29kZTpvLmVuY29kZSxkZWNvZGU6by5kZWNvZGV9fSx1LmJpbmFyeS5yYXcuZW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZSl9LHUuYmluYXJ5LnJhdy5kZWNvZGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXQ7bnx8KG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpKTtmb3IodmFyIGk9cj1yfHwwLGE9MDthPGUubGVuZ3RoOysrYSluW2krK109ZS5jaGFyQ29kZUF0KGEpO3JldHVybiB0P2ktcjpufSx1LmJpbmFyeS5oZXguZW5jb2RlPXUuYnl0ZXNUb0hleCx1LmJpbmFyeS5oZXguZGVjb2RlPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj10O258fChuPW5ldyBVaW50OEFycmF5KE1hdGguY2VpbChlLmxlbmd0aC8yKSkpO3ZhciBpPTAsYT1yPXJ8fDA7Zm9yKDEmZS5sZW5ndGgmJihpPTEsblthKytdPXBhcnNlSW50KGVbMF0sMTYpKTtpPGUubGVuZ3RoO2krPTIpblthKytdPXBhcnNlSW50KGUuc3Vic3RyKGksMiksMTYpO3JldHVybiB0P2EtcjpufSx1LmJpbmFyeS5iYXNlNjQuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG4saSxhPVwiXCIscz1cIlwiLG89MDtvPGUuYnl0ZUxlbmd0aDspcj1lW28rK10sbj1lW28rK10saT1lW28rK10sYSs9Zi5jaGFyQXQocj4+MiksYSs9Zi5jaGFyQXQoKDMmcik8PDR8bj4+NCksaXNOYU4obik/YSs9XCI9PVwiOihhKz1mLmNoYXJBdCgoMTUmbik8PDJ8aT4+NiksYSs9aXNOYU4oaSk/XCI9XCI6Zi5jaGFyQXQoNjMmaSkpLHQmJmEubGVuZ3RoPnQmJihzKz1hLnN1YnN0cigwLHQpK1wiXFxyXFxuXCIsYT1hLnN1YnN0cih0KSk7cmV0dXJuIHMrPWF9LHUuYmluYXJ5LmJhc2U2NC5kZWNvZGU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGksYSxzLG89dDtvfHwobz1uZXcgVWludDhBcnJheSgzKk1hdGguY2VpbChlLmxlbmd0aC80KSkpLGU9ZS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZyxcIlwiKTtmb3IodmFyIHU9MCxjPXI9cnx8MDt1PGUubGVuZ3RoOyluPWhbZS5jaGFyQ29kZUF0KHUrKyktNDNdLGk9aFtlLmNoYXJDb2RlQXQodSsrKS00M10sYT1oW2UuY2hhckNvZGVBdCh1KyspLTQzXSxzPWhbZS5jaGFyQ29kZUF0KHUrKyktNDNdLG9bYysrXT1uPDwyfGk+PjQsNjQhPT1hJiYob1tjKytdPSgxNSZpKTw8NHxhPj4yLDY0IT09cyYmKG9bYysrXT0oMyZhKTw8NnxzKSk7cmV0dXJuIHQ/Yy1yOm8uc3ViYXJyYXkoMCxjKX0sdS5iaW5hcnkuYmFzZTU4LmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB1LmJpbmFyeS5iYXNlTi5lbmNvZGUoZSxwLHQpfSx1LmJpbmFyeS5iYXNlNTguZGVjb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHUuYmluYXJ5LmJhc2VOLmRlY29kZShlLHAsdCl9LHUudGV4dD17dXRmODp7fSx1dGYxNjp7fX0sdS50ZXh0LnV0ZjguZW5jb2RlPWZ1bmN0aW9uKGUsdCxyKXtlPXUuZW5jb2RlVXRmOChlKTt2YXIgbj10O258fChuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSk7Zm9yKHZhciBpPXI9cnx8MCxhPTA7YTxlLmxlbmd0aDsrK2EpbltpKytdPWUuY2hhckNvZGVBdChhKTtyZXR1cm4gdD9pLXI6bn0sdS50ZXh0LnV0ZjguZGVjb2RlPWZ1bmN0aW9uKGUpe3JldHVybiB1LmRlY29kZVV0ZjgoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGUpKX0sdS50ZXh0LnV0ZjE2LmVuY29kZT1mdW5jdGlvbihlLHQscil7dmFyIG49dDtufHwobj1uZXcgVWludDhBcnJheSgyKmUubGVuZ3RoKSk7Zm9yKHZhciBpPW5ldyBVaW50MTZBcnJheShuLmJ1ZmZlciksYT1yPXJ8fDAscz1yLG89MDtvPGUubGVuZ3RoOysrbylpW3MrK109ZS5jaGFyQ29kZUF0KG8pLGErPTI7cmV0dXJuIHQ/YS1yOm59LHUudGV4dC51dGYxNi5kZWNvZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDE2QXJyYXkoZS5idWZmZXIpKX0sdS5kZWZsYXRlPWZ1bmN0aW9uKGUsdCxyKXtpZih0PXUuZGVjb2RlNjQoZS5kZWZsYXRlKHUuZW5jb2RlNjQodCkpLnJ2YWwpLHIpe3ZhciBuPTI7MzImdC5jaGFyQ29kZUF0KDEpJiYobj02KSx0PXQuc3Vic3RyaW5nKG4sdC5sZW5ndGgtNCl9cmV0dXJuIHR9LHUuaW5mbGF0ZT1mdW5jdGlvbihlLHQscil7dmFyIG49ZS5pbmZsYXRlKHUuZW5jb2RlNjQodCkpLnJ2YWw7cmV0dXJuIG51bGw9PT1uP251bGw6dS5kZWNvZGU2NChuKX07dmFyIGQ9ZnVuY3Rpb24oZSx0LHIpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIldlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS5cIik7dmFyIG47aWYobnVsbD09PXI/bj1lLnJlbW92ZUl0ZW0odCk6KHI9dS5lbmNvZGU2NChKU09OLnN0cmluZ2lmeShyKSksbj1lLnNldEl0ZW0odCxyKSksdm9pZCAwIT09biYmITAhPT1uLnJ2YWwpe3ZhciBpPW5ldyBFcnJvcihuLmVycm9yLm1lc3NhZ2UpO3Rocm93IGkuaWQ9bi5lcnJvci5pZCxpLm5hbWU9bi5lcnJvci5uYW1lLGl9fSx5PWZ1bmN0aW9uKGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLlwiKTt2YXIgcj1lLmdldEl0ZW0odCk7aWYoZS5pbml0KWlmKG51bGw9PT1yLnJ2YWwpe2lmKHIuZXJyb3Ipe3ZhciBuPW5ldyBFcnJvcihyLmVycm9yLm1lc3NhZ2UpO3Rocm93IG4uaWQ9ci5lcnJvci5pZCxuLm5hbWU9ci5lcnJvci5uYW1lLG59cj1udWxsfWVsc2Ugcj1yLnJ2YWw7cmV0dXJuIG51bGwhPT1yJiYocj1KU09OLnBhcnNlKHUuZGVjb2RlNjQocikpKSxyfSxnPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXkoZSx0KTtudWxsPT09aSYmKGk9e30pLGlbcl09bixkKGUsdCxpKX0sbT1mdW5jdGlvbihlLHQscil7dmFyIG49eShlLHQpO3JldHVybiBudWxsIT09biYmKG49ciBpbiBuP25bcl06bnVsbCksbn0sdj1mdW5jdGlvbihlLHQscil7dmFyIG49eShlLHQpO2lmKG51bGwhPT1uJiZyIGluIG4pe2RlbGV0ZSBuW3JdO3ZhciBpPSEwO2Zvcih2YXIgYSBpbiBuKXtpPSExO2JyZWFrfWkmJihuPW51bGwpLGQoZSx0LG4pfX0sYj1mdW5jdGlvbihlLHQpe2QoZSx0LG51bGwpfSxFPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbixpPW51bGw7dm9pZCAwPT09ciYmKHI9W1wid2ViXCIsXCJmbGFzaFwiXSk7dmFyIGE9ITEscz1udWxsO2Zvcih2YXIgbyBpbiByKXtuPXJbb107dHJ5e2lmKFwiZmxhc2hcIj09PW58fFwiYm90aFwiPT09bil7aWYobnVsbD09PXRbMF0pdGhyb3cgbmV3IEVycm9yKFwiRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLlwiKTtpPWUuYXBwbHkodGhpcyx0KSxhPVwiZmxhc2hcIj09PW59XCJ3ZWJcIiE9PW4mJlwiYm90aFwiIT09bnx8KHRbMF09bG9jYWxTdG9yYWdlLGk9ZS5hcHBseSh0aGlzLHQpLGE9ITApfWNhdGNoKGUpe3M9ZX1pZihhKWJyZWFrfWlmKCFhKXRocm93IHM7cmV0dXJuIGl9O3Uuc2V0SXRlbT1mdW5jdGlvbihlLHQscixuLGkpe0UoZyxhcmd1bWVudHMsaSl9LHUuZ2V0SXRlbT1mdW5jdGlvbihlLHQscixuKXtyZXR1cm4gRShtLGFyZ3VtZW50cyxuKX0sdS5yZW1vdmVJdGVtPWZ1bmN0aW9uKGUsdCxyLG4pe0Uodixhcmd1bWVudHMsbil9LHUuY2xlYXJJdGVtcz1mdW5jdGlvbihlLHQscil7RShiLGFyZ3VtZW50cyxyKX0sdS5wYXJzZVVybD1mdW5jdGlvbihlKXt2YXIgdD0vXihodHRwcz8pOlxcL1xcLyhbXjomXlxcL10qKTo/KFxcZCopKC4qKSQvZzt0Lmxhc3RJbmRleD0wO3ZhciByPXQuZXhlYyhlKSxuPW51bGw9PT1yP251bGw6e2Z1bGw6ZSxzY2hlbWU6clsxXSxob3N0OnJbMl0scG9ydDpyWzNdLHBhdGg6cls0XX07cmV0dXJuIG4mJihuLmZ1bGxIb3N0PW4uaG9zdCxuLnBvcnQ/ODAhPT1uLnBvcnQmJlwiaHR0cFwiPT09bi5zY2hlbWU/bi5mdWxsSG9zdCs9XCI6XCIrbi5wb3J0OjQ0MyE9PW4ucG9ydCYmXCJodHRwc1wiPT09bi5zY2hlbWUmJihuLmZ1bGxIb3N0Kz1cIjpcIituLnBvcnQpOlwiaHR0cFwiPT09bi5zY2hlbWU/bi5wb3J0PTgwOlwiaHR0cHNcIj09PW4uc2NoZW1lJiYobi5wb3J0PTQ0Myksbi5mdWxsPW4uc2NoZW1lK1wiOi8vXCIrbi5mdWxsSG9zdCksbn07dmFyIFM9bnVsbDt1LmdldFF1ZXJ5VmFyaWFibGVzPWZ1bmN0aW9uKGUpe3ZhciB0LHI9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXt9LHI9ZS5zcGxpdChcIiZcIiksbj0wO248ci5sZW5ndGg7bisrKXt2YXIgaSxhLHM9cltuXS5pbmRleE9mKFwiPVwiKTtzPjA/KGk9cltuXS5zdWJzdHJpbmcoMCxzKSxhPXJbbl0uc3Vic3RyaW5nKHMrMSkpOihpPXJbbl0sYT1udWxsKSxpIGluIHR8fCh0W2ldPVtdKSxpIGluIE9iamVjdC5wcm90b3R5cGV8fG51bGw9PT1hfHx0W2ldLnB1c2godW5lc2NhcGUoYSkpfXJldHVybiB0fTtyZXR1cm4gdm9pZCAwPT09ZT8obnVsbD09PVMmJihTPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5sb2NhdGlvbiYmd2luZG93LmxvY2F0aW9uLnNlYXJjaD9yKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTp7fSksdD1TKTp0PXIoZSksdH0sdS5wYXJzZUZyYWdtZW50PWZ1bmN0aW9uKGUpe3ZhciB0PWUscj1cIlwiLG49ZS5pbmRleE9mKFwiP1wiKTtuPjAmJih0PWUuc3Vic3RyaW5nKDAsbikscj1lLnN1YnN0cmluZyhuKzEpKTt2YXIgaT10LnNwbGl0KFwiL1wiKTtyZXR1cm4gaS5sZW5ndGg+MCYmXCJcIj09PWlbMF0mJmkuc2hpZnQoKSx7cGF0aFN0cmluZzp0LHF1ZXJ5U3RyaW5nOnIscGF0aDppLHF1ZXJ5OlwiXCI9PT1yP3t9OnUuZ2V0UXVlcnlWYXJpYWJsZXMocil9fSx1Lm1ha2VSZXF1ZXN0PWZ1bmN0aW9uKGUpe3ZhciB0PXUucGFyc2VGcmFnbWVudChlKSxyPXtwYXRoOnQucGF0aFN0cmluZyxxdWVyeTp0LnF1ZXJ5U3RyaW5nLGdldFBhdGg6ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWU/dC5wYXRoOnQucGF0aFtlXX0sZ2V0UXVlcnk6ZnVuY3Rpb24oZSxyKXt2YXIgbjtyZXR1cm4gdm9pZCAwPT09ZT9uPXQucXVlcnk6KG49dC5xdWVyeVtlXSkmJnZvaWQgMCE9PXImJihuPW5bcl0pLG59LGdldFF1ZXJ5TGFzdDpmdW5jdGlvbihlLHQpe3ZhciBuPXIuZ2V0UXVlcnkoZSk7cmV0dXJuIG4/bltuLmxlbmd0aC0xXTp0fX07cmV0dXJuIHJ9LHUubWFrZUxpbms9ZnVuY3Rpb24oZSx0LHIpe2U9alF1ZXJ5LmlzQXJyYXkoZSk/ZS5qb2luKFwiL1wiKTplO3ZhciBuPWpRdWVyeS5wYXJhbSh0fHx7fSk7cmV0dXJuIHI9cnx8XCJcIixlKyhuLmxlbmd0aD4wP1wiP1wiK246XCJcIikrKHIubGVuZ3RoPjA/XCIjXCIrcjpcIlwiKX0sdS5zZXRQYXRoPWZ1bmN0aW9uKGUsdCxyKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUpZm9yKHZhciBuPTAsaT10Lmxlbmd0aDtuPGk7KXt2YXIgYT10W24rK107aWYobj09aSllW2FdPXI7ZWxzZXt2YXIgcz1hIGluIGU7KCFzfHxzJiZcIm9iamVjdFwiIT10eXBlb2YgZVthXXx8cyYmbnVsbD09PWVbYV0pJiYoZVthXT17fSksZT1lW2FdfX19LHUuZ2V0UGF0aD1mdW5jdGlvbihlLHQscil7Zm9yKHZhciBuPTAsaT10Lmxlbmd0aCxhPSEwO2EmJm48aSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lOyl7dmFyIHM9dFtuKytdOyhhPXMgaW4gZSkmJihlPWVbc10pfXJldHVybiBhP2U6cn0sdS5kZWxldGVQYXRoPWZ1bmN0aW9uKGUsdCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lKWZvcih2YXIgcj0wLG49dC5sZW5ndGg7cjxuOyl7dmFyIGk9dFtyKytdO2lmKHI9PW4pZGVsZXRlIGVbaV07ZWxzZXtpZighKGkgaW4gZSl8fFwib2JqZWN0XCIhPXR5cGVvZiBlW2ldfHxudWxsPT09ZVtpXSlicmVhaztlPWVbaV19fX0sdS5pc0VtcHR5PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkodCkpcmV0dXJuITE7cmV0dXJuITB9LHUuZm9ybWF0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG49LyUuL2csaT0wLGE9W10scz0wO3Q9bi5leGVjKGUpOyl7KHI9ZS5zdWJzdHJpbmcocyxuLmxhc3RJbmRleC0yKSkubGVuZ3RoPjAmJmEucHVzaChyKSxzPW4ubGFzdEluZGV4O3ZhciBvPXRbMF1bMV07c3dpdGNoKG8pe2Nhc2VcInNcIjpjYXNlXCJvXCI6aTxhcmd1bWVudHMubGVuZ3RoP2EucHVzaChhcmd1bWVudHNbMStpKytdKTphLnB1c2goXCI8Pz5cIik7YnJlYWs7Y2FzZVwiJVwiOmEucHVzaChcIiVcIik7YnJlYWs7ZGVmYXVsdDphLnB1c2goXCI8JVwiK28rXCI/PlwiKX19cmV0dXJuIGEucHVzaChlLnN1YnN0cmluZyhzKSksYS5qb2luKFwiXCIpfSx1LmZvcm1hdE51bWJlcj1mdW5jdGlvbihlLHQscixuKXt2YXIgaT1lLGE9aXNOYU4odD1NYXRoLmFicyh0KSk/Mjp0LHM9dm9pZCAwPT09cj9cIixcIjpyLG89dm9pZCAwPT09bj9cIi5cIjpuLHU9aTwwP1wiLVwiOlwiXCIsYz1wYXJzZUludChpPU1hdGguYWJzKCtpfHwwKS50b0ZpeGVkKGEpLDEwKStcIlwiLGw9Yy5sZW5ndGg+Mz9jLmxlbmd0aCUzOjA7cmV0dXJuIHUrKGw/Yy5zdWJzdHIoMCxsKStvOlwiXCIpK2Muc3Vic3RyKGwpLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLFwiJDFcIitvKSsoYT9zK01hdGguYWJzKGktYykudG9GaXhlZChhKS5zbGljZSgyKTpcIlwiKX0sdS5mb3JtYXRTaXplPWZ1bmN0aW9uKGUpe3JldHVybiBlPWU+PTEwNzM3NDE4MjQ/dS5mb3JtYXROdW1iZXIoZS8xMDczNzQxODI0LDIsXCIuXCIsXCJcIikrXCIgR2lCXCI6ZT49MTA0ODU3Nj91LmZvcm1hdE51bWJlcihlLzEwNDg1NzYsMixcIi5cIixcIlwiKStcIiBNaUJcIjplPj0xMDI0P3UuZm9ybWF0TnVtYmVyKGUvMTAyNCwwKStcIiBLaUJcIjp1LmZvcm1hdE51bWJlcihlLDApK1wiIGJ5dGVzXCJ9LHUuYnl0ZXNGcm9tSVA9ZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1lLmluZGV4T2YoXCIuXCIpP3UuYnl0ZXNGcm9tSVB2NChlKTotMSE9PWUuaW5kZXhPZihcIjpcIik/dS5ieXRlc0Zyb21JUHY2KGUpOm51bGx9LHUuYnl0ZXNGcm9tSVB2ND1mdW5jdGlvbihlKXtpZig0IT09KGU9ZS5zcGxpdChcIi5cIikpLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIHQ9dS5jcmVhdGVCdWZmZXIoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBuPXBhcnNlSW50KGVbcl0sMTApO2lmKGlzTmFOKG4pKXJldHVybiBudWxsO3QucHV0Qnl0ZShuKX1yZXR1cm4gdC5nZXRCeXRlcygpfSx1LmJ5dGVzRnJvbUlQdjY9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAscj0yKig4LShlPWUuc3BsaXQoXCI6XCIpLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1lLmxlbmd0aCYmKyt0LCEwfSkpKS5sZW5ndGgrdCksbj11LmNyZWF0ZUJ1ZmZlcigpLGk9MDtpPDg7KytpKWlmKGVbaV0mJjAhPT1lW2ldLmxlbmd0aCl7dmFyIGE9dS5oZXhUb0J5dGVzKGVbaV0pO2EubGVuZ3RoPDImJm4ucHV0Qnl0ZSgwKSxuLnB1dEJ5dGVzKGEpfWVsc2Ugbi5maWxsV2l0aEJ5dGUoMCxyKSxyPTA7cmV0dXJuIG4uZ2V0Qnl0ZXMoKX0sdS5ieXRlc1RvSVA9ZnVuY3Rpb24oZSl7cmV0dXJuIDQ9PT1lLmxlbmd0aD91LmJ5dGVzVG9JUHY0KGUpOjE2PT09ZS5sZW5ndGg/dS5ieXRlc1RvSVB2NihlKTpudWxsfSx1LmJ5dGVzVG9JUHY0PWZ1bmN0aW9uKGUpe2lmKDQhPT1lLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7KytyKXQucHVzaChlLmNoYXJDb2RlQXQocikpO3JldHVybiB0LmpvaW4oXCIuXCIpfSx1LmJ5dGVzVG9JUHY2PWZ1bmN0aW9uKGUpe2lmKDE2IT09ZS5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciB0PVtdLHI9W10sbj0wLGk9MDtpPGUubGVuZ3RoO2krPTIpe2Zvcih2YXIgYT11LmJ5dGVzVG9IZXgoZVtpXStlW2krMV0pO1wiMFwiPT09YVswXSYmXCIwXCIhPT1hOylhPWEuc3Vic3RyKDEpO2lmKFwiMFwiPT09YSl7dmFyIHM9cltyLmxlbmd0aC0xXSxvPXQubGVuZ3RoO3MmJm89PT1zLmVuZCsxPyhzLmVuZD1vLHMuZW5kLXMuc3RhcnQ+cltuXS5lbmQtcltuXS5zdGFydCYmKG49ci5sZW5ndGgtMSkpOnIucHVzaCh7c3RhcnQ6byxlbmQ6b30pfXQucHVzaChhKX1pZihyLmxlbmd0aD4wKXt2YXIgYz1yW25dO2MuZW5kLWMuc3RhcnQ+MCYmKHQuc3BsaWNlKGMuc3RhcnQsYy5lbmQtYy5zdGFydCsxLFwiXCIpLDA9PT1jLnN0YXJ0JiZ0LnVuc2hpZnQoXCJcIiksNz09PWMuZW5kJiZ0LnB1c2goXCJcIikpfXJldHVybiB0LmpvaW4oXCI6XCIpfSx1LmVzdGltYXRlQ29yZXM9ZnVuY3Rpb24oZSx0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYodD1lLGU9e30pLGU9ZXx8e30sXCJjb3Jlc1wiaW4gdSYmIWUudXBkYXRlKXJldHVybiB0KG51bGwsdS5jb3Jlcyk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmXCJoYXJkd2FyZUNvbmN1cnJlbmN5XCJpbiBuYXZpZ2F0b3ImJm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5PjApcmV0dXJuIHUuY29yZXM9bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3ksdChudWxsLHUuY29yZXMpO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBXb3JrZXIpcmV0dXJuIHUuY29yZXM9MSx0KG51bGwsdS5jb3Jlcyk7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpcmV0dXJuIHUuY29yZXM9Mix0KG51bGwsdS5jb3Jlcyk7dmFyIHI9VVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXCIoXCIsZnVuY3Rpb24oKXtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1EYXRlLm5vdygpLHI9dCs0O0RhdGUubm93KCk8cjspO3NlbGYucG9zdE1lc3NhZ2Uoe3N0OnQsZXQ6cn0pfSkpfS50b1N0cmluZygpLFwiKSgpXCJdLHt0eXBlOlwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwifSkpOyFmdW5jdGlvbiBlKG4saSxhKXtpZigwPT09aSl7dmFyIHM9TWF0aC5mbG9vcihuLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSt0fSksMCkvbi5sZW5ndGgpO3JldHVybiB1LmNvcmVzPU1hdGgubWF4KDEscyksVVJMLnJldm9rZU9iamVjdFVSTChyKSx0KG51bGwsdS5jb3Jlcyl9IWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPVtdLGk9W10sYT0wO2E8ZTsrK2Epe3ZhciBzPW5ldyBXb3JrZXIocik7cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChmdW5jdGlvbihyKXtpZihpLnB1c2goci5kYXRhKSxpLmxlbmd0aD09PWUpe2Zvcih2YXIgYT0wO2E8ZTsrK2EpblthXS50ZXJtaW5hdGUoKTt0KG51bGwsaSl9fSkpLG4ucHVzaChzKX1mb3IoYT0wO2E8ZTsrK2EpblthXS5wb3N0TWVzc2FnZShhKX0oYSwoZnVuY3Rpb24odCxyKXtuLnB1c2goZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9W10sbj0wO248ZTsrK24pZm9yKHZhciBpPXRbbl0sYT1yW25dPVtdLHM9MDtzPGU7KytzKWlmKG4hPT1zKXt2YXIgbz10W3NdOyhpLnN0Pm8uc3QmJmkuc3Q8by5ldHx8by5zdD5pLnN0JiZvLnN0PGkuZXQpJiZhLnB1c2gocyl9cmV0dXJuIHIucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBNYXRoLm1heChlLHQubGVuZ3RoKX0pLDApfShhLHIpKSxlKG4saS0xLGEpfSkpfShbXSw1LDE2KX19KS5jYWxsKHRoaXMscigxOCkscig4Nykuc2V0SW1tZWRpYXRlLHIoMTcpLHIoMTMpLkJ1ZmZlcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMjEpLGk9cig2NyksYT1yKDExMykscz1yKDExNCk7dC5qc29uPXM7Y29uc3Qgbz1yKDI2KTt0LnNlcmlhbGl6ZVByaW1pdGl2ZXM9bztjb25zdCB1PXIoMzcpO3QucGFyc2VQcmltaXRpdmVzPXU7Y29uc3QgYz1yKDIxKTt0LnNjaGVtYXM9Yztjb25zdCBsPXtzZXJpYWxpemVyRnJvbVNjaGVtYTppLnNlcmlhbGl6ZXJGcm9tU2NoZW1hLHNlcmlhbGl6ZVR4Omkuc2VyaWFsaXplVHgsc2VyaWFsaXplT3JkZXI6aS5zZXJpYWxpemVPcmRlcixwYXJzZXJGcm9tU2NoZW1hOmEucGFyc2VyRnJvbVNjaGVtYSxwYXJzZVR4OmEucGFyc2VUeCxwYXJzZU9yZGVyOmEucGFyc2VPcmRlcn07ZnVuY3Rpb24gZihlLHQscixuKXtjb25zdCBzPWkuc2VyaWFsaXplckZyb21TY2hlbWEodCxuKSxvPWEucGFyc2VyRnJvbVNjaGVtYSh0LHIpKHMoZSkpLnZhbHVlO3JldHVybiBPYmplY3QuYXNzaWduKHt9LGUsbyl9dC5iaW5hcnk9bCx0LmNvbnZlcnRMb25nRmllbGRzPWYsdC5jb252ZXJ0VHhMb25nRmllbGRzPWZ1bmN0aW9uKGUsdCxyKXtjb25zdHt0eXBlOmksdmVyc2lvbjphfT1lO3JldHVybiBmKGUsbi5nZXRUcmFuc2FjdGlvblNjaGVtYShpLGEpLHQscil9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG47T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9cig1MSksYT1yKDUzKTt0LnNlZWRXb3Jkc0xpc3Q9YS5zZWVkV29yZHNMaXN0O3ZhciBzPXIoNTYpO3QuQ2hhaWRJZD1zLkNoYWlkSWQ7dmFyIG89cig1NSk7dC5TZWVkPW8uU2VlZDt2YXIgdT1yKDM0KTt0LmlzUHJpdmF0ZUtleT11LmlzUHJpdmF0ZUtleSx0LmlzUHVibGljS2V5PXUuaXNQdWJsaWNLZXk7dmFyIGM9cig1MSk7dC5jcnlwdG89Yy5jcnlwdG8sZnVuY3Rpb24oZSl7Zm9yKHZhciByIGluIGUpdC5oYXNPd25Qcm9wZXJ0eShyKXx8KHRbcl09ZVtyXSl9KHIoMjApKSx0LnNpZ25CeXRlcz0obj1pLmNyeXB0byh7b3V0cHV0OlwiQmFzZTU4XCJ9KSkuc2lnbkJ5dGVzLHQua2V5UGFpcj1uLmtleVBhaXIsdC5wdWJsaWNLZXk9bi5wdWJsaWNLZXksdC5wcml2YXRlS2V5PW4ucHJpdmF0ZUtleSx0LmFkZHJlc3M9bi5hZGRyZXNzLHQuYmxha2UyYj1uLmJsYWtlMmIsdC5rZWNjYWs9bi5rZWNjYWssdC5zaGEyNTY9bi5zaGEyNTYsdC5zaGFyZWRLZXk9bi5zaGFyZWRLZXksdC5zZWVkV2l0aE5vbmNlPW4uc2VlZFdpdGhOb25jZSx0LmJhc2U2NEVuY29kZT1uLmJhc2U2NEVuY29kZSx0LmJhc2U2NERlY29kZT1uLmJhc2U2NERlY29kZSx0LmJhc2U1OEVuY29kZT1uLmJhc2U1OEVuY29kZSx0LmJhc2U1OERlY29kZT1uLmJhc2U1OERlY29kZSx0LmJhc2UxNkVuY29kZT1uLmJhc2UxNkVuY29kZSx0LmJhc2UxNkRlY29kZT1uLmJhc2UxNkRlY29kZSx0LnN0cmluZ1RvQnl0ZXM9bi5zdHJpbmdUb0J5dGVzLHQuYnl0ZXNUb1N0cmluZz1uLmJ5dGVzVG9TdHJpbmcsdC5yYW5kb209bi5yYW5kb20sdC5yYW5kb21TZWVkPW4ucmFuZG9tU2VlZCx0LnJhbmRvbUJ5dGVzPW4ucmFuZG9tQnl0ZXMsdC52ZXJpZnlTaWduYXR1cmU9bi52ZXJpZnlTaWduYXR1cmUsdC52ZXJpZnlQdWJsaWNLZXk9bi52ZXJpZnlQdWJsaWNLZXksdC52ZXJpZnlBZGRyZXNzPW4udmVyaWZ5QWRkcmVzcyx0Lm1lc3NhZ2VEZWNyeXB0PW4ubWVzc2FnZURlY3J5cHQsdC5tZXNzYWdlRW5jcnlwdD1uLm1lc3NhZ2VFbmNyeXB0LHQuYWVzRGVjcnlwdD1uLmFlc0RlY3J5cHQsdC5hZXNFbmNyeXB0PW4uYWVzRW5jcnlwdCx0LmVuY3J5cHRTZWVkPW4uZW5jcnlwdFNlZWQsdC5kZWNyeXB0U2VlZD1uLmRlY3J5cHRTZWVkLHQucnNhS2V5UGFpcj1uLnJzYUtleVBhaXIsdC5yc2FLZXlQYWlyU3luYz1uLnJzYUtleVBhaXJTeW5jLHQucnNhU2lnbj1uLnJzYVNpZ24sdC5yc2FWZXJpZnk9bi5yc2FWZXJpZnksdC5tZXJrbGVWZXJpZnk9bi5tZXJrbGVWZXJpZnksdC5zcGxpdD1uLnNwbGl0LHQuY29uY2F0PW4uY29uY2F0fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSl7Zm9yKHZhciByIGluIGUpdC5oYXNPd25Qcm9wZXJ0eShyKXx8KHRbcl09ZVtyXSl9KHIoNikpO2NvbnN0IG49cigxMTYpLGk9cigxMTcpLGE9cigxMTgpLHM9cigxMTkpLG89cigxMjApLHU9cigxMjEpLGM9cigxMjIpLGw9cigxMjMpLGY9cigxMjQpLGg9cigxMjUpLHA9cigxMjYpLGQ9cigxMjcpLHk9cigxMjgpLGc9cigxMjkpLG09cig2OCksdj1yKDEzMCksYj1yKDEzMSksRT1yKDEzMiksUz1yKDEzMyk7dC52YWxpZGF0ZT17dHJhbnNmZXI6bi50cmFuc2ZlclZhbGlkYXRvcixtYXNzVHJhbnNmZXI6aS5tYXNzVHJhbnNmZXJWYWxpZGF0b3IsYWxpYXM6YS5hbGlhc1ZhbGlkYXRvcixpc3N1ZTpwLmlzc3VlVmFsaWRhdG9yLHJlaXNzdWU6aC5yZWlzc3VlVmFsaWRhdG9yLHNwb25zb3JzaGlwOmMuc3BvbnNvcnNoaXBWYWxpZGF0b3IsYnVybjpzLmJ1cm5WYWxpZGF0b3Isc2V0QXNzZXRTY3JpcHQ6bC5zZXRBc3NldFNjcmlwdFZhbGlkYXRvcixjYW5jZWxMZWFzZTpvLmNhbmNlbExlYXNlVmFsaWRhdG9yLGRhdGE6dS5kYXRhVmFsaWRhdG9yLGxlYXNlOmQubGVhc2VWYWxpZGF0b3Isc2V0U2NyaXB0OmYuc2V0U2NyaXB0VmFsaWRhdG9yLGludm9rZVNjcmlwdDp5Lmludm9rZVZhbGlkYXRvcixleGNoYW5nZTpnLmV4Y2hhbmdlVmFsaWRhdG9yLGNhbmNlbE9yZGVyOnYuY2FuY2VsT3JkZXJWYWxpZGF0b3IsY3VzdG9tRGF0YTpiLmN1c3RvbURhdGFWYWxpZGF0b3Isb3JkZXI6bS5vcmRlclZhbGlkYXRvcix3YXZlc0F1dGg6Uy5hdXRoVmFsaWRhdG9yLGF1dGg6RS5hdXRoVmFsaWRhdG9yfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cig0KSxpPTE0MCxhPXtBVkFJTEFCTEVfQ0hBUlM6XCItLjAxMjM0NTY3ODlAX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsTUFYX0FMSUFTX0xFTkdUSDozMCxNSU5fQUxJQVNfTEVOR1RIOjR9LHM9NCxvPTE2LHU9MWUzO3QuZGVmYXVsdFZhbHVlPWU9PigpPT5lLHQubm9wZT1lPT5lLHQucGlwZT0oLi4uZSk9PnQ9PmUucmVkdWNlKChlLHQpPT50KGUpLHQpLHQudmFsaWRhdGVQaXBlPSguLi5lKT0+dD0+e2xldCByPSEwO2Zvcihjb25zdCBuIG9mIGUpaWYocj0hIW4odCksIXIpcmV0dXJuITE7cmV0dXJuIHJ9LHQucHJvcD1lPT50PT50P3RbZV06dm9pZCAwLHQubHRlPWU9PnQ9PmU+PXQsdC5ndGU9ZT0+dD0+ZTw9dCx0LmlmRWxzZT0oZSx0LHIpPT5uPT5lKG4pP3Qobik6cihuKSx0LmlzRXE9ZT0+cj0+e3N3aXRjaCghMCl7Y2FzZSB0LmlzTnVtYmVyKHIpJiZ0LmlzTnVtYmVyKGUpOnJldHVybiBOdW1iZXIocik9PT1OdW1iZXIoZSk7Y2FzZSB0LmlzU3RyaW5nKHIpJiZ0LmlzU3RyaW5nKGUpOnJldHVybiBTdHJpbmcoZSk9PT1TdHJpbmcocik7Y2FzZSB0LmlzQm9vbGVhbihyKSYmdC5pc0Jvb2xlYW4oZSk6cmV0dXJuIEJvb2xlYW4ocik9PT1Cb29sZWFuKGUpO2RlZmF1bHQ6cmV0dXJuIGU9PT1yfX0sdC5vckVxPWU9PnI9PmUuc29tZSh0LmlzRXEocikpLHQuaXNSZXF1aXJlZD1lPT50PT4hZXx8bnVsbCE9dCx0LmlzU3RyaW5nPWU9Plwic3RyaW5nXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgU3RyaW5nLHQuaXNOdW1iZXI9ZT0+KFwibnVtYmVyXCI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgTnVtYmVyKSYmIWlzTmFOKE51bWJlcihlKSksdC5pc051bWJlckxpa2U9ZT0+IShudWxsPT1lfHxpc05hTihOdW1iZXIoZSkpfHwhZSYmMCE9PWUpLHQuaXNCb29sZWFuPWU9Pm51bGwhPWUmJihcImJvb2xlYW5cIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBCb29sZWFuKSx0LmlzQnl0ZUFycmF5PWU9PntpZighZSlyZXR1cm4hMTtjb25zdCByPW5ldyBVaW50OEFycmF5KGUpO3JldHVybiByLmxlbmd0aD09PWUubGVuZ3RoJiZyLmV2ZXJ5KChyLG4pPT50LmlzRXEocikoZVtuXSkpfSx0LmlzQXJyYXk9ZT0+QXJyYXkuaXNBcnJheShlKSx0LmJ5dGVzTGVuZ3RoPWU9PnQ9Pnt0cnl7cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0KS5sZW5ndGg9PT1lfWNhdGNoKGUpe3JldHVybiExfX0sdC5pc0Jhc2U1OD1lPT57dHJ5e24uYmFzZTU4RGVjb2RlKGUpfWNhdGNoKGUpe3JldHVybiExfXJldHVybiEwfSx0LmlzQmFzZTY0PWU9Pnt0cnl7ZT1lLnJlcGxhY2UoL15iYXNlNjQ6LyxcIlwiKSxuLmJhc2U2NERlY29kZShlKX1jYXRjaChlKXtyZXR1cm4hMX1yZXR1cm4hMH0sdC5pc1ZhbGlkQWRkcmVzcz0oZSxyKT0+e2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHwhdC5pc0Jhc2U1OChlKSlyZXR1cm4hMTtsZXQgaT1uLmJhc2U1OERlY29kZShlKTtpZigxIT09aVswXSlyZXR1cm4hMTtpZihudWxsIT1yJiZpWzFdIT1yKXJldHVybiExO2xldCBhPWkuc2xpY2UoMCwyMikscz1pLnNsaWNlKDIyLDI2KSxvPW4ua2VjY2FrKG4uYmxha2UyYihhKSkuc2xpY2UoMCw0KTtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKHNbZV0hPT1vW2VdKXJldHVybiExO3JldHVybiEwfTt2YXIgYzt0LmlzVmFsaWRBbGlhc05hbWU9dC5pZkVsc2UoKGM9YS5BVkFJTEFCTEVfQ0hBUlMsZT0+ZS5zcGxpdChcIlwiKS5ldmVyeShlPT5jLmluY2x1ZGVzKGUpKSksdC5waXBlKHQucHJvcChcImxlbmd0aFwiKSx0LnZhbGlkYXRlUGlwZSh0Lmx0ZShhLk1BWF9BTElBU19MRU5HVEgpLHQuZ3RlKGEuTUlOX0FMSUFTX0xFTkdUSCkpKSx0LmRlZmF1bHRWYWx1ZSghMSkpLHQuaXNWYWxpZEFsaWFzPXQudmFsaWRhdGVQaXBlKHQuaXNTdHJpbmcsdC5waXBlKGU9PmUuc3BsaXQoXCI6XCIpLHQuaWZFbHNlKGU9PlwiYWxpYXNcIiE9PWVbMF18fDMhPT1lLmxlbmd0aCx0LmRlZmF1bHRWYWx1ZSghMSksdC5waXBlKHQucHJvcCgyKSx0LmlzVmFsaWRBbGlhc05hbWUpKSkpLHQuaXNIYXNoPXQudmFsaWRhdGVQaXBlKHQuaXNSZXF1aXJlZCghMCksdC5pc0Jhc2U1OCx0LnBpcGUoZT0+bi5iYXNlNThEZWNvZGUoZSksdC5ieXRlc0xlbmd0aCgzMikpKSx0LmlzUHVibGljS2V5PXQuaXNIYXNoLHQuaXNBc3NldElkPXQuaWZFbHNlKHQub3JFcShbXCJcIixudWxsLHZvaWQgMCxcIldBVkVTXCJdKSx0LmRlZmF1bHRWYWx1ZSghMCksdC5pc0hhc2gpLHQuaXNBdHRhY2htZW50PXQuaWZFbHNlKHQub3JFcShbbnVsbCx2b2lkIDBdKSx0LmRlZmF1bHRWYWx1ZSghMCksdC5waXBlKHQuaWZFbHNlKHQuaXNCYXNlNTgsbi5iYXNlNThEZWNvZGUsdC5ub3BlKSx0LmlmRWxzZSh0LmlzQnl0ZUFycmF5LHQucGlwZSh0LnByb3AoXCJsZW5ndGhcIiksdC5sdGUoaSkpLHQuZGVmYXVsdFZhbHVlKCExKSkpKTtjb25zdCBsPXtpbnRlZ2VyOnQuaXNOdW1iZXJMaWtlLGJvb2xlYW46dC5pc0Jvb2xlYW4sc3RyaW5nOnQuaXNTdHJpbmcsYmluYXJ5OnQuaXNCYXNlNjR9O3QuaXNWYWxpZERhdGFQYWlyPWU9PiEoIWxbZS50eXBlXXx8IWxbZS50eXBlXShlLnZhbHVlKSksdC5pc1ZhbGlkRGF0YT10LnZhbGlkYXRlUGlwZSh0LmlzUmVxdWlyZWQoITApLHQucGlwZSh0LnByb3AoXCJrZXlcIiksdC52YWxpZGF0ZVBpcGUodC5pc1N0cmluZyxlPT4hIWUpKSx0LmlzVmFsaWREYXRhUGFpciksdC5pc1ZhbGlkQXNzZXROYW1lPXQudmFsaWRhdGVQaXBlKHQuaXNSZXF1aXJlZCghMCksdC5pc1N0cmluZyx0LnBpcGUobi5zdHJpbmdUb0J5dGVzLHQucHJvcChcImxlbmd0aFwiKSx0LmlmRWxzZSh0Lmd0ZShzKSx0Lmx0ZShvKSx0LmRlZmF1bHRWYWx1ZSghMSkpKSksdC5pc1ZhbGlkQXNzZXREZXNjcmlwdGlvbj10LmlmRWxzZSh0LmlzUmVxdWlyZWQoITEpLHQuZGVmYXVsdFZhbHVlKCEwKSx0LnBpcGUobi5zdHJpbmdUb0J5dGVzLHQucHJvcChcImxlbmd0aFwiKSx0Lmx0ZSh1KSkpLHQuZXhjZXB0aW9uPWU9Pnt0aHJvdyBuZXcgRXJyb3IoZSl9LHQuaXNSZWNpcGllbnQ9dC5pZkVsc2UodC5pc1ZhbGlkQWRkcmVzcyx0LmRlZmF1bHRWYWx1ZSghMCksdC5pc1ZhbGlkQWxpYXMpLHQudmFsaWRhdGVCeVNoZW1hPShlLHIpPT5uPT4oT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW2UsaV0pPT57Y29uc3QgYT10LnByb3AoZSkobnx8e30pO2koYSl8fHQuZXhjZXB0aW9uKHIoZSxhKSl9KSwhMCksdC5nZXRFcnJvcj0oZSx0KT0+YHR4IFwiJHtlfVwiLCBoYXMgd3JvbmcgZGF0YTogJHtKU09OLnN0cmluZ2lmeSh0KX0uIENoZWNrIHR4IGRhdGEuYH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cig0KTt0Lm1hcE9iaj0oZSx0KT0+T2JqZWN0LmVudHJpZXMoZSkubWFwKChbZSxyXSk9PltlLHQocildKS5yZWR1Y2UoKGUsW3Qscl0pPT5PYmplY3QuYXNzaWduKHt9LGUse1t0XTpyfSkse30pLHQuZ2V0U2VuZGVyUHVibGljS2V5PWZ1bmN0aW9uKGUsdCl7aWYoMD09PWUubGVuZ3RoJiZudWxsPT10LnNlbmRlclB1YmxpY0tleSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBlaXRoZXIgc2VlZCBvciBzZW5kZXJQdWJsaWNLZXlcIik7cmV0dXJuIG51bGw9PXQuc2VuZGVyUHVibGljS2V5P24ucHVibGljS2V5KGVbMF1bMF0pOnQuc2VuZGVyUHVibGljS2V5fSx0LmJhc2U2NFByZWZpeD1lPT5udWxsPT1lfHxcImJhc2U2NDpcIj09PWUuc2xpY2UoMCw3KT9lOlwiYmFzZTY0OlwiK2UsdC5hZGRQcm9vZj1mdW5jdGlvbihlLHQscil7aWYobnVsbD09cilyZXR1cm4gZS5wcm9vZnM9Wy4uLmUucHJvb2ZzLHRdLGU7aWYobnVsbCE9ZS5wcm9vZnMmJmUucHJvb2ZzW3JdKXRocm93IG5ldyBFcnJvcihgUHJvb2YgYXQgaW5kZXggJHtyfSBhbHJlYWR5IGV4aXN0cy5gKTtmb3IobGV0IHQ9ZS5wcm9vZnMubGVuZ3RoO3Q8cjt0KyspZS5wcm9vZnMucHVzaChcIlwiKTtyZXR1cm4gZS5wcm9vZnNbcl09dCxlfSx0LmNvbnZlcnRUb1BhaXJzPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP1tdOlwic3RyaW5nXCI9PXR5cGVvZiBlP1tbZSx2b2lkIDBdXTpcInByaXZhdGVLZXlcImluIGU/W1tlLHZvaWQgMF1dOkFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoKGUsdCk9PltlLHRdKS5maWx0ZXIoKFtlLHRdKT0+ZSk6T2JqZWN0LmtleXMoZSkubWFwKGU9PnBhcnNlSW50KGUpKS5maWx0ZXIoZT0+IWlzTmFOKGUpKS5zb3J0KCkubWFwKHQ9PltlW3RdLHRdKX0sdC5pc09yZGVyPWU9PnZvaWQgMCE9PWUuYXNzZXRQYWlyLHQubmV0d29ya0J5dGU9ZnVuY3Rpb24oZSx0KXtzd2l0Y2godHlwZW9mIGUpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBlLmNoYXJDb2RlQXQoMCk7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIGU7ZGVmYXVsdDpyZXR1cm4gdH19LHQuZmVlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZmVlP2UuZmVlOmUuYWRkaXRpb25hbEZlZT90K2UuYWRkaXRpb25hbEZlZTp0fSx0Lm5vcm1hbGl6ZUFzc2V0SWQ9ZnVuY3Rpb24oZSl7cmV0dXJuXCJXQVZFU1wiPT09KGU9ZXx8bnVsbCk/bnVsbDplfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNzMpLGk9cigxMzgpLGE9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBzKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PWEuY2FsbChlKX1mdW5jdGlvbiBvKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGV9ZnVuY3Rpb24gdShlKXtyZXR1cm5cIltvYmplY3QgRnVuY3Rpb25dXCI9PT1hLmNhbGwoZSl9ZnVuY3Rpb24gYyhlLHQpe2lmKG51bGwhPWUpaWYoXCJvYmplY3RcIiE9dHlwZW9mIGUmJihlPVtlXSkscyhlKSlmb3IodmFyIHI9MCxuPWUubGVuZ3RoO3I8bjtyKyspdC5jYWxsKG51bGwsZVtyXSxyLGUpO2Vsc2UgZm9yKHZhciBpIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkmJnQuY2FsbChudWxsLGVbaV0saSxlKX1lLmV4cG9ydHM9e2lzQXJyYXk6cyxpc0FycmF5QnVmZmVyOmZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PWEuY2FsbChlKX0saXNCdWZmZXI6aSxpc0Zvcm1EYXRhOmZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBGb3JtRGF0YSYmZSBpbnN0YW5jZW9mIEZvcm1EYXRhfSxpc0FycmF5QnVmZmVyVmlldzpmdW5jdGlvbihlKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJkFycmF5QnVmZmVyLmlzVmlldz9BcnJheUJ1ZmZlci5pc1ZpZXcoZSk6ZSYmZS5idWZmZXImJmUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9LGlzU3RyaW5nOmZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfSxpc051bWJlcjpmdW5jdGlvbihlKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZX0saXNPYmplY3Q6byxpc1VuZGVmaW5lZDpmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZX0saXNEYXRlOmZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBEYXRlXVwiPT09YS5jYWxsKGUpfSxpc0ZpbGU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEZpbGVdXCI9PT1hLmNhbGwoZSl9LGlzQmxvYjpmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgQmxvYl1cIj09PWEuY2FsbChlKX0saXNGdW5jdGlvbjp1LGlzU3RyZWFtOmZ1bmN0aW9uKGUpe3JldHVybiBvKGUpJiZ1KGUucGlwZSl9LGlzVVJMU2VhcmNoUGFyYW1zOmZ1bmN0aW9uKGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBVUkxTZWFyY2hQYXJhbXMmJmUgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXN9LGlzU3RhbmRhcmRCcm93c2VyRW52OmZ1bmN0aW9uKCl7cmV0dXJuKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3J8fFwiUmVhY3ROYXRpdmVcIiE9PW5hdmlnYXRvci5wcm9kdWN0JiZcIk5hdGl2ZVNjcmlwdFwiIT09bmF2aWdhdG9yLnByb2R1Y3QmJlwiTlNcIiE9PW5hdmlnYXRvci5wcm9kdWN0KSYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCl9LGZvckVhY2g6YyxtZXJnZTpmdW5jdGlvbiBlKCl7dmFyIHQ9e307ZnVuY3Rpb24gcihyLG4pe1wib2JqZWN0XCI9PXR5cGVvZiB0W25dJiZcIm9iamVjdFwiPT10eXBlb2Ygcj90W25dPWUodFtuXSxyKTp0W25dPXJ9Zm9yKHZhciBuPTAsaT1hcmd1bWVudHMubGVuZ3RoO248aTtuKyspYyhhcmd1bWVudHNbbl0scik7cmV0dXJuIHR9LGRlZXBNZXJnZTpmdW5jdGlvbiBlKCl7dmFyIHQ9e307ZnVuY3Rpb24gcihyLG4pe1wib2JqZWN0XCI9PXR5cGVvZiB0W25dJiZcIm9iamVjdFwiPT10eXBlb2Ygcj90W25dPWUodFtuXSxyKTp0W25dPVwib2JqZWN0XCI9PXR5cGVvZiByP2Uoe30scik6cn1mb3IodmFyIG49MCxpPWFyZ3VtZW50cy5sZW5ndGg7bjxpO24rKyljKGFyZ3VtZW50c1tuXSxyKTtyZXR1cm4gdH0sZXh0ZW5kOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gYyh0LChmdW5jdGlvbih0LGkpe2VbaV09ciYmXCJmdW5jdGlvblwiPT10eXBlb2YgdD9uKHQscik6dH0pKSxlfSx0cmltOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoL15cXHMqLyxcIlwiKS5yZXBsYWNlKC9cXHMqJC8sXCJcIil9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7ZS5leHBvcnRzPW4ubWQ9bi5tZHx8e30sbi5tZC5hbGdvcml0aG1zPW4ubWQuYWxnb3JpdGhtc3x8e319LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSx0KXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighcilyZXR1cm4gZTt2YXIgbixpLGE9ci5jYWxsKGUpLHM9W107dHJ5e2Zvcig7KHZvaWQgMD09PXR8fHQtLSA+MCkmJiEobj1hLm5leHQoKSkuZG9uZTspcy5wdXNoKG4udmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e24mJiFuLmRvbmUmJihyPWEucmV0dXJuKSYmci5jYWxsKGEpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gc30saT10aGlzJiZ0aGlzLl9fc3ByZWFkfHxmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllPWUuY29uY2F0KG4oYXJndW1lbnRzW3RdKSk7cmV0dXJuIGV9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBhPXIoMTEpLHM9cig5Myk7dC5zdHJpbmdUb0J5dGVzPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9XCJ1dGY4XCIpLFwidXRmOFwiPT09dClyZXR1cm4gcy5zdHJUb1V0ZjhBcnJheShlKTtpZihcInJhd1wiPT09dClyZXR1cm4gVWludDhBcnJheS5mcm9tKGkoZSkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQ29kZUF0KDApfSkpKTt0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZyBcIit0KX0sdC5ieXRlc1RvU3RyaW5nPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9XCJ1dGY4XCIpLFwidXRmOFwiPT09dClyZXR1cm4gcy51dGY4QXJyYXlUb1N0cihBcnJheS5mcm9tKGEuX2Zyb21JbihlKSkpO2lmKFwicmF3XCI9PT10KXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsQXJyYXkuZnJvbShhLl9mcm9tSW4oZSkpKTt0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZyBcIit0KX0sdC5iaW5hcnlTdHJpbmdUb0J5dGVzPWZ1bmN0aW9uKGUpe3JldHVybiBVaW50OEFycmF5LmZyb20oaShlKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNoYXJDb2RlQXQoMCl9KSkpfSx0LmJ5dGVzVG9CaW5hcnlTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxBcnJheS5mcm9tKGEuX2Zyb21JbihlKSkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoMjMpLGk9cigxMCksYT1mdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZXx8ZSBpbnN0YW5jZW9mIFN0cmluZ30scz1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl9O3QuX2Zyb21Jbj1mdW5jdGlvbihlKXtyZXR1cm4gYShlKT9uLmJhc2U1OERlY29kZShlKTpzKGUpP2U6VWludDhBcnJheS5mcm9tKGUpfSx0Ll9mcm9tUmF3SW49ZnVuY3Rpb24oZSl7cmV0dXJuIGEoZSk/aS5zdHJpbmdUb0J5dGVzKGUpOnMoZSk/ZTpVaW50OEFycmF5LmZyb20oZSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDI5KSxyKDkwKSxyKDkxKSxyKDIpLG4ucmFuZG9tJiZuLnJhbmRvbS5nZXRCeXRlcz9lLmV4cG9ydHM9bi5yYW5kb206ZnVuY3Rpb24odCl7dmFyIHI9e30saT1uZXcgQXJyYXkoNCksYT1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7ZnVuY3Rpb24gcygpe3ZhciBlPW4ucHJuZy5jcmVhdGUocik7cmV0dXJuIGUuZ2V0Qnl0ZXM9ZnVuY3Rpb24odCxyKXtyZXR1cm4gZS5nZW5lcmF0ZSh0LHIpfSxlLmdldEJ5dGVzU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gZS5nZW5lcmF0ZSh0KX0sZX1yLmZvcm1hdEtleT1mdW5jdGlvbihlKXt2YXIgdD1uLnV0aWwuY3JlYXRlQnVmZmVyKGUpO3JldHVybihlPW5ldyBBcnJheSg0KSlbMF09dC5nZXRJbnQzMigpLGVbMV09dC5nZXRJbnQzMigpLGVbMl09dC5nZXRJbnQzMigpLGVbM109dC5nZXRJbnQzMigpLG4uYWVzLl9leHBhbmRLZXkoZSwhMSl9LHIuZm9ybWF0U2VlZD1mdW5jdGlvbihlKXt2YXIgdD1uLnV0aWwuY3JlYXRlQnVmZmVyKGUpO3JldHVybihlPW5ldyBBcnJheSg0KSlbMF09dC5nZXRJbnQzMigpLGVbMV09dC5nZXRJbnQzMigpLGVbMl09dC5nZXRJbnQzMigpLGVbM109dC5nZXRJbnQzMigpLGV9LHIuY2lwaGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4uYWVzLl91cGRhdGVCbG9jayhlLHQsaSwhMSksYS5wdXRJbnQzMihpWzBdKSxhLnB1dEludDMyKGlbMV0pLGEucHV0SW50MzIoaVsyXSksYS5wdXRJbnQzMihpWzNdKSxhLmdldEJ5dGVzKCl9LHIuaW5jcmVtZW50PWZ1bmN0aW9uKGUpe3JldHVybisrZVszXSxlfSxyLm1kPW4ubWQuc2hhMjU2O3ZhciBvPXMoKSx1PW51bGwsYz1uLnV0aWwuZ2xvYmFsU2NvcGUsbD1jLmNyeXB0b3x8Yy5tc0NyeXB0bztpZihsJiZsLmdldFJhbmRvbVZhbHVlcyYmKHU9ZnVuY3Rpb24oZSl7cmV0dXJuIGwuZ2V0UmFuZG9tVmFsdWVzKGUpfSksbi5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0fHwhbi51dGlsLmlzTm9kZWpzJiYhdSl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8d2luZG93LmRvY3VtZW50LG8uY29sbGVjdEludCgrbmV3IERhdGUsMzIpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3Ipe3ZhciBmPVwiXCI7Zm9yKHZhciBoIGluIG5hdmlnYXRvcil0cnl7XCJzdHJpbmdcIj09dHlwZW9mIG5hdmlnYXRvcltoXSYmKGYrPW5hdmlnYXRvcltoXSl9Y2F0Y2goZSl7fW8uY29sbGVjdChmKSxmPW51bGx9dCYmKHQoKS5tb3VzZW1vdmUoKGZ1bmN0aW9uKGUpe28uY29sbGVjdEludChlLmNsaWVudFgsMTYpLG8uY29sbGVjdEludChlLmNsaWVudFksMTYpfSkpLHQoKS5rZXlwcmVzcygoZnVuY3Rpb24oZSl7by5jb2xsZWN0SW50KGUuY2hhckNvZGUsOCl9KSkpfWlmKG4ucmFuZG9tKWZvcih2YXIgaCBpbiBvKW4ucmFuZG9tW2hdPW9baF07ZWxzZSBuLnJhbmRvbT1vO24ucmFuZG9tLmNyZWF0ZUluc3RhbmNlPXMsZS5leHBvcnRzPW4ucmFuZG9tfShcInVuZGVmaW5lZFwiIT10eXBlb2YgalF1ZXJ5P2pRdWVyeTpudWxsKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG52YXIgbj1yKDI4KSxpPXIoODUpLGE9cig4Nik7ZnVuY3Rpb24gcygpe3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIG8oZSx0KXtpZihzKCk8dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KGU9bmV3IFVpbnQ4QXJyYXkodCkpLl9fcHJvdG9fXz11LnByb3RvdHlwZToobnVsbD09PWUmJihlPW5ldyB1KHQpKSxlLmxlbmd0aD10KSxlfWZ1bmN0aW9uIHUoZSx0LHIpe2lmKCEodS5UWVBFRF9BUlJBWV9TVVBQT1JUfHx0aGlzIGluc3RhbmNlb2YgdSkpcmV0dXJuIG5ldyB1KGUsdCxyKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7cmV0dXJuIGYodGhpcyxlKX1yZXR1cm4gYyh0aGlzLGUsdCxyKX1mdW5jdGlvbiBjKGUsdCxyLG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2Z1bmN0aW9uKGUsdCxyLG4pe2lmKHQuYnl0ZUxlbmd0aCxyPDB8fHQuYnl0ZUxlbmd0aDxyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZih0LmJ5dGVMZW5ndGg8cisobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpO3Q9dm9pZCAwPT09ciYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheSh0KTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KHQscik6bmV3IFVpbnQ4QXJyYXkodCxyLG4pO3UuVFlQRURfQVJSQVlfU1VQUE9SVD8oZT10KS5fX3Byb3RvX189dS5wcm90b3R5cGU6ZT1oKGUsdCk7cmV0dXJuIGV9KGUsdCxyLG4pOlwic3RyaW5nXCI9PXR5cGVvZiB0P2Z1bmN0aW9uKGUsdCxyKXtcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9PXJ8fChyPVwidXRmOFwiKTtpZighdS5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHxkKHQsciksaT0oZT1vKGUsbikpLndyaXRlKHQscik7aSE9PW4mJihlPWUuc2xpY2UoMCxpKSk7cmV0dXJuIGV9KGUsdCxyKTpmdW5jdGlvbihlLHQpe2lmKHUuaXNCdWZmZXIodCkpe3ZhciByPTB8cCh0Lmxlbmd0aCk7cmV0dXJuIDA9PT0oZT1vKGUscikpLmxlbmd0aD9lOih0LmNvcHkoZSwwLDAsciksZSl9aWYodCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZ0LmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcImxlbmd0aFwiaW4gdClyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgdC5sZW5ndGh8fChuPXQubGVuZ3RoKSE9bj9vKGUsMCk6aChlLHQpO2lmKFwiQnVmZmVyXCI9PT10LnR5cGUmJmEodC5kYXRhKSlyZXR1cm4gaChlLHQuZGF0YSl9dmFyIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9KGUsdCl9ZnVuY3Rpb24gbChlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7aWYoZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpfWZ1bmN0aW9uIGYoZSx0KXtpZihsKHQpLGU9byhlLHQ8MD8wOjB8cCh0KSksIXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIHI9MDtyPHQ7KytyKWVbcl09MDtyZXR1cm4gZX1mdW5jdGlvbiBoKGUsdCl7dmFyIHI9dC5sZW5ndGg8MD8wOjB8cCh0Lmxlbmd0aCk7ZT1vKGUscik7Zm9yKHZhciBuPTA7bjxyO24rPTEpZVtuXT0yNTUmdFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBwKGUpe2lmKGU+PXMoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIitzKCkudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiAwfGV9ZnVuY3Rpb24gZChlLHQpe2lmKHUuaXNCdWZmZXIoZSkpcmV0dXJuIGUubGVuZ3RoO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3JiYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVybiBlLmJ5dGVMZW5ndGg7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJihlPVwiXCIrZSk7dmFyIHI9ZS5sZW5ndGg7aWYoMD09PXIpcmV0dXJuIDA7Zm9yKHZhciBuPSExOzspc3dpdGNoKHQpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHI7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZSB2b2lkIDA6cmV0dXJuIGooZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiAyKnI7Y2FzZVwiaGV4XCI6cmV0dXJuIHI+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBGKGUpLmxlbmd0aDtkZWZhdWx0OmlmKG4pcmV0dXJuIGooZSkubGVuZ3RoO3Q9KFwiXCIrdCkudG9Mb3dlckNhc2UoKSxuPSEwfX1mdW5jdGlvbiB5KGUsdCxyKXt2YXIgbj0hMTtpZigodm9pZCAwPT09dHx8dDwwKSYmKHQ9MCksdD50aGlzLmxlbmd0aClyZXR1cm5cIlwiO2lmKCh2b2lkIDA9PT1yfHxyPnRoaXMubGVuZ3RoKSYmKHI9dGhpcy5sZW5ndGgpLHI8PTApcmV0dXJuXCJcIjtpZigocj4+Pj0wKTw9KHQ+Pj49MCkpcmV0dXJuXCJcIjtmb3IoZXx8KGU9XCJ1dGY4XCIpOzspc3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBfKHRoaXMsdCxyKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdyh0aGlzLHQscik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gTih0aGlzLHQscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIFIodGhpcyx0LHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBJKHRoaXMsdCxyKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gUCh0aGlzLHQscik7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCksbj0hMH19ZnVuY3Rpb24gZyhlLHQscil7dmFyIG49ZVt0XTtlW3RdPWVbcl0sZVtyXT1ufWZ1bmN0aW9uIG0oZSx0LHIsbixpKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHI/KG49cixyPTApOnI+MjE0NzQ4MzY0Nz9yPTIxNDc0ODM2NDc6cjwtMjE0NzQ4MzY0OCYmKHI9LTIxNDc0ODM2NDgpLHI9K3IsaXNOYU4ocikmJihyPWk/MDplLmxlbmd0aC0xKSxyPDAmJihyPWUubGVuZ3RoK3IpLHI+PWUubGVuZ3RoKXtpZihpKXJldHVybi0xO3I9ZS5sZW5ndGgtMX1lbHNlIGlmKHI8MCl7aWYoIWkpcmV0dXJuLTE7cj0wfWlmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD11LmZyb20odCxuKSksdS5pc0J1ZmZlcih0KSlyZXR1cm4gMD09PXQubGVuZ3RoPy0xOnYoZSx0LHIsbixpKTtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdCY9MjU1LHUuVFlQRURfQVJSQVlfU1VQUE9SVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9pP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHQscik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHQscik6dihlLFt0XSxyLG4saSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiB2KGUsdCxyLG4saSl7dmFyIGEscz0xLG89ZS5sZW5ndGgsdT10Lmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoXCJ1Y3MyXCI9PT0obj1TdHJpbmcobikudG9Mb3dlckNhc2UoKSl8fFwidWNzLTJcIj09PW58fFwidXRmMTZsZVwiPT09bnx8XCJ1dGYtMTZsZVwiPT09bikpe2lmKGUubGVuZ3RoPDJ8fHQubGVuZ3RoPDIpcmV0dXJuLTE7cz0yLG8vPTIsdS89MixyLz0yfWZ1bmN0aW9uIGMoZSx0KXtyZXR1cm4gMT09PXM/ZVt0XTplLnJlYWRVSW50MTZCRSh0KnMpfWlmKGkpe3ZhciBsPS0xO2ZvcihhPXI7YTxvO2ErKylpZihjKGUsYSk9PT1jKHQsLTE9PT1sPzA6YS1sKSl7aWYoLTE9PT1sJiYobD1hKSxhLWwrMT09PXUpcmV0dXJuIGwqc31lbHNlLTEhPT1sJiYoYS09YS1sKSxsPS0xfWVsc2UgZm9yKHIrdT5vJiYocj1vLXUpLGE9cjthPj0wO2EtLSl7Zm9yKHZhciBmPSEwLGg9MDtoPHU7aCsrKWlmKGMoZSxhK2gpIT09Yyh0LGgpKXtmPSExO2JyZWFrfWlmKGYpcmV0dXJuIGF9cmV0dXJuLTF9ZnVuY3Rpb24gYihlLHQscixuKXtyPU51bWJlcihyKXx8MDt2YXIgaT1lLmxlbmd0aC1yO24/KG49TnVtYmVyKG4pKT5pJiYobj1pKTpuPWk7dmFyIGE9dC5sZW5ndGg7aWYoYSUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7bj5hLzImJihuPWEvMik7Zm9yKHZhciBzPTA7czxuOysrcyl7dmFyIG89cGFyc2VJbnQodC5zdWJzdHIoMipzLDIpLDE2KTtpZihpc05hTihvKSlyZXR1cm4gcztlW3Irc109b31yZXR1cm4gc31mdW5jdGlvbiBFKGUsdCxyLG4pe3JldHVybiBxKGoodCxlLmxlbmd0aC1yKSxlLHIsbil9ZnVuY3Rpb24gUyhlLHQscixuKXtyZXR1cm4gcShmdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7KytyKXQucHVzaCgyNTUmZS5jaGFyQ29kZUF0KHIpKTtyZXR1cm4gdH0odCksZSxyLG4pfWZ1bmN0aW9uIFQoZSx0LHIsbil7cmV0dXJuIFMoZSx0LHIsbil9ZnVuY3Rpb24gQyhlLHQscixuKXtyZXR1cm4gcShGKHQpLGUscixuKX1mdW5jdGlvbiBBKGUsdCxyLG4pe3JldHVybiBxKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByLG4saSxhPVtdLHM9MDtzPGUubGVuZ3RoJiYhKCh0LT0yKTwwKTsrK3Mpcj1lLmNoYXJDb2RlQXQocyksbj1yPj44LGk9ciUyNTYsYS5wdXNoKGkpLGEucHVzaChuKTtyZXR1cm4gYX0odCxlLmxlbmd0aC1yKSxlLHIsbil9ZnVuY3Rpb24gSShlLHQscil7cmV0dXJuIDA9PT10JiZyPT09ZS5sZW5ndGg/bi5mcm9tQnl0ZUFycmF5KGUpOm4uZnJvbUJ5dGVBcnJheShlLnNsaWNlKHQscikpfWZ1bmN0aW9uIHcoZSx0LHIpe3I9TWF0aC5taW4oZS5sZW5ndGgscik7Zm9yKHZhciBuPVtdLGk9dDtpPHI7KXt2YXIgYSxzLG8sdSxjPWVbaV0sbD1udWxsLGY9Yz4yMzk/NDpjPjIyMz8zOmM+MTkxPzI6MTtpZihpK2Y8PXIpc3dpdGNoKGYpe2Nhc2UgMTpjPDEyOCYmKGw9Yyk7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYoYT1lW2krMV0pKSYmKHU9KDMxJmMpPDw2fDYzJmEpPjEyNyYmKGw9dSk7YnJlYWs7Y2FzZSAzOmE9ZVtpKzFdLHM9ZVtpKzJdLDEyOD09KDE5MiZhKSYmMTI4PT0oMTkyJnMpJiYodT0oMTUmYyk8PDEyfCg2MyZhKTw8Nnw2MyZzKT4yMDQ3JiYodTw1NTI5Nnx8dT41NzM0MykmJihsPXUpO2JyZWFrO2Nhc2UgNDphPWVbaSsxXSxzPWVbaSsyXSxvPWVbaSszXSwxMjg9PSgxOTImYSkmJjEyOD09KDE5MiZzKSYmMTI4PT0oMTkyJm8pJiYodT0oMTUmYyk8PDE4fCg2MyZhKTw8MTJ8KDYzJnMpPDw2fDYzJm8pPjY1NTM1JiZ1PDExMTQxMTImJihsPXUpfW51bGw9PT1sPyhsPTY1NTMzLGY9MSk6bD42NTUzNSYmKGwtPTY1NTM2LG4ucHVzaChsPj4+MTAmMTAyM3w1NTI5NiksbD01NjMyMHwxMDIzJmwpLG4ucHVzaChsKSxpKz1mfXJldHVybiBmdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZih0PD1CKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKTt2YXIgcj1cIlwiLG49MDtmb3IoO248dDspcis9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShuLG4rPUIpKTtyZXR1cm4gcn0obil9dC5CdWZmZXI9dSx0LlNsb3dCdWZmZXI9ZnVuY3Rpb24oZSl7K2UhPWUmJihlPTApO3JldHVybiB1LmFsbG9jKCtlKX0sdC5JTlNQRUNUX01BWF9CWVRFUz01MCx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09ZS5UWVBFRF9BUlJBWV9TVVBQT1JUP2UuVFlQRURfQVJSQVlfU1VQUE9SVDpmdW5jdGlvbigpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gZS5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PWUuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc3ViYXJyYXkmJjA9PT1lLnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaChlKXtyZXR1cm4hMX19KCksdC5rTWF4TGVuZ3RoPXMoKSx1LnBvb2xTaXplPTgxOTIsdS5fYXVnbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX189dS5wcm90b3R5cGUsZX0sdS5mcm9tPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gYyhudWxsLGUsdCxyKX0sdS5UWVBFRF9BUlJBWV9TVVBQT1JUJiYodS5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHUuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJnVbU3ltYm9sLnNwZWNpZXNdPT09dSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLHUuYWxsb2M9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gbCh0KSx0PD0wP28oZSx0KTp2b2lkIDAhPT1yP1wic3RyaW5nXCI9PXR5cGVvZiBuP28oZSx0KS5maWxsKHIsbik6byhlLHQpLmZpbGwocik6byhlLHQpfShudWxsLGUsdCxyKX0sdS5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gZihudWxsLGUpfSx1LmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gZihudWxsLGUpfSx1LmlzQnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVybiEobnVsbD09ZXx8IWUuX2lzQnVmZmVyKX0sdS5jb21wYXJlPWZ1bmN0aW9uKGUsdCl7aWYoIXUuaXNCdWZmZXIoZSl8fCF1LmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO2lmKGU9PT10KXJldHVybiAwO2Zvcih2YXIgcj1lLmxlbmd0aCxuPXQubGVuZ3RoLGk9MCxhPU1hdGgubWluKHIsbik7aTxhOysraSlpZihlW2ldIT09dFtpXSl7cj1lW2ldLG49dFtpXTticmVha31yZXR1cm4gcjxuPy0xOm48cj8xOjB9LHUuaXNFbmNvZGluZz1mdW5jdGlvbihlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19LHUuY29uY2F0PWZ1bmN0aW9uKGUsdCl7aWYoIWEoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PWUubGVuZ3RoKXJldHVybiB1LmFsbG9jKDApO3ZhciByO2lmKHZvaWQgMD09PXQpZm9yKHQ9MCxyPTA7cjxlLmxlbmd0aDsrK3IpdCs9ZVtyXS5sZW5ndGg7dmFyIG49dS5hbGxvY1Vuc2FmZSh0KSxpPTA7Zm9yKHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIHM9ZVtyXTtpZighdS5pc0J1ZmZlcihzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTtzLmNvcHkobixpKSxpKz1zLmxlbmd0aH1yZXR1cm4gbn0sdS5ieXRlTGVuZ3RoPWQsdS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLHUucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz0yKWcodGhpcyx0LHQrMSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlNCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz00KWcodGhpcyx0LHQrMyksZyh0aGlzLHQrMSx0KzIpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTghPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IodmFyIHQ9MDt0PGU7dCs9OClnKHRoaXMsdCx0KzcpLGcodGhpcyx0KzEsdCs2KSxnKHRoaXMsdCsyLHQrNSksZyh0aGlzLHQrMyx0KzQpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBlPTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT1lP1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/dyh0aGlzLDAsZSk6eS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtpZighdS5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PWV8fDA9PT11LmNvbXBhcmUodGhpcyxlKX0sdS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBlPVwiXCIscj10LklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0aGlzLmxlbmd0aD4wJiYoZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCxyKS5tYXRjaCgvLnsyfS9nKS5qb2luKFwiIFwiKSx0aGlzLmxlbmd0aD5yJiYoZSs9XCIgLi4uIFwiKSksXCI8QnVmZmVyIFwiK2UrXCI+XCJ9LHUucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24oZSx0LHIsbixpKXtpZighdS5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1yJiYocj1lP2UubGVuZ3RoOjApLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWkmJihpPXRoaXMubGVuZ3RoKSx0PDB8fHI+ZS5sZW5ndGh8fG48MHx8aT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPj1pJiZ0Pj1yKXJldHVybiAwO2lmKG4+PWkpcmV0dXJuLTE7aWYodD49cilyZXR1cm4gMTtpZih0aGlzPT09ZSlyZXR1cm4gMDtmb3IodmFyIGE9KGk+Pj49MCktKG4+Pj49MCkscz0ocj4+Pj0wKS0odD4+Pj0wKSxvPU1hdGgubWluKGEscyksYz10aGlzLnNsaWNlKG4saSksbD1lLnNsaWNlKHQsciksZj0wO2Y8bzsrK2YpaWYoY1tmXSE9PWxbZl0pe2E9Y1tmXSxzPWxbZl07YnJlYWt9cmV0dXJuIGE8cz8tMTpzPGE/MTowfSx1LnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbihlLHQscil7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YoZSx0LHIpfSx1LnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbSh0aGlzLGUsdCxyLCEwKX0sdS5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBtKHRoaXMsZSx0LHIsITEpfSx1LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlLHQscixuKXtpZih2b2lkIDA9PT10KW49XCJ1dGY4XCIscj10aGlzLmxlbmd0aCx0PTA7ZWxzZSBpZih2b2lkIDA9PT1yJiZcInN0cmluZ1wiPT10eXBlb2YgdCluPXQscj10aGlzLmxlbmd0aCx0PTA7ZWxzZXtpZighaXNGaW5pdGUodCkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7dHw9MCxpc0Zpbml0ZShyKT8ocnw9MCx2b2lkIDA9PT1uJiYobj1cInV0ZjhcIikpOihuPXIscj12b2lkIDApfXZhciBpPXRoaXMubGVuZ3RoLXQ7aWYoKHZvaWQgMD09PXJ8fHI+aSkmJihyPWkpLGUubGVuZ3RoPjAmJihyPDB8fHQ8MCl8fHQ+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtufHwobj1cInV0ZjhcIik7Zm9yKHZhciBhPSExOzspc3dpdGNoKG4pe2Nhc2VcImhleFwiOnJldHVybiBiKHRoaXMsZSx0LHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBFKHRoaXMsZSx0LHIpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIFModGhpcyxlLHQscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIFQodGhpcyxlLHQscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIEModGhpcyxlLHQscik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEEodGhpcyxlLHQscik7ZGVmYXVsdDppZihhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIituKTtuPShcIlwiK24pLnRvTG93ZXJDYXNlKCksYT0hMH19LHUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTt2YXIgQj00MDk2O2Z1bmN0aW9uIE4oZSx0LHIpe3ZhciBuPVwiXCI7cj1NYXRoLm1pbihlLmxlbmd0aCxyKTtmb3IodmFyIGk9dDtpPHI7KytpKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoMTI3JmVbaV0pO3JldHVybiBufWZ1bmN0aW9uIFIoZSx0LHIpe3ZhciBuPVwiXCI7cj1NYXRoLm1pbihlLmxlbmd0aCxyKTtmb3IodmFyIGk9dDtpPHI7KytpKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtpXSk7cmV0dXJuIG59ZnVuY3Rpb24gXyhlLHQscil7dmFyIG49ZS5sZW5ndGg7KCF0fHx0PDApJiYodD0wKSwoIXJ8fHI8MHx8cj5uKSYmKHI9bik7Zm9yKHZhciBpPVwiXCIsYT10O2E8cjsrK2EpaSs9TShlW2FdKTtyZXR1cm4gaX1mdW5jdGlvbiBQKGUsdCxyKXtmb3IodmFyIG49ZS5zbGljZSh0LHIpLGk9XCJcIixhPTA7YTxuLmxlbmd0aDthKz0yKWkrPVN0cmluZy5mcm9tQ2hhckNvZGUoblthXSsyNTYqblthKzFdKTtyZXR1cm4gaX1mdW5jdGlvbiBPKGUsdCxyKXtpZihlJTEhPTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3Q+cil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9ZnVuY3Rpb24gayhlLHQscixuLGksYSl7aWYoIXUuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYodD5pfHx0PGEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYocituPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIFUoZSx0LHIsbil7dDwwJiYodD02NTUzNSt0KzEpO2Zvcih2YXIgaT0wLGE9TWF0aC5taW4oZS5sZW5ndGgtciwyKTtpPGE7KytpKWVbcitpXT0odCYyNTU8PDgqKG4/aToxLWkpKT4+PjgqKG4/aToxLWkpfWZ1bmN0aW9uIEwoZSx0LHIsbil7dDwwJiYodD00Mjk0OTY3Mjk1K3QrMSk7Zm9yKHZhciBpPTAsYT1NYXRoLm1pbihlLmxlbmd0aC1yLDQpO2k8YTsrK2kpZVtyK2ldPXQ+Pj44KihuP2k6My1pKSYyNTV9ZnVuY3Rpb24gRChlLHQscixuLGksYSl7aWYocituPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKHI8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBWKGUsdCxyLG4sYSl7cmV0dXJuIGF8fEQoZSwwLHIsNCksaS53cml0ZShlLHQscixuLDIzLDQpLHIrNH1mdW5jdGlvbiB4KGUsdCxyLG4sYSl7cmV0dXJuIGF8fEQoZSwwLHIsOCksaS53cml0ZShlLHQscixuLDUyLDgpLHIrOH11LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihlLHQpe3ZhciByLG49dGhpcy5sZW5ndGg7aWYoKGU9fn5lKTwwPyhlKz1uKTwwJiYoZT0wKTplPm4mJihlPW4pLCh0PXZvaWQgMD09PXQ/bjp+fnQpPDA/KHQrPW4pPDAmJih0PTApOnQ+biYmKHQ9biksdDxlJiYodD1lKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQpKHI9dGhpcy5zdWJhcnJheShlLHQpKS5fX3Byb3RvX189dS5wcm90b3R5cGU7ZWxzZXt2YXIgaT10LWU7cj1uZXcgdShpLHZvaWQgMCk7Zm9yKHZhciBhPTA7YTxpOysrYSlyW2FdPXRoaXNbYStlXX1yZXR1cm4gcn0sdS5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbihlLHQscil7ZXw9MCx0fD0wLHJ8fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIG49dGhpc1tlXSxpPTEsYT0wOysrYTx0JiYoaSo9MjU2KTspbis9dGhpc1tlK2FdKmk7cmV0dXJuIG59LHUucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24oZSx0LHIpe2V8PTAsdHw9MCxyfHxPKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbZSstLXRdLGk9MTt0PjAmJihpKj0yNTYpOyluKz10aGlzW2UrLS10XSppO3JldHVybiBufSx1LnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8TyhlLDEsdGhpcy5sZW5ndGgpLHRoaXNbZV19LHUucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxPKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh9LHUucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxPKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXTw8OHx0aGlzW2UrMV19LHUucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxPKGUsNCx0aGlzLmxlbmd0aCksKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpKzE2Nzc3MjE2KnRoaXNbZSszXX0sdS5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fE8oZSw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW2VdKyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfSx1LnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24oZSx0LHIpe2V8PTAsdHw9MCxyfHxPKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbZV0saT0xLGE9MDsrK2E8dCYmKGkqPTI1Nik7KW4rPXRoaXNbZSthXSppO3JldHVybiBuPj0oaSo9MTI4KSYmKG4tPU1hdGgucG93KDIsOCp0KSksbn0sdS5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKGUsdCxyKXtlfD0wLHR8PTAscnx8TyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10LGk9MSxhPXRoaXNbZSstLW5dO24+MCYmKGkqPTI1Nik7KWErPXRoaXNbZSstLW5dKmk7cmV0dXJuIGE+PShpKj0xMjgpJiYoYS09TWF0aC5wb3coMiw4KnQpKSxhfSx1LnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxPKGUsMSx0aGlzLmxlbmd0aCksMTI4JnRoaXNbZV0/LTEqKDI1NS10aGlzW2VdKzEpOnRoaXNbZV19LHUucHJvdG90eXBlLnJlYWRJbnQxNkxFPWZ1bmN0aW9uKGUsdCl7dHx8TyhlLDIsdGhpcy5sZW5ndGgpO3ZhciByPXRoaXNbZV18dGhpc1tlKzFdPDw4O3JldHVybiAzMjc2OCZyPzQyOTQ5MDE3NjB8cjpyfSx1LnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbihlLHQpe3R8fE8oZSwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0sdS5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8TyhlLDQsdGhpcy5sZW5ndGgpLHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTZ8dGhpc1tlKzNdPDwyNH0sdS5wcm90b3R5cGUucmVhZEludDMyQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8TyhlLDQsdGhpcy5sZW5ndGgpLHRoaXNbZV08PDI0fHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXX0sdS5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8TyhlLDQsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLGUsITAsMjMsNCl9LHUucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fE8oZSw0LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyxlLCExLDIzLDQpfSx1LnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8TyhlLDgsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLGUsITAsNTIsOCl9LHUucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxPKGUsOCx0aGlzLmxlbmd0aCksaS5yZWFkKHRoaXMsZSwhMSw1Miw4KX0sdS5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24oZSx0LHIsbil7KGU9K2UsdHw9MCxyfD0wLG4pfHxrKHRoaXMsZSx0LHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIGk9MSxhPTA7Zm9yKHRoaXNbdF09MjU1JmU7KythPHImJihpKj0yNTYpOyl0aGlzW3QrYV09ZS9pJjI1NTtyZXR1cm4gdCtyfSx1LnByb3RvdHlwZS53cml0ZVVJbnRCRT1mdW5jdGlvbihlLHQscixuKXsoZT0rZSx0fD0wLHJ8PTAsbil8fGsodGhpcyxlLHQscixNYXRoLnBvdygyLDgqciktMSwwKTt2YXIgaT1yLTEsYT0xO2Zvcih0aGlzW3QraV09MjU1JmU7LS1pPj0wJiYoYSo9MjU2KTspdGhpc1t0K2ldPWUvYSYyNTU7cmV0dXJuIHQrcn0sdS5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxrKHRoaXMsZSx0LDEsMjU1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVHx8KGU9TWF0aC5mbG9vcihlKSksdGhpc1t0XT0yNTUmZSx0KzF9LHUucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8ayh0aGlzLGUsdCwyLDY1NTM1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgpOlUodGhpcyxlLHQsITApLHQrMn0sdS5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxrKHRoaXMsZSx0LDIsNjU1MzUsMCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPWU+Pj44LHRoaXNbdCsxXT0yNTUmZSk6VSh0aGlzLGUsdCwhMSksdCsyfSx1LnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fGsodGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0KzNdPWU+Pj4yNCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCsxXT1lPj4+OCx0aGlzW3RdPTI1NSZlKTpMKHRoaXMsZSx0LCEwKSx0KzR9LHUucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8ayh0aGlzLGUsdCw0LDQyOTQ5NjcyOTUsMCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPWU+Pj4yNCx0aGlzW3QrMV09ZT4+PjE2LHRoaXNbdCsyXT1lPj4+OCx0aGlzW3QrM109MjU1JmUpOkwodGhpcyxlLHQsITEpLHQrNH0sdS5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbihlLHQscixuKXtpZihlPStlLHR8PTAsIW4pe3ZhciBpPU1hdGgucG93KDIsOCpyLTEpO2sodGhpcyxlLHQscixpLTEsLWkpfXZhciBhPTAscz0xLG89MDtmb3IodGhpc1t0XT0yNTUmZTsrK2E8ciYmKHMqPTI1Nik7KWU8MCYmMD09PW8mJjAhPT10aGlzW3QrYS0xXSYmKG89MSksdGhpc1t0K2FdPShlL3M+PjApLW8mMjU1O3JldHVybiB0K3J9LHUucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24oZSx0LHIsbil7aWYoZT0rZSx0fD0wLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtrKHRoaXMsZSx0LHIsaS0xLC1pKX12YXIgYT1yLTEscz0xLG89MDtmb3IodGhpc1t0K2FdPTI1NSZlOy0tYT49MCYmKHMqPTI1Nik7KWU8MCYmMD09PW8mJjAhPT10aGlzW3QrYSsxXSYmKG89MSksdGhpc1t0K2FdPShlL3M+PjApLW8mMjU1O3JldHVybiB0K3J9LHUucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlLHQscil7cmV0dXJuIGU9K2UsdHw9MCxyfHxrKHRoaXMsZSx0LDEsMTI3LC0xMjgpLHUuVFlQRURfQVJSQVlfU1VQUE9SVHx8KGU9TWF0aC5mbG9vcihlKSksZTwwJiYoZT0yNTUrZSsxKSx0aGlzW3RdPTI1NSZlLHQrMX0sdS5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fGsodGhpcyxlLHQsMiwzMjc2NywtMzI3NjgpLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgpOlUodGhpcyxlLHQsITApLHQrMn0sdS5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fGsodGhpcyxlLHQsMiwzMjc2NywtMzI3NjgpLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUpOlUodGhpcyxlLHQsITEpLHQrMn0sdS5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZT0rZSx0fD0wLHJ8fGsodGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44LHRoaXNbdCsyXT1lPj4+MTYsdGhpc1t0KzNdPWU+Pj4yNCk6TCh0aGlzLGUsdCwhMCksdCs0fSx1LnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPStlLHR8PTAscnx8ayh0aGlzLGUsdCw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLGU8MCYmKGU9NDI5NDk2NzI5NStlKzEpLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlKTpMKHRoaXMsZSx0LCExKSx0KzR9LHUucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIFYodGhpcyxlLHQsITAscil9LHUucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbihlLHQscil7cmV0dXJuIFYodGhpcyxlLHQsITEscil9LHUucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiB4KHRoaXMsZSx0LCEwLHIpfSx1LnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4geCh0aGlzLGUsdCwhMSxyKX0sdS5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlLHQscixuKXtpZihyfHwocj0wKSxufHwwPT09bnx8KG49dGhpcy5sZW5ndGgpLHQ+PWUubGVuZ3RoJiYodD1lLmxlbmd0aCksdHx8KHQ9MCksbj4wJiZuPHImJihuPXIpLG49PT1yKXJldHVybiAwO2lmKDA9PT1lLmxlbmd0aHx8MD09PXRoaXMubGVuZ3RoKXJldHVybiAwO2lmKHQ8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYocjwwfHxyPj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHNcIik7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7bj50aGlzLmxlbmd0aCYmKG49dGhpcy5sZW5ndGgpLGUubGVuZ3RoLXQ8bi1yJiYobj1lLmxlbmd0aC10K3IpO3ZhciBpLGE9bi1yO2lmKHRoaXM9PT1lJiZyPHQmJnQ8bilmb3IoaT1hLTE7aT49MDstLWkpZVtpK3RdPXRoaXNbaStyXTtlbHNlIGlmKGE8MWUzfHwhdS5UWVBFRF9BUlJBWV9TVVBQT1JUKWZvcihpPTA7aTxhOysraSllW2krdF09dGhpc1tpK3JdO2Vsc2UgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KHIscithKSx0KTtyZXR1cm4gYX0sdS5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbihlLHQscixuKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQ/KG49dCx0PTAscj10aGlzLmxlbmd0aCk6XCJzdHJpbmdcIj09dHlwZW9mIHImJihuPXIscj10aGlzLmxlbmd0aCksMT09PWUubGVuZ3RoKXt2YXIgaT1lLmNoYXJDb2RlQXQoMCk7aTwyNTYmJihlPWkpfWlmKHZvaWQgMCE9PW4mJlwic3RyaW5nXCIhPXR5cGVvZiBuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuJiYhdS5pc0VuY29kaW5nKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIituKX1lbHNlXCJudW1iZXJcIj09dHlwZW9mIGUmJihlJj0yNTUpO2lmKHQ8MHx8dGhpcy5sZW5ndGg8dHx8dGhpcy5sZW5ndGg8cil0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtpZihyPD10KXJldHVybiB0aGlzO3ZhciBhO2lmKHQ+Pj49MCxyPXZvaWQgMD09PXI/dGhpcy5sZW5ndGg6cj4+PjAsZXx8KGU9MCksXCJudW1iZXJcIj09dHlwZW9mIGUpZm9yKGE9dDthPHI7KythKXRoaXNbYV09ZTtlbHNle3ZhciBzPXUuaXNCdWZmZXIoZSk/ZTpqKG5ldyB1KGUsbikudG9TdHJpbmcoKSksbz1zLmxlbmd0aDtmb3IoYT0wO2E8ci10OysrYSl0aGlzW2ErdF09c1thJW9dfXJldHVybiB0aGlzfTt2YXIgSz0vW14rXFwvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gTShlKXtyZXR1cm4gZTwxNj9cIjBcIitlLnRvU3RyaW5nKDE2KTplLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiBqKGUsdCl7dmFyIHI7dD10fHwxLzA7Zm9yKHZhciBuPWUubGVuZ3RoLGk9bnVsbCxhPVtdLHM9MDtzPG47KytzKXtpZigocj1lLmNoYXJDb2RlQXQocykpPjU1Mjk1JiZyPDU3MzQ0KXtpZighaSl7aWYocj41NjMxOSl7KHQtPTMpPi0xJiZhLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWlmKHMrMT09PW4peyh0LT0zKT4tMSYmYS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pPXI7Y29udGludWV9aWYocjw1NjMyMCl7KHQtPTMpPi0xJiZhLnB1c2goMjM5LDE5MSwxODkpLGk9cjtjb250aW51ZX1yPTY1NTM2KyhpLTU1Mjk2PDwxMHxyLTU2MzIwKX1lbHNlIGkmJih0LT0zKT4tMSYmYS5wdXNoKDIzOSwxOTEsMTg5KTtpZihpPW51bGwscjwxMjgpe2lmKCh0LT0xKTwwKWJyZWFrO2EucHVzaChyKX1lbHNlIGlmKHI8MjA0OCl7aWYoKHQtPTIpPDApYnJlYWs7YS5wdXNoKHI+PjZ8MTkyLDYzJnJ8MTI4KX1lbHNlIGlmKHI8NjU1MzYpe2lmKCh0LT0zKTwwKWJyZWFrO2EucHVzaChyPj4xMnwyMjQscj4+NiY2M3wxMjgsNjMmcnwxMjgpfWVsc2V7aWYoIShyPDExMTQxMTIpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKTtpZigodC09NCk8MClicmVhazthLnB1c2gocj4+MTh8MjQwLHI+PjEyJjYzfDEyOCxyPj42JjYzfDEyOCw2MyZyfDEyOCl9fXJldHVybiBhfWZ1bmN0aW9uIEYoZSl7cmV0dXJuIG4udG9CeXRlQXJyYXkoZnVuY3Rpb24oZSl7aWYoKGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJpbT9lLnRyaW0oKTplLnJlcGxhY2UoL15cXHMrfFxccyskL2csXCJcIil9KGUpLnJlcGxhY2UoSyxcIlwiKSkubGVuZ3RoPDIpcmV0dXJuXCJcIjtmb3IoO2UubGVuZ3RoJTQhPTA7KWUrPVwiPVwiO3JldHVybiBlfShlKSl9ZnVuY3Rpb24gcShlLHQscixuKXtmb3IodmFyIGk9MDtpPG4mJiEoaStyPj10Lmxlbmd0aHx8aT49ZS5sZW5ndGgpOysraSl0W2krcl09ZVtpXTtyZXR1cm4gaX19KS5jYWxsKHRoaXMscigxNykpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1yKDExKSxhPXIoOTQpLHM9bihyKDMyKSksbz1uKHIoOSkpLHU9bihyKDk1KSksYz1yKDEwKTt0Ll9oYXNoQ2hhaW49ZnVuY3Rpb24oZSl7cmV0dXJuIGkuX2Zyb21Jbih0LmtlY2Nhayh0LmJsYWtlMmIoaS5fZnJvbUluKGUpKSkpfSx0LnNoYTI1Nj1mdW5jdGlvbihlKXt2YXIgdD1vLmFsZ29yaXRobXMuc2hhMjU2LmNyZWF0ZSgpO3JldHVybiB0LnVwZGF0ZShjLmJ5dGVzVG9TdHJpbmcoZSxcInJhd1wiKSksYy5zdHJpbmdUb0J5dGVzKHQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxcInJhd1wiKX0sdC5ibGFrZTJiPWZ1bmN0aW9uKGUpe3JldHVybiB1LmJsYWtlMmIoaS5fZnJvbUluKGUpLG51bGwsMzIpfSx0LmtlY2Nhaz1mdW5jdGlvbihlKXtyZXR1cm4gaS5fZnJvbUluKGEua2VjY2FrMjU2LmFycmF5KGkuX2Zyb21JbihlKSkpfSx0LmhtYWNTSEEyNTY9ZnVuY3Rpb24oZSx0KXt2YXIgcj1zLmNyZWF0ZSgpO3JldHVybiByLnN0YXJ0KFwic2hhMjU2XCIsYy5ieXRlc1RvU3RyaW5nKGkuX2Zyb21Jbih0KSxcInJhd1wiKSksci51cGRhdGUoYy5ieXRlc1RvU3RyaW5nKGkuX2Zyb21JbihlKSxcInJhd1wiKSksYy5zdHJpbmdUb0J5dGVzKHIuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxcInJhd1wiKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMikscigxNik7dmFyIGk9ZS5leHBvcnRzPW4uYXNuMT1uLmFzbjF8fHt9O2Z1bmN0aW9uIGEoZSx0LHIpe2lmKHI+dCl7dmFyIG49bmV3IEVycm9yKFwiVG9vIGZldyBieXRlcyB0byBwYXJzZSBERVIuXCIpO3Rocm93IG4uYXZhaWxhYmxlPWUubGVuZ3RoKCksbi5yZW1haW5pbmc9dCxuLnJlcXVlc3RlZD1yLG59fWkuQ2xhc3M9e1VOSVZFUlNBTDowLEFQUExJQ0FUSU9OOjY0LENPTlRFWFRfU1BFQ0lGSUM6MTI4LFBSSVZBVEU6MTkyfSxpLlR5cGU9e05PTkU6MCxCT09MRUFOOjEsSU5URUdFUjoyLEJJVFNUUklORzozLE9DVEVUU1RSSU5HOjQsTlVMTDo1LE9JRDo2LE9ERVNDOjcsRVhURVJOQUw6OCxSRUFMOjksRU5VTUVSQVRFRDoxMCxFTUJFRERFRDoxMSxVVEY4OjEyLFJPSUQ6MTMsU0VRVUVOQ0U6MTYsU0VUOjE3LFBSSU5UQUJMRVNUUklORzoxOSxJQTVTVFJJTkc6MjIsVVRDVElNRToyMyxHRU5FUkFMSVpFRFRJTUU6MjQsQk1QU1RSSU5HOjMwfSxpLmNyZWF0ZT1mdW5jdGlvbihlLHQscixhLHMpe2lmKG4udXRpbC5pc0FycmF5KGEpKXtmb3IodmFyIG89W10sdT0wO3U8YS5sZW5ndGg7Kyt1KXZvaWQgMCE9PWFbdV0mJm8ucHVzaChhW3VdKTthPW99dmFyIGM9e3RhZ0NsYXNzOmUsdHlwZTp0LGNvbnN0cnVjdGVkOnIsY29tcG9zZWQ6cnx8bi51dGlsLmlzQXJyYXkoYSksdmFsdWU6YX07cmV0dXJuIHMmJlwiYml0U3RyaW5nQ29udGVudHNcImluIHMmJihjLmJpdFN0cmluZ0NvbnRlbnRzPXMuYml0U3RyaW5nQ29udGVudHMsYy5vcmlnaW5hbD1pLmNvcHkoYykpLGN9LGkuY29weT1mdW5jdGlvbihlLHQpe3ZhciByO2lmKG4udXRpbC5pc0FycmF5KGUpKXtyPVtdO2Zvcih2YXIgYT0wO2E8ZS5sZW5ndGg7KythKXIucHVzaChpLmNvcHkoZVthXSx0KSk7cmV0dXJuIHJ9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZToocj17dGFnQ2xhc3M6ZS50YWdDbGFzcyx0eXBlOmUudHlwZSxjb25zdHJ1Y3RlZDplLmNvbnN0cnVjdGVkLGNvbXBvc2VkOmUuY29tcG9zZWQsdmFsdWU6aS5jb3B5KGUudmFsdWUsdCl9LHQmJiF0LmV4Y2x1ZGVCaXRTdHJpbmdDb250ZW50cyYmKHIuYml0U3RyaW5nQ29udGVudHM9ZS5iaXRTdHJpbmdDb250ZW50cykscil9LGkuZXF1YWxzPWZ1bmN0aW9uKGUsdCxyKXtpZihuLnV0aWwuaXNBcnJheShlKSl7aWYoIW4udXRpbC5pc0FycmF5KHQpKXJldHVybiExO2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2EpaWYoIWkuZXF1YWxzKGVbYV0sdFthXSkpcmV0dXJuITE7cmV0dXJuITB9aWYodHlwZW9mIGUhPXR5cGVvZiB0KXJldHVybiExO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBlPT09dDt2YXIgcz1lLnRhZ0NsYXNzPT09dC50YWdDbGFzcyYmZS50eXBlPT09dC50eXBlJiZlLmNvbnN0cnVjdGVkPT09dC5jb25zdHJ1Y3RlZCYmZS5jb21wb3NlZD09PXQuY29tcG9zZWQmJmkuZXF1YWxzKGUudmFsdWUsdC52YWx1ZSk7cmV0dXJuIHImJnIuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzJiYocz1zJiZlLmJpdFN0cmluZ0NvbnRlbnRzPT09dC5iaXRTdHJpbmdDb250ZW50cyksc30saS5nZXRCZXJWYWx1ZUxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1lLmdldEJ5dGUoKTtpZigxMjghPT10KXJldHVybiAxMjgmdD9lLmdldEludCgoMTI3JnQpPDwzKTp0fTt2YXIgcz1mdW5jdGlvbihlLHQpe3ZhciByPWUuZ2V0Qnl0ZSgpO2lmKHQtLSwxMjghPT1yKXt2YXIgbjtpZigxMjgmcil7dmFyIGk9MTI3JnI7YShlLHQsaSksbj1lLmdldEludChpPDwzKX1lbHNlIG49cjtpZihuPDApdGhyb3cgbmV3IEVycm9yKFwiTmVnYXRpdmUgbGVuZ3RoOiBcIituKTtyZXR1cm4gbn19O2kuZnJvbURlcj1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17c3RyaWN0OiEwLGRlY29kZUJpdFN0cmluZ3M6ITB9KSxcImJvb2xlYW5cIj09dHlwZW9mIHQmJih0PXtzdHJpY3Q6dCxkZWNvZGVCaXRTdHJpbmdzOiEwfSksXCJzdHJpY3RcImluIHR8fCh0LnN0cmljdD0hMCksXCJkZWNvZGVCaXRTdHJpbmdzXCJpbiB0fHwodC5kZWNvZGVCaXRTdHJpbmdzPSEwKSxcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bi51dGlsLmNyZWF0ZUJ1ZmZlcihlKSksZnVuY3Rpb24gZSh0LHIsbixvKXt2YXIgdTthKHQsciwyKTt2YXIgYz10LmdldEJ5dGUoKTtyLS07dmFyIGw9MTkyJmMsZj0zMSZjO3U9dC5sZW5ndGgoKTt2YXIgaCxwLGQ9cyh0LHIpO2lmKHItPXUtdC5sZW5ndGgoKSx2b2lkIDAhPT1kJiZkPnIpe2lmKG8uc3RyaWN0KXt2YXIgeT1uZXcgRXJyb3IoXCJUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuXCIpO3Rocm93IHkuYXZhaWxhYmxlPXQubGVuZ3RoKCkseS5yZW1haW5pbmc9cix5LnJlcXVlc3RlZD1kLHl9ZD1yfXZhciBnPTMyPT0oMzImYyk7aWYoZylpZihoPVtdLHZvaWQgMD09PWQpZm9yKDs7KXtpZihhKHQsciwyKSx0LmJ5dGVzKDIpPT09U3RyaW5nLmZyb21DaGFyQ29kZSgwLDApKXt0LmdldEJ5dGVzKDIpLHItPTI7YnJlYWt9dT10Lmxlbmd0aCgpLGgucHVzaChlKHQscixuKzEsbykpLHItPXUtdC5sZW5ndGgoKX1lbHNlIGZvcig7ZD4wOyl1PXQubGVuZ3RoKCksaC5wdXNoKGUodCxkLG4rMSxvKSksci09dS10Lmxlbmd0aCgpLGQtPXUtdC5sZW5ndGgoKTt2b2lkIDA9PT1oJiZsPT09aS5DbGFzcy5VTklWRVJTQUwmJmY9PT1pLlR5cGUuQklUU1RSSU5HJiYocD10LmJ5dGVzKGQpKTtpZih2b2lkIDA9PT1oJiZvLmRlY29kZUJpdFN0cmluZ3MmJmw9PT1pLkNsYXNzLlVOSVZFUlNBTCYmZj09PWkuVHlwZS5CSVRTVFJJTkcmJmQ+MSl7dmFyIG09dC5yZWFkLHY9cixiPTA7aWYoZj09PWkuVHlwZS5CSVRTVFJJTkcmJihhKHQsciwxKSxiPXQuZ2V0Qnl0ZSgpLHItLSksMD09PWIpdHJ5e3U9dC5sZW5ndGgoKTt2YXIgRT17dmVyYm9zZTpvLnZlcmJvc2Usc3RyaWN0OiEwLGRlY29kZUJpdFN0cmluZ3M6ITB9LFM9ZSh0LHIsbisxLEUpLFQ9dS10Lmxlbmd0aCgpO3ItPVQsZj09aS5UeXBlLkJJVFNUUklORyYmVCsrO3ZhciBDPVMudGFnQ2xhc3M7VCE9PWR8fEMhPT1pLkNsYXNzLlVOSVZFUlNBTCYmQyE9PWkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQ3x8KGg9W1NdKX1jYXRjaChlKXt9dm9pZCAwPT09aCYmKHQucmVhZD1tLHI9dil9aWYodm9pZCAwPT09aCl7aWYodm9pZCAwPT09ZCl7aWYoby5zdHJpY3QpdGhyb3cgbmV3IEVycm9yKFwiTm9uLWNvbnN0cnVjdGVkIEFTTi4xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aC5cIik7ZD1yfWlmKGY9PT1pLlR5cGUuQk1QU1RSSU5HKWZvcihoPVwiXCI7ZD4wO2QtPTIpYSh0LHIsMiksaCs9U3RyaW5nLmZyb21DaGFyQ29kZSh0LmdldEludDE2KCkpLHItPTI7ZWxzZSBoPXQuZ2V0Qnl0ZXMoZCl9dmFyIEE9dm9pZCAwPT09cD9udWxsOntiaXRTdHJpbmdDb250ZW50czpwfTtyZXR1cm4gaS5jcmVhdGUobCxmLGcsaCxBKX0oZSxlLmxlbmd0aCgpLDAsdCl9LGkudG9EZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLHI9ZS50YWdDbGFzc3xlLnR5cGUsYT1uLnV0aWwuY3JlYXRlQnVmZmVyKCkscz0hMTtpZihcImJpdFN0cmluZ0NvbnRlbnRzXCJpbiBlJiYocz0hMCxlLm9yaWdpbmFsJiYocz1pLmVxdWFscyhlLGUub3JpZ2luYWwpKSkscylhLnB1dEJ5dGVzKGUuYml0U3RyaW5nQ29udGVudHMpO2Vsc2UgaWYoZS5jb21wb3NlZCl7ZS5jb25zdHJ1Y3RlZD9yfD0zMjphLnB1dEJ5dGUoMCk7Zm9yKHZhciBvPTA7bzxlLnZhbHVlLmxlbmd0aDsrK28pdm9pZCAwIT09ZS52YWx1ZVtvXSYmYS5wdXRCdWZmZXIoaS50b0RlcihlLnZhbHVlW29dKSl9ZWxzZSBpZihlLnR5cGU9PT1pLlR5cGUuQk1QU1RSSU5HKWZvcihvPTA7bzxlLnZhbHVlLmxlbmd0aDsrK28pYS5wdXRJbnQxNihlLnZhbHVlLmNoYXJDb2RlQXQobykpO2Vsc2UgZS50eXBlPT09aS5UeXBlLklOVEVHRVImJmUudmFsdWUubGVuZ3RoPjEmJigwPT09ZS52YWx1ZS5jaGFyQ29kZUF0KDApJiYwPT0oMTI4JmUudmFsdWUuY2hhckNvZGVBdCgxKSl8fDI1NT09PWUudmFsdWUuY2hhckNvZGVBdCgwKSYmMTI4PT0oMTI4JmUudmFsdWUuY2hhckNvZGVBdCgxKSkpP2EucHV0Qnl0ZXMoZS52YWx1ZS5zdWJzdHIoMSkpOmEucHV0Qnl0ZXMoZS52YWx1ZSk7aWYodC5wdXRCeXRlKHIpLGEubGVuZ3RoKCk8PTEyNyl0LnB1dEJ5dGUoMTI3JmEubGVuZ3RoKCkpO2Vsc2V7dmFyIHU9YS5sZW5ndGgoKSxjPVwiXCI7ZG97Yys9U3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdSksdT4+Pj04fXdoaWxlKHU+MCk7dC5wdXRCeXRlKDEyOHxjLmxlbmd0aCk7Zm9yKG89Yy5sZW5ndGgtMTtvPj0wOy0tbyl0LnB1dEJ5dGUoYy5jaGFyQ29kZUF0KG8pKX1yZXR1cm4gdC5wdXRCdWZmZXIoYSksdH0saS5vaWRUb0Rlcj1mdW5jdGlvbihlKXt2YXIgdCxyLGksYSxzPWUuc3BsaXQoXCIuXCIpLG89bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO28ucHV0Qnl0ZSg0MCpwYXJzZUludChzWzBdLDEwKStwYXJzZUludChzWzFdLDEwKSk7Zm9yKHZhciB1PTI7dTxzLmxlbmd0aDsrK3Upe3Q9ITAscj1bXSxpPXBhcnNlSW50KHNbdV0sMTApO2Rve2E9MTI3JmksaT4+Pj03LHR8fChhfD0xMjgpLHIucHVzaChhKSx0PSExfXdoaWxlKGk+MCk7Zm9yKHZhciBjPXIubGVuZ3RoLTE7Yz49MDstLWMpby5wdXRCeXRlKHJbY10pfXJldHVybiBvfSxpLmRlclRvT2lkPWZ1bmN0aW9uKGUpe3ZhciB0O1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1uLnV0aWwuY3JlYXRlQnVmZmVyKGUpKTt2YXIgcj1lLmdldEJ5dGUoKTt0PU1hdGguZmxvb3Ioci80MCkrXCIuXCIrciU0MDtmb3IodmFyIGk9MDtlLmxlbmd0aCgpPjA7KWk8PD03LDEyOCYocj1lLmdldEJ5dGUoKSk/aSs9MTI3JnI6KHQrPVwiLlwiKyhpK3IpLGk9MCk7cmV0dXJuIHR9LGkudXRjVGltZVRvRGF0ZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZSxyPXBhcnNlSW50KGUuc3Vic3RyKDAsMiksMTApO3I9cj49NTA/MTkwMCtyOjJlMytyO3ZhciBuPXBhcnNlSW50KGUuc3Vic3RyKDIsMiksMTApLTEsaT1wYXJzZUludChlLnN1YnN0cig0LDIpLDEwKSxhPXBhcnNlSW50KGUuc3Vic3RyKDYsMiksMTApLHM9cGFyc2VJbnQoZS5zdWJzdHIoOCwyKSwxMCksbz0wO2lmKGUubGVuZ3RoPjExKXt2YXIgdT1lLmNoYXJBdCgxMCksYz0xMDtcIitcIiE9PXUmJlwiLVwiIT09dSYmKG89cGFyc2VJbnQoZS5zdWJzdHIoMTAsMiksMTApLGMrPTIpfWlmKHQuc2V0VVRDRnVsbFllYXIocixuLGkpLHQuc2V0VVRDSG91cnMoYSxzLG8sMCksYyYmKFwiK1wiPT09KHU9ZS5jaGFyQXQoYykpfHxcIi1cIj09PXUpKXt2YXIgbD02MCpwYXJzZUludChlLnN1YnN0cihjKzEsMiksMTApK3BhcnNlSW50KGUuc3Vic3RyKGMrNCwyKSwxMCk7bCo9NmU0LFwiK1wiPT09dT90LnNldFRpbWUoK3QtbCk6dC5zZXRUaW1lKCt0K2wpfXJldHVybiB0fSxpLmdlbmVyYWxpemVkVGltZVRvRGF0ZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0ZSxyPXBhcnNlSW50KGUuc3Vic3RyKDAsNCksMTApLG49cGFyc2VJbnQoZS5zdWJzdHIoNCwyKSwxMCktMSxpPXBhcnNlSW50KGUuc3Vic3RyKDYsMiksMTApLGE9cGFyc2VJbnQoZS5zdWJzdHIoOCwyKSwxMCkscz1wYXJzZUludChlLnN1YnN0cigxMCwyKSwxMCksbz1wYXJzZUludChlLnN1YnN0cigxMiwyKSwxMCksdT0wLGM9MCxsPSExO1wiWlwiPT09ZS5jaGFyQXQoZS5sZW5ndGgtMSkmJihsPSEwKTt2YXIgZj1lLmxlbmd0aC01LGg9ZS5jaGFyQXQoZik7XCIrXCIhPT1oJiZcIi1cIiE9PWh8fChjPTYwKnBhcnNlSW50KGUuc3Vic3RyKGYrMSwyKSwxMCkrcGFyc2VJbnQoZS5zdWJzdHIoZis0LDIpLDEwKSxjKj02ZTQsXCIrXCI9PT1oJiYoYyo9LTEpLGw9ITApO3JldHVyblwiLlwiPT09ZS5jaGFyQXQoMTQpJiYodT0xZTMqcGFyc2VGbG9hdChlLnN1YnN0cigxNCksMTApKSxsPyh0LnNldFVUQ0Z1bGxZZWFyKHIsbixpKSx0LnNldFVUQ0hvdXJzKGEscyxvLHUpLHQuc2V0VGltZSgrdCtjKSk6KHQuc2V0RnVsbFllYXIocixuLGkpLHQuc2V0SG91cnMoYSxzLG8sdSkpLHR9LGkuZGF0ZVRvVXRjVGltZT1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gZTt2YXIgdD1cIlwiLHI9W107ci5wdXNoKChcIlwiK2UuZ2V0VVRDRnVsbFllYXIoKSkuc3Vic3RyKDIpKSxyLnB1c2goXCJcIisoZS5nZXRVVENNb250aCgpKzEpKSxyLnB1c2goXCJcIitlLmdldFVUQ0RhdGUoKSksci5wdXNoKFwiXCIrZS5nZXRVVENIb3VycygpKSxyLnB1c2goXCJcIitlLmdldFVUQ01pbnV0ZXMoKSksci5wdXNoKFwiXCIrZS5nZXRVVENTZWNvbmRzKCkpO2Zvcih2YXIgbj0wO248ci5sZW5ndGg7KytuKXJbbl0ubGVuZ3RoPDImJih0Kz1cIjBcIiksdCs9cltuXTtyZXR1cm4gdCs9XCJaXCJ9LGkuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lPWZ1bmN0aW9uKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBlO3ZhciB0PVwiXCIscj1bXTtyLnB1c2goXCJcIitlLmdldFVUQ0Z1bGxZZWFyKCkpLHIucHVzaChcIlwiKyhlLmdldFVUQ01vbnRoKCkrMSkpLHIucHVzaChcIlwiK2UuZ2V0VVRDRGF0ZSgpKSxyLnB1c2goXCJcIitlLmdldFVUQ0hvdXJzKCkpLHIucHVzaChcIlwiK2UuZ2V0VVRDTWludXRlcygpKSxyLnB1c2goXCJcIitlLmdldFVUQ1NlY29uZHMoKSk7Zm9yKHZhciBuPTA7bjxyLmxlbmd0aDsrK24pcltuXS5sZW5ndGg8MiYmKHQrPVwiMFwiKSx0Kz1yW25dO3JldHVybiB0Kz1cIlpcIn0saS5pbnRlZ2VyVG9EZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO2lmKGU+PS0xMjgmJmU8MTI4KXJldHVybiB0LnB1dFNpZ25lZEludChlLDgpO2lmKGU+PS0zMjc2OCYmZTwzMjc2OClyZXR1cm4gdC5wdXRTaWduZWRJbnQoZSwxNik7aWYoZT49LTgzODg2MDgmJmU8ODM4ODYwOClyZXR1cm4gdC5wdXRTaWduZWRJbnQoZSwyNCk7aWYoZT49LTIxNDc0ODM2NDgmJmU8MjE0NzQ4MzY0OClyZXR1cm4gdC5wdXRTaWduZWRJbnQoZSwzMik7dmFyIHI9bmV3IEVycm9yKFwiSW50ZWdlciB0b28gbGFyZ2U7IG1heCBpcyAzMi1iaXRzLlwiKTt0aHJvdyByLmludGVnZXI9ZSxyfSxpLmRlclRvSW50ZWdlcj1mdW5jdGlvbihlKXtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bi51dGlsLmNyZWF0ZUJ1ZmZlcihlKSk7dmFyIHQ9OCplLmxlbmd0aCgpO2lmKHQ+MzIpdGhyb3cgbmV3IEVycm9yKFwiSW50ZWdlciB0b28gbGFyZ2U7IG1heCBpcyAzMi1iaXRzLlwiKTtyZXR1cm4gZS5nZXRTaWduZWRJbnQodCl9LGkudmFsaWRhdGU9ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIHM9ITE7aWYoZS50YWdDbGFzcyE9PXQudGFnQ2xhc3MmJnZvaWQgMCE9PXQudGFnQ2xhc3N8fGUudHlwZSE9PXQudHlwZSYmdm9pZCAwIT09dC50eXBlKWEmJihlLnRhZ0NsYXNzIT09dC50YWdDbGFzcyYmYS5wdXNoKFwiW1wiK3QubmFtZSsnXSBFeHBlY3RlZCB0YWcgY2xhc3MgXCInK3QudGFnQ2xhc3MrJ1wiLCBnb3QgXCInK2UudGFnQ2xhc3MrJ1wiJyksZS50eXBlIT09dC50eXBlJiZhLnB1c2goXCJbXCIrdC5uYW1lKyddIEV4cGVjdGVkIHR5cGUgXCInK3QudHlwZSsnXCIsIGdvdCBcIicrZS50eXBlKydcIicpKTtlbHNlIGlmKGUuY29uc3RydWN0ZWQ9PT10LmNvbnN0cnVjdGVkfHx2b2lkIDA9PT10LmNvbnN0cnVjdGVkKXtpZihzPSEwLHQudmFsdWUmJm4udXRpbC5pc0FycmF5KHQudmFsdWUpKWZvcih2YXIgbz0wLHU9MDtzJiZ1PHQudmFsdWUubGVuZ3RoOysrdSlzPXQudmFsdWVbdV0ub3B0aW9uYWx8fCExLGUudmFsdWVbb10mJigocz1pLnZhbGlkYXRlKGUudmFsdWVbb10sdC52YWx1ZVt1XSxyLGEpKT8rK286dC52YWx1ZVt1XS5vcHRpb25hbCYmKHM9ITApKSwhcyYmYSYmYS5wdXNoKFwiW1wiK3QubmFtZSsnXSBUYWcgY2xhc3MgXCInK3QudGFnQ2xhc3MrJ1wiLCB0eXBlIFwiJyt0LnR5cGUrJ1wiIGV4cGVjdGVkIHZhbHVlIGxlbmd0aCBcIicrdC52YWx1ZS5sZW5ndGgrJ1wiLCBnb3QgXCInK2UudmFsdWUubGVuZ3RoKydcIicpO2lmKHMmJnIpaWYodC5jYXB0dXJlJiYoclt0LmNhcHR1cmVdPWUudmFsdWUpLHQuY2FwdHVyZUFzbjEmJihyW3QuY2FwdHVyZUFzbjFdPWUpLHQuY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzJiZcImJpdFN0cmluZ0NvbnRlbnRzXCJpbiBlJiYoclt0LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50c109ZS5iaXRTdHJpbmdDb250ZW50cyksdC5jYXB0dXJlQml0U3RyaW5nVmFsdWUmJlwiYml0U3RyaW5nQ29udGVudHNcImluIGUpaWYoZS5iaXRTdHJpbmdDb250ZW50cy5sZW5ndGg8MilyW3QuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXT1cIlwiO2Vsc2V7aWYoMCE9PWUuYml0U3RyaW5nQ29udGVudHMuY2hhckNvZGVBdCgwKSl0aHJvdyBuZXcgRXJyb3IoXCJjYXB0dXJlQml0U3RyaW5nVmFsdWUgb25seSBzdXBwb3J0ZWQgZm9yIHplcm8gdW51c2VkIGJpdHNcIik7clt0LmNhcHR1cmVCaXRTdHJpbmdWYWx1ZV09ZS5iaXRTdHJpbmdDb250ZW50cy5zbGljZSgxKX19ZWxzZSBhJiZhLnB1c2goXCJbXCIrdC5uYW1lKyddIEV4cGVjdGVkIGNvbnN0cnVjdGVkIFwiJyt0LmNvbnN0cnVjdGVkKydcIiwgZ290IFwiJytlLmNvbnN0cnVjdGVkKydcIicpO3JldHVybiBzfTt2YXIgbz0vW15cXFxcdTAwMDAtXFxcXHUwMGZmXS87aS5wcmV0dHlQcmludD1mdW5jdGlvbihlLHQscil7dmFyIGE9XCJcIjtyPXJ8fDIsKHQ9dHx8MCk+MCYmKGErPVwiXFxuXCIpO2Zvcih2YXIgcz1cIlwiLHU9MDt1PHQqcjsrK3Upcys9XCIgXCI7c3dpdGNoKGErPXMrXCJUYWc6IFwiLGUudGFnQ2xhc3Mpe2Nhc2UgaS5DbGFzcy5VTklWRVJTQUw6YSs9XCJVbml2ZXJzYWw6XCI7YnJlYWs7Y2FzZSBpLkNsYXNzLkFQUExJQ0FUSU9OOmErPVwiQXBwbGljYXRpb246XCI7YnJlYWs7Y2FzZSBpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUM6YSs9XCJDb250ZXh0LVNwZWNpZmljOlwiO2JyZWFrO2Nhc2UgaS5DbGFzcy5QUklWQVRFOmErPVwiUHJpdmF0ZTpcIn1pZihlLnRhZ0NsYXNzPT09aS5DbGFzcy5VTklWRVJTQUwpc3dpdGNoKGErPWUudHlwZSxlLnR5cGUpe2Nhc2UgaS5UeXBlLk5PTkU6YSs9XCIgKE5vbmUpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuQk9PTEVBTjphKz1cIiAoQm9vbGVhbilcIjticmVhaztjYXNlIGkuVHlwZS5JTlRFR0VSOmErPVwiIChJbnRlZ2VyKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLkJJVFNUUklORzphKz1cIiAoQml0IHN0cmluZylcIjticmVhaztjYXNlIGkuVHlwZS5PQ1RFVFNUUklORzphKz1cIiAoT2N0ZXQgc3RyaW5nKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLk5VTEw6YSs9XCIgKE51bGwpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuT0lEOmErPVwiIChPYmplY3QgSWRlbnRpZmllcilcIjticmVhaztjYXNlIGkuVHlwZS5PREVTQzphKz1cIiAoT2JqZWN0IERlc2NyaXB0b3IpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuRVhURVJOQUw6YSs9XCIgKEV4dGVybmFsIG9yIEluc3RhbmNlIG9mKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLlJFQUw6YSs9XCIgKFJlYWwpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuRU5VTUVSQVRFRDphKz1cIiAoRW51bWVyYXRlZClcIjticmVhaztjYXNlIGkuVHlwZS5FTUJFRERFRDphKz1cIiAoRW1iZWRkZWQgUERWKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLlVURjg6YSs9XCIgKFVURjgpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuUk9JRDphKz1cIiAoUmVsYXRpdmUgT2JqZWN0IElkZW50aWZpZXIpXCI7YnJlYWs7Y2FzZSBpLlR5cGUuU0VRVUVOQ0U6YSs9XCIgKFNlcXVlbmNlKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLlNFVDphKz1cIiAoU2V0KVwiO2JyZWFrO2Nhc2UgaS5UeXBlLlBSSU5UQUJMRVNUUklORzphKz1cIiAoUHJpbnRhYmxlIFN0cmluZylcIjticmVhaztjYXNlIGkuVHlwZS5JQTVTdHJpbmc6YSs9XCIgKElBNVN0cmluZyAoQVNDSUkpKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLlVUQ1RJTUU6YSs9XCIgKFVUQyB0aW1lKVwiO2JyZWFrO2Nhc2UgaS5UeXBlLkdFTkVSQUxJWkVEVElNRTphKz1cIiAoR2VuZXJhbGl6ZWQgdGltZSlcIjticmVhaztjYXNlIGkuVHlwZS5CTVBTVFJJTkc6YSs9XCIgKEJNUCBTdHJpbmcpXCJ9ZWxzZSBhKz1lLnR5cGU7aWYoYSs9XCJcXG5cIixhKz1zK1wiQ29uc3RydWN0ZWQ6IFwiK2UuY29uc3RydWN0ZWQrXCJcXG5cIixlLmNvbXBvc2VkKXt2YXIgYz0wLGw9XCJcIjtmb3IodT0wO3U8ZS52YWx1ZS5sZW5ndGg7Kyt1KXZvaWQgMCE9PWUudmFsdWVbdV0mJihjKz0xLGwrPWkucHJldHR5UHJpbnQoZS52YWx1ZVt1XSx0KzEsciksdSsxPGUudmFsdWUubGVuZ3RoJiYobCs9XCIsXCIpKTthKz1zK1wiU3ViIHZhbHVlczogXCIrYytsfWVsc2V7aWYoYSs9cytcIlZhbHVlOiBcIixlLnR5cGU9PT1pLlR5cGUuT0lEKXt2YXIgZj1pLmRlclRvT2lkKGUudmFsdWUpO2ErPWYsbi5wa2kmJm4ucGtpLm9pZHMmJmYgaW4gbi5wa2kub2lkcyYmKGErPVwiIChcIituLnBraS5vaWRzW2ZdK1wiKSBcIil9aWYoZS50eXBlPT09aS5UeXBlLklOVEVHRVIpdHJ5e2ErPWkuZGVyVG9JbnRlZ2VyKGUudmFsdWUpfWNhdGNoKHQpe2ErPVwiMHhcIituLnV0aWwuYnl0ZXNUb0hleChlLnZhbHVlKX1lbHNlIGlmKGUudHlwZT09PWkuVHlwZS5CSVRTVFJJTkcpe2lmKGUudmFsdWUubGVuZ3RoPjE/YSs9XCIweFwiK24udXRpbC5ieXRlc1RvSGV4KGUudmFsdWUuc2xpY2UoMSkpOmErPVwiKG5vbmUpXCIsZS52YWx1ZS5sZW5ndGg+MCl7dmFyIGg9ZS52YWx1ZS5jaGFyQ29kZUF0KDApOzE9PWg/YSs9XCIgKDEgdW51c2VkIGJpdCBzaG93bilcIjpoPjEmJihhKz1cIiAoXCIraCtcIiB1bnVzZWQgYml0cyBzaG93bilcIil9fWVsc2UgZS50eXBlPT09aS5UeXBlLk9DVEVUU1RSSU5HPyhvLnRlc3QoZS52YWx1ZSl8fChhKz1cIihcIitlLnZhbHVlK1wiKSBcIiksYSs9XCIweFwiK24udXRpbC5ieXRlc1RvSGV4KGUudmFsdWUpKTplLnR5cGU9PT1pLlR5cGUuVVRGOD9hKz1uLnV0aWwuZGVjb2RlVXRmOChlLnZhbHVlKTplLnR5cGU9PT1pLlR5cGUuUFJJTlRBQkxFU1RSSU5HfHxlLnR5cGU9PT1pLlR5cGUuSUE1U3RyaW5nP2ErPWUudmFsdWU6by50ZXN0KGUudmFsdWUpP2ErPVwiMHhcIituLnV0aWwuYnl0ZXNUb0hleChlLnZhbHVlKTowPT09ZS52YWx1ZS5sZW5ndGg/YSs9XCJbbnVsbF1cIjphKz1lLnZhbHVlfXJldHVybiBhfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7bi5wa2k9bi5wa2l8fHt9O3ZhciBpPWUuZXhwb3J0cz1uLnBraS5vaWRzPW4ub2lkcz1uLm9pZHN8fHt9O2Z1bmN0aW9uIGEoZSx0KXtpW2VdPXQsaVt0XT1lfWZ1bmN0aW9uIHMoZSx0KXtpW2VdPXR9YShcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCIsXCJyc2FFbmNyeXB0aW9uXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEuNFwiLFwibWQ1V2l0aFJTQUVuY3J5cHRpb25cIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMS41XCIsXCJzaGExV2l0aFJTQUVuY3J5cHRpb25cIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMS43XCIsXCJSU0FFUy1PQUVQXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEuOFwiLFwibWdmMVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjlcIixcInBTcGVjaWZpZWRcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMS4xMFwiLFwiUlNBU1NBLVBTU1wiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjExXCIsXCJzaGEyNTZXaXRoUlNBRW5jcnlwdGlvblwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjEyXCIsXCJzaGEzODRXaXRoUlNBRW5jcnlwdGlvblwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xLjEzXCIsXCJzaGE1MTJXaXRoUlNBRW5jcnlwdGlvblwiKSxhKFwiMS4yLjg0MC4xMDA0MC40LjNcIixcImRzYS13aXRoLXNoYTFcIiksYShcIjEuMy4xNC4zLjIuN1wiLFwiZGVzQ0JDXCIpLGEoXCIxLjMuMTQuMy4yLjI2XCIsXCJzaGExXCIpLGEoXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMi4xXCIsXCJzaGEyNTZcIiksYShcIjIuMTYuODQwLjEuMTAxLjMuNC4yLjJcIixcInNoYTM4NFwiKSxhKFwiMi4xNi44NDAuMS4xMDEuMy40LjIuM1wiLFwic2hhNTEyXCIpLGEoXCIxLjIuODQwLjExMzU0OS4yLjVcIixcIm1kNVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS43LjFcIixcImRhdGFcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuNy4yXCIsXCJzaWduZWREYXRhXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjcuM1wiLFwiZW52ZWxvcGVkRGF0YVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS43LjRcIixcInNpZ25lZEFuZEVudmVsb3BlZERhdGFcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuNy41XCIsXCJkaWdlc3RlZERhdGFcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuNy42XCIsXCJlbmNyeXB0ZWREYXRhXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuMVwiLFwiZW1haWxBZGRyZXNzXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuMlwiLFwidW5zdHJ1Y3R1cmVkTmFtZVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS45LjNcIixcImNvbnRlbnRUeXBlXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuNFwiLFwibWVzc2FnZURpZ2VzdFwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS45LjVcIixcInNpZ25pbmdUaW1lXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuNlwiLFwiY291bnRlclNpZ25hdHVyZVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS45LjdcIixcImNoYWxsZW5nZVBhc3N3b3JkXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuOFwiLFwidW5zdHJ1Y3R1cmVkQWRkcmVzc1wiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS45LjE0XCIsXCJleHRlbnNpb25SZXF1ZXN0XCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuMjBcIixcImZyaWVuZGx5TmFtZVwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS45LjIxXCIsXCJsb2NhbEtleUlkXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjkuMjIuMVwiLFwieDUwOUNlcnRpZmljYXRlXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMVwiLFwia2V5QmFnXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMlwiLFwicGtjczhTaHJvdWRlZEtleUJhZ1wiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjNcIixcImNlcnRCYWdcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS40XCIsXCJjcmxCYWdcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41XCIsXCJzZWNyZXRCYWdcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS42XCIsXCJzYWZlQ29udGVudHNCYWdcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuNS4xM1wiLFwicGtjczVQQkVTMlwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS41LjEyXCIsXCJwa2NzNVBCS0RGMlwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjFcIixcInBiZVdpdGhTSEFBbmQxMjhCaXRSQzRcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yXCIsXCJwYmVXaXRoU0hBQW5kNDBCaXRSQzRcIiksYShcIjEuMi44NDAuMTEzNTQ5LjEuMTIuMS4zXCIsXCJwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEyLjEuNFwiLFwicGJlV2l0aFNIQUFuZDItS2V5VHJpcGxlREVTLUNCQ1wiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjVcIixcInBiZVdpdGhTSEFBbmQxMjhCaXRSQzItQ0JDXCIpLGEoXCIxLjIuODQwLjExMzU0OS4xLjEyLjEuNlwiLFwicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMi43XCIsXCJobWFjV2l0aFNIQTFcIiksYShcIjEuMi44NDAuMTEzNTQ5LjIuOFwiLFwiaG1hY1dpdGhTSEEyMjRcIiksYShcIjEuMi44NDAuMTEzNTQ5LjIuOVwiLFwiaG1hY1dpdGhTSEEyNTZcIiksYShcIjEuMi44NDAuMTEzNTQ5LjIuMTBcIixcImhtYWNXaXRoU0hBMzg0XCIpLGEoXCIxLjIuODQwLjExMzU0OS4yLjExXCIsXCJobWFjV2l0aFNIQTUxMlwiKSxhKFwiMS4yLjg0MC4xMTM1NDkuMy43XCIsXCJkZXMtRURFMy1DQkNcIiksYShcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjJcIixcImFlczEyOC1DQkNcIiksYShcIjIuMTYuODQwLjEuMTAxLjMuNC4xLjIyXCIsXCJhZXMxOTItQ0JDXCIpLGEoXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMS40MlwiLFwiYWVzMjU2LUNCQ1wiKSxhKFwiMi41LjQuM1wiLFwiY29tbW9uTmFtZVwiKSxhKFwiMi41LjQuNVwiLFwic2VyaWFsTmFtZVwiKSxhKFwiMi41LjQuNlwiLFwiY291bnRyeU5hbWVcIiksYShcIjIuNS40LjdcIixcImxvY2FsaXR5TmFtZVwiKSxhKFwiMi41LjQuOFwiLFwic3RhdGVPclByb3ZpbmNlTmFtZVwiKSxhKFwiMi41LjQuMTBcIixcIm9yZ2FuaXphdGlvbk5hbWVcIiksYShcIjIuNS40LjExXCIsXCJvcmdhbml6YXRpb25hbFVuaXROYW1lXCIpLGEoXCIyLjUuNC4xM1wiLFwiZGVzY3JpcHRpb25cIiksYShcIjIuMTYuODQwLjEuMTEzNzMwLjEuMVwiLFwibnNDZXJ0VHlwZVwiKSxhKFwiMi4xNi44NDAuMS4xMTM3MzAuMS4xM1wiLFwibnNDb21tZW50XCIpLHMoXCIyLjUuMjkuMVwiLFwiYXV0aG9yaXR5S2V5SWRlbnRpZmllclwiKSxzKFwiMi41LjI5LjJcIixcImtleUF0dHJpYnV0ZXNcIikscyhcIjIuNS4yOS4zXCIsXCJjZXJ0aWZpY2F0ZVBvbGljaWVzXCIpLHMoXCIyLjUuMjkuNFwiLFwia2V5VXNhZ2VSZXN0cmljdGlvblwiKSxzKFwiMi41LjI5LjVcIixcInBvbGljeU1hcHBpbmdcIikscyhcIjIuNS4yOS42XCIsXCJzdWJ0cmVlc0NvbnN0cmFpbnRcIikscyhcIjIuNS4yOS43XCIsXCJzdWJqZWN0QWx0TmFtZVwiKSxzKFwiMi41LjI5LjhcIixcImlzc3VlckFsdE5hbWVcIikscyhcIjIuNS4yOS45XCIsXCJzdWJqZWN0RGlyZWN0b3J5QXR0cmlidXRlc1wiKSxzKFwiMi41LjI5LjEwXCIsXCJiYXNpY0NvbnN0cmFpbnRzXCIpLHMoXCIyLjUuMjkuMTFcIixcIm5hbWVDb25zdHJhaW50c1wiKSxzKFwiMi41LjI5LjEyXCIsXCJwb2xpY3lDb25zdHJhaW50c1wiKSxzKFwiMi41LjI5LjEzXCIsXCJiYXNpY0NvbnN0cmFpbnRzXCIpLGEoXCIyLjUuMjkuMTRcIixcInN1YmplY3RLZXlJZGVudGlmaWVyXCIpLGEoXCIyLjUuMjkuMTVcIixcImtleVVzYWdlXCIpLHMoXCIyLjUuMjkuMTZcIixcInByaXZhdGVLZXlVc2FnZVBlcmlvZFwiKSxhKFwiMi41LjI5LjE3XCIsXCJzdWJqZWN0QWx0TmFtZVwiKSxhKFwiMi41LjI5LjE4XCIsXCJpc3N1ZXJBbHROYW1lXCIpLGEoXCIyLjUuMjkuMTlcIixcImJhc2ljQ29uc3RyYWludHNcIikscyhcIjIuNS4yOS4yMFwiLFwiY1JMTnVtYmVyXCIpLHMoXCIyLjUuMjkuMjFcIixcImNSTFJlYXNvblwiKSxzKFwiMi41LjI5LjIyXCIsXCJleHBpcmF0aW9uRGF0ZVwiKSxzKFwiMi41LjI5LjIzXCIsXCJpbnN0cnVjdGlvbkNvZGVcIikscyhcIjIuNS4yOS4yNFwiLFwiaW52YWxpZGl0eURhdGVcIikscyhcIjIuNS4yOS4yNVwiLFwiY1JMRGlzdHJpYnV0aW9uUG9pbnRzXCIpLHMoXCIyLjUuMjkuMjZcIixcImlzc3VpbmdEaXN0cmlidXRpb25Qb2ludFwiKSxzKFwiMi41LjI5LjI3XCIsXCJkZWx0YUNSTEluZGljYXRvclwiKSxzKFwiMi41LjI5LjI4XCIsXCJpc3N1aW5nRGlzdHJpYnV0aW9uUG9pbnRcIikscyhcIjIuNS4yOS4yOVwiLFwiY2VydGlmaWNhdGVJc3N1ZXJcIikscyhcIjIuNS4yOS4zMFwiLFwibmFtZUNvbnN0cmFpbnRzXCIpLGEoXCIyLjUuMjkuMzFcIixcImNSTERpc3RyaWJ1dGlvblBvaW50c1wiKSxhKFwiMi41LjI5LjMyXCIsXCJjZXJ0aWZpY2F0ZVBvbGljaWVzXCIpLHMoXCIyLjUuMjkuMzNcIixcInBvbGljeU1hcHBpbmdzXCIpLHMoXCIyLjUuMjkuMzRcIixcInBvbGljeUNvbnN0cmFpbnRzXCIpLGEoXCIyLjUuMjkuMzVcIixcImF1dGhvcml0eUtleUlkZW50aWZpZXJcIikscyhcIjIuNS4yOS4zNlwiLFwicG9saWN5Q29uc3RyYWludHNcIiksYShcIjIuNS4yOS4zN1wiLFwiZXh0S2V5VXNhZ2VcIikscyhcIjIuNS4yOS40NlwiLFwiZnJlc2hlc3RDUkxcIikscyhcIjIuNS4yOS41NFwiLFwiaW5oaWJpdEFueVBvbGljeVwiKSxhKFwiMS4zLjYuMS40LjEuMTExMjkuMi40LjJcIixcInRpbWVzdGFtcExpc3RcIiksYShcIjEuMy42LjEuNS41LjcuMS4xXCIsXCJhdXRob3JpdHlJbmZvQWNjZXNzXCIpLGEoXCIxLjMuNi4xLjUuNS43LjMuMVwiLFwic2VydmVyQXV0aFwiKSxhKFwiMS4zLjYuMS41LjUuNy4zLjJcIixcImNsaWVudEF1dGhcIiksYShcIjEuMy42LjEuNS41LjcuMy4zXCIsXCJjb2RlU2lnbmluZ1wiKSxhKFwiMS4zLjYuMS41LjUuNy4zLjRcIixcImVtYWlsUHJvdGVjdGlvblwiKSxhKFwiMS4zLjYuMS41LjUuNy4zLjhcIixcInRpbWVTdGFtcGluZ1wiKX0sZnVuY3Rpb24oZSx0KXt2YXIgcjtyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3I9cnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChlKXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfWUuZXhwb3J0cz1yfSxmdW5jdGlvbihlLHQpe3ZhciByLG4saT1lLmV4cG9ydHM9e307ZnVuY3Rpb24gYSgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gcygpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBvKGUpe2lmKHI9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KGUsMCk7aWYoKHI9PT1hfHwhcikmJnNldFRpbWVvdXQpcmV0dXJuIHI9c2V0VGltZW91dCxzZXRUaW1lb3V0KGUsMCk7dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19IWZ1bmN0aW9uKCl7dHJ5e3I9XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0OmF9Y2F0Y2goZSl7cj1hfXRyeXtuPVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6c31jYXRjaChlKXtuPXN9fSgpO3ZhciB1LGM9W10sbD0hMSxmPS0xO2Z1bmN0aW9uIGgoKXtsJiZ1JiYobD0hMSx1Lmxlbmd0aD9jPXUuY29uY2F0KGMpOmY9LTEsYy5sZW5ndGgmJnAoKSl9ZnVuY3Rpb24gcCgpe2lmKCFsKXt2YXIgZT1vKGgpO2w9ITA7Zm9yKHZhciB0PWMubGVuZ3RoO3Q7KXtmb3IodT1jLGM9W107KytmPHQ7KXUmJnVbZl0ucnVuKCk7Zj0tMSx0PWMubGVuZ3RofXU9bnVsbCxsPSExLGZ1bmN0aW9uKGUpe2lmKG49PT1jbGVhclRpbWVvdXQpcmV0dXJuIGNsZWFyVGltZW91dChlKTtpZigobj09PXN8fCFuKSYmY2xlYXJUaW1lb3V0KXJldHVybiBuPWNsZWFyVGltZW91dCxjbGVhclRpbWVvdXQoZSk7dHJ5e24oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX0oZSl9fWZ1bmN0aW9uIGQoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1mdW5jdGlvbiB5KCl7fWkubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKWZvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyLTFdPWFyZ3VtZW50c1tyXTtjLnB1c2gobmV3IGQoZSx0KSksMSE9PWMubGVuZ3RofHxsfHxvKHApfSxkLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxpLnRpdGxlPVwiYnJvd3NlclwiLGkuYnJvd3Nlcj0hMCxpLmVudj17fSxpLmFyZ3Y9W10saS52ZXJzaW9uPVwiXCIsaS52ZXJzaW9ucz17fSxpLm9uPXksaS5hZGRMaXN0ZW5lcj15LGkub25jZT15LGkub2ZmPXksaS5yZW1vdmVMaXN0ZW5lcj15LGkucmVtb3ZlQWxsTGlzdGVuZXJzPXksaS5lbWl0PXksaS5wcmVwZW5kTGlzdGVuZXI9eSxpLnByZXBlbmRPbmNlTGlzdGVuZXI9eSxpLmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX0saS5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxpLmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifSxpLmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0saS51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLHQpe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCFyKXJldHVybiBlO3ZhciBuLGksYT1yLmNhbGwoZSkscz1bXTt0cnl7Zm9yKDsodm9pZCAwPT09dHx8dC0tID4wKSYmIShuPWEubmV4dCgpKS5kb25lOylzLnB1c2gobi52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7biYmIW4uZG9uZSYmKHI9YS5yZXR1cm4pJiZyLmNhbGwoYSl9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBzfSxpPXRoaXMmJnRoaXMuX19zcHJlYWR8fGZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWU9ZS5jb25jYXQobihhcmd1bWVudHNbdF0pKTtyZXR1cm4gZX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9cigxMSk7dC5jb25jYXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9W10sdD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZVt0XT1hcmd1bWVudHNbdF07cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBVaW50OEFycmF5LmZyb20oaShlLGEuX2Zyb21Jbih0KSkpfSksbmV3IFVpbnQ4QXJyYXkoMCkpfSx0LnNwbGl0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0W3ItMV09YXJndW1lbnRzW3JdO3ZhciBuPXQucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybnthcnI6ZS5hcnIuc2xpY2UodCkscjppKGUucixbZS5hcnIuc2xpY2UoMCx0KV0pfX0pLHthcnI6YS5fZnJvbUluKGUpLHI6W119KSxzPW4ucixvPW4uYXJyO3JldHVybiBpKHMsW29dKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlBVQkxJQ19LRVlfTEVOR1RIPTMyLHQuUFJJVkFURV9LRVlfTEVOR1RIPTMyLHQuU0lHTkFUVVJFX0xFTkdUSD02NCx0LkFERFJFU1NfTEVOR1RIPTI2LHQuTUFJTl9ORVRfQ0hBSU5fSUQ9ODcsdC5URVNUX05FVF9DSEFJTl9JRD04NH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigyNiksaT1yKDM3KSxhPXIoMTEyKSxzPXIoNjcpO3ZhciBvOyFmdW5jdGlvbihlKXtlW2UuR0VORVNJUz0xXT1cIkdFTkVTSVNcIixlW2UuUEFZTUVOVD0yXT1cIlBBWU1FTlRcIixlW2UuSVNTVUU9M109XCJJU1NVRVwiLGVbZS5UUkFOU0ZFUj00XT1cIlRSQU5TRkVSXCIsZVtlLlJFSVNTVUU9NV09XCJSRUlTU1VFXCIsZVtlLkJVUk49Nl09XCJCVVJOXCIsZVtlLkVYQ0hBTkdFPTddPVwiRVhDSEFOR0VcIixlW2UuTEVBU0U9OF09XCJMRUFTRVwiLGVbZS5DQU5DRUxfTEVBU0U9OV09XCJDQU5DRUxfTEVBU0VcIixlW2UuQUxJQVM9MTBdPVwiQUxJQVNcIixlW2UuTUFTU19UUkFOU0ZFUj0xMV09XCJNQVNTX1RSQU5TRkVSXCIsZVtlLkRBVEE9MTJdPVwiREFUQVwiLGVbZS5TRVRfU0NSSVBUPTEzXT1cIlNFVF9TQ1JJUFRcIixlW2UuU1BPTlNPUlNISVA9MTRdPVwiU1BPTlNPUlNISVBcIixlW2UuU0VUX0FTU0VUX1NDUklQVD0xNV09XCJTRVRfQVNTRVRfU0NSSVBUXCIsZVtlLklOVk9LRV9TQ1JJUFQ9MTZdPVwiSU5WT0tFX1NDUklQVFwifShvPXQuVFJBTlNBQ1RJT05fVFlQRXx8KHQuVFJBTlNBQ1RJT05fVFlQRT17fSkpO2NvbnN0IHU9e3RvQnl0ZXM6bi5TSE9SVCxmcm9tQnl0ZXM6aS5QX1NIT1JUfSxjPXt0b0J5dGVzOm4uSU5ULGZyb21CeXRlczppLlBfSU5UfTt2YXIgbDshZnVuY3Rpb24oZSl7ZS5sb25nRmllbGQ9ZT0+W2Use3RvQnl0ZXM6bi5MT05HLGZyb21CeXRlczppLlBfTE9OR31dLGUuYnl0ZUZpZWxkPWU9PltlLHt0b0J5dGVzOm4uQllURSxmcm9tQnl0ZXM6aS5QX0JZVEV9XSxlLmJvb2xlYW5GaWVsZD1lPT5bZSx7dG9CeXRlczpuLkJPT0wsZnJvbUJ5dGVzOmkuUF9CT09MRUFOfV0sZS5zdHJpbmdGaWVsZD1lPT5bZSx7dG9CeXRlczpuLkxFTihuLlNIT1JUKShuLlNUUklORyksZnJvbUJ5dGVzOmkuUF9TVFJJTkdfVkFSKGkuUF9TSE9SVCl9XSxlLmJhc2U1OGZpZWxkMzI9ZT0+W2Use3RvQnl0ZXM6bi5CQVNFNThfU1RSSU5HLGZyb21CeXRlczppLlBfQkFTRTU4X0ZJWEVEKDMyKX1dLGUuYmFzZTU4T3B0aW9uMzI9ZT0+W2Use3RvQnl0ZXM6ZT0+XCJXQVZFU1wiPT09ZT9uLk9QVElPTihuLkJBU0U1OF9TVFJJTkcpKG51bGwpOm4uT1BUSU9OKG4uQkFTRTU4X1NUUklORykoZSksZnJvbUJ5dGVzOmkuUF9PUFRJT04oaS5QX0JBU0U1OF9GSVhFRCgzMikpfV0sZS5iYXNlNjRmaWVsZD1lPT5bZSx7dG9CeXRlczpuLkxFTihuLlNIT1JUKShuLkJBU0U2NF9TVFJJTkcpLGZyb21CeXRlczppLlBfQkFTRTY0KGkuUF9TSE9SVCl9XSxlLmJ5dGVDb25zdGFudD1lPT5bXCJub25hbWVcIix7dG9CeXRlczooKT0+VWludDhBcnJheS5mcm9tKFtlXSksZnJvbUJ5dGVzOigpPT4oe3ZhbHVlOnZvaWQgMCxzaGlmdDoxfSl9XSxlLmFsaWFzPVtcImFsaWFzXCIse3RvQnl0ZXM6bi5MRU4obi5TSE9SVCkobi5TVFJJTkcpLGZyb21CeXRlczppLmJ5dGVOZXdBbGlhc1RvU3RyaW5nfV0sZS5hbW91bnQ9ZS5sb25nRmllbGQoXCJhbW91bnRcIiksZS5hc3NldERlc2NyaXB0aW9uPWUuc3RyaW5nRmllbGQoXCJkZXNjcmlwdGlvblwiKSxlLmFzc2V0SWQ9ZS5iYXNlNThmaWVsZDMyKFwiYXNzZXRJZFwiKSxlLmFzc2V0TmFtZT1lLnN0cmluZ0ZpZWxkKFwibmFtZVwiKSxlLmF0dGFjaG1lbnQ9W1wiYXR0YWNobWVudFwiLHt0b0J5dGVzOm4uTEVOKG4uU0hPUlQpKG4uQkFTRTU4X1NUUklORyksZnJvbUJ5dGVzOmkuUF9CQVNFNThfVkFSKGkuUF9TSE9SVCl9XSxlLmNoYWluSWQ9ZS5ieXRlRmllbGQoXCJjaGFpbklkXCIpLGUuZGVjaW1hbHM9ZS5ieXRlRmllbGQoXCJkZWNpbWFsc1wiKSxlLmZlZT1lLmxvbmdGaWVsZChcImZlZVwiKSxlLmxlYXNlQXNzZXRJZD1lLmJhc2U1OE9wdGlvbjMyKFwibGVhc2VBc3NldElkXCIpLGUubGVhc2VJZD1lLmJhc2U1OGZpZWxkMzIoXCJsZWFzZUlkXCIpLGUub3B0aW9uYWxBc3NldElkPWUuYmFzZTU4T3B0aW9uMzIoXCJhc3NldElkXCIpLGUucXVhbnRpdHk9ZS5sb25nRmllbGQoXCJxdWFudGl0eVwiKSxlLnJlaXNzdWFibGU9ZS5ib29sZWFuRmllbGQoXCJyZWlzc3VhYmxlXCIpLGUucmVjaXBpZW50PVtcInJlY2lwaWVudFwiLHt0b0J5dGVzOm4uQUREUkVTU19PUl9BTElBUyxmcm9tQnl0ZXM6aS5ieXRlVG9BZGRyZXNzT3JBbGlhc31dLGUuc2NyaXB0PVtcInNjcmlwdFwiLHt0b0J5dGVzOm4uU0NSSVBULGZyb21CeXRlczppLmJ5dGVUb1NjcmlwdH1dLGUuc2VuZGVyUHVibGljS2V5PWUuYmFzZTU4ZmllbGQzMihcInNlbmRlclB1YmxpY0tleVwiKSxlLnNpZ25hdHVyZT1bXCJzaWduYXR1cmVcIix7dG9CeXRlczpuLkJBU0U1OF9TVFJJTkcsZnJvbUJ5dGVzOmkuUF9CQVNFNThfRklYRUQoNjQpfV0sZS50aW1lc3RhbXA9ZS5sb25nRmllbGQoXCJ0aW1lc3RhbXBcIiksZS50eXBlPWUuYnl0ZUZpZWxkKFwidHlwZVwiKSxlLnZlcnNpb249ZS5ieXRlRmllbGQoXCJ2ZXJzaW9uXCIpLGUucHJvb2ZzPVtcInByb29mc1wiLHt0eXBlOlwiYXJyYXlcIixpdGVtczp7dG9CeXRlczpuLkxFTihuLlNIT1JUKShuLkJBU0U1OF9TVFJJTkcpLGZyb21CeXRlczppLlBfQkFTRTU4X1ZBUihpLlBfU0hPUlQpfX1dO2NvbnN0IHQ9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2UucmVjaXBpZW50LGUuYW1vdW50XX07ZS50cmFuc2ZlcnM9W1widHJhbnNmZXJzXCIse3R5cGU6XCJhcnJheVwiLGl0ZW1zOnR9XTtjb25zdCByPXt0eXBlOlwiZGF0YVR4RmllbGRcIixpdGVtczpuZXcgTWFwKFtbYS5EQVRBX0ZJRUxEX1RZUEUuSU5URUdFUix7dG9CeXRlczpuLkxPTkcsZnJvbUJ5dGVzOmkuUF9MT05HfV0sW2EuREFUQV9GSUVMRF9UWVBFLkJPT0xFQU4se3RvQnl0ZXM6bi5CT09MLGZyb21CeXRlczppLlBfQk9PTEVBTn1dLFthLkRBVEFfRklFTERfVFlQRS5CSU5BUlkse3RvQnl0ZXM6bi5MRU4obi5TSE9SVCkobi5CQVNFNjRfU1RSSU5HKSxmcm9tQnl0ZXM6aS5QX0JBU0U2NChpLlBfU0hPUlQpfV0sW2EuREFUQV9GSUVMRF9UWVBFLlNUUklORyx7dG9CeXRlczpuLkxFTihuLlNIT1JUKShuLlNUUklORyksZnJvbUJ5dGVzOmkuUF9TVFJJTkdfVkFSKGkuUF9TSE9SVCl9XV0pfTtlLmRhdGE9W1wiZGF0YVwiLHt0eXBlOlwiYXJyYXlcIixpdGVtczpyfV07Y29uc3Qgcz1hLmFueU9mKFtbMCx7dG9CeXRlczpuLkxPTkcsZnJvbUJ5dGVzOmkuUF9MT05HfSxcImludGVnZXJcIl0sWzEse3RvQnl0ZXM6bi5MRU4obi5JTlQpKG4uQkFTRTY0X1NUUklORyksZnJvbUJ5dGVzOmkuUF9CQVNFNjQoaS5QX0lOVCl9LFwiYmluYXJ5XCJdLFsyLHt0b0J5dGVzOm4uTEVOKG4uSU5UKShuLlNUUklORyksZnJvbUJ5dGVzOmkuUF9TVFJJTkdfVkFSKGkuUF9JTlQpfSxcInN0cmluZ1wiXSxbNix7dG9CeXRlczooKT0+VWludDhBcnJheS5mcm9tKFtdKSxmcm9tQnl0ZXM6KCk9Pih7dmFsdWU6ITAsc2hpZnQ6MH0pfSxcImJvb2xlYW5cIl0sWzcse3RvQnl0ZXM6KCk9PlVpbnQ4QXJyYXkuZnJvbShbXSksZnJvbUJ5dGVzOigpPT4oe3ZhbHVlOiExLHNoaWZ0OjB9KX0sXCJib29sZWFuXCJdXSx7dmFsdWVGaWVsZDpcInZhbHVlXCJ9KTtlLmZ1bmN0aW9uQ2FsbD1bXCJjYWxsXCIse3R5cGU6XCJvYmplY3RcIixvcHRpb25hbDohMCxzY2hlbWE6W2UuYnl0ZUNvbnN0YW50KDkpLGUuYnl0ZUNvbnN0YW50KDEpLFtcImZ1bmN0aW9uXCIse3RvQnl0ZXM6bi5MRU4obi5JTlQpKG4uU1RSSU5HKSxmcm9tQnl0ZXM6aS5QX1NUUklOR19WQVIoaS5QX0lOVCl9XSxbXCJhcmdzXCIse3R5cGU6XCJhcnJheVwiLHRvQnl0ZXM6bi5JTlQsZnJvbUJ5dGVzOmkuUF9JTlQsaXRlbXM6c31dXX1dLGUucGF5bWVudD17dHlwZTpcIm9iamVjdFwiLHdpdGhMZW5ndGg6dSxzY2hlbWE6W2UuYW1vdW50LGUub3B0aW9uYWxBc3NldElkXX0sZS5wYXltZW50cz1bXCJwYXltZW50XCIse3R5cGU6XCJhcnJheVwiLGl0ZW1zOmUucGF5bWVudH1dfShsPXQudHhGaWVsZHN8fCh0LnR4RmllbGRzPXt9KSksdC5vcmRlclNjaGVtYVYxPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnNlbmRlclB1YmxpY0tleSxsLmJhc2U1OGZpZWxkMzIoXCJtYXRjaGVyUHVibGljS2V5XCIpLFtcImFzc2V0UGFpclwiLHt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLmJhc2U1OE9wdGlvbjMyKFwiYW1vdW50QXNzZXRcIiksbC5iYXNlNThPcHRpb24zMihcInByaWNlQXNzZXRcIildfV0sW1wib3JkZXJUeXBlXCIse3RvQnl0ZXM6ZT0+bi5CWVRFKFwic2VsbFwiPT09ZT8xOjApLGZyb21CeXRlczooZSx0PTApPT4xPT09aS5QX0JZVEUoZSx0KS52YWx1ZT97dmFsdWU6XCJzZWxsXCIsc2hpZnQ6MX06e3ZhbHVlOlwiYnV5XCIsc2hpZnQ6MX19XSxsLmxvbmdGaWVsZChcInByaWNlXCIpLGwubG9uZ0ZpZWxkKFwiYW1vdW50XCIpLGwudGltZXN0YW1wLGwubG9uZ0ZpZWxkKFwiZXhwaXJhdGlvblwiKSxsLmxvbmdGaWVsZChcIm1hdGNoZXJGZWVcIildfSx0Lm9yZGVyU2NoZW1hVjI9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wudmVyc2lvbiwuLi50Lm9yZGVyU2NoZW1hVjEuc2NoZW1hXX0sdC5vcmRlclNjaGVtYVYzPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOlsuLi50Lm9yZGVyU2NoZW1hVjIuc2NoZW1hLFtcIm1hdGNoZXJGZWVBc3NldElkXCIsbC5vcHRpb25hbEFzc2V0SWRbMV1dXX0sdC5hbGlhc1NjaGVtYVYyPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuc2VuZGVyUHVibGljS2V5LFtbXCJhbGlhc1wiLFwiY2hhaW5JZFwiXSx7dHlwZTpcIm9iamVjdFwiLHdpdGhMZW5ndGg6dSxzY2hlbWE6W2wuYnl0ZUNvbnN0YW50KDIpLGwuY2hhaW5JZCxsLmFsaWFzXX1dLGwuZmVlLGwudGltZXN0YW1wXX0sdC5idXJuU2NoZW1hVjI9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wudHlwZSxsLnZlcnNpb24sbC5jaGFpbklkLGwuc2VuZGVyUHVibGljS2V5LGwuYXNzZXRJZCxsLnF1YW50aXR5LGwuZmVlLGwudGltZXN0YW1wXX0sdC5jYW5jZWxMZWFzZVNjaGVtYVYyPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuY2hhaW5JZCxsLnNlbmRlclB1YmxpY0tleSxsLmZlZSxsLnRpbWVzdGFtcCxsLmxlYXNlSWRdfSx0Lmludm9rZVNjcmlwdFNjaGVtYVYxPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuY2hhaW5JZCxsLnNlbmRlclB1YmxpY0tleSxbXCJkQXBwXCIsbC5yZWNpcGllbnRbMV1dLGwuZnVuY3Rpb25DYWxsLGwucGF5bWVudHMsbC5mZWUsW1wiZmVlQXNzZXRJZFwiLGwub3B0aW9uYWxBc3NldElkWzFdXSxsLnRpbWVzdGFtcF19LHQuZGF0YVNjaGVtYVYxPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuc2VuZGVyUHVibGljS2V5LGwuZGF0YSxsLnRpbWVzdGFtcCxsLmZlZV19LHQucHJvb2ZzU2NoZW1hVjA9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W1tcInNpZ25hdHVyZVwiLHt0b0J5dGVzOm4uQkFTRTU4X1NUUklORyxmcm9tQnl0ZXM6aS5QX0JBU0U1OF9GSVhFRCg2NCl9XV19LHQucHJvb2ZzU2NoZW1hVjE9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wuYnl0ZUNvbnN0YW50KDEpLGwucHJvb2ZzXX07Y29uc3QgZj17dHlwZTpcIm9iamVjdFwiLHNjaGVtYTpbLi4udC5vcmRlclNjaGVtYVYxLnNjaGVtYSxsLnNpZ25hdHVyZV19O3QuZXhjaGFuZ2VTY2hlbWFWMT17dHlwZTpcIm9iamVjdFwiLHNjaGVtYTpbbC50eXBlLFtcIm9yZGVyMVwiLHtmcm9tQnl0ZXM6KCk9Pih7dmFsdWU6dm9pZCAwLHNoaWZ0OjR9KSx0b0J5dGVzOmU9Pm4uSU5UKHMuc2VyaWFsaXplckZyb21TY2hlbWEoZikoZSkubGVuZ3RoKX1dLFtcIm9yZGVyMlwiLHtmcm9tQnl0ZXM6KCk9Pih7dmFsdWU6dm9pZCAwLHNoaWZ0OjR9KSx0b0J5dGVzOmU9Pm4uSU5UKHMuc2VyaWFsaXplckZyb21TY2hlbWEoZikoZSkubGVuZ3RoKX1dLFtcIm9yZGVyMVwiLGZdLFtcIm9yZGVyMlwiLGZdLGwubG9uZ0ZpZWxkKFwicHJpY2VcIiksbC5sb25nRmllbGQoXCJhbW91bnRcIiksbC5sb25nRmllbGQoXCJidXlNYXRjaGVyRmVlXCIpLGwubG9uZ0ZpZWxkKFwic2VsbE1hdGNoZXJGZWVcIiksbC5sb25nRmllbGQoXCJmZWVcIiksbC5sb25nRmllbGQoXCJ0aW1lc3RhbXBcIildfTtjb25zdCBoPWEuYW55T2YoW1sxLHt0eXBlOlwib2JqZWN0XCIsd2l0aExlbmd0aDp7dG9CeXRlczplPT5uLklOVChlLTEpLGZyb21CeXRlczplPT57Y29uc3R7dmFsdWU6dCxzaGlmdDpyfT1pLlBfSU5UKGUpO3JldHVybnt2YWx1ZTp0KzEsc2hpZnQ6cn19fSxzY2hlbWE6W2wuYnl0ZUNvbnN0YW50KDEpLC4uLnQub3JkZXJTY2hlbWFWMS5zY2hlbWEsLi4udC5wcm9vZnNTY2hlbWFWMC5zY2hlbWFdfV0sWzIse3R5cGU6XCJvYmplY3RcIix3aXRoTGVuZ3RoOmMsc2NoZW1hOlsuLi50Lm9yZGVyU2NoZW1hVjIuc2NoZW1hLC4uLnQucHJvb2ZzU2NoZW1hVjEuc2NoZW1hXX1dXSx7ZGlzY3JpbWluYXRvckZpZWxkOlwidmVyc2lvblwiLGRpc2NyaW1pbmF0b3JCeXRlUG9zOjR9KTt0LmV4Y2hhbmdlU2NoZW1hVjI9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wuYnl0ZUNvbnN0YW50KDApLGwudHlwZSxsLnZlcnNpb24sW1wib3JkZXIxXCIsaF0sW1wib3JkZXIyXCIsaF0sbC5sb25nRmllbGQoXCJwcmljZVwiKSxsLmxvbmdGaWVsZChcImFtb3VudFwiKSxsLmxvbmdGaWVsZChcImJ1eU1hdGNoZXJGZWVcIiksbC5sb25nRmllbGQoXCJzZWxsTWF0Y2hlckZlZVwiKSxsLmxvbmdGaWVsZChcImZlZVwiKSxsLmxvbmdGaWVsZChcInRpbWVzdGFtcFwiKV19LHQuaXNzdWVTY2hlbWFWMj17dHlwZTpcIm9iamVjdFwiLHNjaGVtYTpbbC50eXBlLGwudmVyc2lvbixsLmNoYWluSWQsbC5zZW5kZXJQdWJsaWNLZXksbC5hc3NldE5hbWUsbC5hc3NldERlc2NyaXB0aW9uLGwucXVhbnRpdHksbC5kZWNpbWFscyxsLnJlaXNzdWFibGUsbC5mZWUsbC50aW1lc3RhbXAsbC5zY3JpcHRdfSx0LmxlYXNlU2NoZW1hVjI9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wudHlwZSxsLnZlcnNpb24sbC5sZWFzZUFzc2V0SWQsbC5zZW5kZXJQdWJsaWNLZXksbC5yZWNpcGllbnQsbC5hbW91bnQsbC5mZWUsbC50aW1lc3RhbXBdfSx0Lm1hc3NUcmFuc2ZlclNjaGVtYVYxPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuc2VuZGVyUHVibGljS2V5LGwub3B0aW9uYWxBc3NldElkLGwudHJhbnNmZXJzLGwudGltZXN0YW1wLGwuZmVlLGwuYXR0YWNobWVudF19LHQucmVpc3N1ZVNjaGVtYVYyPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuY2hhaW5JZCxsLnNlbmRlclB1YmxpY0tleSxsLmFzc2V0SWQsbC5xdWFudGl0eSxsLnJlaXNzdWFibGUsbC5mZWUsbC50aW1lc3RhbXBdfSx0LnNldEFzc2V0U2NyaXB0U2NoZW1hVjE9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wudHlwZSxsLnZlcnNpb24sbC5jaGFpbklkLGwuc2VuZGVyUHVibGljS2V5LGwuYXNzZXRJZCxsLmZlZSxsLnRpbWVzdGFtcCxsLnNjcmlwdF19LHQuc2V0U2NyaXB0U2NoZW1hVjE9e3R5cGU6XCJvYmplY3RcIixzY2hlbWE6W2wudHlwZSxsLnZlcnNpb24sbC5jaGFpbklkLGwuc2VuZGVyUHVibGljS2V5LGwuc2NyaXB0LGwuZmVlLGwudGltZXN0YW1wXX0sdC5zcG9uc29yc2hpcFNjaGVtYVYxPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuc2VuZGVyUHVibGljS2V5LGwuYXNzZXRJZCxsLmxvbmdGaWVsZChcIm1pblNwb25zb3JlZEFzc2V0RmVlXCIpLGwuZmVlLGwudGltZXN0YW1wXX0sdC50cmFuc2ZlclNjaGVtYVYyPXt0eXBlOlwib2JqZWN0XCIsc2NoZW1hOltsLnR5cGUsbC52ZXJzaW9uLGwuc2VuZGVyUHVibGljS2V5LGwub3B0aW9uYWxBc3NldElkLFtcImZlZUFzc2V0SWRcIixsLm9wdGlvbmFsQXNzZXRJZFsxXV0sbC50aW1lc3RhbXAsbC5hbW91bnQsbC5mZWUsbC5yZWNpcGllbnQsbC5hdHRhY2htZW50XX0sdC5zY2hlbWFzQnlUeXBlTWFwPXtbby5HRU5FU0lTXTp7fSxbby5QQVlNRU5UXTp7fSxbby5JU1NVRV06ezI6dC5pc3N1ZVNjaGVtYVYyfSxbby5UUkFOU0ZFUl06ezI6dC50cmFuc2ZlclNjaGVtYVYyfSxbby5SRUlTU1VFXTp7Mjp0LnJlaXNzdWVTY2hlbWFWMn0sW28uQlVSTl06ezI6dC5idXJuU2NoZW1hVjJ9LFtvLkVYQ0hBTkdFXTp7MTp0LmV4Y2hhbmdlU2NoZW1hVjEsMjp0LmV4Y2hhbmdlU2NoZW1hVjJ9LFtvLkxFQVNFXTp7Mjp0LmxlYXNlU2NoZW1hVjJ9LFtvLkNBTkNFTF9MRUFTRV06ezI6dC5jYW5jZWxMZWFzZVNjaGVtYVYyfSxbby5BTElBU106ezI6dC5hbGlhc1NjaGVtYVYyfSxbby5NQVNTX1RSQU5TRkVSXTp7MTp0Lm1hc3NUcmFuc2ZlclNjaGVtYVYxfSxbby5EQVRBXTp7MTp0LmRhdGFTY2hlbWFWMX0sW28uU0VUX1NDUklQVF06ezE6dC5zZXRTY3JpcHRTY2hlbWFWMX0sW28uU1BPTlNPUlNISVBdOnsxOnQuc3BvbnNvcnNoaXBTY2hlbWFWMX0sW28uU0VUX0FTU0VUX1NDUklQVF06ezE6dC5zZXRBc3NldFNjcmlwdFNjaGVtYVYxfSxbby5JTlZPS0VfU0NSSVBUXTp7MTp0Lmludm9rZVNjcmlwdFNjaGVtYVYxfX0sdC5vcmRlclZlcnNpb25NYXA9ezE6dC5vcmRlclNjaGVtYVYxLDI6dC5vcmRlclNjaGVtYVYyLDM6dC5vcmRlclNjaGVtYVYzfSx0LmdldFRyYW5zYWN0aW9uU2NoZW1hPWZ1bmN0aW9uKGUscil7Y29uc3Qgbj10LnNjaGVtYXNCeVR5cGVNYXBbZV07aWYoXCJvYmplY3RcIiE9dHlwZW9mIG4pdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgdHggdHlwZTogJHtlfWApO2NvbnN0IGk9bltyfHwxXTtpZihcIm9iamVjdFwiIT10eXBlb2YgaSl0aHJvdyBuZXcgRXJyb3IoYEluY29ycmVjdCB0eCB2ZXJzaW9uOiAke3J9YCk7cmV0dXJuIGl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4ocigxMikpLGE9cig1Mykscz1yKDEwKSxvPWZ1bmN0aW9uKGUpe3JldHVybiBzLnN0cmluZ1RvQnl0ZXMoaS5kZWZhdWx0LmdldEJ5dGVzU3luYyhlKSxcInJhd1wiKX07dC5yYW5kb209ZnVuY3Rpb24ocixuKXtzd2l0Y2gobil7Y2FzZVwiQXJyYXk4XCI6cmV0dXJuIEFycmF5LmZyb20obyhyKSk7Y2FzZVwiQXJyYXkxNlwiOnJldHVybiBBcnJheS5mcm9tKHQucmFuZG9tKHIsXCJVaW50MTZBcnJheVwiKSk7Y2FzZVwiQXJyYXkzMlwiOnJldHVybiBBcnJheS5mcm9tKHQucmFuZG9tKHIsXCJVaW50MzJBcnJheVwiKSk7Y2FzZVwiQnVmZmVyXCI6cmV0dXJuIGZ1bmN0aW9uKCl7dHJ5e25ldyBlKDEpfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuIFVzZSBOb2RlLmpzIG9yIEJyb3dzZXJpZnkgZm9yIGJyb3dzZXIgc3VwcG9ydC5cIil9fSgpLGUuZnJvbShvKHIpKTtjYXNlXCJVaW50OEFycmF5XCI6cmV0dXJuIG8ocik7Y2FzZVwiVWludDE2QXJyYXlcIjpyZXR1cm4gbmV3IFVpbnQxNkFycmF5KHIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIG8oMikucmVkdWNlKChmdW5jdGlvbihlLHQscil7cmV0dXJuIGV8dDw8OCooMS1yKX0pLDApfSkpO2Nhc2VcIlVpbnQzMkFycmF5XCI6cmV0dXJuIG5ldyBVaW50MzJBcnJheShyKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBvKDQpLnJlZHVjZSgoZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlfHQ8PDgqKDEtcil9KSwwKX0pKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihuK1wiIGlzIHVuc3VwcG9ydGVkLlwiKX19LHQucmFuZG9tQnl0ZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIHQucmFuZG9tKGUsXCJVaW50OEFycmF5XCIpfSx0LnJhbmRvbVNlZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTE1KSx0LnJhbmRvbShlLFwiQXJyYXkzMlwiKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBhLnNlZWRXb3Jkc0xpc3RbZSVhLnNlZWRXb3Jkc0xpc3QubGVuZ3RoXX0pKS5qb2luKFwiIFwiKX19KS5jYWxsKHRoaXMscigxMykuQnVmZmVyKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPXIoMiksYT1uKHIoOTIpKSxzPXIoMTEpLG89cigxMCk7dC5iYXNlNjREZWNvZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIG8uc3RyaW5nVG9CeXRlcyhpLmRlY29kZTY0KGUpLFwicmF3XCIpfSx0LmJhc2U2NEVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gaS5lbmNvZGU2NChvLmJ5dGVzVG9TdHJpbmcocy5fZnJvbUluKGUpLFwicmF3XCIpKX0sdC5iYXNlNThEZWNvZGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGEuZGVmYXVsdC5kZWNvZGUoZSl9LHQuYmFzZTU4RW5jb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBhLmRlZmF1bHQuZW5jb2RlKHMuX2Zyb21JbihlKSl9LHQuYmFzZTE2RGVjb2RlPWZ1bmN0aW9uKGUpe3JldHVybiBvLnN0cmluZ1RvQnl0ZXMoaS5oZXhUb0J5dGVzKGUpLFwicmF3XCIpfSx0LmJhc2UxNkVuY29kZT1mdW5jdGlvbihlKXtyZXR1cm4gaS5ieXRlc1RvSGV4KG8uYnl0ZXNUb1N0cmluZyhzLl9mcm9tSW4oZSksXCJyYXdcIikpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMDt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpLGk9ZnVuY3Rpb24oZSl7dmFyIHQscj1uZXcgRmxvYXQ2NEFycmF5KDE2KTtpZihlKWZvcih0PTA7dDxlLmxlbmd0aDt0Kyspclt0XT1lW3RdO3JldHVybiByfSxhPShuZXcgVWludDhBcnJheSgxNiksbmV3IFVpbnQ4QXJyYXkoMzIpKTthWzBdPTk7dmFyIHM9aSgpLG89aShbMV0pLHU9aShbNTYxMjksMV0pLGM9aShbMzA4ODMsNDk1MywxOTkxNCwzMDE4Nyw1NTQ2NywxNjcwNSwyNjM3LDExMiw1OTU0NCwzMDU4NSwxNjUwNSwzNjAzOSw2NTEzOSwxMTExOSwyNzg4NiwyMDk5NV0pLGw9aShbNjE3ODUsOTkwNiwzOTgyOCw2MDM3NCw0NTM5OCwzMzQxMSw1Mjc0LDIyNCw1MzU1Miw2MTE3MSwzMzAxMCw2NTQyLDY0NzQzLDIyMjM5LDU1NzcyLDkyMjJdKSxmPWkoWzU0NTU0LDM2NjQ1LDExNjE2LDUxNTQyLDQyOTMwLDM4MTgxLDUxMDQwLDI2OTI0LDU2NDEyLDY0OTgyLDU3OTA1LDQ5MzE2LDIxNTAyLDUyNTkwLDE0MDM1LDg1NTNdKSxoPWkoWzI2MjAwLDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0LDI2MjE0XSkscD1pKFs0MTEzNiwxODk1OCw2OTUxLDUwNDE0LDU4NDg4LDQ0MzM1LDYxNTAsMTIwOTksNTUyMDcsMTU4NjcsMTUzLDExMDg1LDU3MDk5LDIwNDE3LDkzNDQsMTExMzldKTtmdW5jdGlvbiBkKGUsdCxyLG4pe2VbdF09cj4+MjQmMjU1LGVbdCsxXT1yPj4xNiYyNTUsZVt0KzJdPXI+PjgmMjU1LGVbdCszXT0yNTUmcixlW3QrNF09bj4+MjQmMjU1LGVbdCs1XT1uPj4xNiYyNTUsZVt0KzZdPW4+PjgmMjU1LGVbdCs3XT0yNTUmbn1mdW5jdGlvbiB5KGUsdCxyLG4pe3JldHVybiBmdW5jdGlvbihlLHQscixuLGkpe3ZhciBhLHM9MDtmb3IoYT0wO2E8aTthKyspc3w9ZVt0K2FdXnJbbithXTtyZXR1cm4oMSZzLTE+Pj44KS0xfShlLHQscixuLDMyKX1mdW5jdGlvbiBnKGUsdCl7Zm9yKHZhciByPTA7cjwxNjtyKyspZVtyXT0wfHRbcl19ZnVuY3Rpb24gbShlKXt2YXIgdCxyLG49MTtmb3IodD0wO3Q8MTY7dCsrKXI9ZVt0XStuKzY1NTM1LG49TWF0aC5mbG9vcihyLzY1NTM2KSxlW3RdPXItNjU1MzYqbjtlWzBdKz1uLTErMzcqKG4tMSl9ZnVuY3Rpb24gdihlLHQscil7Zm9yKHZhciBuLGk9fihyLTEpLGE9MDthPDE2O2ErKyluPWkmKGVbYV1edFthXSksZVthXV49bix0W2FdXj1ufWZ1bmN0aW9uIGIoZSx0KXt2YXIgcixuLGEscz1pKCksbz1pKCk7Zm9yKHI9MDtyPDE2O3IrKylvW3JdPXRbcl07Zm9yKG0obyksbShvKSxtKG8pLG49MDtuPDI7bisrKXtmb3Ioc1swXT1vWzBdLTY1NTE3LHI9MTtyPDE1O3IrKylzW3JdPW9bcl0tNjU1MzUtKHNbci0xXT4+MTYmMSksc1tyLTFdJj02NTUzNTtzWzE1XT1vWzE1XS0zMjc2Ny0oc1sxNF0+PjE2JjEpLGE9c1sxNV0+PjE2JjEsc1sxNF0mPTY1NTM1LHYobyxzLDEtYSl9Zm9yKHI9MDtyPDE2O3IrKyllWzIqcl09MjU1Jm9bcl0sZVsyKnIrMV09b1tyXT4+OH1mdW5jdGlvbiBFKGUsdCl7dmFyIHI9bmV3IFVpbnQ4QXJyYXkoMzIpLG49bmV3IFVpbnQ4QXJyYXkoMzIpO3JldHVybiBiKHIsZSksYihuLHQpLHkociwwLG4sMCl9ZnVuY3Rpb24gUyhlKXt2YXIgdD1uZXcgVWludDhBcnJheSgzMik7cmV0dXJuIGIodCxlKSwxJnRbMF19ZnVuY3Rpb24gVChlLHQpe2Zvcih2YXIgcj0wO3I8MTY7cisrKWVbcl09dFsyKnJdKyh0WzIqcisxXTw8OCk7ZVsxNV0mPTMyNzY3fWZ1bmN0aW9uIEMoZSx0LHIpe2Zvcih2YXIgbj0wO248MTY7bisrKWVbbl09dFtuXStyW25dfWZ1bmN0aW9uIEEoZSx0LHIpe2Zvcih2YXIgbj0wO248MTY7bisrKWVbbl09dFtuXS1yW25dfWZ1bmN0aW9uIEkoZSx0LHIpe3ZhciBuLGksYT0wLHM9MCxvPTAsdT0wLGM9MCxsPTAsZj0wLGg9MCxwPTAsZD0wLHk9MCxnPTAsbT0wLHY9MCxiPTAsRT0wLFM9MCxUPTAsQz0wLEE9MCxJPTAsdz0wLEI9MCxOPTAsUj0wLF89MCxQPTAsTz0wLGs9MCxVPTAsTD0wLEQ9clswXSxWPXJbMV0seD1yWzJdLEs9clszXSxNPXJbNF0saj1yWzVdLEY9cls2XSxxPXJbN10sej1yWzhdLEc9cls5XSxIPXJbMTBdLFk9clsxMV0sUT1yWzEyXSxXPXJbMTNdLFg9clsxNF0sJD1yWzE1XTthKz0obj10WzBdKSpELHMrPW4qVixvKz1uKngsdSs9bipLLGMrPW4qTSxsKz1uKmosZis9bipGLGgrPW4qcSxwKz1uKnosZCs9bipHLHkrPW4qSCxnKz1uKlksbSs9bipRLHYrPW4qVyxiKz1uKlgsRSs9biokLHMrPShuPXRbMV0pKkQsbys9bipWLHUrPW4qeCxjKz1uKkssbCs9bipNLGYrPW4qaixoKz1uKkYscCs9bipxLGQrPW4qeix5Kz1uKkcsZys9bipILG0rPW4qWSx2Kz1uKlEsYis9bipXLEUrPW4qWCxTKz1uKiQsbys9KG49dFsyXSkqRCx1Kz1uKlYsYys9bip4LGwrPW4qSyxmKz1uKk0saCs9bipqLHArPW4qRixkKz1uKnEseSs9bip6LGcrPW4qRyxtKz1uKkgsdis9bipZLGIrPW4qUSxFKz1uKlcsUys9bipYLFQrPW4qJCx1Kz0obj10WzNdKSpELGMrPW4qVixsKz1uKngsZis9bipLLGgrPW4qTSxwKz1uKmosZCs9bipGLHkrPW4qcSxnKz1uKnosbSs9bipHLHYrPW4qSCxiKz1uKlksRSs9bipRLFMrPW4qVyxUKz1uKlgsQys9biokLGMrPShuPXRbNF0pKkQsbCs9bipWLGYrPW4qeCxoKz1uKksscCs9bipNLGQrPW4qaix5Kz1uKkYsZys9bipxLG0rPW4qeix2Kz1uKkcsYis9bipILEUrPW4qWSxTKz1uKlEsVCs9bipXLEMrPW4qWCxBKz1uKiQsbCs9KG49dFs1XSkqRCxmKz1uKlYsaCs9bip4LHArPW4qSyxkKz1uKk0seSs9bipqLGcrPW4qRixtKz1uKnEsdis9bip6LGIrPW4qRyxFKz1uKkgsUys9bipZLFQrPW4qUSxDKz1uKlcsQSs9bipYLEkrPW4qJCxmKz0obj10WzZdKSpELGgrPW4qVixwKz1uKngsZCs9bipLLHkrPW4qTSxnKz1uKmosbSs9bipGLHYrPW4qcSxiKz1uKnosRSs9bipHLFMrPW4qSCxUKz1uKlksQys9bipRLEErPW4qVyxJKz1uKlgsdys9biokLGgrPShuPXRbN10pKkQscCs9bipWLGQrPW4qeCx5Kz1uKkssZys9bipNLG0rPW4qaix2Kz1uKkYsYis9bipxLEUrPW4qeixTKz1uKkcsVCs9bipILEMrPW4qWSxBKz1uKlEsSSs9bipXLHcrPW4qWCxCKz1uKiQscCs9KG49dFs4XSkqRCxkKz1uKlYseSs9bip4LGcrPW4qSyxtKz1uKk0sdis9bipqLGIrPW4qRixFKz1uKnEsUys9bip6LFQrPW4qRyxDKz1uKkgsQSs9bipZLEkrPW4qUSx3Kz1uKlcsQis9bipYLE4rPW4qJCxkKz0obj10WzldKSpELHkrPW4qVixnKz1uKngsbSs9bipLLHYrPW4qTSxiKz1uKmosRSs9bipGLFMrPW4qcSxUKz1uKnosQys9bipHLEErPW4qSCxJKz1uKlksdys9bipRLEIrPW4qVyxOKz1uKlgsUis9biokLHkrPShuPXRbMTBdKSpELGcrPW4qVixtKz1uKngsdis9bipLLGIrPW4qTSxFKz1uKmosUys9bipGLFQrPW4qcSxDKz1uKnosQSs9bipHLEkrPW4qSCx3Kz1uKlksQis9bipRLE4rPW4qVyxSKz1uKlgsXys9biokLGcrPShuPXRbMTFdKSpELG0rPW4qVix2Kz1uKngsYis9bipLLEUrPW4qTSxTKz1uKmosVCs9bipGLEMrPW4qcSxBKz1uKnosSSs9bipHLHcrPW4qSCxCKz1uKlksTis9bipRLFIrPW4qVyxfKz1uKlgsUCs9biokLG0rPShuPXRbMTJdKSpELHYrPW4qVixiKz1uKngsRSs9bipLLFMrPW4qTSxUKz1uKmosQys9bipGLEErPW4qcSxJKz1uKnosdys9bipHLEIrPW4qSCxOKz1uKlksUis9bipRLF8rPW4qVyxQKz1uKlgsTys9biokLHYrPShuPXRbMTNdKSpELGIrPW4qVixFKz1uKngsUys9bipLLFQrPW4qTSxDKz1uKmosQSs9bipGLEkrPW4qcSx3Kz1uKnosQis9bipHLE4rPW4qSCxSKz1uKlksXys9bipRLFArPW4qVyxPKz1uKlgsays9biokLGIrPShuPXRbMTRdKSpELEUrPW4qVixTKz1uKngsVCs9bipLLEMrPW4qTSxBKz1uKmosSSs9bipGLHcrPW4qcSxCKz1uKnosTis9bipHLFIrPW4qSCxfKz1uKlksUCs9bipRLE8rPW4qVyxrKz1uKlgsVSs9biokLEUrPShuPXRbMTVdKSpELHMrPTM4KihUKz1uKngpLG8rPTM4KihDKz1uKkspLHUrPTM4KihBKz1uKk0pLGMrPTM4KihJKz1uKmopLGwrPTM4Kih3Kz1uKkYpLGYrPTM4KihCKz1uKnEpLGgrPTM4KihOKz1uKnopLHArPTM4KihSKz1uKkcpLGQrPTM4KihfKz1uKkgpLHkrPTM4KihQKz1uKlkpLGcrPTM4KihPKz1uKlEpLG0rPTM4KihrKz1uKlcpLHYrPTM4KihVKz1uKlgpLGIrPTM4KihMKz1uKiQpLGE9KG49KGErPTM4KihTKz1uKlYpKSsoaT0xKSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSkscz0obj1zK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLG89KG49bytpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSx1PShuPXUraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksYz0obj1jK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGw9KG49bCtpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxmPShuPWYraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksaD0obj1oK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLHA9KG49cCtpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxkPShuPWQraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSkseT0obj15K2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGc9KG49ZytpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxtPShuPW0raSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksdj0obj12K2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGI9KG49YitpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxFPShuPUUraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksYT0obj0oYSs9aS0xKzM3KihpLTEpKSsoaT0xKSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSkscz0obj1zK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLG89KG49bytpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSx1PShuPXUraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksYz0obj1jK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGw9KG49bCtpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxmPShuPWYraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksaD0obj1oK2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLHA9KG49cCtpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxkPShuPWQraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSkseT0obj15K2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGc9KG49ZytpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxtPShuPW0raSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksdj0obj12K2krNjU1MzUpLTY1NTM2KihpPU1hdGguZmxvb3Iobi82NTUzNikpLGI9KG49YitpKzY1NTM1KS02NTUzNiooaT1NYXRoLmZsb29yKG4vNjU1MzYpKSxFPShuPUUraSs2NTUzNSktNjU1MzYqKGk9TWF0aC5mbG9vcihuLzY1NTM2KSksYSs9aS0xKzM3KihpLTEpLGVbMF09YSxlWzFdPXMsZVsyXT1vLGVbM109dSxlWzRdPWMsZVs1XT1sLGVbNl09ZixlWzddPWgsZVs4XT1wLGVbOV09ZCxlWzEwXT15LGVbMTFdPWcsZVsxMl09bSxlWzEzXT12LGVbMTRdPWIsZVsxNV09RX1mdW5jdGlvbiB3KGUsdCl7SShlLHQsdCl9ZnVuY3Rpb24gQihlLHQpe3ZhciByLG49aSgpO2ZvcihyPTA7cjwxNjtyKyspbltyXT10W3JdO2ZvcihyPTI1MztyPj0wO3ItLSl3KG4sbiksMiE9PXImJjQhPT1yJiZJKG4sbix0KTtmb3Iocj0wO3I8MTY7cisrKWVbcl09bltyXX1mdW5jdGlvbiBOKGUsdCxyKXt2YXIgbixhLHM9bmV3IFVpbnQ4QXJyYXkoMzIpLG89bmV3IEZsb2F0NjRBcnJheSg4MCksYz1pKCksbD1pKCksZj1pKCksaD1pKCkscD1pKCksZD1pKCk7Zm9yKGE9MDthPDMxO2ErKylzW2FdPXRbYV07Zm9yKHNbMzFdPTEyNyZ0WzMxXXw2NCxzWzBdJj0yNDgsVChvLHIpLGE9MDthPDE2O2ErKylsW2FdPW9bYV0saFthXT1jW2FdPWZbYV09MDtmb3IoY1swXT1oWzBdPTEsYT0yNTQ7YT49MDstLWEpdihjLGwsbj1zW2E+Pj4zXT4+Pig3JmEpJjEpLHYoZixoLG4pLEMocCxjLGYpLEEoYyxjLGYpLEMoZixsLGgpLEEobCxsLGgpLHcoaCxwKSx3KGQsYyksSShjLGYsYyksSShmLGwscCksQyhwLGMsZiksQShjLGMsZiksdyhsLGMpLEEoZixoLGQpLEkoYyxmLHUpLEMoYyxjLGgpLEkoZixmLGMpLEkoYyxoLGQpLEkoaCxsLG8pLHcobCxwKSx2KGMsbCxuKSx2KGYsaCxuKTtmb3IoYT0wO2E8MTY7YSsrKW9bYSsxNl09Y1thXSxvW2ErMzJdPWZbYV0sb1thKzQ4XT1sW2FdLG9bYSs2NF09aFthXTt2YXIgeT1vLnN1YmFycmF5KDMyKSxnPW8uc3ViYXJyYXkoMTYpO3JldHVybiBCKHkseSksSShnLGcseSksYihlLGcpLDB9dmFyIFI9WzExMTYzNTI0MDgsMzYwOTc2NzQ1OCwxODk5NDQ3NDQxLDYwMjg5MTcyNSwzMDQ5MzIzNDcxLDM5NjQ0ODQzOTksMzkyMTAwOTU3MywyMTczMjk1NTQ4LDk2MTk4NzE2Myw0MDgxNjI4NDcyLDE1MDg5NzA5OTMsMzA1MzgzNDI2NSwyNDUzNjM1NzQ4LDI5Mzc2NzE1NzksMjg3MDc2MzIyMSwzNjY0NjA5NTYwLDM2MjQzODEwODAsMjczNDg4MzM5NCwzMTA1OTg0MDEsMTE2NDk5NjU0Miw2MDcyMjUyNzgsMTMyMzYxMDc2NCwxNDI2ODgxOTg3LDM1OTAzMDQ5OTQsMTkyNTA3ODM4OCw0MDY4MTgyMzgzLDIxNjIwNzgyMDYsOTkxMzM2MTEzLDI2MTQ4ODgxMDMsNjMzODAzMzE3LDMyNDgyMjI1ODAsMzQ3OTc3NDg2OCwzODM1MzkwNDAxLDI2NjY2MTM0NTgsNDAyMjIyNDc3NCw5NDQ3MTExMzksMjY0MzQ3MDc4LDIzNDEyNjI3NzMsNjA0ODA3NjI4LDIwMDc4MDA5MzMsNzcwMjU1OTgzLDE0OTU5OTA5MDEsMTI0OTE1MDEyMiwxODU2NDMxMjM1LDE1NTUwODE2OTIsMzE3NTIxODEzMiwxOTk2MDY0OTg2LDIxOTg5NTA4MzcsMjU1NDIyMDg4MiwzOTk5NzE5MzM5LDI4MjE4MzQzNDksNzY2Nzg0MDE2LDI5NTI5OTY4MDgsMjU2NjU5NDg3OSwzMjEwMzEzNjcxLDMyMDMzMzc5NTYsMzMzNjU3MTg5MSwxMDM0NDU3MDI2LDM1ODQ1Mjg3MTEsMjQ2Njk0ODkwMSwxMTM5MjY5OTMsMzc1ODMyNjM4MywzMzgyNDE4OTUsMTY4NzE3OTM2LDY2NjMwNzIwNSwxMTg4MTc5OTY0LDc3MzUyOTkxMiwxNTQ2MDQ1NzM0LDEyOTQ3NTczNzIsMTUyMjgwNTQ4NSwxMzk2MTgyMjkxLDI2NDM4MzM4MjMsMTY5NTE4MzcwMCwyMzQzNTI3MzkwLDE5ODY2NjEwNTEsMTAxNDQ3NzQ4MCwyMTc3MDI2MzUwLDEyMDY3NTkxNDIsMjQ1Njk1NjAzNywzNDQwNzc2MjcsMjczMDQ4NTkyMSwxMjkwODYzNDYwLDI4MjAzMDI0MTEsMzE1ODQ1NDI3MywzMjU5NzMwODAwLDM1MDU5NTI2NTcsMzM0NTc2NDc3MSwxMDYyMTcwMDgsMzUxNjA2NTgxNywzNjA2MDA4MzQ0LDM2MDAzNTI4MDQsMTQzMjcyNTc3Niw0MDk0NTcxOTA5LDE0NjcwMzE1OTQsMjc1NDIzMzQ0LDg1MTE2OTcyMCw0MzAyMjc3MzQsMzEwMDgyMzc1Miw1MDY5NDg2MTYsMTM2MzI1ODE5NSw2NTkwNjA1NTYsMzc1MDY4NTU5Myw4ODM5OTc4NzcsMzc4NTA1MDI4MCw5NTgxMzk1NzEsMzMxODMwNzQyNywxMzIyODIyMjE4LDM4MTI3MjM0MDMsMTUzNzAwMjA2MywyMDAzMDM0OTk1LDE3NDc4NzM3NzksMzYwMjAzNjg5OSwxOTU1NTYyMjIyLDE1NzU5OTAwMTIsMjAyNDEwNDgxNSwxMTI1NTkyOTI4LDIyMjc3MzA0NTIsMjcxNjkwNDMwNiwyMzYxODUyNDI0LDQ0Mjc3NjA0NCwyNDI4NDM2NDc0LDU5MzY5ODM0NCwyNzU2NzM0MTg3LDM3MzMxMTAyNDksMzIwNDAzMTQ3OSwyOTk5MzUxNTczLDMzMjkzMjUyOTgsMzgxNTkyMDQyNywzMzkxNTY5NjE0LDM5MjgzODM5MDAsMzUxNTI2NzI3MSw1NjYyODA3MTEsMzk0MDE4NzYwNiwzNDU0MDY5NTM0LDQxMTg2MzAyNzEsNDAwMDIzOTk5MiwxMTY0MTg0NzQsMTkxNDEzODU1NCwxNzQyOTI0MjEsMjczMTA1NTI3MCwyODkzODAzNTYsMzIwMzk5MzAwNiw0NjAzOTMyNjksMzIwNjIwMzE1LDY4NTQ3MTczMyw1ODc0OTY4MzYsODUyMTQyOTcxLDEwODY3OTI4NTEsMTAxNzAzNjI5OCwzNjU1NDMxMDAsMTEyNjAwMDU4MCwyNjE4Mjk3Njc2LDEyODgwMzM0NzAsMzQwOTg1NTE1OCwxNTAxNTA1OTQ4LDQyMzQ1MDk4NjYsMTYwNzE2NzkxNSw5ODcxNjc0NjgsMTgxNjQwMjMxNiwxMjQ2MTg5NTkxXTtmdW5jdGlvbiBfKGUsdCxyLG4pe2Zvcih2YXIgaSxhLHMsbyx1LGMsbCxmLGgscCxkLHksZyxtLHYsYixFLFMsVCxDLEEsSSx3LEIsTixfLFA9bmV3IEludDMyQXJyYXkoMTYpLE89bmV3IEludDMyQXJyYXkoMTYpLGs9ZVswXSxVPWVbMV0sTD1lWzJdLEQ9ZVszXSxWPWVbNF0seD1lWzVdLEs9ZVs2XSxNPWVbN10saj10WzBdLEY9dFsxXSxxPXRbMl0sej10WzNdLEc9dFs0XSxIPXRbNV0sWT10WzZdLFE9dFs3XSxXPTA7bj49MTI4Oyl7Zm9yKFQ9MDtUPDE2O1QrKylDPTgqVCtXLFBbVF09cltDKzBdPDwyNHxyW0MrMV08PDE2fHJbQysyXTw8OHxyW0MrM10sT1tUXT1yW0MrNF08PDI0fHJbQys1XTw8MTZ8cltDKzZdPDw4fHJbQys3XTtmb3IoVD0wO1Q8ODA7VCsrKWlmKGk9ayxhPVUscz1MLG89RCx1PVYsYz14LGw9SyxNLGg9aixwPUYsZD1xLHk9eixnPUcsbT1ILHY9WSxRLHc9NjU1MzUmKEk9USksQj1JPj4+MTYsTj02NTUzNSYoQT1NKSxfPUE+Pj4xNix3Kz02NTUzNSYoST0oRz4+PjE0fFY8PDE4KV4oRz4+PjE4fFY8PDE0KV4oVj4+Pjl8Rzw8MjMpKSxCKz1JPj4+MTYsTis9NjU1MzUmKEE9KFY+Pj4xNHxHPDwxOCleKFY+Pj4xOHxHPDwxNCleKEc+Pj45fFY8PDIzKSksXys9QT4+PjE2LHcrPTY1NTM1JihJPUcmSF5+RyZZKSxCKz1JPj4+MTYsTis9NjU1MzUmKEE9ViZ4Xn5WJkspLF8rPUE+Pj4xNixBPVJbMipUXSx3Kz02NTUzNSYoST1SWzIqVCsxXSksQis9ST4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LEE9UFtUJTE2XSxCKz0oST1PW1QlMTZdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LE4rPShCKz0odys9NjU1MzUmSSk+Pj4xNik+Pj4xNix3PTY1NTM1JihJPVM9NjU1MzUmd3xCPDwxNiksQj1JPj4+MTYsTj02NTUzNSYoQT1FPTY1NTM1Jk58KF8rPU4+Pj4xNik8PDE2KSxfPUE+Pj4xNix3Kz02NTUzNSYoST0oaj4+PjI4fGs8PDQpXihrPj4+MnxqPDwzMCleKGs+Pj43fGo8PDI1KSksQis9ST4+PjE2LE4rPTY1NTM1JihBPShrPj4+Mjh8ajw8NCleKGo+Pj4yfGs8PDMwKV4oaj4+Pjd8azw8MjUpKSxfKz1BPj4+MTYsQis9KEk9aiZGXmomcV5GJnEpPj4+MTYsTis9NjU1MzUmKEE9ayZVXmsmTF5VJkwpLF8rPUE+Pj4xNixmPTY1NTM1JihOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpfChfKz1OPj4+MTYpPDwxNixiPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST15KSxCPUk+Pj4xNixOPTY1NTM1JihBPW8pLF89QT4+PjE2LEIrPShJPVMpPj4+MTYsTis9NjU1MzUmKEE9RSksXys9QT4+PjE2LFU9aSxMPWEsRD1zLFY9bz02NTUzNSYoTis9KEIrPSh3Kz02NTUzNSZJKT4+PjE2KT4+PjE2KXwoXys9Tj4+PjE2KTw8MTYseD11LEs9YyxNPWwsaz1mLEY9aCxxPXAsej1kLEc9eT02NTUzNSZ3fEI8PDE2LEg9ZyxZPW0sUT12LGo9YixUJTE2PT0xNSlmb3IoQz0wO0M8MTY7QysrKUE9UFtDXSx3PTY1NTM1JihJPU9bQ10pLEI9ST4+PjE2LE49NjU1MzUmQSxfPUE+Pj4xNixBPVBbKEMrOSklMTZdLHcrPTY1NTM1JihJPU9bKEMrOSklMTZdKSxCKz1JPj4+MTYsTis9NjU1MzUmQSxfKz1BPj4+MTYsRT1QWyhDKzEpJTE2XSx3Kz02NTUzNSYoST0oKFM9T1soQysxKSUxNl0pPj4+MXxFPDwzMSleKFM+Pj44fEU8PDI0KV4oUz4+Pjd8RTw8MjUpKSxCKz1JPj4+MTYsTis9NjU1MzUmKEE9KEU+Pj4xfFM8PDMxKV4oRT4+Pjh8Uzw8MjQpXkU+Pj43KSxfKz1BPj4+MTYsRT1QWyhDKzE0KSUxNl0sQis9KEk9KChTPU9bKEMrMTQpJTE2XSk+Pj4xOXxFPDwxMyleKEU+Pj4yOXxTPDwzKV4oUz4+PjZ8RTw8MjYpKT4+PjE2LE4rPTY1NTM1JihBPShFPj4+MTl8Uzw8MTMpXihTPj4+Mjl8RTw8MyleRT4+PjYpLF8rPUE+Pj4xNixfKz0oTis9KEIrPSh3Kz02NTUzNSZJKT4+PjE2KT4+PjE2KT4+PjE2LFBbQ109NjU1MzUmTnxfPDwxNixPW0NdPTY1NTM1Jnd8Qjw8MTY7dz02NTUzNSYoST1qKSxCPUk+Pj4xNixOPTY1NTM1JihBPWspLF89QT4+PjE2LEE9ZVswXSxCKz0oST10WzBdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVswXT1rPTY1NTM1Jk58Xzw8MTYsdFswXT1qPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1GKSxCPUk+Pj4xNixOPTY1NTM1JihBPVUpLF89QT4+PjE2LEE9ZVsxXSxCKz0oST10WzFdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVsxXT1VPTY1NTM1Jk58Xzw8MTYsdFsxXT1GPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1xKSxCPUk+Pj4xNixOPTY1NTM1JihBPUwpLF89QT4+PjE2LEE9ZVsyXSxCKz0oST10WzJdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVsyXT1MPTY1NTM1Jk58Xzw8MTYsdFsyXT1xPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST16KSxCPUk+Pj4xNixOPTY1NTM1JihBPUQpLF89QT4+PjE2LEE9ZVszXSxCKz0oST10WzNdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVszXT1EPTY1NTM1Jk58Xzw8MTYsdFszXT16PTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1HKSxCPUk+Pj4xNixOPTY1NTM1JihBPVYpLF89QT4+PjE2LEE9ZVs0XSxCKz0oST10WzRdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVs0XT1WPTY1NTM1Jk58Xzw8MTYsdFs0XT1HPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1IKSxCPUk+Pj4xNixOPTY1NTM1JihBPXgpLF89QT4+PjE2LEE9ZVs1XSxCKz0oST10WzVdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVs1XT14PTY1NTM1Jk58Xzw8MTYsdFs1XT1IPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1ZKSxCPUk+Pj4xNixOPTY1NTM1JihBPUspLF89QT4+PjE2LEE9ZVs2XSxCKz0oST10WzZdKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVs2XT1LPTY1NTM1Jk58Xzw8MTYsdFs2XT1ZPTY1NTM1Jnd8Qjw8MTYsdz02NTUzNSYoST1RKSxCPUk+Pj4xNixOPTY1NTM1JihBPU0pLF89QT4+PjE2LEE9ZVs3XSxCKz0oST10WzddKT4+PjE2LE4rPTY1NTM1JkEsXys9QT4+PjE2LF8rPShOKz0oQis9KHcrPTY1NTM1JkkpPj4+MTYpPj4+MTYpPj4+MTYsZVs3XT1NPTY1NTM1Jk58Xzw8MTYsdFs3XT1RPTY1NTM1Jnd8Qjw8MTYsVys9MTI4LG4tPTEyOH1yZXR1cm4gbn1mdW5jdGlvbiBQKGUsdCxyKXt2YXIgbixpPW5ldyBJbnQzMkFycmF5KDgpLGE9bmV3IEludDMyQXJyYXkoOCkscz1uZXcgVWludDhBcnJheSgyNTYpLG89cjtmb3IoaVswXT0xNzc5MDMzNzAzLGlbMV09MzE0NDEzNDI3NyxpWzJdPTEwMTM5MDQyNDIsaVszXT0yNzczNDgwNzYyLGlbNF09MTM1OTg5MzExOSxpWzVdPTI2MDA4MjI5MjQsaVs2XT01Mjg3MzQ2MzUsaVs3XT0xNTQxNDU5MjI1LGFbMF09NDA4OTIzNTcyMCxhWzFdPTIyMjc4NzM1OTUsYVsyXT00MjcxMTc1NzIzLGFbM109MTU5NTc1MDEyOSxhWzRdPTI5MTc1NjUxMzcsYVs1XT03MjU1MTExOTksYVs2XT00MjE1Mzg5NTQ3LGFbN109MzI3MDMzMjA5LF8oaSxhLHQsciksciU9MTI4LG49MDtuPHI7bisrKXNbbl09dFtvLXIrbl07Zm9yKHNbcl09MTI4LHNbKHI9MjU2LTEyOCoocjwxMTI/MTowKSktOV09MCxkKHMsci04LG8vNTM2ODcwOTEyfDAsbzw8MyksXyhpLGEscyxyKSxuPTA7bjw4O24rKylkKGUsOCpuLGlbbl0sYVtuXSk7cmV0dXJuIDB9ZnVuY3Rpb24gTyhlLHQpe3ZhciByPWkoKSxuPWkoKSxhPWkoKSxzPWkoKSxvPWkoKSx1PWkoKSxjPWkoKSxmPWkoKSxoPWkoKTtBKHIsZVsxXSxlWzBdKSxBKGgsdFsxXSx0WzBdKSxJKHIscixoKSxDKG4sZVswXSxlWzFdKSxDKGgsdFswXSx0WzFdKSxJKG4sbixoKSxJKGEsZVszXSx0WzNdKSxJKGEsYSxsKSxJKHMsZVsyXSx0WzJdKSxDKHMscyxzKSxBKG8sbixyKSxBKHUscyxhKSxDKGMscyxhKSxDKGYsbixyKSxJKGVbMF0sbyx1KSxJKGVbMV0sZixjKSxJKGVbMl0sYyx1KSxJKGVbM10sbyxmKX1mdW5jdGlvbiBrKGUsdCxyKXtmb3IodmFyIG49MDtuPDQ7bisrKXYoZVtuXSx0W25dLHIpfWZ1bmN0aW9uIFUoZSx0KXt2YXIgcj1pKCksbj1pKCksYT1pKCk7QihhLHRbMl0pLEkocix0WzBdLGEpLEkobix0WzFdLGEpLGIoZSxuKSxlWzMxXV49UyhyKTw8N31mdW5jdGlvbiBMKGUsdCxyKXt2YXIgbixpO2ZvcihnKGVbMF0scyksZyhlWzFdLG8pLGcoZVsyXSxvKSxnKGVbM10scyksaT0yNTU7aT49MDstLWkpayhlLHQsbj1yW2kvOHwwXT4+KDcmaSkmMSksTyh0LGUpLE8oZSxlKSxrKGUsdCxuKX1mdW5jdGlvbiBEKGUsdCl7dmFyIHI9W2koKSxpKCksaSgpLGkoKV07ZyhyWzBdLGYpLGcoclsxXSxoKSxnKHJbMl0sbyksSShyWzNdLGYsaCksTChlLHIsdCl9dmFyIFY9bmV3IEZsb2F0NjRBcnJheShbMjM3LDIxMSwyNDUsOTIsMjYsOTksMTgsODgsMjE0LDE1NiwyNDcsMTYyLDIyMiwyNDksMjIyLDIwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDE2XSk7ZnVuY3Rpb24geChlLHQpe3ZhciByLG4saSxhO2ZvcihuPTYzO24+PTMyOy0tbil7Zm9yKHI9MCxpPW4tMzIsYT1uLTEyO2k8YTsrK2kpdFtpXSs9ci0xNip0W25dKlZbaS0obi0zMildLHI9dFtpXSsxMjg+PjgsdFtpXS09MjU2KnI7dFtpXSs9cix0W25dPTB9Zm9yKHI9MCxpPTA7aTwzMjtpKyspdFtpXSs9ci0odFszMV0+PjQpKlZbaV0scj10W2ldPj44LHRbaV0mPTI1NTtmb3IoaT0wO2k8MzI7aSsrKXRbaV0tPXIqVltpXTtmb3Iobj0wO248MzI7bisrKXRbbisxXSs9dFtuXT4+OCxlW25dPTI1NSZ0W25dfWZ1bmN0aW9uIEsoZSl7dmFyIHQscj1uZXcgRmxvYXQ2NEFycmF5KDY0KTtmb3IodD0wO3Q8NjQ7dCsrKXJbdF09ZVt0XTtmb3IodD0wO3Q8NjQ7dCsrKWVbdF09MDt4KGUscil9ZnVuY3Rpb24gTShlLHQscixuLGEpe2Zvcih2YXIgcz1uZXcgVWludDhBcnJheSg2NCksbz1baSgpLGkoKSxpKCksaSgpXSx1PTA7dTwzMjt1Kyspc1t1XT1uW3VdO3NbMF0mPTI0OCxzWzMxXSY9MTI3LHNbMzFdfD02NCxEKG8scyksVShzLnN1YmFycmF5KDMyKSxvKTt2YXIgYyxsPTEyOCZzWzYzXTtyZXR1cm4gYz1hP2Z1bmN0aW9uKGUsdCxyLG4sYSl7bmV3IFVpbnQ4QXJyYXkoNjQpO3ZhciBzLG8sdT1uZXcgVWludDhBcnJheSg2NCksYz1uZXcgVWludDhBcnJheSg2NCksbD1uZXcgRmxvYXQ2NEFycmF5KDY0KSxmPVtpKCksaSgpLGkoKSxpKCldO2ZvcihlWzBdPTI1NCxzPTE7czwzMjtzKyspZVtzXT0yNTU7Zm9yKHM9MDtzPDMyO3MrKyllWzMyK3NdPW5bc107Zm9yKHM9MDtzPHI7cysrKWVbNjQrc109dFtzXTtmb3Iocz0wO3M8NjQ7cysrKWVbcis2NCtzXT1hW3NdO2ZvcihQKGMsZSxyKzEyOCksSyhjKSxEKGYsYyksVShlLGYpLHM9MDtzPDMyO3MrKyllW3MrMzJdPW5bMzIrc107Zm9yKFAodSxlLHIrNjQpLEsodSkscz0wO3M8NjQ7cysrKWVbcis2NCtzXT0wO2ZvcihzPTA7czw2NDtzKyspbFtzXT0wO2ZvcihzPTA7czwzMjtzKyspbFtzXT1jW3NdO2ZvcihzPTA7czwzMjtzKyspZm9yKG89MDtvPDMyO28rKylsW3Mrb10rPXVbc10qbltvXTtyZXR1cm4geChlLnN1YmFycmF5KDMyLHIrNjQpLGwpLHIrNjR9KGUsdCxyLHMsYSk6ZnVuY3Rpb24oZSx0LHIsbil7bmV3IFVpbnQ4QXJyYXkoNjQpO3ZhciBhLHMsbz1uZXcgVWludDhBcnJheSg2NCksdT1uZXcgVWludDhBcnJheSg2NCksYz1uZXcgRmxvYXQ2NEFycmF5KDY0KSxsPVtpKCksaSgpLGkoKSxpKCldO2ZvcihhPTA7YTxyO2ErKyllWzY0K2FdPXRbYV07Zm9yKGE9MDthPDMyO2ErKyllWzMyK2FdPW5bYV07Zm9yKFAodSxlLnN1YmFycmF5KDMyKSxyKzMyKSxLKHUpLEQobCx1KSxVKGUsbCksYT0wO2E8MzI7YSsrKWVbYSszMl09blszMithXTtmb3IoUChvLGUscis2NCksSyhvKSxhPTA7YTw2NDthKyspY1thXT0wO2ZvcihhPTA7YTwzMjthKyspY1thXT11W2FdO2ZvcihhPTA7YTwzMjthKyspZm9yKHM9MDtzPDMyO3MrKyljW2Erc10rPW9bYV0qbltzXTtyZXR1cm4geChlLnN1YmFycmF5KDMyKSxjKSxyKzY0fShlLHQscixzKSxlWzYzXXw9bCxjfWZ1bmN0aW9uIGooZSx0KXt2YXIgcj1pKCksbj1pKCksYT1pKCksdT1pKCksbD1pKCksZj1pKCksaD1pKCk7cmV0dXJuIGcoZVsyXSxvKSxUKGVbMV0sdCksdyhhLGVbMV0pLEkodSxhLGMpLEEoYSxhLGVbMl0pLEModSxlWzJdLHUpLHcobCx1KSx3KGYsbCksSShoLGYsbCksSShyLGgsYSksSShyLHIsdSksZnVuY3Rpb24oZSx0KXt2YXIgcixuPWkoKTtmb3Iocj0wO3I8MTY7cisrKW5bcl09dFtyXTtmb3Iocj0yNTA7cj49MDtyLS0pdyhuLG4pLDEhPT1yJiZJKG4sbix0KTtmb3Iocj0wO3I8MTY7cisrKWVbcl09bltyXX0ocixyKSxJKHIscixhKSxJKHIscix1KSxJKHIscix1KSxJKGVbMF0scix1KSx3KG4sZVswXSksSShuLG4sdSksRShuLGEpJiZJKGVbMF0sZVswXSxwKSx3KG4sZVswXSksSShuLG4sdSksRShuLGEpPy0xOihTKGVbMF0pPT09dFszMV0+PjcmJkEoZVswXSxzLGVbMF0pLEkoZVszXSxlWzBdLGVbMV0pLDApfWZ1bmN0aW9uIEYoZSx0LHIsbil7dmFyIGE9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoMzIpLHI9aSgpLG49aSgpLGE9aSgpO3JldHVybiBUKHIsZSksQyhuLHIsbyksQShhLHIsbyksQihuLG4pLEkobixuLGEpLGIodCxuKSx0fShuKTtyZXR1cm4gYVszMV18PTEyOCZ0WzYzXSx0WzYzXSY9MTI3LGZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBhLHM9bmV3IFVpbnQ4QXJyYXkoMzIpLG89bmV3IFVpbnQ4QXJyYXkoNjQpLHU9W2koKSxpKCksaSgpLGkoKV0sYz1baSgpLGkoKSxpKCksaSgpXTtpZigtMSxyPDY0KXJldHVybi0xO2lmKGooYyxuKSlyZXR1cm4tMTtmb3IoYT0wO2E8cjthKyspZVthXT10W2FdO2ZvcihhPTA7YTwzMjthKyspZVthKzMyXT1uW2FdO2lmKFAobyxlLHIpLEsobyksTCh1LGMsbyksRChjLHQuc3ViYXJyYXkoMzIpKSxPKHUsYyksVShzLHUpLHItPTY0LHkodCwwLHMsMCkpe2ZvcihhPTA7YTxyO2ErKyllW2FdPTA7cmV0dXJuLTF9Zm9yKGE9MDthPHI7YSsrKWVbYV09dFthKzY0XTtyZXR1cm4gcn0oZSx0LHIsYSl9ZnVuY3Rpb24gcSgpe2Zvcih2YXIgZSx0LHI9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspcltuXT1hcmd1bWVudHNbbl07Zm9yKHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKWlmKFwiW29iamVjdCBVaW50OEFycmF5XVwiIT09KGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50c1t0XSkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGUgXCIrZStcIiwgdXNlIFVpbnQ4QXJyYXlcIil9bi5zaGFyZWRLZXk9ZnVuY3Rpb24oZSx0KXtpZihxKHQsZSksMzIhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBwdWJsaWMga2V5IGxlbmd0aFwiKTtpZigzMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIndyb25nIHNlY3JldCBrZXkgbGVuZ3RoXCIpO3ZhciByPW5ldyBVaW50OEFycmF5KDMyKTtyZXR1cm4gTihyLGUsdCkscn0sbi5zaWduTWVzc2FnZT1mdW5jdGlvbihlLHQscil7aWYocSh0LGUpLDMyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwid3Jvbmcgc2VjcmV0IGtleSBsZW5ndGhcIik7aWYocil7aWYocShyKSw2NCE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIndyb25nIHJhbmRvbSBkYXRhIGxlbmd0aFwiKTt2YXIgbj1uZXcgVWludDhBcnJheSgxMjgrdC5sZW5ndGgpO3JldHVybiBNKG4sdCx0Lmxlbmd0aCxlLHIpLG5ldyBVaW50OEFycmF5KG4uc3ViYXJyYXkoMCw2NCt0Lmxlbmd0aCkpfXZhciBpPW5ldyBVaW50OEFycmF5KDY0K3QubGVuZ3RoKTtyZXR1cm4gTShpLHQsdC5sZW5ndGgsZSksaX0sbi5vcGVuTWVzc2FnZT1mdW5jdGlvbihlLHQpe2lmKHEodCxlKSwzMiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIndyb25nIHB1YmxpYyBrZXkgbGVuZ3RoXCIpO3ZhciByPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxuPUYocix0LHQubGVuZ3RoLGUpO2lmKG48MClyZXR1cm4gbnVsbDtmb3IodmFyIGk9bmV3IFVpbnQ4QXJyYXkobiksYT0wO2E8aS5sZW5ndGg7YSsrKWlbYV09clthXTtyZXR1cm4gaX0sbi5zaWduPWZ1bmN0aW9uKGUsdCxyKXtpZihxKGUsdCksMzIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBzZWNyZXQga2V5IGxlbmd0aFwiKTtpZihyJiYocShyKSw2NCE9PXIubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyByYW5kb20gZGF0YSBsZW5ndGhcIik7dmFyIG49bmV3IFVpbnQ4QXJyYXkoKHI/MTI4OjY0KSt0Lmxlbmd0aCk7TShuLHQsdC5sZW5ndGgsZSxyKTtmb3IodmFyIGk9bmV3IFVpbnQ4QXJyYXkoNjQpLGE9MDthPGkubGVuZ3RoO2ErKylpW2FdPW5bYV07cmV0dXJuIGl9LG4udmVyaWZ5PWZ1bmN0aW9uKGUsdCxyKXtpZihxKHQscixlKSw2NCE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIndyb25nIHNpZ25hdHVyZSBsZW5ndGhcIik7aWYoMzIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBwdWJsaWMga2V5IGxlbmd0aFwiKTt2YXIgbixpPW5ldyBVaW50OEFycmF5KDY0K3QubGVuZ3RoKSxhPW5ldyBVaW50OEFycmF5KDY0K3QubGVuZ3RoKTtmb3Iobj0wO248NjQ7bisrKWlbbl09cltuXTtmb3Iobj0wO248dC5sZW5ndGg7bisrKWlbbis2NF09dFtuXTtyZXR1cm4gRihhLGksaS5sZW5ndGgsZSk+PTB9LG4uZ2VuZXJhdGVLZXlQYWlyPWZ1bmN0aW9uKGUpe2lmKHEoZSksMzIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBzZWVkIGxlbmd0aFwiKTtmb3IodmFyIHQ9bmV3IFVpbnQ4QXJyYXkoMzIpLHI9bmV3IFVpbnQ4QXJyYXkoMzIpLG49MDtuPDMyO24rKyl0W25dPWVbbl07cmV0dXJuIE4ocix0LGEpLHRbMF0mPTI0OCx0WzMxXSY9MTI3LHRbMzFdfD02NCxyWzMxXSY9MTI3LHtwdWJsaWM6cixwcml2YXRlOnR9fSx0LmRlZmF1bHQ9bn0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7aWYocigxNSkscig2MCkscigxNikscigxMDEpLHIoMTAyKSxyKDEyKSxyKDIpLHZvaWQgMD09PWkpdmFyIGk9bi5qc2JuLkJpZ0ludGVnZXI7dmFyIGE9bi51dGlsLmlzTm9kZWpzP3IoMzEpOm51bGwscz1uLmFzbjEsbz1uLnV0aWw7bi5wa2k9bi5wa2l8fHt9LGUuZXhwb3J0cz1uLnBraS5yc2E9bi5yc2E9bi5yc2F8fHt9O3ZhciB1PW4ucGtpLGM9WzYsNCwyLDQsMiw0LDYsMl0sbD17bmFtZTpcIlByaXZhdGVLZXlJbmZvXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUHJpdmF0ZUtleUluZm8udmVyc2lvblwiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInByaXZhdGVLZXlWZXJzaW9uXCJ9LHtuYW1lOlwiUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobVwiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwcml2YXRlS2V5T2lkXCJ9XX0se25hbWU6XCJQcml2YXRlS2V5SW5mb1wiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLk9DVEVUU1RSSU5HLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwcml2YXRlS2V5XCJ9XX0sZj17bmFtZTpcIlJTQVByaXZhdGVLZXlcIix0YWdDbGFzczpzLkNsYXNzLlVOSVZFUlNBTCx0eXBlOnMuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJSU0FQcml2YXRlS2V5LnZlcnNpb25cIix0YWdDbGFzczpzLkNsYXNzLlVOSVZFUlNBTCx0eXBlOnMuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwcml2YXRlS2V5VmVyc2lvblwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkubW9kdWx1c1wiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInByaXZhdGVLZXlNb2R1bHVzXCJ9LHtuYW1lOlwiUlNBUHJpdmF0ZUtleS5wdWJsaWNFeHBvbmVudFwiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInByaXZhdGVLZXlQdWJsaWNFeHBvbmVudFwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50XCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudFwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkucHJpbWUxXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHJpdmF0ZUtleVByaW1lMVwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkucHJpbWUyXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHJpdmF0ZUtleVByaW1lMlwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkuZXhwb25lbnQxXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHJpdmF0ZUtleUV4cG9uZW50MVwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkuZXhwb25lbnQyXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHJpdmF0ZUtleUV4cG9uZW50MlwifSx7bmFtZTpcIlJTQVByaXZhdGVLZXkuY29lZmZpY2llbnRcIix0YWdDbGFzczpzLkNsYXNzLlVOSVZFUlNBTCx0eXBlOnMuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwcml2YXRlS2V5Q29lZmZpY2llbnRcIn1dfSxoPXtuYW1lOlwiUlNBUHVibGljS2V5XCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUlNBUHVibGljS2V5Lm1vZHVsdXNcIix0YWdDbGFzczpzLkNsYXNzLlVOSVZFUlNBTCx0eXBlOnMuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwdWJsaWNLZXlNb2R1bHVzXCJ9LHtuYW1lOlwiUlNBUHVibGljS2V5LmV4cG9uZW50XCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwicHVibGljS2V5RXhwb25lbnRcIn1dfSxwPW4ucGtpLnJzYS5wdWJsaWNLZXlWYWxpZGF0b3I9e25hbWU6XCJTdWJqZWN0UHVibGljS2V5SW5mb1wiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLGNhcHR1cmVBc24xOlwic3ViamVjdFB1YmxpY0tleUluZm9cIix2YWx1ZTpbe25hbWU6XCJTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyXCIsdGFnQ2xhc3M6cy5DbGFzcy5VTklWRVJTQUwsdHlwZTpzLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIix0YWdDbGFzczpzLkNsYXNzLlVOSVZFUlNBTCx0eXBlOnMuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInB1YmxpY0tleU9pZFwifV19LHtuYW1lOlwiU3ViamVjdFB1YmxpY0tleUluZm8uc3ViamVjdFB1YmxpY0tleVwiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLkJJVFNUUklORyxjb25zdHJ1Y3RlZDohMSx2YWx1ZTpbe25hbWU6XCJTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleVwiLHRhZ0NsYXNzOnMuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6cy5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLG9wdGlvbmFsOiEwLGNhcHR1cmVBc24xOlwicnNhUHVibGljS2V5XCJ9XX1dfSxkPWZ1bmN0aW9uKGUpe3ZhciB0O2lmKCEoZS5hbGdvcml0aG0gaW4gdS5vaWRzKSl7dmFyIHI9bmV3IEVycm9yKFwiVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0uXCIpO3Rocm93IHIuYWxnb3JpdGhtPWUuYWxnb3JpdGhtLHJ9dD11Lm9pZHNbZS5hbGdvcml0aG1dO3ZhciBuPXMub2lkVG9EZXIodCkuZ2V0Qnl0ZXMoKSxpPXMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5TRVFVRU5DRSwhMCxbXSksYT1zLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuU0VRVUVOQ0UsITAsW10pO2EudmFsdWUucHVzaChzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuT0lELCExLG4pKSxhLnZhbHVlLnB1c2gocy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLk5VTEwsITEsXCJcIikpO3ZhciBvPXMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5PQ1RFVFNUUklORywhMSxlLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO3JldHVybiBpLnZhbHVlLnB1c2goYSksaS52YWx1ZS5wdXNoKG8pLHMudG9EZXIoaSkuZ2V0Qnl0ZXMoKX0seT1mdW5jdGlvbihlLHQscil7aWYocilyZXR1cm4gZS5tb2RQb3codC5lLHQubik7aWYoIXQucHx8IXQucSlyZXR1cm4gZS5tb2RQb3codC5kLHQubik7dmFyIGE7dC5kUHx8KHQuZFA9dC5kLm1vZCh0LnAuc3VidHJhY3QoaS5PTkUpKSksdC5kUXx8KHQuZFE9dC5kLm1vZCh0LnEuc3VidHJhY3QoaS5PTkUpKSksdC5xSW52fHwodC5xSW52PXQucS5tb2RJbnZlcnNlKHQucCkpO2Rve2E9bmV3IGkobi51dGlsLmJ5dGVzVG9IZXgobi5yYW5kb20uZ2V0Qnl0ZXModC5uLmJpdExlbmd0aCgpLzgpKSwxNil9d2hpbGUoYS5jb21wYXJlVG8odC5uKT49MHx8IWEuZ2NkKHQubikuZXF1YWxzKGkuT05FKSk7Zm9yKHZhciBzPShlPWUubXVsdGlwbHkoYS5tb2RQb3codC5lLHQubikpLm1vZCh0Lm4pKS5tb2QodC5wKS5tb2RQb3codC5kUCx0LnApLG89ZS5tb2QodC5xKS5tb2RQb3codC5kUSx0LnEpO3MuY29tcGFyZVRvKG8pPDA7KXM9cy5hZGQodC5wKTt2YXIgdT1zLnN1YnRyYWN0KG8pLm11bHRpcGx5KHQucUludikubW9kKHQucCkubXVsdGlwbHkodC5xKS5hZGQobyk7cmV0dXJuIHU9dS5tdWx0aXBseShhLm1vZEludmVyc2UodC5uKSkubW9kKHQubil9O2Z1bmN0aW9uIGcoZSx0LHIpe3ZhciBpPW4udXRpbC5jcmVhdGVCdWZmZXIoKSxhPU1hdGguY2VpbCh0Lm4uYml0TGVuZ3RoKCkvOCk7aWYoZS5sZW5ndGg+YS0xMSl7dmFyIHM9bmV3IEVycm9yKFwiTWVzc2FnZSBpcyB0b28gbG9uZyBmb3IgUEtDUyMxIHYxLjUgcGFkZGluZy5cIik7dGhyb3cgcy5sZW5ndGg9ZS5sZW5ndGgscy5tYXg9YS0xMSxzfWkucHV0Qnl0ZSgwKSxpLnB1dEJ5dGUocik7dmFyIG8sdT1hLTMtZS5sZW5ndGg7aWYoMD09PXJ8fDE9PT1yKXtvPTA9PT1yPzA6MjU1O2Zvcih2YXIgYz0wO2M8dTsrK2MpaS5wdXRCeXRlKG8pfWVsc2UgZm9yKDt1PjA7KXt2YXIgbD0wLGY9bi5yYW5kb20uZ2V0Qnl0ZXModSk7Zm9yKGM9MDtjPHU7KytjKTA9PT0obz1mLmNoYXJDb2RlQXQoYykpPysrbDppLnB1dEJ5dGUobyk7dT1sfXJldHVybiBpLnB1dEJ5dGUoMCksaS5wdXRCeXRlcyhlKSxpfWZ1bmN0aW9uIG0oZSx0LHIsaSl7dmFyIGE9TWF0aC5jZWlsKHQubi5iaXRMZW5ndGgoKS84KSxzPW4udXRpbC5jcmVhdGVCdWZmZXIoZSksbz1zLmdldEJ5dGUoKSx1PXMuZ2V0Qnl0ZSgpO2lmKDAhPT1vfHxyJiYwIT09dSYmMSE9PXV8fCFyJiYyIT11fHxyJiYwPT09dSYmdm9pZCAwPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0aW9uIGJsb2NrIGlzIGludmFsaWQuXCIpO3ZhciBjPTA7aWYoMD09PXUpe2M9YS0zLWk7Zm9yKHZhciBsPTA7bDxjOysrbClpZigwIT09cy5nZXRCeXRlKCkpdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBibG9jayBpcyBpbnZhbGlkLlwiKX1lbHNlIGlmKDE9PT11KWZvcihjPTA7cy5sZW5ndGgoKT4xOyl7aWYoMjU1IT09cy5nZXRCeXRlKCkpey0tcy5yZWFkO2JyZWFrfSsrY31lbHNlIGlmKDI9PT11KWZvcihjPTA7cy5sZW5ndGgoKT4xOyl7aWYoMD09PXMuZ2V0Qnl0ZSgpKXstLXMucmVhZDticmVha30rK2N9aWYoMCE9PXMuZ2V0Qnl0ZSgpfHxjIT09YS0zLXMubGVuZ3RoKCkpdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGlvbiBibG9jayBpcyBpbnZhbGlkLlwiKTtyZXR1cm4gcy5nZXRCeXRlcygpfWZ1bmN0aW9uIHYoZSx0LHIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihyPXQsdD17fSk7dmFyIGE9e2FsZ29yaXRobTp7bmFtZToodD10fHx7fSkuYWxnb3JpdGhtfHxcIlBSSU1FSU5DXCIsb3B0aW9uczp7d29ya2Vyczp0LndvcmtlcnN8fDIsd29ya0xvYWQ6dC53b3JrTG9hZHx8MTAwLHdvcmtlclNjcmlwdDp0LndvcmtlclNjcmlwdH19fTtmdW5jdGlvbiBzKCl7byhlLnBCaXRzLChmdW5jdGlvbih0LG4pe3JldHVybiB0P3IodCk6KGUucD1uLG51bGwhPT1lLnE/Yyh0LGUucSk6dm9pZCBvKGUucUJpdHMsYykpfSkpfWZ1bmN0aW9uIG8oZSx0KXtuLnByaW1lLmdlbmVyYXRlUHJvYmFibGVQcmltZShlLGEsdCl9ZnVuY3Rpb24gYyh0LG4pe2lmKHQpcmV0dXJuIHIodCk7aWYoZS5xPW4sZS5wLmNvbXBhcmVUbyhlLnEpPDApe3ZhciBhPWUucDtlLnA9ZS5xLGUucT1hfWlmKDAhPT1lLnAuc3VidHJhY3QoaS5PTkUpLmdjZChlLmUpLmNvbXBhcmVUbyhpLk9ORSkpcmV0dXJuIGUucD1udWxsLHZvaWQgcygpO2lmKDAhPT1lLnEuc3VidHJhY3QoaS5PTkUpLmdjZChlLmUpLmNvbXBhcmVUbyhpLk9ORSkpcmV0dXJuIGUucT1udWxsLHZvaWQgbyhlLnFCaXRzLGMpO2lmKGUucDE9ZS5wLnN1YnRyYWN0KGkuT05FKSxlLnExPWUucS5zdWJ0cmFjdChpLk9ORSksZS5waGk9ZS5wMS5tdWx0aXBseShlLnExKSwwIT09ZS5waGkuZ2NkKGUuZSkuY29tcGFyZVRvKGkuT05FKSlyZXR1cm4gZS5wPWUucT1udWxsLHZvaWQgcygpO2lmKGUubj1lLnAubXVsdGlwbHkoZS5xKSxlLm4uYml0TGVuZ3RoKCkhPT1lLmJpdHMpcmV0dXJuIGUucT1udWxsLHZvaWQgbyhlLnFCaXRzLGMpO3ZhciBsPWUuZS5tb2RJbnZlcnNlKGUucGhpKTtlLmtleXM9e3ByaXZhdGVLZXk6dS5yc2Euc2V0UHJpdmF0ZUtleShlLm4sZS5lLGwsZS5wLGUucSxsLm1vZChlLnAxKSxsLm1vZChlLnExKSxlLnEubW9kSW52ZXJzZShlLnApKSxwdWJsaWNLZXk6dS5yc2Euc2V0UHVibGljS2V5KGUubixlLmUpfSxyKG51bGwsZS5rZXlzKX1cInBybmdcImluIHQmJihhLnBybmc9dC5wcm5nKSxzKCl9ZnVuY3Rpb24gYihlKXt2YXIgdD1lLnRvU3RyaW5nKDE2KTt0WzBdPj1cIjhcIiYmKHQ9XCIwMFwiK3QpO3ZhciByPW4udXRpbC5oZXhUb0J5dGVzKHQpO3JldHVybiByLmxlbmd0aD4xJiYoMD09PXIuY2hhckNvZGVBdCgwKSYmMD09KDEyOCZyLmNoYXJDb2RlQXQoMSkpfHwyNTU9PT1yLmNoYXJDb2RlQXQoMCkmJjEyOD09KDEyOCZyLmNoYXJDb2RlQXQoMSkpKT9yLnN1YnN0cigxKTpyfWZ1bmN0aW9uIEUoZSl7cmV0dXJuIGU8PTEwMD8yNzplPD0xNTA/MTg6ZTw9MjAwPzE1OmU8PTI1MD8xMjplPD0zMDA/OTplPD0zNTA/ODplPD00MDA/NzplPD01MDA/NjplPD02MDA/NTplPD04MDA/NDplPD0xMjUwPzM6Mn1mdW5jdGlvbiBTKGUpe3JldHVybiBuLnV0aWwuaXNOb2RlanMmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGFbZV19ZnVuY3Rpb24gVChlKXtyZXR1cm4gdm9pZCAwIT09by5nbG9iYWxTY29wZSYmXCJvYmplY3RcIj09dHlwZW9mIG8uZ2xvYmFsU2NvcGUuY3J5cHRvJiZcIm9iamVjdFwiPT10eXBlb2Ygby5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGVbZV19ZnVuY3Rpb24gQyhlKXtyZXR1cm4gdm9pZCAwIT09by5nbG9iYWxTY29wZSYmXCJvYmplY3RcIj09dHlwZW9mIG8uZ2xvYmFsU2NvcGUubXNDcnlwdG8mJlwib2JqZWN0XCI9PXR5cGVvZiBvLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZSYmXCJmdW5jdGlvblwiPT10eXBlb2Ygby5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGVbZV19ZnVuY3Rpb24gQShlKXtmb3IodmFyIHQ9bi51dGlsLmhleFRvQnl0ZXMoZS50b1N0cmluZygxNikpLHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLGk9MDtpPHQubGVuZ3RoOysraSlyW2ldPXQuY2hhckNvZGVBdChpKTtyZXR1cm4gcn11LnJzYS5lbmNyeXB0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgYSxzPXIsbz1NYXRoLmNlaWwodC5uLmJpdExlbmd0aCgpLzgpOyExIT09ciYmITAhPT1yPyhzPTI9PT1yLGE9ZyhlLHQscikpOihhPW4udXRpbC5jcmVhdGVCdWZmZXIoKSkucHV0Qnl0ZXMoZSk7Zm9yKHZhciB1PW5ldyBpKGEudG9IZXgoKSwxNiksYz15KHUsdCxzKS50b1N0cmluZygxNiksbD1uLnV0aWwuY3JlYXRlQnVmZmVyKCksZj1vLU1hdGguY2VpbChjLmxlbmd0aC8yKTtmPjA7KWwucHV0Qnl0ZSgwKSwtLWY7cmV0dXJuIGwucHV0Qnl0ZXMobi51dGlsLmhleFRvQnl0ZXMoYykpLGwuZ2V0Qnl0ZXMoKX0sdS5yc2EuZGVjcnlwdD1mdW5jdGlvbihlLHQscixhKXt2YXIgcz1NYXRoLmNlaWwodC5uLmJpdExlbmd0aCgpLzgpO2lmKGUubGVuZ3RoIT09cyl7dmFyIG89bmV3IEVycm9yKFwiRW5jcnlwdGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuXCIpO3Rocm93IG8ubGVuZ3RoPWUubGVuZ3RoLG8uZXhwZWN0ZWQ9cyxvfXZhciB1PW5ldyBpKG4udXRpbC5jcmVhdGVCdWZmZXIoZSkudG9IZXgoKSwxNik7aWYodS5jb21wYXJlVG8odC5uKT49MCl0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgbWVzc2FnZSBpcyBpbnZhbGlkLlwiKTtmb3IodmFyIGM9eSh1LHQscikudG9TdHJpbmcoMTYpLGw9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLGY9cy1NYXRoLmNlaWwoYy5sZW5ndGgvMik7Zj4wOylsLnB1dEJ5dGUoMCksLS1mO3JldHVybiBsLnB1dEJ5dGVzKG4udXRpbC5oZXhUb0J5dGVzKGMpKSwhMSE9PWE/bShsLmdldEJ5dGVzKCksdCxyKTpsLmdldEJ5dGVzKCl9LHUucnNhLmNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGU9ZnVuY3Rpb24oZSx0LHIpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1wYXJzZUludChlLDEwKSksZT1lfHwyMDQ4O3ZhciBhLHM9KHI9cnx8e30pLnBybmd8fG4ucmFuZG9tLG89e25leHRCeXRlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9cy5nZXRCeXRlc1N5bmMoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcillW3JdPXQuY2hhckNvZGVBdChyKX19LHU9ci5hbGdvcml0aG18fFwiUFJJTUVJTkNcIjtpZihcIlBSSU1FSU5DXCIhPT11KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IGdlbmVyYXRpb24gYWxnb3JpdGhtOiBcIit1KTtyZXR1cm4oYT17YWxnb3JpdGhtOnUsc3RhdGU6MCxiaXRzOmUscm5nOm8sZUludDp0fHw2NTUzNyxlOm5ldyBpKG51bGwpLHA6bnVsbCxxOm51bGwscUJpdHM6ZT4+MSxwQml0czplLShlPj4xKSxwcVN0YXRlOjAsbnVtOm51bGwsa2V5czpudWxsfSkuZS5mcm9tSW50KGEuZUludCksYX0sdS5yc2Euc3RlcEtleVBhaXJHZW5lcmF0aW9uU3RhdGU9ZnVuY3Rpb24oZSx0KXtcImFsZ29yaXRobVwiaW4gZXx8KGUuYWxnb3JpdGhtPVwiUFJJTUVJTkNcIik7dmFyIHI9bmV3IGkobnVsbCk7ci5mcm9tSW50KDMwKTtmb3IodmFyIG4sYT0wLHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZXx0fSxvPStuZXcgRGF0ZSxsPTA7bnVsbD09PWUua2V5cyYmKHQ8PTB8fGw8dCk7KXtpZigwPT09ZS5zdGF0ZSl7dmFyIGY9bnVsbD09PWUucD9lLnBCaXRzOmUucUJpdHMsaD1mLTE7MD09PWUucHFTdGF0ZT8oZS5udW09bmV3IGkoZixlLnJuZyksZS5udW0udGVzdEJpdChoKXx8ZS5udW0uYml0d2lzZVRvKGkuT05FLnNoaWZ0TGVmdChoKSxzLGUubnVtKSxlLm51bS5kQWRkT2Zmc2V0KDMxLWUubnVtLm1vZChyKS5ieXRlVmFsdWUoKSwwKSxhPTAsKytlLnBxU3RhdGUpOjE9PT1lLnBxU3RhdGU/ZS5udW0uYml0TGVuZ3RoKCk+Zj9lLnBxU3RhdGU9MDplLm51bS5pc1Byb2JhYmxlUHJpbWUoRShlLm51bS5iaXRMZW5ndGgoKSkpPysrZS5wcVN0YXRlOmUubnVtLmRBZGRPZmZzZXQoY1thKyslOF0sMCk6Mj09PWUucHFTdGF0ZT9lLnBxU3RhdGU9MD09PWUubnVtLnN1YnRyYWN0KGkuT05FKS5nY2QoZS5lKS5jb21wYXJlVG8oaS5PTkUpPzM6MDozPT09ZS5wcVN0YXRlJiYoZS5wcVN0YXRlPTAsbnVsbD09PWUucD9lLnA9ZS5udW06ZS5xPWUubnVtLG51bGwhPT1lLnAmJm51bGwhPT1lLnEmJisrZS5zdGF0ZSxlLm51bT1udWxsKX1lbHNlIGlmKDE9PT1lLnN0YXRlKWUucC5jb21wYXJlVG8oZS5xKTwwJiYoZS5udW09ZS5wLGUucD1lLnEsZS5xPWUubnVtKSwrK2Uuc3RhdGU7ZWxzZSBpZigyPT09ZS5zdGF0ZSllLnAxPWUucC5zdWJ0cmFjdChpLk9ORSksZS5xMT1lLnEuc3VidHJhY3QoaS5PTkUpLGUucGhpPWUucDEubXVsdGlwbHkoZS5xMSksKytlLnN0YXRlO2Vsc2UgaWYoMz09PWUuc3RhdGUpMD09PWUucGhpLmdjZChlLmUpLmNvbXBhcmVUbyhpLk9ORSk/KytlLnN0YXRlOihlLnA9bnVsbCxlLnE9bnVsbCxlLnN0YXRlPTApO2Vsc2UgaWYoND09PWUuc3RhdGUpZS5uPWUucC5tdWx0aXBseShlLnEpLGUubi5iaXRMZW5ndGgoKT09PWUuYml0cz8rK2Uuc3RhdGU6KGUucT1udWxsLGUuc3RhdGU9MCk7ZWxzZSBpZig1PT09ZS5zdGF0ZSl7dmFyIHA9ZS5lLm1vZEludmVyc2UoZS5waGkpO2Uua2V5cz17cHJpdmF0ZUtleTp1LnJzYS5zZXRQcml2YXRlS2V5KGUubixlLmUscCxlLnAsZS5xLHAubW9kKGUucDEpLHAubW9kKGUucTEpLGUucS5tb2RJbnZlcnNlKGUucCkpLHB1YmxpY0tleTp1LnJzYS5zZXRQdWJsaWNLZXkoZS5uLGUuZSl9fWwrPShuPStuZXcgRGF0ZSktbyxvPW59cmV0dXJuIG51bGwhPT1lLmtleXN9LHUucnNhLmdlbmVyYXRlS2V5UGFpcj1mdW5jdGlvbihlLHQscixpKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aD9cIm9iamVjdFwiPT10eXBlb2YgZT8ocj1lLGU9dm9pZCAwKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYoaT1lLGU9dm9pZCAwKToyPT09YXJndW1lbnRzLmxlbmd0aD9cIm51bWJlclwiPT10eXBlb2YgZT9cImZ1bmN0aW9uXCI9PXR5cGVvZiB0PyhpPXQsdD12b2lkIDApOlwibnVtYmVyXCIhPXR5cGVvZiB0JiYocj10LHQ9dm9pZCAwKToocj1lLGk9dCxlPXZvaWQgMCx0PXZvaWQgMCk6Mz09PWFyZ3VtZW50cy5sZW5ndGgmJihcIm51bWJlclwiPT10eXBlb2YgdD9cImZ1bmN0aW9uXCI9PXR5cGVvZiByJiYoaT1yLHI9dm9pZCAwKTooaT1yLHI9dCx0PXZvaWQgMCkpLHI9cnx8e30sdm9pZCAwPT09ZSYmKGU9ci5iaXRzfHwyMDQ4KSx2b2lkIDA9PT10JiYodD1yLmV8fDY1NTM3KSwhbi5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0JiYhci5wcm5nJiZlPj0yNTYmJmU8PTE2Mzg0JiYoNjU1Mzc9PT10fHwzPT09dCkpaWYoaSl7aWYoUyhcImdlbmVyYXRlS2V5UGFpclwiKSlyZXR1cm4gYS5nZW5lcmF0ZUtleVBhaXIoXCJyc2FcIix7bW9kdWx1c0xlbmd0aDplLHB1YmxpY0V4cG9uZW50OnQscHVibGljS2V5RW5jb2Rpbmc6e3R5cGU6XCJzcGtpXCIsZm9ybWF0OlwicGVtXCJ9LHByaXZhdGVLZXlFbmNvZGluZzp7dHlwZTpcInBrY3M4XCIsZm9ybWF0OlwicGVtXCJ9fSwoZnVuY3Rpb24oZSx0LHIpe2lmKGUpcmV0dXJuIGkoZSk7aShudWxsLHtwcml2YXRlS2V5OnUucHJpdmF0ZUtleUZyb21QZW0ocikscHVibGljS2V5OnUucHVibGljS2V5RnJvbVBlbSh0KX0pfSkpO2lmKFQoXCJnZW5lcmF0ZUtleVwiKSYmVChcImV4cG9ydEtleVwiKSlyZXR1cm4gby5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtuYW1lOlwiUlNBU1NBLVBLQ1MxLXYxXzVcIixtb2R1bHVzTGVuZ3RoOmUscHVibGljRXhwb25lbnQ6QSh0KSxoYXNoOntuYW1lOlwiU0hBLTI1NlwifX0sITAsW1wic2lnblwiLFwidmVyaWZ5XCJdKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gby5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInBrY3M4XCIsZS5wcml2YXRlS2V5KX0pKS50aGVuKHZvaWQgMCwoZnVuY3Rpb24oZSl7aShlKX0pKS50aGVuKChmdW5jdGlvbihlKXtpZihlKXt2YXIgdD11LnByaXZhdGVLZXlGcm9tQXNuMShzLmZyb21EZXIobi51dGlsLmNyZWF0ZUJ1ZmZlcihlKSkpO2kobnVsbCx7cHJpdmF0ZUtleTp0LHB1YmxpY0tleTp1LnNldFJzYVB1YmxpY0tleSh0Lm4sdC5lKX0pfX0pKTtpZihDKFwiZ2VuZXJhdGVLZXlcIikmJkMoXCJleHBvcnRLZXlcIikpe3ZhciBjPW8uZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtuYW1lOlwiUlNBU1NBLVBLQ1MxLXYxXzVcIixtb2R1bHVzTGVuZ3RoOmUscHVibGljRXhwb25lbnQ6QSh0KSxoYXNoOntuYW1lOlwiU0hBLTI1NlwifX0sITAsW1wic2lnblwiLFwidmVyaWZ5XCJdKTtyZXR1cm4gYy5vbmNvbXBsZXRlPWZ1bmN0aW9uKGUpe3ZhciB0PWUudGFyZ2V0LnJlc3VsdCxyPW8uZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmV4cG9ydEtleShcInBrY3M4XCIsdC5wcml2YXRlS2V5KTtyLm9uY29tcGxldGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50YXJnZXQucmVzdWx0LHI9dS5wcml2YXRlS2V5RnJvbUFzbjEocy5mcm9tRGVyKG4udXRpbC5jcmVhdGVCdWZmZXIodCkpKTtpKG51bGwse3ByaXZhdGVLZXk6cixwdWJsaWNLZXk6dS5zZXRSc2FQdWJsaWNLZXkoci5uLHIuZSl9KX0sci5vbmVycm9yPWZ1bmN0aW9uKGUpe2koZSl9fSx2b2lkKGMub25lcnJvcj1mdW5jdGlvbihlKXtpKGUpfSl9fWVsc2UgaWYoUyhcImdlbmVyYXRlS2V5UGFpclN5bmNcIikpe3ZhciBsPWEuZ2VuZXJhdGVLZXlQYWlyU3luYyhcInJzYVwiLHttb2R1bHVzTGVuZ3RoOmUscHVibGljRXhwb25lbnQ6dCxwdWJsaWNLZXlFbmNvZGluZzp7dHlwZTpcInNwa2lcIixmb3JtYXQ6XCJwZW1cIn0scHJpdmF0ZUtleUVuY29kaW5nOnt0eXBlOlwicGtjczhcIixmb3JtYXQ6XCJwZW1cIn19KTtyZXR1cm57cHJpdmF0ZUtleTp1LnByaXZhdGVLZXlGcm9tUGVtKGwucHJpdmF0ZUtleSkscHVibGljS2V5OnUucHVibGljS2V5RnJvbVBlbShsLnB1YmxpY0tleSl9fXZhciBmPXUucnNhLmNyZWF0ZUtleVBhaXJHZW5lcmF0aW9uU3RhdGUoZSx0LHIpO2lmKCFpKXJldHVybiB1LnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZShmLDApLGYua2V5czt2KGYscixpKX0sdS5zZXRSc2FQdWJsaWNLZXk9dS5yc2Euc2V0UHVibGljS2V5PWZ1bmN0aW9uKGUsdCl7dmFyIHI9e246ZSxlOnQsZW5jcnlwdDpmdW5jdGlvbihlLHQsaSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQ/dD10LnRvVXBwZXJDYXNlKCk6dm9pZCAwPT09dCYmKHQ9XCJSU0FFUy1QS0NTMS1WMV81XCIpLFwiUlNBRVMtUEtDUzEtVjFfNVwiPT09dCl0PXtlbmNvZGU6ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBnKGUsdCwyKS5nZXRCeXRlcygpfX07ZWxzZSBpZihcIlJTQS1PQUVQXCI9PT10fHxcIlJTQUVTLU9BRVBcIj09PXQpdD17ZW5jb2RlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4ucGtjczEuZW5jb2RlX3JzYV9vYWVwKHQsZSxpKX19O2Vsc2UgaWYoLTEhPT1bXCJSQVdcIixcIk5PTkVcIixcIk5VTExcIixudWxsXS5pbmRleE9mKHQpKXQ9e2VuY29kZTpmdW5jdGlvbihlKXtyZXR1cm4gZX19O2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInK3QrJ1wiLicpO3ZhciBhPXQuZW5jb2RlKGUsciwhMCk7cmV0dXJuIHUucnNhLmVuY3J5cHQoYSxyLCEwKX0sdmVyaWZ5OmZ1bmN0aW9uKGUsdCxuKXtcInN0cmluZ1wiPT10eXBlb2Ygbj9uPW4udG9VcHBlckNhc2UoKTp2b2lkIDA9PT1uJiYobj1cIlJTQVNTQS1QS0NTMS1WMV81XCIpLFwiUlNBU1NBLVBLQ1MxLVYxXzVcIj09PW4/bj17dmVyaWZ5OmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9bSh0LHIsITApLGU9PT1zLmZyb21EZXIodCkudmFsdWVbMV0udmFsdWV9fTpcIk5PTkVcIiE9PW4mJlwiTlVMTFwiIT09biYmbnVsbCE9PW58fChuPXt2ZXJpZnk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PSh0PW0odCxyLCEwKSl9fSk7dmFyIGk9dS5yc2EuZGVjcnlwdCh0LHIsITAsITEpO3JldHVybiBuLnZlcmlmeShlLGksci5uLmJpdExlbmd0aCgpKX19O3JldHVybiByfSx1LnNldFJzYVByaXZhdGVLZXk9dS5yc2Euc2V0UHJpdmF0ZUtleT1mdW5jdGlvbihlLHQscixpLGEscyxvLGMpe3ZhciBsPXtuOmUsZTp0LGQ6cixwOmkscTphLGRQOnMsZFE6byxxSW52OmMsZGVjcnlwdDpmdW5jdGlvbihlLHQscil7XCJzdHJpbmdcIj09dHlwZW9mIHQ/dD10LnRvVXBwZXJDYXNlKCk6dm9pZCAwPT09dCYmKHQ9XCJSU0FFUy1QS0NTMS1WMV81XCIpO3ZhciBpPXUucnNhLmRlY3J5cHQoZSxsLCExLCExKTtpZihcIlJTQUVTLVBLQ1MxLVYxXzVcIj09PXQpdD17ZGVjb2RlOm19O2Vsc2UgaWYoXCJSU0EtT0FFUFwiPT09dHx8XCJSU0FFUy1PQUVQXCI9PT10KXQ9e2RlY29kZTpmdW5jdGlvbihlLHQpe3JldHVybiBuLnBrY3MxLmRlY29kZV9yc2Ffb2FlcCh0LGUscil9fTtlbHNle2lmKC0xPT09W1wiUkFXXCIsXCJOT05FXCIsXCJOVUxMXCIsbnVsbF0uaW5kZXhPZih0KSl0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lOiBcIicrdCsnXCIuJyk7dD17ZGVjb2RlOmZ1bmN0aW9uKGUpe3JldHVybiBlfX19cmV0dXJuIHQuZGVjb2RlKGksbCwhMSl9LHNpZ246ZnVuY3Rpb24oZSx0KXt2YXIgcj0hMTtcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9dC50b1VwcGVyQ2FzZSgpKSx2b2lkIDA9PT10fHxcIlJTQVNTQS1QS0NTMS1WMV81XCI9PT10Pyh0PXtlbmNvZGU6ZH0scj0xKTpcIk5PTkVcIiE9PXQmJlwiTlVMTFwiIT09dCYmbnVsbCE9PXR8fCh0PXtlbmNvZGU6ZnVuY3Rpb24oKXtyZXR1cm4gZX19LHI9MSk7dmFyIG49dC5lbmNvZGUoZSxsLm4uYml0TGVuZ3RoKCkpO3JldHVybiB1LnJzYS5lbmNyeXB0KG4sbCxyKX19O3JldHVybiBsfSx1LndyYXBSc2FQcml2YXRlS2V5PWZ1bmN0aW9uKGUpe3JldHVybiBzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuU0VRVUVOQ0UsITAsW3MuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLHMuaW50ZWdlclRvRGVyKDApLmdldEJ5dGVzKCkpLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5TRVFVRU5DRSwhMCxbcy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLk9JRCwhMSxzLm9pZFRvRGVyKHUub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuTlVMTCwhMSxcIlwiKV0pLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5PQ1RFVFNUUklORywhMSxzLnRvRGVyKGUpLmdldEJ5dGVzKCkpXSl9LHUucHJpdmF0ZUtleUZyb21Bc24xPWZ1bmN0aW9uKGUpe3ZhciB0LHIsYSxvLGMsaCxwLGQseT17fSxnPVtdO2lmKHMudmFsaWRhdGUoZSxsLHksZykmJihlPXMuZnJvbURlcihuLnV0aWwuY3JlYXRlQnVmZmVyKHkucHJpdmF0ZUtleSkpKSx5PXt9LGc9W10sIXMudmFsaWRhdGUoZSxmLHksZykpe3ZhciBtPW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUga2V5LiBBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQcml2YXRlS2V5LlwiKTt0aHJvdyBtLmVycm9ycz1nLG19cmV0dXJuIHQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcih5LnByaXZhdGVLZXlNb2R1bHVzKS50b0hleCgpLHI9bi51dGlsLmNyZWF0ZUJ1ZmZlcih5LnByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCkudG9IZXgoKSxhPW4udXRpbC5jcmVhdGVCdWZmZXIoeS5wcml2YXRlS2V5UHJpdmF0ZUV4cG9uZW50KS50b0hleCgpLG89bi51dGlsLmNyZWF0ZUJ1ZmZlcih5LnByaXZhdGVLZXlQcmltZTEpLnRvSGV4KCksYz1uLnV0aWwuY3JlYXRlQnVmZmVyKHkucHJpdmF0ZUtleVByaW1lMikudG9IZXgoKSxoPW4udXRpbC5jcmVhdGVCdWZmZXIoeS5wcml2YXRlS2V5RXhwb25lbnQxKS50b0hleCgpLHA9bi51dGlsLmNyZWF0ZUJ1ZmZlcih5LnByaXZhdGVLZXlFeHBvbmVudDIpLnRvSGV4KCksZD1uLnV0aWwuY3JlYXRlQnVmZmVyKHkucHJpdmF0ZUtleUNvZWZmaWNpZW50KS50b0hleCgpLHUuc2V0UnNhUHJpdmF0ZUtleShuZXcgaSh0LDE2KSxuZXcgaShyLDE2KSxuZXcgaShhLDE2KSxuZXcgaShvLDE2KSxuZXcgaShjLDE2KSxuZXcgaShoLDE2KSxuZXcgaShwLDE2KSxuZXcgaShkLDE2KSl9LHUucHJpdmF0ZUtleVRvQXNuMT11LnByaXZhdGVLZXlUb1JTQVByaXZhdGVLZXk9ZnVuY3Rpb24oZSl7cmV0dXJuIHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5TRVFVRU5DRSwhMCxbcy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLklOVEVHRVIsITEscy5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSkscy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLklOVEVHRVIsITEsYihlLm4pKSxzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuSU5URUdFUiwhMSxiKGUuZSkpLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLGIoZS5kKSkscy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLklOVEVHRVIsITEsYihlLnApKSxzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuSU5URUdFUiwhMSxiKGUucSkpLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLGIoZS5kUCkpLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLGIoZS5kUSkpLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLGIoZS5xSW52KSldKX0sdS5wdWJsaWNLZXlGcm9tQXNuMT1mdW5jdGlvbihlKXt2YXIgdD17fSxyPVtdO2lmKHMudmFsaWRhdGUoZSxwLHQscikpe3ZhciBhLG89cy5kZXJUb09pZCh0LnB1YmxpY0tleU9pZCk7aWYobyE9PXUub2lkcy5yc2FFbmNyeXB0aW9uKXRocm93KGE9bmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgcHVibGljIGtleS4gVW5rbm93biBPSUQuXCIpKS5vaWQ9byxhO2U9dC5yc2FQdWJsaWNLZXl9aWYocj1bXSwhcy52YWxpZGF0ZShlLGgsdCxyKSl0aHJvdyhhPW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHB1YmxpYyBrZXkuIEFTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVB1YmxpY0tleS5cIikpLmVycm9ycz1yLGE7dmFyIGM9bi51dGlsLmNyZWF0ZUJ1ZmZlcih0LnB1YmxpY0tleU1vZHVsdXMpLnRvSGV4KCksbD1uLnV0aWwuY3JlYXRlQnVmZmVyKHQucHVibGljS2V5RXhwb25lbnQpLnRvSGV4KCk7cmV0dXJuIHUuc2V0UnNhUHVibGljS2V5KG5ldyBpKGMsMTYpLG5ldyBpKGwsMTYpKX0sdS5wdWJsaWNLZXlUb0FzbjE9dS5wdWJsaWNLZXlUb1N1YmplY3RQdWJsaWNLZXlJbmZvPWZ1bmN0aW9uKGUpe3JldHVybiBzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuU0VRVUVOQ0UsITAsW3MuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5TRVFVRU5DRSwhMCxbcy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLk9JRCwhMSxzLm9pZFRvRGVyKHUub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuTlVMTCwhMSxcIlwiKV0pLHMuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5CSVRTVFJJTkcsITEsW3UucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoZSldKV0pfSx1LnB1YmxpY0tleVRvUlNBUHVibGljS2V5PWZ1bmN0aW9uKGUpe3JldHVybiBzLmNyZWF0ZShzLkNsYXNzLlVOSVZFUlNBTCxzLlR5cGUuU0VRVUVOQ0UsITAsW3MuY3JlYXRlKHMuQ2xhc3MuVU5JVkVSU0FMLHMuVHlwZS5JTlRFR0VSLCExLGIoZS5uKSkscy5jcmVhdGUocy5DbGFzcy5VTklWRVJTQUwscy5UeXBlLklOVEVHRVIsITEsYihlLmUpKV0pfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cig2NSksaT1yKDI4KSxhPXIoMzYpLHM9cig2Nik7dC5lbXB0eT1VaW50OEFycmF5LmZyb20oW10pLHQuemVybz1VaW50OEFycmF5LmZyb20oWzBdKSx0Lm9uZT1VaW50OEFycmF5LmZyb20oWzFdKSx0LkJBU0U1OF9TVFJJTkc9ZT0+bi5kZWZhdWx0LmRlY29kZShlKSx0LkJBU0U2NF9TVFJJTkc9ZT0+aS50b0J5dGVBcnJheShlLnJlcGxhY2UoXCJiYXNlNjQ6XCIsXCJcIikpLHQuU1RSSU5HPWU9PmU/KGU9PlVpbnQ4QXJyYXkuZnJvbShbLi4udW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGUpKV0ubWFwKGU9PmUuY2hhckNvZGVBdCgwKSkpKShlKTp0LmVtcHR5LHQuQllURT1lPT5VaW50OEFycmF5LmZyb20oW2VdKSx0LkJPT0w9ZT0+dC5CWVRFKGU/MTowKSx0LkJZVEVTPWU9PlVpbnQ4QXJyYXkuZnJvbShlKSx0LlNIT1JUPWU9Pntjb25zdCB0PW5ldyBzLkJpZ051bWJlcihNYXRoLmZsb29yKGUpKS50b0J5dGVzKCk7cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShBcnJheS5mcm9tKHtsZW5ndGg6Mn0sKGUscik9PnRbci0yK3QubGVuZ3RoXXx8MCkpfSx0LklOVD1lPT57Y29uc3QgdD1uZXcgcy5CaWdOdW1iZXIoTWF0aC5mbG9vcihlKSkudG9CeXRlcygpO3JldHVybiBVaW50OEFycmF5LmZyb20oQXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChlLHIpPT50W3ItNCt0Lmxlbmd0aF18fDApKX0sdC5PUFRJT049ZT0+cj0+bnVsbD09cnx8XCJzdHJpbmdcIj09dHlwZW9mIHImJjA9PXIubGVuZ3RoP3QuemVybzphLmNvbmNhdCh0Lm9uZSxlKHIpKSx0LkxFTj1lPT50PT5yPT57Y29uc3Qgbj10KHIpLGk9ZShuLmxlbmd0aCk7cmV0dXJuIGEuY29uY2F0KGksbil9LHQuQ09VTlQ9ZT0+dD0+cj0+e2NvbnN0IG49YS5jb25jYXQoLi4uci5tYXAoZT0+dChlKSkpLGk9ZShyLmxlbmd0aCk7cmV0dXJuIGEuY29uY2F0KGksbil9LHQuTE9ORz1lPT57bGV0IHQ7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpe2lmKGU+TWF0aC5wb3coMiw1MyktMSl0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gaXMgdG9vIGJpZyB0byBiZSBwcmVjaXNlbHkgcmVwcmVzZW50ZWQgYXMganMgbnVtYmVyLiBVc2Ugc3RyaW5nIGluc3RlYWRgKTt0PW5ldyBzLkJpZ051bWJlcihNYXRoLmZsb29yKGUpKS50b0J5dGVzKCl9ZWxzZSB0PW5ldyBzLkJpZ051bWJlcihlKS50b0J5dGVzKCk7cmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShBcnJheS5mcm9tKHtsZW5ndGg6OH0sKGUscik9PnRbci04K3QubGVuZ3RoXXx8MCkpfSx0LlNDUklQVD1lPT50Lk9QVElPTih0LkxFTih0LlNIT1JUKSh0LkJBU0U2NF9TVFJJTkcpKShlP2Uuc2xpY2UoNyk6bnVsbCksdC5BTElBUz1lPT57Y29uc3RbcixuLGldPWUuc3BsaXQoXCI6XCIpO2lmKCFufHwxIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXR3b3JrIGJ5dGUgaW4gYWxpYXNcIik7aWYoIWl8fDA9PT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFsaWFzIGJvZHlcIik7cmV0dXJuIGEuY29uY2F0KFsyXSxbbi5jaGFyQ29kZUF0KDApXSx0LkxFTih0LlNIT1JUKSh0LlNUUklORykoaSkpfSx0LkFERFJFU1NfT1JfQUxJQVM9ZT0+ZS5zdGFydHNXaXRoKFwiYWxpYXNcIik/dC5BTElBUyhlKTp0LkJBU0U1OF9TVFJJTkcoZSl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDcpLGE9cig0KSxzPXIoMyksbz1yKDUpO3QubWFzc1RyYW5zZmVyPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1uLlRSQU5TQUNUSU9OX1RZUEUuTUFTU19UUkFOU0ZFUix1PWUudmVyc2lvbnx8MSxjPWkuY29udmVydFRvUGFpcnModCksbD1pLmdldFNlbmRlclB1YmxpY0tleShjLGUpO2lmKCFBcnJheS5pc0FycmF5KGUudHJhbnNmZXJzKSl0aHJvdyBuZXcgRXJyb3IoJ1tcInRyYW5zZmVycyBzaG91bGQgYmUgYXJyYXlcIl0nKTtjb25zdCBmPXt0eXBlOnIsdmVyc2lvbjp1LHNlbmRlclB1YmxpY0tleTpsLGFzc2V0SWQ6aS5ub3JtYWxpemVBc3NldElkKGUuYXNzZXRJZCksdHJhbnNmZXJzOmUudHJhbnNmZXJzLGZlZTppLmZlZShlLDFlNSsxZTUqTWF0aC5jZWlsKC41KmUudHJhbnNmZXJzLmxlbmd0aCkpLHRpbWVzdGFtcDplLnRpbWVzdGFtcHx8RGF0ZS5ub3coKSxhdHRhY2htZW50OmUuYXR0YWNobWVudHx8XCJcIixwcm9vZnM6ZS5wcm9vZnN8fFtdLGlkOlwiXCJ9O28udmFsaWRhdGUubWFzc1RyYW5zZmVyKGYpO2NvbnN0IGg9cy5iaW5hcnkuc2VyaWFsaXplVHgoZik7cmV0dXJuIGMuZm9yRWFjaCgoW2UsdF0pPT5pLmFkZFByb29mKGYsYS5zaWduQnl0ZXMoZSxoKSx0KSksZi5pZD1hLmJhc2U1OEVuY29kZShhLmJsYWtlMmIoaCkpLGZ9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5ieXRlTGVuZ3RoPWZ1bmN0aW9uKGUpe3ZhciB0PWMoZSkscj10WzBdLG49dFsxXTtyZXR1cm4gMyoocituKS80LW59LHQudG9CeXRlQXJyYXk9ZnVuY3Rpb24oZSl7dmFyIHQscixuPWMoZSkscz1uWzBdLG89blsxXSx1PW5ldyBhKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gMyoodCtyKS80LXJ9KDAscyxvKSksbD0wLGY9bz4wP3MtNDpzO2ZvcihyPTA7cjxmO3IrPTQpdD1pW2UuY2hhckNvZGVBdChyKV08PDE4fGlbZS5jaGFyQ29kZUF0KHIrMSldPDwxMnxpW2UuY2hhckNvZGVBdChyKzIpXTw8NnxpW2UuY2hhckNvZGVBdChyKzMpXSx1W2wrK109dD4+MTYmMjU1LHVbbCsrXT10Pj44JjI1NSx1W2wrK109MjU1JnQ7Mj09PW8mJih0PWlbZS5jaGFyQ29kZUF0KHIpXTw8MnxpW2UuY2hhckNvZGVBdChyKzEpXT4+NCx1W2wrK109MjU1JnQpOzE9PT1vJiYodD1pW2UuY2hhckNvZGVBdChyKV08PDEwfGlbZS5jaGFyQ29kZUF0KHIrMSldPDw0fGlbZS5jaGFyQ29kZUF0KHIrMildPj4yLHVbbCsrXT10Pj44JjI1NSx1W2wrK109MjU1JnQpO3JldHVybiB1fSx0LmZyb21CeXRlQXJyYXk9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9ZS5sZW5ndGgsaT1yJTMsYT1bXSxzPTAsbz1yLWk7czxvO3MrPTE2MzgzKWEucHVzaChsKGUscyxzKzE2MzgzPm8/bzpzKzE2MzgzKSk7MT09PWk/KHQ9ZVtyLTFdLGEucHVzaChuW3Q+PjJdK25bdDw8NCY2M10rXCI9PVwiKSk6Mj09PWkmJih0PShlW3ItMl08PDgpK2Vbci0xXSxhLnB1c2goblt0Pj4xMF0rblt0Pj40JjYzXStuW3Q8PDImNjNdK1wiPVwiKSk7cmV0dXJuIGEuam9pbihcIlwiKX07Zm9yKHZhciBuPVtdLGk9W10sYT1cInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDhBcnJheT9VaW50OEFycmF5OkFycmF5LHM9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsbz0wLHU9cy5sZW5ndGg7bzx1OysrbyluW29dPXNbb10saVtzLmNoYXJDb2RlQXQobyldPW87ZnVuY3Rpb24gYyhlKXt2YXIgdD1lLmxlbmd0aDtpZih0JTQ+MCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciByPWUuaW5kZXhPZihcIj1cIik7cmV0dXJuLTE9PT1yJiYocj10KSxbcixyPT09dD8wOjQtciU0XX1mdW5jdGlvbiBsKGUsdCxyKXtmb3IodmFyIGksYSxzPVtdLG89dDtvPHI7bys9MylpPShlW29dPDwxNiYxNjcxMTY4MCkrKGVbbysxXTw8OCY2NTI4MCkrKDI1NSZlW28rMl0pLHMucHVzaChuWyhhPWkpPj4xOCY2M10rblthPj4xMiY2M10rblthPj42JjYzXStuWzYzJmFdKTtyZXR1cm4gcy5qb2luKFwiXCIpfWlbXCItXCIuY2hhckNvZGVBdCgwKV09NjIsaVtcIl9cIi5jaGFyQ29kZUF0KDApXT02M30sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7ZnVuY3Rpb24gaShlLHQpe24uY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKGUsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuLmFlcy5BbGdvcml0aG0oZSx0KX0pKX1yKDMwKSxyKDUyKSxyKDIpLGUuZXhwb3J0cz1uLmFlcz1uLmFlc3x8e30sbi5hZXMuc3RhcnRFbmNyeXB0aW5nPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPXkoe2tleTplLG91dHB1dDpyLGRlY3J5cHQ6ITEsbW9kZTpufSk7cmV0dXJuIGkuc3RhcnQodCksaX0sbi5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcj1mdW5jdGlvbihlLHQpe3JldHVybiB5KHtrZXk6ZSxvdXRwdXQ6bnVsbCxkZWNyeXB0OiExLG1vZGU6dH0pfSxuLmFlcy5zdGFydERlY3J5cHRpbmc9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGk9eSh7a2V5OmUsb3V0cHV0OnIsZGVjcnlwdDohMCxtb2RlOm59KTtyZXR1cm4gaS5zdGFydCh0KSxpfSxuLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHkoe2tleTplLG91dHB1dDpudWxsLGRlY3J5cHQ6ITAsbW9kZTp0fSl9LG4uYWVzLkFsZ29yaXRobT1mdW5jdGlvbihlLHQpe2x8fGgoKTt2YXIgcj10aGlzO3IubmFtZT1lLHIubW9kZT1uZXcgdCh7YmxvY2tTaXplOjE2LGNpcGhlcjp7ZW5jcnlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBkKHIuX3csZSx0LCExKX0sZGVjcnlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBkKHIuX3csZSx0LCEwKX19fSksci5faW5pdD0hMX0sbi5hZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLl9pbml0KXt2YXIgdCxyPWUua2V5O2lmKFwic3RyaW5nXCIhPXR5cGVvZiByfHwxNiE9PXIubGVuZ3RoJiYyNCE9PXIubGVuZ3RoJiYzMiE9PXIubGVuZ3RoKXtpZihuLnV0aWwuaXNBcnJheShyKSYmKDE2PT09ci5sZW5ndGh8fDI0PT09ci5sZW5ndGh8fDMyPT09ci5sZW5ndGgpKXt0PXIscj1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDsrK2kpci5wdXRCeXRlKHRbaV0pfX1lbHNlIHI9bi51dGlsLmNyZWF0ZUJ1ZmZlcihyKTtpZighbi51dGlsLmlzQXJyYXkocikpe3Q9cixyPVtdO3ZhciBhPXQubGVuZ3RoKCk7aWYoMTY9PT1hfHwyND09PWF8fDMyPT09YSl7YT4+Pj0yO2ZvcihpPTA7aTxhOysraSlyLnB1c2godC5nZXRJbnQzMigpKX19aWYoIW4udXRpbC5pc0FycmF5KHIpfHw0IT09ci5sZW5ndGgmJjYhPT1yLmxlbmd0aCYmOCE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IHBhcmFtZXRlci5cIik7dmFyIHM9dGhpcy5tb2RlLm5hbWUsbz0tMSE9PVtcIkNGQlwiLFwiT0ZCXCIsXCJDVFJcIixcIkdDTVwiXS5pbmRleE9mKHMpO3RoaXMuX3c9cChyLGUuZGVjcnlwdCYmIW8pLHRoaXMuX2luaXQ9ITB9fSxuLmFlcy5fZXhwYW5kS2V5PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGx8fGgoKSxwKGUsdCl9LG4uYWVzLl91cGRhdGVCbG9jaz1kLGkoXCJBRVMtRUNCXCIsbi5jaXBoZXIubW9kZXMuZWNiKSxpKFwiQUVTLUNCQ1wiLG4uY2lwaGVyLm1vZGVzLmNiYyksaShcIkFFUy1DRkJcIixuLmNpcGhlci5tb2Rlcy5jZmIpLGkoXCJBRVMtT0ZCXCIsbi5jaXBoZXIubW9kZXMub2ZiKSxpKFwiQUVTLUNUUlwiLG4uY2lwaGVyLm1vZGVzLmN0ciksaShcIkFFUy1HQ01cIixuLmNpcGhlci5tb2Rlcy5nY20pO3ZhciBhLHMsbyx1LGMsbD0hMSxmPTQ7ZnVuY3Rpb24gaCgpe2w9ITAsbz1bMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NF07Zm9yKHZhciBlPW5ldyBBcnJheSgyNTYpLHQ9MDt0PDEyODsrK3QpZVt0XT10PDwxLGVbdCsxMjhdPXQrMTI4PDwxXjI4MzthPW5ldyBBcnJheSgyNTYpLHM9bmV3IEFycmF5KDI1NiksdT1uZXcgQXJyYXkoNCksYz1uZXcgQXJyYXkoNCk7Zm9yKHQ9MDt0PDQ7Kyt0KXVbdF09bmV3IEFycmF5KDI1NiksY1t0XT1uZXcgQXJyYXkoMjU2KTt2YXIgcixuLGksZixoLHAsZCx5PTAsZz0wO2Zvcih0PTA7dDwyNTY7Kyt0KXtmPShmPWdeZzw8MV5nPDwyXmc8PDNeZzw8NCk+PjheMjU1JmZeOTksYVt5XT1mLHNbZl09eSxwPShoPWVbZl0pPDwyNF5mPDwxNl5mPDw4XmZeaCxkPSgocj1lW3ldKV4obj1lW3JdKV4oaT1lW25dKSk8PDI0Xih5XmkpPDwxNl4oeV5uXmkpPDw4Xnlecl5pO2Zvcih2YXIgbT0wO208NDsrK20pdVttXVt5XT1wLGNbbV1bZl09ZCxwPXA8PDI0fHA+Pj44LGQ9ZDw8MjR8ZD4+Pjg7MD09PXk/eT1nPTE6KHk9cl5lW2VbZVtyXmldXV0sZ149ZVtlW2ddXSl9fWZ1bmN0aW9uIHAoZSx0KXtmb3IodmFyIHIsbj1lLnNsaWNlKDApLGk9MSxzPW4ubGVuZ3RoLHU9Zioocys2KzEpLGw9cztsPHU7KytsKXI9bltsLTFdLGwlcz09MD8ocj1hW3I+Pj4xNiYyNTVdPDwyNF5hW3I+Pj44JjI1NV08PDE2XmFbMjU1JnJdPDw4XmFbcj4+PjI0XV5vW2ldPDwyNCxpKyspOnM+NiYmbCVzPT00JiYocj1hW3I+Pj4yNF08PDI0XmFbcj4+PjE2JjI1NV08PDE2XmFbcj4+PjgmMjU1XTw8OF5hWzI1NSZyXSksbltsXT1uW2wtc11ecjtpZih0KXtmb3IodmFyIGgscD1jWzBdLGQ9Y1sxXSx5PWNbMl0sZz1jWzNdLG09bi5zbGljZSgwKSx2PShsPTAsKHU9bi5sZW5ndGgpLWYpO2w8dTtsKz1mLHYtPWYpaWYoMD09PWx8fGw9PT11LWYpbVtsXT1uW3ZdLG1bbCsxXT1uW3YrM10sbVtsKzJdPW5bdisyXSxtW2wrM109blt2KzFdO2Vsc2UgZm9yKHZhciBiPTA7YjxmOysrYiloPW5bditiXSxtW2wrKDMmLWIpXT1wW2FbaD4+PjI0XV1eZFthW2g+Pj4xNiYyNTVdXV55W2FbaD4+PjgmMjU1XV1eZ1thWzI1NSZoXV07bj1tfXJldHVybiBufWZ1bmN0aW9uIGQoZSx0LHIsbil7dmFyIGksbyxsLGYsaCxwLGQseSxnLG0sdixiLEU9ZS5sZW5ndGgvNC0xO24/KGk9Y1swXSxvPWNbMV0sbD1jWzJdLGY9Y1szXSxoPXMpOihpPXVbMF0sbz11WzFdLGw9dVsyXSxmPXVbM10saD1hKSxwPXRbMF1eZVswXSxkPXRbbj8zOjFdXmVbMV0seT10WzJdXmVbMl0sZz10W24/MTozXV5lWzNdO2Zvcih2YXIgUz0zLFQ9MTtUPEU7KytUKW09aVtwPj4+MjRdXm9bZD4+PjE2JjI1NV1ebFt5Pj4+OCYyNTVdXmZbMjU1JmddXmVbKytTXSx2PWlbZD4+PjI0XV5vW3k+Pj4xNiYyNTVdXmxbZz4+PjgmMjU1XV5mWzI1NSZwXV5lWysrU10sYj1pW3k+Pj4yNF1eb1tnPj4+MTYmMjU1XV5sW3A+Pj44JjI1NV1eZlsyNTUmZF1eZVsrK1NdLGc9aVtnPj4+MjRdXm9bcD4+PjE2JjI1NV1ebFtkPj4+OCYyNTVdXmZbMjU1JnldXmVbKytTXSxwPW0sZD12LHk9YjtyWzBdPWhbcD4+PjI0XTw8MjReaFtkPj4+MTYmMjU1XTw8MTZeaFt5Pj4+OCYyNTVdPDw4XmhbMjU1JmddXmVbKytTXSxyW24/MzoxXT1oW2Q+Pj4yNF08PDI0XmhbeT4+PjE2JjI1NV08PDE2XmhbZz4+PjgmMjU1XTw8OF5oWzI1NSZwXV5lWysrU10sclsyXT1oW3k+Pj4yNF08PDI0XmhbZz4+PjE2JjI1NV08PDE2XmhbcD4+PjgmMjU1XTw8OF5oWzI1NSZkXV5lWysrU10scltuPzE6M109aFtnPj4+MjRdPDwyNF5oW3A+Pj4xNiYyNTVdPDwxNl5oW2Q+Pj44JjI1NV08PDheaFsyNTUmeV1eZVsrK1NdfWZ1bmN0aW9uIHkoZSl7dmFyIHQscj1cIkFFUy1cIisoKGU9ZXx8e30pLm1vZGV8fFwiQ0JDXCIpLnRvVXBwZXJDYXNlKCksaT0odD1lLmRlY3J5cHQ/bi5jaXBoZXIuY3JlYXRlRGVjaXBoZXIocixlLmtleSk6bi5jaXBoZXIuY3JlYXRlQ2lwaGVyKHIsZS5rZXkpKS5zdGFydDtyZXR1cm4gdC5zdGFydD1mdW5jdGlvbihlLHIpe3ZhciBhPW51bGw7ciBpbnN0YW5jZW9mIG4udXRpbC5CeXRlQnVmZmVyJiYoYT1yLHI9e30pLChyPXJ8fHt9KS5vdXRwdXQ9YSxyLml2PWUsaS5jYWxsKHQscil9LHR9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDIpLGUuZXhwb3J0cz1uLmNpcGhlcj1uLmNpcGhlcnx8e30sbi5jaXBoZXIuYWxnb3JpdGhtcz1uLmNpcGhlci5hbGdvcml0aG1zfHx7fSxuLmNpcGhlci5jcmVhdGVDaXBoZXI9ZnVuY3Rpb24oZSx0KXt2YXIgcj1lO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByJiYocj1uLmNpcGhlci5nZXRBbGdvcml0aG0ocikpJiYocj1yKCkpLCFyKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIrZSk7cmV0dXJuIG5ldyBuLmNpcGhlci5CbG9ja0NpcGhlcih7YWxnb3JpdGhtOnIsa2V5OnQsZGVjcnlwdDohMX0pfSxuLmNpcGhlci5jcmVhdGVEZWNpcGhlcj1mdW5jdGlvbihlLHQpe3ZhciByPWU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJihyPW4uY2lwaGVyLmdldEFsZ29yaXRobShyKSkmJihyPXIoKSksIXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIitlKTtyZXR1cm4gbmV3IG4uY2lwaGVyLkJsb2NrQ2lwaGVyKHthbGdvcml0aG06cixrZXk6dCxkZWNyeXB0OiEwfSl9LG4uY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtPWZ1bmN0aW9uKGUsdCl7ZT1lLnRvVXBwZXJDYXNlKCksbi5jaXBoZXIuYWxnb3JpdGhtc1tlXT10fSxuLmNpcGhlci5nZXRBbGdvcml0aG09ZnVuY3Rpb24oZSl7cmV0dXJuKGU9ZS50b1VwcGVyQ2FzZSgpKWluIG4uY2lwaGVyLmFsZ29yaXRobXM/bi5jaXBoZXIuYWxnb3JpdGhtc1tlXTpudWxsfTt2YXIgaT1uLmNpcGhlci5CbG9ja0NpcGhlcj1mdW5jdGlvbihlKXt0aGlzLmFsZ29yaXRobT1lLmFsZ29yaXRobSx0aGlzLm1vZGU9dGhpcy5hbGdvcml0aG0ubW9kZSx0aGlzLmJsb2NrU2l6ZT10aGlzLm1vZGUuYmxvY2tTaXplLHRoaXMuX2ZpbmlzaD0hMSx0aGlzLl9pbnB1dD1udWxsLHRoaXMub3V0cHV0PW51bGwsdGhpcy5fb3A9ZS5kZWNyeXB0P3RoaXMubW9kZS5kZWNyeXB0OnRoaXMubW9kZS5lbmNyeXB0LHRoaXMuX2RlY3J5cHQ9ZS5kZWNyeXB0LHRoaXMuYWxnb3JpdGhtLmluaXRpYWxpemUoZSl9O2kucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGUpe2U9ZXx8e307dmFyIHQ9e307Zm9yKHZhciByIGluIGUpdFtyXT1lW3JdO3QuZGVjcnlwdD10aGlzLl9kZWNyeXB0LHRoaXMuX2ZpbmlzaD0hMSx0aGlzLl9pbnB1dD1uLnV0aWwuY3JlYXRlQnVmZmVyKCksdGhpcy5vdXRwdXQ9ZS5vdXRwdXR8fG4udXRpbC5jcmVhdGVCdWZmZXIoKSx0aGlzLm1vZGUuc3RhcnQodCl9LGkucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihlKXtmb3IoZSYmdGhpcy5faW5wdXQucHV0QnVmZmVyKGUpOyF0aGlzLl9vcC5jYWxsKHRoaXMubW9kZSx0aGlzLl9pbnB1dCx0aGlzLm91dHB1dCx0aGlzLl9maW5pc2gpJiYhdGhpcy5fZmluaXNoOyk7dGhpcy5faW5wdXQuY29tcGFjdCgpfSxpLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oZSl7IWV8fFwiRUNCXCIhPT10aGlzLm1vZGUubmFtZSYmXCJDQkNcIiE9PXRoaXMubW9kZS5uYW1lfHwodGhpcy5tb2RlLnBhZD1mdW5jdGlvbih0KXtyZXR1cm4gZSh0aGlzLmJsb2NrU2l6ZSx0LCExKX0sdGhpcy5tb2RlLnVucGFkPWZ1bmN0aW9uKHQpe3JldHVybiBlKHRoaXMuYmxvY2tTaXplLHQsITApfSk7dmFyIHQ9e307cmV0dXJuIHQuZGVjcnlwdD10aGlzLl9kZWNyeXB0LHQub3ZlcmZsb3c9dGhpcy5faW5wdXQubGVuZ3RoKCkldGhpcy5ibG9ja1NpemUsISghdGhpcy5fZGVjcnlwdCYmdGhpcy5tb2RlLnBhZCYmIXRoaXMubW9kZS5wYWQodGhpcy5faW5wdXQsdCkpJiYodGhpcy5fZmluaXNoPSEwLHRoaXMudXBkYXRlKCksISh0aGlzLl9kZWNyeXB0JiZ0aGlzLm1vZGUudW5wYWQmJiF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsdCkpJiYhKHRoaXMubW9kZS5hZnRlckZpbmlzaCYmIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCx0KSkpfX0sZnVuY3Rpb24oZSx0KXt9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoOSkscigyKSwoZS5leHBvcnRzPW4uaG1hYz1uLmhtYWN8fHt9KS5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgZT1udWxsLHQ9bnVsbCxyPW51bGwsaT1udWxsLGE9e3N0YXJ0OmZ1bmN0aW9uKGEscyl7aWYobnVsbCE9PWEpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpe2lmKCEoKGE9YS50b0xvd2VyQ2FzZSgpKWluIG4ubWQuYWxnb3JpdGhtcykpdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhhc2ggYWxnb3JpdGhtIFwiJythKydcIicpO3Q9bi5tZC5hbGdvcml0aG1zW2FdLmNyZWF0ZSgpfWVsc2UgdD1hO2lmKG51bGw9PT1zKXM9ZTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiBzKXM9bi51dGlsLmNyZWF0ZUJ1ZmZlcihzKTtlbHNlIGlmKG4udXRpbC5pc0FycmF5KHMpKXt2YXIgbz1zO3M9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO2Zvcih2YXIgdT0wO3U8by5sZW5ndGg7Kyt1KXMucHV0Qnl0ZShvW3VdKX12YXIgYz1zLmxlbmd0aCgpO2M+dC5ibG9ja0xlbmd0aCYmKHQuc3RhcnQoKSx0LnVwZGF0ZShzLmJ5dGVzKCkpLHM9dC5kaWdlc3QoKSkscj1uLnV0aWwuY3JlYXRlQnVmZmVyKCksaT1uLnV0aWwuY3JlYXRlQnVmZmVyKCksYz1zLmxlbmd0aCgpO2Zvcih1PTA7dTxjOysrdSl7bz1zLmF0KHUpO3IucHV0Qnl0ZSg1NF5vKSxpLnB1dEJ5dGUoOTJebyl9aWYoYzx0LmJsb2NrTGVuZ3RoKWZvcihvPXQuYmxvY2tMZW5ndGgtYyx1PTA7dTxvOysrdSlyLnB1dEJ5dGUoNTQpLGkucHV0Qnl0ZSg5Mik7ZT1zLHI9ci5ieXRlcygpLGk9aS5ieXRlcygpfXQuc3RhcnQoKSx0LnVwZGF0ZShyKX0sdXBkYXRlOmZ1bmN0aW9uKGUpe3QudXBkYXRlKGUpfSxnZXRNYWM6ZnVuY3Rpb24oKXt2YXIgZT10LmRpZ2VzdCgpLmJ5dGVzKCk7cmV0dXJuIHQuc3RhcnQoKSx0LnVwZGF0ZShpKSx0LnVwZGF0ZShlKSx0LmRpZ2VzdCgpfX07cmV0dXJuIGEuZGlnZXN0PWEuZ2V0TWFjLGF9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9cigyMCksYT1yKDU1KSxzPXIoMTQpLG89cigxMSksdT1yKDE5KSxjPXIoMzQpLGw9bihyKDI0KSk7dC5zZWVkV2l0aE5vbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3NlZWQ6YS5TZWVkLnRvQmluYXJ5KGUpLnNlZWQsbm9uY2U6dH19O3Qua2V5UGFpcj1mdW5jdGlvbihlKXt2YXIgdD1hLlNlZWQudG9CaW5hcnkoZSkscj1mdW5jdGlvbihlLHQpe3ZhciByPVswLDAsMCwwXTtpZih0JiZ0PjApZm9yKHZhciBuPXQsaT0zO2k+PTA7aS0tKXJbMy1pXT1NYXRoLmZsb29yKG4vTWF0aC5wb3coMiw4KmkpKSxuJT1NYXRoLnBvdygyLDgqaSk7dmFyIGE9dS5jb25jYXQocixlKSxvPXMuX2hhc2hDaGFpbihhKTtyZXR1cm4gcy5zaGEyNTYobyl9KHQuc2VlZCx0Lm5vbmNlKSxuPWwuZGVmYXVsdC5nZW5lcmF0ZUtleVBhaXIocik7cmV0dXJue3ByaXZhdGVLZXk6bi5wcml2YXRlLHB1YmxpY0tleTpuLnB1YmxpY319LHQuYWRkcmVzcz1mdW5jdGlvbihlLHIpe3JldHVybiB2b2lkIDA9PT1yJiYocj1pLk1BSU5fTkVUX0NIQUlOX0lEKSxjLmlzUHVibGljS2V5KGUpP2Z1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9aS5NQUlOX05FVF9DSEFJTl9JRCk7dmFyIHI9WzEsXCJzdHJpbmdcIj09dHlwZW9mIHQ/dC5jaGFyQ29kZUF0KDApOnRdLG49cy5faGFzaENoYWluKGUpLnNsaWNlKDAsMjApLGE9dS5jb25jYXQocixuKSxvPXMuX2hhc2hDaGFpbihhKS5zbGljZSgwLDQpO3JldHVybiB1LmNvbmNhdChhLG8pfShvLl9mcm9tSW4oZS5wdWJsaWNLZXkpLHIpOnQuYWRkcmVzcyh0LmtleVBhaXIoZSkscil9LHQucHVibGljS2V5PWZ1bmN0aW9uKGUpe3JldHVybiBjLmlzUHJpdmF0ZUtleShlKT9sLmRlZmF1bHQuZ2VuZXJhdGVLZXlQYWlyKG8uX2Zyb21JbihlLnByaXZhdGVLZXkpKS5wdWJsaWM6dC5rZXlQYWlyKGUpLnB1YmxpY0tleX0sdC5wcml2YXRlS2V5PWZ1bmN0aW9uKGUpe3JldHVybiB0LmtleVBhaXIoZSkucHJpdmF0ZUtleX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmlzUHVibGljS2V5PWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1lLnB1YmxpY0tleX0sdC5pc1ByaXZhdGVLZXk9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PWUucHJpdmF0ZUtleX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMik7dmFyIGk9ZS5leHBvcnRzPW4ucGVtPW4ucGVtfHx7fTtmdW5jdGlvbiBhKGUpe2Zvcih2YXIgdD1lLm5hbWUrXCI6IFwiLHI9W10sbj1mdW5jdGlvbihlLHQpe3JldHVyblwiIFwiK3R9LGk9MDtpPGUudmFsdWVzLmxlbmd0aDsrK2kpci5wdXNoKGUudmFsdWVzW2ldLnJlcGxhY2UoL14oXFxTK1xcclxcbikvLG4pKTt0Kz1yLmpvaW4oXCIsXCIpK1wiXFxyXFxuXCI7dmFyIGE9MCxzPS0xO2ZvcihpPTA7aTx0Lmxlbmd0aDsrK2ksKythKWlmKGE+NjUmJi0xIT09cyl7dmFyIG89dFtzXTtcIixcIj09PW8/KCsrcyx0PXQuc3Vic3RyKDAscykrXCJcXHJcXG4gXCIrdC5zdWJzdHIocykpOnQ9dC5zdWJzdHIoMCxzKStcIlxcclxcblwiK28rdC5zdWJzdHIocysxKSxhPWktcy0xLHM9LTEsKytpfWVsc2VcIiBcIiE9PXRbaV0mJlwiXFx0XCIhPT10W2ldJiZcIixcIiE9PXRbaV18fChzPWkpO3JldHVybiB0fWZ1bmN0aW9uIHMoZSl7cmV0dXJuIGUucmVwbGFjZSgvXlxccysvLFwiXCIpfWkuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7dD10fHx7fTt2YXIgcixpPVwiLS0tLS1CRUdJTiBcIitlLnR5cGUrXCItLS0tLVxcclxcblwiO2lmKGUucHJvY1R5cGUmJihpKz1hKHI9e25hbWU6XCJQcm9jLVR5cGVcIix2YWx1ZXM6W1N0cmluZyhlLnByb2NUeXBlLnZlcnNpb24pLGUucHJvY1R5cGUudHlwZV19KSksZS5jb250ZW50RG9tYWluJiYoaSs9YShyPXtuYW1lOlwiQ29udGVudC1Eb21haW5cIix2YWx1ZXM6W2UuY29udGVudERvbWFpbl19KSksZS5kZWtJbmZvJiYocj17bmFtZTpcIkRFSy1JbmZvXCIsdmFsdWVzOltlLmRla0luZm8uYWxnb3JpdGhtXX0sZS5kZWtJbmZvLnBhcmFtZXRlcnMmJnIudmFsdWVzLnB1c2goZS5kZWtJbmZvLnBhcmFtZXRlcnMpLGkrPWEocikpLGUuaGVhZGVycylmb3IodmFyIHM9MDtzPGUuaGVhZGVycy5sZW5ndGg7KytzKWkrPWEoZS5oZWFkZXJzW3NdKTtyZXR1cm4gZS5wcm9jVHlwZSYmKGkrPVwiXFxyXFxuXCIpLGkrPW4udXRpbC5lbmNvZGU2NChlLmJvZHksdC5tYXhsaW5lfHw2NCkrXCJcXHJcXG5cIixpKz1cIi0tLS0tRU5EIFwiK2UudHlwZStcIi0tLS0tXFxyXFxuXCJ9LGkuZGVjb2RlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPVtdLGk9L1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZyxhPS8oW1xceDIxLVxceDdlXSspOlxccyooW1xceDIxLVxceDdlXFxzXjpdKykvLG89L1xccj9cXG4vO3Q9aS5leGVjKGUpOyl7dmFyIHU9e3R5cGU6dFsxXSxwcm9jVHlwZTpudWxsLGNvbnRlbnREb21haW46bnVsbCxkZWtJbmZvOm51bGwsaGVhZGVyczpbXSxib2R5Om4udXRpbC5kZWNvZGU2NCh0WzNdKX07aWYoci5wdXNoKHUpLHRbMl0pe2Zvcih2YXIgYz10WzJdLnNwbGl0KG8pLGw9MDt0JiZsPGMubGVuZ3RoOyl7Zm9yKHZhciBmPWNbbF0ucmVwbGFjZSgvXFxzKyQvLFwiXCIpLGg9bCsxO2g8Yy5sZW5ndGg7KytoKXt2YXIgcD1jW2hdO2lmKCEvXFxzLy50ZXN0KHBbMF0pKWJyZWFrO2YrPXAsbD1ofWlmKHQ9Zi5tYXRjaChhKSl7Zm9yKHZhciBkPXtuYW1lOnRbMV0sdmFsdWVzOltdfSx5PXRbMl0uc3BsaXQoXCIsXCIpLGc9MDtnPHkubGVuZ3RoOysrZylkLnZhbHVlcy5wdXNoKHMoeVtnXSkpO2lmKHUucHJvY1R5cGUpaWYodS5jb250ZW50RG9tYWlufHxcIkNvbnRlbnQtRG9tYWluXCIhPT1kLm5hbWUpaWYodS5kZWtJbmZvfHxcIkRFSy1JbmZvXCIhPT1kLm5hbWUpdS5oZWFkZXJzLnB1c2goZCk7ZWxzZXtpZigwPT09ZC52YWx1ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgaGVhZGVyIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3ViZmllbGQuJyk7dS5kZWtJbmZvPXthbGdvcml0aG06eVswXSxwYXJhbWV0ZXJzOnlbMV18fG51bGx9fWVsc2UgdS5jb250ZW50RG9tYWluPXlbMF18fFwiXCI7ZWxzZXtpZihcIlByb2MtVHlwZVwiIT09ZC5uYW1lKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBmaXJzdCBlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtpZigyIT09ZC52YWx1ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiIGhlYWRlciBtdXN0IGhhdmUgdHdvIHN1YmZpZWxkcy4nKTt1LnByb2NUeXBlPXt2ZXJzaW9uOnlbMF0sdHlwZTp5WzFdfX19KytsfWlmKFwiRU5DUllQVEVEXCI9PT11LnByb2NUeXBlJiYhdS5kZWtJbmZvKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIkRFSy1JbmZvXCIgaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyl9fWlmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS5cIik7cmV0dXJuIHJ9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jb25jYXQ9KC4uLmUpPT5lLnJlZHVjZSgoZSx0KT0+VWludDhBcnJheS5mcm9tKFsuLi5lLC4uLnRdKSxuZXcgVWludDhBcnJheSgwKSksdC5yYW5nZT0oZSx0LHI9MSk9PkFycmF5LmZyb20oe2xlbmd0aDp0LWV9KS5tYXAoKHQsbik9Pm4qcitlKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigxMTEpLGk9cig2NSksYT1yKDI4KSxzPXIoNjYpO3QuQUxJQVNfVkVSU0lPTj0yO3QuUF9PUFRJT049ZT0+KHQscj0wKT0+e2lmKDA9PT10W3JdKXJldHVybnt2YWx1ZTpudWxsLHNoaWZ0OjF9O2NvbnN0IG49ZSh0LHIrMSk7cmV0dXJue3ZhbHVlOm4udmFsdWUsc2hpZnQ6bi5zaGlmdCsxfX0sdC5QX0JZVEU9KGUsdD0wKT0+KHt2YWx1ZTplW3RdLHNoaWZ0OjF9KSx0LlBfU0hPUlQ9KGUsdD0wKT0+KHt2YWx1ZToyNTYqZVt0XStlW3QrMV0sc2hpZnQ6Mn0pLHQuUF9JTlQ9KGUsdD0wKT0+KHt2YWx1ZTpNYXRoLnBvdygyLDI0KSplW3RdK01hdGgucG93KDIsMTYpKmVbdCsxXStNYXRoLnBvdygyLDgpKmVbdCsyXStlW3QrM10sc2hpZnQ6NH0pLHQuUF9MT05HPShlLHQ9MCk9Pih7dmFsdWU6cy5CaWdOdW1iZXIuZnJvbUJ5dGVzKEFycmF5LmZyb20oZS5zbGljZSh0LHQrOCkpKS50b1N0cmluZygpLHNoaWZ0Ojh9KSx0LlBfQk9PTEVBTj0oZSx0PTApPT57cmV0dXJue3ZhbHVlOiEhZVt0XSxzaGlmdDoxfX0sdC5QX1NUUklOR19GSVhFRD1lPT4odCxyPTApPT57Y29uc3QgaT1uLlV0ZjhBcnJheVRvU3RyKHQuc2xpY2UocixyK2UpKTtyZXR1cm57c2hpZnQ6ZSx2YWx1ZTppfX0sdC5QX1NUUklOR19WQVI9ZT0+KHIsbj0wKT0+e2NvbnN0IGk9ZShyLG4pLHt2YWx1ZTphfT10LlBfU1RSSU5HX0ZJWEVEKGkudmFsdWUpKHIsbitpLnNoaWZ0KTtyZXR1cm57c2hpZnQ6aS52YWx1ZStpLnNoaWZ0LHZhbHVlOmF9fSx0LlBfQkFTRTU4X0ZJWEVEPWU9Pih0LHI9MCk9PntyZXR1cm57dmFsdWU6aS5kZWZhdWx0LmVuY29kZSh0LnNsaWNlKHIscitlKSksc2hpZnQ6ZX19LHQuUF9CQVNFNThfVkFSPWU9PihyLG49MCk9Pntjb25zdCBpPWUocixuKSx7dmFsdWU6YX09dC5QX0JBU0U1OF9GSVhFRChpLnZhbHVlKShyLG4rMik7cmV0dXJue3NoaWZ0OmkudmFsdWUrMix2YWx1ZTphfX0sdC5QX0JBU0U2ND1lPT4odCxyPTApPT57Y29uc3Qgbj1lKHQsciksaT1gYmFzZTY0OiR7YS5mcm9tQnl0ZUFycmF5KHQuc2xpY2UocituLnNoaWZ0LHIrbi5zaGlmdCtuLnZhbHVlKSl9YDtyZXR1cm57c2hpZnQ6bi52YWx1ZStuLnNoaWZ0LHZhbHVlOml9fTt0LmJ5dGVUb1N0cmluZ1dpdGhMZW5ndGg9KGUscj0wKT0+e2NvbnN0IGk9dC5QX1NIT1JUKGUscikse3ZhbHVlOmF9PShlPT4odCxyKT0+e2NvbnN0IGk9bi5VdGY4QXJyYXlUb1N0cih0LnNsaWNlKHIscitlKSk7cmV0dXJue3NoaWZ0OmUsdmFsdWU6aX19KShpLnZhbHVlKShlLHIrMik7cmV0dXJue3NoaWZ0OmkudmFsdWUrMix2YWx1ZTphfX0sdC5ieXRlVG9CYXNlNTg9KGUsdD0wLHIpPT57Y29uc3Qgbj1yfHwzMjtyZXR1cm57dmFsdWU6aS5kZWZhdWx0LmVuY29kZShlLnNsaWNlKHQsdCtuKSksc2hpZnQ6bn19LHQuYnl0ZVRvQmFzZTU4V2l0aExlbmd0aD0oZSxyPTApPT57Y29uc3Qgbj10LlBfU0hPUlQoZSxyKTtyZXR1cm57dmFsdWU6aS5kZWZhdWx0LmVuY29kZShlLnNsaWNlKHIrbi5zaGlmdCxyK24uc2hpZnQrbi52YWx1ZSkpLHNoaWZ0Om4uc2hpZnQrbi52YWx1ZX19LHQuYnl0ZVRvQWRkcmVzc09yQWxpYXM9KGUscj0wKT0+e2lmKGVbcl09PT10LkFMSUFTX1ZFUlNJT04pe2NvbnN0IG49dC5ieXRlVG9TdHJpbmdXaXRoTGVuZ3RoKGUscisyKTtyZXR1cm57c2hpZnQ6bi5zaGlmdCsyLHZhbHVlOmBhbGlhczoke1N0cmluZy5mcm9tQ2hhckNvZGUoZVtyKzFdKX06JHtuLnZhbHVlfWB9fXJldHVybiB0LmJ5dGVUb0Jhc2U1OChlLHIsMjYpfSx0LmJ5dGVOZXdBbGlhc1RvU3RyaW5nPShlLHI9MCk9Pntjb25zdCBuPXQuUF9TSE9SVChlLHIpLnZhbHVlKzIse3ZhbHVlOml9PXQuYnl0ZVRvU3RyaW5nV2l0aExlbmd0aChlLHIpO3JldHVybntzaGlmdDpuLHZhbHVlOml9fSx0LmJ5dGVUb1NjcmlwdD0oZSxyPTApPT57aWYoMD09PWVbcl0pcmV0dXJue3NoaWZ0OjEsdmFsdWU6bnVsbH07Y29uc3Qgbj10LlBfU0hPUlQoZSxyKzEpLGk9cisxK24uc2hpZnQscz1yKzErbi5zaGlmdCtuLnZhbHVlO3JldHVybnt2YWx1ZTpgYmFzZTY0OiR7YS5mcm9tQnl0ZUFycmF5KGUuc2xpY2UoaSxzKSl9YCxzaGlmdDpzLXJ9fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNCksYT1yKDcpLHM9cigzKSxvPXIoNSk7dC5yZWlzc3VlPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1uLlRSQU5TQUNUSU9OX1RZUEUuUkVJU1NVRSx1PWUudmVyc2lvbnx8MixjPWEuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6YS5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxhc3NldElkOmUuYXNzZXRJZCxxdWFudGl0eTplLnF1YW50aXR5LHJlaXNzdWFibGU6ZS5yZWlzc3VhYmxlLGNoYWluSWQ6YS5uZXR3b3JrQnl0ZShlLmNoYWluSWQsODcpLGZlZTphLmZlZShlLDFlOCksdGltZXN0YW1wOmUudGltZXN0YW1wfHxEYXRlLm5vdygpLHByb29mczplLnByb29mc3x8W10saWQ6XCJcIn07by52YWxpZGF0ZS5yZWlzc3VlKGwpO2NvbnN0IGY9cy5iaW5hcnkuc2VyaWFsaXplVHgobCk7cmV0dXJuIGMuZm9yRWFjaCgoW2UsdF0pPT5hLmFkZFByb29mKGwsaS5zaWduQnl0ZXMoZSxmKSx0KSksbC5pZD1pLmJhc2U1OEVuY29kZShpLmJsYWtlMmIoZikpLGx9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cigzKSxhPXIoNCkscz1yKDcpLG89cig1KTt0LmJ1cm49ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5CVVJOLHU9ZS52ZXJzaW9ufHwyLGM9cy5jb252ZXJ0VG9QYWlycyh0KSxsPXt0eXBlOnIsdmVyc2lvbjp1LHNlbmRlclB1YmxpY0tleTpzLmdldFNlbmRlclB1YmxpY0tleShjLGUpLGFzc2V0SWQ6ZS5hc3NldElkLHF1YW50aXR5OmUucXVhbnRpdHksY2hhaW5JZDpzLm5ldHdvcmtCeXRlKGUuY2hhaW5JZCw4NyksZmVlOnMuZmVlKGUsMWU1KSx0aW1lc3RhbXA6ZS50aW1lc3RhbXB8fERhdGUubm93KCkscHJvb2ZzOmUucHJvb2ZzfHxbXSxpZDpcIlwifTtvLnZhbGlkYXRlLmJ1cm4obCk7Y29uc3QgZj1pLmJpbmFyeS5zZXJpYWxpemVUeChsKTtyZXR1cm4gYy5mb3JFYWNoKChbZSx0XSk9PnMuYWRkUHJvb2YobCxhLnNpZ25CeXRlcyhlLGYpLHQpKSxsLmlkPWEuYmFzZTU4RW5jb2RlKGEuYmxha2UyYihmKSksbH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDMpLGE9cig0KSxzPXIoNyksbz1yKDUpO3QuZXhjaGFuZ2U9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5FWENIQU5HRSx1PWUudmVyc2lvbnx8MixjPXMuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6cy5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxvcmRlcjE6ZS5vcmRlcjEsb3JkZXIyOmUub3JkZXIyLHByaWNlOmUucHJpY2UsYW1vdW50OmUuYW1vdW50LGJ1eU1hdGNoZXJGZWU6ZS5idXlNYXRjaGVyRmVlLHNlbGxNYXRjaGVyRmVlOmUuc2VsbE1hdGNoZXJGZWUsZmVlOnMuZmVlKGUsMWU1KSx0aW1lc3RhbXA6ZS50aW1lc3RhbXB8fERhdGUubm93KCkscHJvb2ZzOmUucHJvb2ZzfHxbXSxpZDpcIlwifTtvLnZhbGlkYXRlLmV4Y2hhbmdlKGwpO2NvbnN0IGY9aS5iaW5hcnkuc2VyaWFsaXplVHgobCk7cmV0dXJuIGMuZm9yRWFjaCgoW2UsdF0pPT5zLmFkZFByb29mKGwsYS5zaWduQnl0ZXMoZSxmKSx0KSksT2JqZWN0LmFzc2lnbih7fSxsLHtpZDphLmJhc2U1OEVuY29kZShhLmJsYWtlMmIoZikpfSl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cig0KSxhPXIoNykscz1yKDMpLG89cig1KTt0LmxlYXNlPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1uLlRSQU5TQUNUSU9OX1RZUEUuTEVBU0UsdT1lLnZlcnNpb258fDIsYz1hLmNvbnZlcnRUb1BhaXJzKHQpLGw9e3R5cGU6cix2ZXJzaW9uOnUsc2VuZGVyUHVibGljS2V5OmEuZ2V0U2VuZGVyUHVibGljS2V5KGMsZSksYW1vdW50OmUuYW1vdW50LHJlY2lwaWVudDplLnJlY2lwaWVudCxmZWU6YS5mZWUoZSwxZTUpLHRpbWVzdGFtcDplLnRpbWVzdGFtcHx8RGF0ZS5ub3coKSxwcm9vZnM6ZS5wcm9vZnN8fFtdLGlkOlwiXCJ9O28udmFsaWRhdGUubGVhc2UobCk7Y29uc3QgZj1zLmJpbmFyeS5zZXJpYWxpemVUeChsKTtyZXR1cm4gYy5mb3JFYWNoKChbZSx0XSk9PmEuYWRkUHJvb2YobCxpLnNpZ25CeXRlcyhlLGYpLHQpKSxsLmlkPWkuYmFzZTU4RW5jb2RlKGkuYmxha2UyYihmKSksbH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDMpLGE9cig0KSxzPXIoNyksbz1yKDUpO3QuY2FuY2VsTGVhc2U9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5DQU5DRUxfTEVBU0UsdT1lLnZlcnNpb258fDIsYz1zLmNvbnZlcnRUb1BhaXJzKHQpLGw9e3R5cGU6cix2ZXJzaW9uOnUsc2VuZGVyUHVibGljS2V5OnMuZ2V0U2VuZGVyUHVibGljS2V5KGMsZSksbGVhc2VJZDplLmxlYXNlSWQsZmVlOnMuZmVlKGUsMWU1KSx0aW1lc3RhbXA6ZS50aW1lc3RhbXB8fERhdGUubm93KCksY2hhaW5JZDpzLm5ldHdvcmtCeXRlKGUuY2hhaW5JZCw4NykscHJvb2ZzOmUucHJvb2ZzfHxbXSxpZDpcIlwifTtvLnZhbGlkYXRlLmNhbmNlbExlYXNlKGwpO2NvbnN0IGY9aS5iaW5hcnkuc2VyaWFsaXplVHgobCk7cmV0dXJuIGMuZm9yRWFjaCgoW2UsdF0pPT5zLmFkZFByb29mKGwsYS5zaWduQnl0ZXMoZSxmKSx0KSksbC5pZD1hLmJhc2U1OEVuY29kZShhLmJsYWtlMmIoZikpLGx9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigzKSx7QkFTRTU4X1NUUklORzppLEJBU0U2NF9TVFJJTkc6YSxCWVRFOnMsQllURVM6byxDT1VOVDp1LExFTjpjLExPTkc6bCxTSE9SVDpmLFNUUklORzpofT1uLnNlcmlhbGl6ZVByaW1pdGl2ZXMscD1yKDQpLGQ9cigwKSx5PXIoNyksZz1yKDMpLG09cig1KSx2PXtpbnRlZ2VyOltcImludGVnZXJcIiwwLGxdLG51bWJlcjpbXCJpbnRlZ2VyXCIsMCxsXSxib29sZWFuOltcImJvb2xlYW5cIiwxLHNdLHN0cmluZzpbXCJzdHJpbmdcIiwzLGMoZikoaCldLGJpbmFyeTpbXCJiaW5hcnlcIiwyLGU9PmMoZikoYSkoZS5zbGljZSg3KSldLF86W1wiYmluYXJ5XCIsMixjKGYpKG8pXX0sYj1lPT52W3R5cGVvZiBlXXx8di5fO3QuZGF0YT1mdW5jdGlvbih0LHIpe2NvbnN0IG49ZC5UUkFOU0FDVElPTl9UWVBFLkRBVEEsYT10LnZlcnNpb258fDEsbz15LmNvbnZlcnRUb1BhaXJzKHIpLHY9eS5nZXRTZW5kZXJQdWJsaWNLZXkobyx0KTtpZighQXJyYXkuaXNBcnJheSh0LmRhdGEpKXRocm93IG5ldyBFcnJvcignW1wiZGF0YSBzaG91bGQgYmUgYXJyYXlcIl0nKTtjb25zdCBFPXQudGltZXN0YW1wfHxEYXRlLm5vdygpO2xldCBTPXAuY29uY2F0KHMoZC5UUkFOU0FDVElPTl9UWVBFLkRBVEEpLHMoMSksaSh2KSx1KGYpKGU9PnAuY29uY2F0KGMoZikoaCkoZS5rZXkpLFtiKGUudmFsdWUpWzFdXSxiKGUudmFsdWUpWzJdKGUudmFsdWUpKSkodC5kYXRhKSxsKEUpKTtjb25zdCBUPTFlNSpNYXRoLmZsb29yKDErKFMubGVuZ3RoKzgtMSkvMTAyNCksQz17dHlwZTpuLHZlcnNpb246YSxzZW5kZXJQdWJsaWNLZXk6dixmZWU6eS5mZWUodCxUKSx0aW1lc3RhbXA6RSxwcm9vZnM6dC5wcm9vZnN8fFtdLGlkOlwiXCIsZGF0YTp0LmRhdGEmJnQuZGF0YS5tYXAodD0+e2lmKHQudHlwZSlyZXR1cm4gdDt7Y29uc3Qgcj1iKHQudmFsdWUpWzBdO3JldHVybnt0eXBlOnIsa2V5OnQua2V5LHZhbHVlOlwiYmluYXJ5XCI9PT1yP1wiYmFzZTY0OlwiK2UuZnJvbSh0LnZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKTp0LnZhbHVlfX19KX07bS52YWxpZGF0ZS5kYXRhKEMpO2NvbnN0IEE9Zy5iaW5hcnkuc2VyaWFsaXplVHgoQyk7cmV0dXJuIG8uZm9yRWFjaCgoW2UsdF0pPT55LmFkZFByb29mKEMscC5zaWduQnl0ZXMoZSxBKSx0KSksQy5pZD1wLmJhc2U1OEVuY29kZShwLmJsYWtlMmIoQSkpLEN9fSkuY2FsbCh0aGlzLHIoMTMpLkJ1ZmZlcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDQpLGE9cig3KSxzPXIoMyksbz1yKDUpO3QuaXNzdWU9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5JU1NVRSx1PWUudmVyc2lvbnx8MixjPWEuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6YS5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxuYW1lOmUubmFtZSxkZXNjcmlwdGlvbjplLmRlc2NyaXB0aW9uLHF1YW50aXR5OmUucXVhbnRpdHksc2NyaXB0Om51bGw9PWUuc2NyaXB0P3ZvaWQgMDphLmJhc2U2NFByZWZpeChlLnNjcmlwdCksZGVjaW1hbHM6bnVsbD09ZS5kZWNpbWFscz84OmUuZGVjaW1hbHMscmVpc3N1YWJsZTplLnJlaXNzdWFibGV8fCExLGZlZToxPT09ZS5xdWFudGl0eT9hLmZlZShlLDFlNik6YS5mZWUoZSwxZTgpLHRpbWVzdGFtcDplLnRpbWVzdGFtcHx8RGF0ZS5ub3coKSxjaGFpbklkOmEubmV0d29ya0J5dGUoZS5jaGFpbklkLDg3KSxwcm9vZnM6ZS5wcm9vZnN8fFtdLGlkOlwiXCJ9O28udmFsaWRhdGUuaXNzdWUobCk7Y29uc3QgZj1zLmJpbmFyeS5zZXJpYWxpemVUeChsKTtyZXR1cm4gYy5mb3JFYWNoKChbZSx0XSk9PmEuYWRkUHJvb2YobCxpLnNpZ25CeXRlcyhlLGYpLHQpKSxsLmlkPWkuYmFzZTU4RW5jb2RlKGkuYmxha2UyYihmKSksbH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDQpLGE9cig3KSxzPXIoNSksbz1yKDMpO3QudHJhbnNmZXI9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5UUkFOU0ZFUix1PWUudmVyc2lvbnx8MixjPWEuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6YS5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxhc3NldElkOmEubm9ybWFsaXplQXNzZXRJZChlLmFzc2V0SWQpLHJlY2lwaWVudDplLnJlY2lwaWVudCxhbW91bnQ6ZS5hbW91bnQsYXR0YWNobWVudDplLmF0dGFjaG1lbnR8fFwiXCIsZmVlOmEuZmVlKGUsMWU1KSxmZWVBc3NldElkOmEubm9ybWFsaXplQXNzZXRJZChlLmZlZUFzc2V0SWQpLHRpbWVzdGFtcDplLnRpbWVzdGFtcHx8RGF0ZS5ub3coKSxwcm9vZnM6ZS5wcm9vZnN8fFtdLGlkOlwiXCJ9O3MudmFsaWRhdGUudHJhbnNmZXIobCk7Y29uc3QgZj1vLmJpbmFyeS5zZXJpYWxpemVUeChsKTtyZXR1cm4gYy5mb3JFYWNoKChbZSx0XSk9PmEuYWRkUHJvb2YobCxpLnNpZ25CeXRlcyhlLGYpLHQpKSxsLmlkPWkuYmFzZTU4RW5jb2RlKGkuYmxha2UyYihmKSksbH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDMpLGE9cig0KSxzPXIoNyksbz1yKDUpO3QuYWxpYXM9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5BTElBUyx1PWUudmVyc2lvbnx8MixjPXMuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6cy5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxhbGlhczplLmFsaWFzLGZlZTpzLmZlZShlLDFlNSksdGltZXN0YW1wOmUudGltZXN0YW1wfHxEYXRlLm5vdygpLGNoYWluSWQ6cy5uZXR3b3JrQnl0ZShlLmNoYWluSWQsODcpLHByb29mczplLnByb29mc3x8W10saWQ6XCJcIn07by52YWxpZGF0ZS5hbGlhcyhsKTtjb25zdCBmPWkuYmluYXJ5LnNlcmlhbGl6ZVR4KGwpO2MuZm9yRWFjaCgoW2UsdF0pPT5zLmFkZFByb29mKGwsYS5zaWduQnl0ZXMoZSxmKSx0KSk7Y29uc3QgaD1bZlswXSwuLi5mLnNsaWNlKDM2LC0xNildO3JldHVybiBsLmlkPWEuYmFzZTU4RW5jb2RlKGEuYmxha2UyYihVaW50OEFycmF5LmZyb20oaCkpKSxsfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNCksYT1yKDcpLHM9cigzKSxvPXIoNSk7dC5zZXRTY3JpcHQ9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5TRVRfU0NSSVBULHU9ZS52ZXJzaW9ufHwxLGM9YS5jb252ZXJ0VG9QYWlycyh0KSxsPWEuZ2V0U2VuZGVyUHVibGljS2V5KGMsZSk7aWYodm9pZCAwPT09ZS5zY3JpcHQpdGhyb3cgbmV3IEVycm9yKFwiU2NyaXB0IGZpZWxkIGNhbm5vdCBiZSB1bmRlZmluZWQuIFVzZSBudWxsIGV4cGxpY2l0bHkgdG8gcmVtb3ZlIHNjcmlwdFwiKTtjb25zdCBmPXt0eXBlOnIsdmVyc2lvbjp1LHNlbmRlclB1YmxpY0tleTpsLGNoYWluSWQ6YS5uZXR3b3JrQnl0ZShlLmNoYWluSWQsODcpLGZlZTphLmZlZShlLDFlNiksdGltZXN0YW1wOmUudGltZXN0YW1wfHxEYXRlLm5vdygpLHByb29mczplLnByb29mc3x8W10saWQ6XCJcIixzY3JpcHQ6YS5iYXNlNjRQcmVmaXgoZS5zY3JpcHQpfTtvLnZhbGlkYXRlLnNldFNjcmlwdChmKTtjb25zdCBoPXMuYmluYXJ5LnNlcmlhbGl6ZVR4KGYpO3JldHVybiBjLmZvckVhY2goKFtlLHRdKT0+YS5hZGRQcm9vZihmLGkuc2lnbkJ5dGVzKGUsaCksdCkpLGYuaWQ9aS5iYXNlNThFbmNvZGUoaS5ibGFrZTJiKGgpKSxmfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNCksYT1yKDcpLHM9cigzKSxvPXIoNSk7dC5zZXRBc3NldFNjcmlwdD1mdW5jdGlvbihlLHQpe2NvbnN0IHI9bi5UUkFOU0FDVElPTl9UWVBFLlNFVF9BU1NFVF9TQ1JJUFQsdT1lLnZlcnNpb258fDEsYz1hLmNvbnZlcnRUb1BhaXJzKHQpLGw9YS5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKTtpZihudWxsPT1lLnNjcmlwdCl0aHJvdyBuZXcgRXJyb3IoXCJBc3NldCBzY3JpcHQgY2Fubm90IGJlIGVtcHR5XCIpO2NvbnN0IGY9e3R5cGU6cix2ZXJzaW9uOnUsc2VuZGVyUHVibGljS2V5OmwsYXNzZXRJZDplLmFzc2V0SWQsY2hhaW5JZDphLm5ldHdvcmtCeXRlKGUuY2hhaW5JZCw4NyksZmVlOmEuZmVlKGUsMWU4KSx0aW1lc3RhbXA6ZS50aW1lc3RhbXB8fERhdGUubm93KCkscHJvb2ZzOmUucHJvb2ZzfHxbXSxpZDpcIlwiLHNjcmlwdDphLmJhc2U2NFByZWZpeChlLnNjcmlwdCl9O28udmFsaWRhdGUuc2V0QXNzZXRTY3JpcHQoZik7Y29uc3QgaD1zLmJpbmFyeS5zZXJpYWxpemVUeChmKTtyZXR1cm4gYy5mb3JFYWNoKChbZSx0XSk9PmEuYWRkUHJvb2YoZixpLnNpZ25CeXRlcyhlLGgpLHQpKSxmLmlkPWkuYmFzZTU4RW5jb2RlKGkuYmxha2UyYihoKSksZn19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDQpLGE9cig3KSxzPXIoMyksbz1yKDUpO3Quc3BvbnNvcnNoaXA9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5TUE9OU09SU0hJUCx1PWUudmVyc2lvbnx8MSxjPWEuY29udmVydFRvUGFpcnModCksbD17dHlwZTpyLHZlcnNpb246dSxzZW5kZXJQdWJsaWNLZXk6YS5nZXRTZW5kZXJQdWJsaWNLZXkoYyxlKSxtaW5TcG9uc29yZWRBc3NldEZlZTplLm1pblNwb25zb3JlZEFzc2V0RmVlLGFzc2V0SWQ6ZS5hc3NldElkLGZlZTphLmZlZShlLDFlOCksdGltZXN0YW1wOmUudGltZXN0YW1wfHxEYXRlLm5vdygpLHByb29mczplLnByb29mc3x8W10saWQ6XCJcIn07by52YWxpZGF0ZS5zcG9uc29yc2hpcChsKTtjb25zdCBmPXMuYmluYXJ5LnNlcmlhbGl6ZVR4KGwpO3JldHVybiBjLmZvckVhY2goKFtlLHRdKT0+YS5hZGRQcm9vZihsLGkuc2lnbkJ5dGVzKGUsZiksdCkpLGwuaWQ9aS5iYXNlNThFbmNvZGUoaS5ibGFrZTJiKGYpKSxsfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNCksYT1yKDcpLHM9cigzKSxvPXIoNSk7dC5pbnZva2VTY3JpcHQ9ZnVuY3Rpb24oZSx0KXtjb25zdCByPW4uVFJBTlNBQ1RJT05fVFlQRS5JTlZPS0VfU0NSSVBULGM9ZS52ZXJzaW9ufHwxLGw9YS5jb252ZXJ0VG9QYWlycyh0KSxmPXt0eXBlOnIsdmVyc2lvbjpjLHNlbmRlclB1YmxpY0tleTphLmdldFNlbmRlclB1YmxpY0tleShsLGUpLGRBcHA6ZS5kQXBwLGNhbGw6ZS5jYWxsJiZPYmplY3QuYXNzaWduKHthcmdzOltdfSxlLmNhbGwpLHBheW1lbnQ6dShlLnBheW1lbnQpLGZlZTphLmZlZShlLDVlNSksZmVlQXNzZXRJZDphLm5vcm1hbGl6ZUFzc2V0SWQoZS5mZWVBc3NldElkKSx0aW1lc3RhbXA6ZS50aW1lc3RhbXB8fERhdGUubm93KCksY2hhaW5JZDphLm5ldHdvcmtCeXRlKGUuY2hhaW5JZCw4NykscHJvb2ZzOmUucHJvb2ZzfHxbXSxpZDpcIlwifTtvLnZhbGlkYXRlLmludm9rZVNjcmlwdChmKTtjb25zdCBoPXMuYmluYXJ5LnNlcmlhbGl6ZVR4KGYpO3JldHVybiBsLmZvckVhY2goKFtlLHRdKT0+YS5hZGRQcm9vZihmLGkuc2lnbkJ5dGVzKGUsaCksdCkpLGYuaWQ9aS5iYXNlNThFbmNvZGUoaS5iYXNlNThFbmNvZGUoaS5ibGFrZTJiKGgpKSksZn07Y29uc3QgdT1lPT5udWxsPT1lP1tdOmUubWFwKGU9Pk9iamVjdC5hc3NpZ24oe30sZSx7YXNzZXRJZDpcIldBVkVTXCI9PT1lLmFzc2V0SWQ/bnVsbDplLmFzc2V0SWR9KSl9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3JldHVybihuPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPTEsbj1hcmd1bWVudHMubGVuZ3RoO3I8bjtyKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW3JdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saT10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSx0KXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighcilyZXR1cm4gZTt2YXIgbixpLGE9ci5jYWxsKGUpLHM9W107dHJ5e2Zvcig7KHZvaWQgMD09PXR8fHQtLSA+MCkmJiEobj1hLm5leHQoKSkuZG9uZTspcy5wdXNoKG4udmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e24mJiFuLmRvbmUmJihyPWEucmV0dXJuKSYmci5jYWxsKGEpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gc30sYT10aGlzJiZ0aGlzLl9fc3ByZWFkfHxmdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyllPWUuY29uY2F0KGkoYXJndW1lbnRzW3RdKSk7cmV0dXJuIGV9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBzPXIoMjIpLG89cig1NCksdT1yKDIzKSxjPXIoMTApLGw9cigxOSksZj1yKDE0KSxoPXIoMzMpLHA9cig5NiksZD1yKDk3KSx5PXIoOTgpLGc9cigxMDkpLG09cigxMTApO3QuY3J5cHRvPWZ1bmN0aW9uKGUpe2lmKGUmJlwiXCI9PWUuc2VlZCl0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBzZWVkIGlzIG5vdCBhbGxvd2VkLlwiKTt2YXIgdCxyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXJbbl09YXJndW1lbnRzW25dO3JldHVybiBlLmFwcGx5KHZvaWQgMCxhKFt0XSxyKSl9fSxpPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgcj1bXSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKylyW25dPWFyZ3VtZW50c1tuXTt2YXIgaT10LmFwcGx5KHZvaWQgMCxhKHIpKTtyZXR1cm4hZXx8ZSYmXCJCYXNlNThcIj09PWUub3V0cHV0P3UuYmFzZTU4RW5jb2RlKGkpOml9fSx2PWUmJmUuc2VlZD9lLnNlZWQ6dm9pZCAwLGI9e3NlZWRXaXRoTm9uY2U6dj9yKGguc2VlZFdpdGhOb25jZSx2KTpoLnNlZWRXaXRoTm9uY2Usc2lnbkJ5dGVzOmkodj9yKHAuc2lnbkJ5dGVzLHYpOnAuc2lnbkJ5dGVzKSxrZXlQYWlyOih0PXY/cihoLmtleVBhaXIsdik6aC5rZXlQYWlyLGZ1bmN0aW9uKCl7Zm9yKHZhciByPVtdLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXJbbl09YXJndW1lbnRzW25dO3ZhciBpPXQuYXBwbHkodm9pZCAwLGEocikpO3JldHVybiFlfHxlJiZcIkJhc2U1OFwiPT09ZS5vdXRwdXQ/e3ByaXZhdGVLZXk6dS5iYXNlNThFbmNvZGUoaS5wcml2YXRlS2V5KSxwdWJsaWNLZXk6dS5iYXNlNThFbmNvZGUoaS5wdWJsaWNLZXkpfTppfSkscHVibGljS2V5Omkodj9yKGgucHVibGljS2V5LHYpOmgucHVibGljS2V5KSxwcml2YXRlS2V5Omkodj9yKGgucHJpdmF0ZUtleSx2KTpoLnByaXZhdGVLZXkpLGFkZHJlc3M6aSh2P3IoaC5hZGRyZXNzLHYpOmguYWRkcmVzcyl9O3JldHVybiBuKHt9LGIse3NoYXJlZEtleTppKG8uc2hhcmVkS2V5KSxibGFrZTJiOmYuYmxha2UyYixrZWNjYWs6Zi5rZWNjYWssc2hhMjU2OmYuc2hhMjU2LGJhc2U2NEVuY29kZTp1LmJhc2U2NEVuY29kZSxiYXNlNjREZWNvZGU6dS5iYXNlNjREZWNvZGUsYmFzZTU4RW5jb2RlOnUuYmFzZTU4RW5jb2RlLGJhc2U1OERlY29kZTp1LmJhc2U1OERlY29kZSxiYXNlMTZFbmNvZGU6dS5iYXNlMTZFbmNvZGUsYmFzZTE2RGVjb2RlOnUuYmFzZTE2RGVjb2RlLHN0cmluZ1RvQnl0ZXM6Yy5zdHJpbmdUb0J5dGVzLGJ5dGVzVG9TdHJpbmc6Yy5ieXRlc1RvU3RyaW5nLHJhbmRvbTpzLnJhbmRvbSxyYW5kb21TZWVkOnMucmFuZG9tU2VlZCxyYW5kb21CeXRlczpzLnJhbmRvbUJ5dGVzLHZlcmlmeVNpZ25hdHVyZTpkLnZlcmlmeVNpZ25hdHVyZSx2ZXJpZnlQdWJsaWNLZXk6ZC52ZXJpZnlQdWJsaWNLZXksdmVyaWZ5QWRkcmVzczpkLnZlcmlmeUFkZHJlc3MsbWVzc2FnZURlY3J5cHQ6by5tZXNzYWdlRGVjcnlwdCxtZXNzYWdlRW5jcnlwdDpvLm1lc3NhZ2VFbmNyeXB0LGFlc0RlY3J5cHQ6by5hZXNEZWNyeXB0LGFlc0VuY3J5cHQ6by5hZXNFbmNyeXB0LGVuY3J5cHRTZWVkOmcuZW5jcnlwdFNlZWQsZGVjcnlwdFNlZWQ6Zy5kZWNyeXB0U2VlZCxyc2FLZXlQYWlyOnkucnNhS2V5UGFpcixyc2FLZXlQYWlyU3luYzp5LnJzYUtleVBhaXJTeW5jLHJzYVNpZ246eS5yc2FTaWduLHJzYVZlcmlmeTp5LnJzYVZlcmlmeSxtZXJrbGVWZXJpZnk6bS5tZXJrbGVWZXJpZnksc3BsaXQ6bC5zcGxpdCxjb25jYXQ6bC5jb25jYXR9KX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMiksbi5jaXBoZXI9bi5jaXBoZXJ8fHt9O3ZhciBpPWUuZXhwb3J0cz1uLmNpcGhlci5tb2Rlcz1uLmNpcGhlci5tb2Rlc3x8e307ZnVuY3Rpb24gYShlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bi51dGlsLmNyZWF0ZUJ1ZmZlcihlKSksbi51dGlsLmlzQXJyYXkoZSkmJmUubGVuZ3RoPjQpe3ZhciB0PWU7ZT1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpZS5wdXRCeXRlKHRbcl0pfXJldHVybiBuLnV0aWwuaXNBcnJheShlKXx8KGU9W2UuZ2V0SW50MzIoKSxlLmdldEludDMyKCksZS5nZXRJbnQzMigpLGUuZ2V0SW50MzIoKV0pLGV9ZnVuY3Rpb24gcyhlKXtlW2UubGVuZ3RoLTFdPWVbZS5sZW5ndGgtMV0rMSY0Mjk0OTY3Mjk1fWZ1bmN0aW9uIG8oZSl7cmV0dXJuW2UvNDI5NDk2NzI5NnwwLDQyOTQ5NjcyOTUmZV19aS5lY2I9ZnVuY3Rpb24oZSl7ZT1lfHx7fSx0aGlzLm5hbWU9XCJFQ0JcIix0aGlzLmNpcGhlcj1lLmNpcGhlcix0aGlzLmJsb2NrU2l6ZT1lLmJsb2NrU2l6ZXx8MTYsdGhpcy5faW50cz10aGlzLmJsb2NrU2l6ZS80LHRoaXMuX2luQmxvY2s9bmV3IEFycmF5KHRoaXMuX2ludHMpLHRoaXMuX291dEJsb2NrPW5ldyBBcnJheSh0aGlzLl9pbnRzKX0saS5lY2IucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGUpe30saS5lY2IucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe2lmKGUubGVuZ3RoKCk8dGhpcy5ibG9ja1NpemUmJiEociYmZS5sZW5ndGgoKT4wKSlyZXR1cm4hMDtmb3IodmFyIG49MDtuPHRoaXMuX2ludHM7KytuKXRoaXMuX2luQmxvY2tbbl09ZS5nZXRJbnQzMigpO3RoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jayx0aGlzLl9vdXRCbG9jayk7Zm9yKG49MDtuPHRoaXMuX2ludHM7KytuKXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbbl0pfSxpLmVjYi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihlLHQscil7aWYoZS5sZW5ndGgoKTx0aGlzLmJsb2NrU2l6ZSYmIShyJiZlLmxlbmd0aCgpPjApKXJldHVybiEwO2Zvcih2YXIgbj0wO248dGhpcy5faW50czsrK24pdGhpcy5faW5CbG9ja1tuXT1lLmdldEludDMyKCk7dGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLHRoaXMuX291dEJsb2NrKTtmb3Iobj0wO248dGhpcy5faW50czsrK24pdC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tuXSl9LGkuZWNiLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj1lLmxlbmd0aCgpPT09dGhpcy5ibG9ja1NpemU/dGhpcy5ibG9ja1NpemU6dGhpcy5ibG9ja1NpemUtZS5sZW5ndGgoKTtyZXR1cm4gZS5maWxsV2l0aEJ5dGUocixyKSwhMH0saS5lY2IucHJvdG90eXBlLnVucGFkPWZ1bmN0aW9uKGUsdCl7aWYodC5vdmVyZmxvdz4wKXJldHVybiExO3ZhciByPWUubGVuZ3RoKCksbj1lLmF0KHItMSk7cmV0dXJuIShuPnRoaXMuYmxvY2tTaXplPDwyKSYmKGUudHJ1bmNhdGUobiksITApfSxpLmNiYz1mdW5jdGlvbihlKXtlPWV8fHt9LHRoaXMubmFtZT1cIkNCQ1wiLHRoaXMuY2lwaGVyPWUuY2lwaGVyLHRoaXMuYmxvY2tTaXplPWUuYmxvY2tTaXplfHwxNix0aGlzLl9pbnRzPXRoaXMuYmxvY2tTaXplLzQsdGhpcy5faW5CbG9jaz1uZXcgQXJyYXkodGhpcy5faW50cyksdGhpcy5fb3V0QmxvY2s9bmV3IEFycmF5KHRoaXMuX2ludHMpfSxpLmNiYy5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oZSl7aWYobnVsbD09PWUuaXYpe2lmKCF0aGlzLl9wcmV2KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVYgcGFyYW1ldGVyLlwiKTt0aGlzLl9pdj10aGlzLl9wcmV2LnNsaWNlKDApfWVsc2V7aWYoIShcIml2XCJpbiBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElWIHBhcmFtZXRlci5cIik7dGhpcy5faXY9YShlLml2KSx0aGlzLl9wcmV2PXRoaXMuX2l2LnNsaWNlKDApfX0saS5jYmMucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe2lmKGUubGVuZ3RoKCk8dGhpcy5ibG9ja1NpemUmJiEociYmZS5sZW5ndGgoKT4wKSlyZXR1cm4hMDtmb3IodmFyIG49MDtuPHRoaXMuX2ludHM7KytuKXRoaXMuX2luQmxvY2tbbl09dGhpcy5fcHJldltuXV5lLmdldEludDMyKCk7dGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLHRoaXMuX291dEJsb2NrKTtmb3Iobj0wO248dGhpcy5faW50czsrK24pdC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tuXSk7dGhpcy5fcHJldj10aGlzLl9vdXRCbG9ja30saS5jYmMucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe2lmKGUubGVuZ3RoKCk8dGhpcy5ibG9ja1NpemUmJiEociYmZS5sZW5ndGgoKT4wKSlyZXR1cm4hMDtmb3IodmFyIG49MDtuPHRoaXMuX2ludHM7KytuKXRoaXMuX2luQmxvY2tbbl09ZS5nZXRJbnQzMigpO3RoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jayx0aGlzLl9vdXRCbG9jayk7Zm9yKG49MDtuPHRoaXMuX2ludHM7KytuKXQucHV0SW50MzIodGhpcy5fcHJldltuXV50aGlzLl9vdXRCbG9ja1tuXSk7dGhpcy5fcHJldj10aGlzLl9pbkJsb2NrLnNsaWNlKDApfSxpLmNiYy5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGUsdCl7dmFyIHI9ZS5sZW5ndGgoKT09PXRoaXMuYmxvY2tTaXplP3RoaXMuYmxvY2tTaXplOnRoaXMuYmxvY2tTaXplLWUubGVuZ3RoKCk7cmV0dXJuIGUuZmlsbFdpdGhCeXRlKHIsciksITB9LGkuY2JjLnByb3RvdHlwZS51bnBhZD1mdW5jdGlvbihlLHQpe2lmKHQub3ZlcmZsb3c+MClyZXR1cm4hMTt2YXIgcj1lLmxlbmd0aCgpLG49ZS5hdChyLTEpO3JldHVybiEobj50aGlzLmJsb2NrU2l6ZTw8MikmJihlLnRydW5jYXRlKG4pLCEwKX0saS5jZmI9ZnVuY3Rpb24oZSl7ZT1lfHx7fSx0aGlzLm5hbWU9XCJDRkJcIix0aGlzLmNpcGhlcj1lLmNpcGhlcix0aGlzLmJsb2NrU2l6ZT1lLmJsb2NrU2l6ZXx8MTYsdGhpcy5faW50cz10aGlzLmJsb2NrU2l6ZS80LHRoaXMuX2luQmxvY2s9bnVsbCx0aGlzLl9vdXRCbG9jaz1uZXcgQXJyYXkodGhpcy5faW50cyksdGhpcy5fcGFydGlhbEJsb2NrPW5ldyBBcnJheSh0aGlzLl9pbnRzKSx0aGlzLl9wYXJ0aWFsT3V0cHV0PW4udXRpbC5jcmVhdGVCdWZmZXIoKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH0saS5jZmIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGUpe2lmKCEoXCJpdlwiaW4gZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJViBwYXJhbWV0ZXIuXCIpO3RoaXMuX2l2PWEoZS5pdiksdGhpcy5faW5CbG9jaz10aGlzLl9pdi5zbGljZSgwKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH0saS5jZmIucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUubGVuZ3RoKCk7aWYoMD09PW4pcmV0dXJuITA7aWYodGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLHRoaXMuX291dEJsb2NrKSwwPT09dGhpcy5fcGFydGlhbEJ5dGVzJiZuPj10aGlzLmJsb2NrU2l6ZSlmb3IodmFyIGk9MDtpPHRoaXMuX2ludHM7KytpKXRoaXMuX2luQmxvY2tbaV09ZS5nZXRJbnQzMigpXnRoaXMuX291dEJsb2NrW2ldLHQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSk7ZWxzZXt2YXIgYT0odGhpcy5ibG9ja1NpemUtbikldGhpcy5ibG9ja1NpemU7YT4wJiYoYT10aGlzLmJsb2NrU2l6ZS1hKSx0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7Zm9yKGk9MDtpPHRoaXMuX2ludHM7KytpKXRoaXMuX3BhcnRpYWxCbG9ja1tpXT1lLmdldEludDMyKCledGhpcy5fb3V0QmxvY2tbaV0sdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0pO2lmKGE+MCllLnJlYWQtPXRoaXMuYmxvY2tTaXplO2Vsc2UgZm9yKGk9MDtpPHRoaXMuX2ludHM7KytpKXRoaXMuX2luQmxvY2tbaV09dGhpcy5fcGFydGlhbEJsb2NrW2ldO2lmKHRoaXMuX3BhcnRpYWxCeXRlcz4wJiZ0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyksYT4wJiYhcilyZXR1cm4gdC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKGEtdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPWEsITA7dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKG4tdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPTB9fSxpLmNmYi5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihlLHQscil7dmFyIG49ZS5sZW5ndGgoKTtpZigwPT09bilyZXR1cm4hMDtpZih0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssdGhpcy5fb3V0QmxvY2spLDA9PT10aGlzLl9wYXJ0aWFsQnl0ZXMmJm4+PXRoaXMuYmxvY2tTaXplKWZvcih2YXIgaT0wO2k8dGhpcy5faW50czsrK2kpdGhpcy5faW5CbG9ja1tpXT1lLmdldEludDMyKCksdC5wdXRJbnQzMih0aGlzLl9pbkJsb2NrW2ldXnRoaXMuX291dEJsb2NrW2ldKTtlbHNle3ZhciBhPSh0aGlzLmJsb2NrU2l6ZS1uKSV0aGlzLmJsb2NrU2l6ZTthPjAmJihhPXRoaXMuYmxvY2tTaXplLWEpLHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtmb3IoaT0wO2k8dGhpcy5faW50czsrK2kpdGhpcy5fcGFydGlhbEJsb2NrW2ldPWUuZ2V0SW50MzIoKSx0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKHRoaXMuX3BhcnRpYWxCbG9ja1tpXV50aGlzLl9vdXRCbG9ja1tpXSk7aWYoYT4wKWUucmVhZC09dGhpcy5ibG9ja1NpemU7ZWxzZSBmb3IoaT0wO2k8dGhpcy5faW50czsrK2kpdGhpcy5faW5CbG9ja1tpXT10aGlzLl9wYXJ0aWFsQmxvY2tbaV07aWYodGhpcy5fcGFydGlhbEJ5dGVzPjAmJnRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKSxhPjAmJiFyKXJldHVybiB0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoYS10aGlzLl9wYXJ0aWFsQnl0ZXMpKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9YSwhMDt0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMobi10aGlzLl9wYXJ0aWFsQnl0ZXMpKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH19LGkub2ZiPWZ1bmN0aW9uKGUpe2U9ZXx8e30sdGhpcy5uYW1lPVwiT0ZCXCIsdGhpcy5jaXBoZXI9ZS5jaXBoZXIsdGhpcy5ibG9ja1NpemU9ZS5ibG9ja1NpemV8fDE2LHRoaXMuX2ludHM9dGhpcy5ibG9ja1NpemUvNCx0aGlzLl9pbkJsb2NrPW51bGwsdGhpcy5fb3V0QmxvY2s9bmV3IEFycmF5KHRoaXMuX2ludHMpLHRoaXMuX3BhcnRpYWxPdXRwdXQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLHRoaXMuX3BhcnRpYWxCeXRlcz0wfSxpLm9mYi5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oZSl7aWYoIShcIml2XCJpbiBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElWIHBhcmFtZXRlci5cIik7dGhpcy5faXY9YShlLml2KSx0aGlzLl9pbkJsb2NrPXRoaXMuX2l2LnNsaWNlKDApLHRoaXMuX3BhcnRpYWxCeXRlcz0wfSxpLm9mYi5wcm90b3R5cGUuZW5jcnlwdD1mdW5jdGlvbihlLHQscil7dmFyIG49ZS5sZW5ndGgoKTtpZigwPT09ZS5sZW5ndGgoKSlyZXR1cm4hMDtpZih0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssdGhpcy5fb3V0QmxvY2spLDA9PT10aGlzLl9wYXJ0aWFsQnl0ZXMmJm4+PXRoaXMuYmxvY2tTaXplKWZvcih2YXIgaT0wO2k8dGhpcy5faW50czsrK2kpdC5wdXRJbnQzMihlLmdldEludDMyKCledGhpcy5fb3V0QmxvY2tbaV0pLHRoaXMuX2luQmxvY2tbaV09dGhpcy5fb3V0QmxvY2tbaV07ZWxzZXt2YXIgYT0odGhpcy5ibG9ja1NpemUtbikldGhpcy5ibG9ja1NpemU7YT4wJiYoYT10aGlzLmJsb2NrU2l6ZS1hKSx0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7Zm9yKGk9MDtpPHRoaXMuX2ludHM7KytpKXRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIoZS5nZXRJbnQzMigpXnRoaXMuX291dEJsb2NrW2ldKTtpZihhPjApZS5yZWFkLT10aGlzLmJsb2NrU2l6ZTtlbHNlIGZvcihpPTA7aTx0aGlzLl9pbnRzOysraSl0aGlzLl9pbkJsb2NrW2ldPXRoaXMuX291dEJsb2NrW2ldO2lmKHRoaXMuX3BhcnRpYWxCeXRlcz4wJiZ0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyksYT4wJiYhcilyZXR1cm4gdC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKGEtdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPWEsITA7dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKG4tdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPTB9fSxpLm9mYi5wcm90b3R5cGUuZGVjcnlwdD1pLm9mYi5wcm90b3R5cGUuZW5jcnlwdCxpLmN0cj1mdW5jdGlvbihlKXtlPWV8fHt9LHRoaXMubmFtZT1cIkNUUlwiLHRoaXMuY2lwaGVyPWUuY2lwaGVyLHRoaXMuYmxvY2tTaXplPWUuYmxvY2tTaXplfHwxNix0aGlzLl9pbnRzPXRoaXMuYmxvY2tTaXplLzQsdGhpcy5faW5CbG9jaz1udWxsLHRoaXMuX291dEJsb2NrPW5ldyBBcnJheSh0aGlzLl9pbnRzKSx0aGlzLl9wYXJ0aWFsT3V0cHV0PW4udXRpbC5jcmVhdGVCdWZmZXIoKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH0saS5jdHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKGUpe2lmKCEoXCJpdlwiaW4gZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJViBwYXJhbWV0ZXIuXCIpO3RoaXMuX2l2PWEoZS5pdiksdGhpcy5faW5CbG9jaz10aGlzLl9pdi5zbGljZSgwKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH0saS5jdHIucHJvdG90eXBlLmVuY3J5cHQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPWUubGVuZ3RoKCk7aWYoMD09PW4pcmV0dXJuITA7aWYodGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLHRoaXMuX291dEJsb2NrKSwwPT09dGhpcy5fcGFydGlhbEJ5dGVzJiZuPj10aGlzLmJsb2NrU2l6ZSlmb3IodmFyIGk9MDtpPHRoaXMuX2ludHM7KytpKXQucHV0SW50MzIoZS5nZXRJbnQzMigpXnRoaXMuX291dEJsb2NrW2ldKTtlbHNle3ZhciBhPSh0aGlzLmJsb2NrU2l6ZS1uKSV0aGlzLmJsb2NrU2l6ZTthPjAmJihhPXRoaXMuYmxvY2tTaXplLWEpLHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtmb3IoaT0wO2k8dGhpcy5faW50czsrK2kpdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihlLmdldEludDMyKCledGhpcy5fb3V0QmxvY2tbaV0pO2lmKGE+MCYmKGUucmVhZC09dGhpcy5ibG9ja1NpemUpLHRoaXMuX3BhcnRpYWxCeXRlcz4wJiZ0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyksYT4wJiYhcilyZXR1cm4gdC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKGEtdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPWEsITA7dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKG4tdGhpcy5fcGFydGlhbEJ5dGVzKSksdGhpcy5fcGFydGlhbEJ5dGVzPTB9cyh0aGlzLl9pbkJsb2NrKX0saS5jdHIucHJvdG90eXBlLmRlY3J5cHQ9aS5jdHIucHJvdG90eXBlLmVuY3J5cHQsaS5nY209ZnVuY3Rpb24oZSl7ZT1lfHx7fSx0aGlzLm5hbWU9XCJHQ01cIix0aGlzLmNpcGhlcj1lLmNpcGhlcix0aGlzLmJsb2NrU2l6ZT1lLmJsb2NrU2l6ZXx8MTYsdGhpcy5faW50cz10aGlzLmJsb2NrU2l6ZS80LHRoaXMuX2luQmxvY2s9bmV3IEFycmF5KHRoaXMuX2ludHMpLHRoaXMuX291dEJsb2NrPW5ldyBBcnJheSh0aGlzLl9pbnRzKSx0aGlzLl9wYXJ0aWFsT3V0cHV0PW4udXRpbC5jcmVhdGVCdWZmZXIoKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MCx0aGlzLl9SPTM3NzQ4NzM2MDB9LGkuZ2NtLnByb3RvdHlwZS5zdGFydD1mdW5jdGlvbihlKXtpZighKFwiaXZcImluIGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVYgcGFyYW1ldGVyLlwiKTt2YXIgdCxyPW4udXRpbC5jcmVhdGVCdWZmZXIoZS5pdik7aWYodGhpcy5fY2lwaGVyTGVuZ3RoPTAsdD1cImFkZGl0aW9uYWxEYXRhXCJpbiBlP24udXRpbC5jcmVhdGVCdWZmZXIoZS5hZGRpdGlvbmFsRGF0YSk6bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLHRoaXMuX3RhZ0xlbmd0aD1cInRhZ0xlbmd0aFwiaW4gZT9lLnRhZ0xlbmd0aDoxMjgsdGhpcy5fdGFnPW51bGwsZS5kZWNyeXB0JiYodGhpcy5fdGFnPW4udXRpbC5jcmVhdGVCdWZmZXIoZS50YWcpLmdldEJ5dGVzKCksdGhpcy5fdGFnLmxlbmd0aCE9PXRoaXMuX3RhZ0xlbmd0aC84KSl0aHJvdyBuZXcgRXJyb3IoXCJBdXRoZW50aWNhdGlvbiB0YWcgZG9lcyBub3QgbWF0Y2ggdGFnIGxlbmd0aC5cIik7dGhpcy5faGFzaEJsb2NrPW5ldyBBcnJheSh0aGlzLl9pbnRzKSx0aGlzLnRhZz1udWxsLHRoaXMuX2hhc2hTdWJrZXk9bmV3IEFycmF5KHRoaXMuX2ludHMpLHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsMCwwLDBdLHRoaXMuX2hhc2hTdWJrZXkpLHRoaXMuY29tcG9uZW50Qml0cz00LHRoaXMuX209dGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LHRoaXMuY29tcG9uZW50Qml0cyk7dmFyIGk9ci5sZW5ndGgoKTtpZigxMj09PWkpdGhpcy5fajA9W3IuZ2V0SW50MzIoKSxyLmdldEludDMyKCksci5nZXRJbnQzMigpLDFdO2Vsc2V7Zm9yKHRoaXMuX2owPVswLDAsMCwwXTtyLmxlbmd0aCgpPjA7KXRoaXMuX2owPXRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSx0aGlzLl9qMCxbci5nZXRJbnQzMigpLHIuZ2V0SW50MzIoKSxyLmdldEludDMyKCksci5nZXRJbnQzMigpXSk7dGhpcy5fajA9dGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LHRoaXMuX2owLFswLDBdLmNvbmNhdChvKDgqaSkpKX10aGlzLl9pbkJsb2NrPXRoaXMuX2owLnNsaWNlKDApLHModGhpcy5faW5CbG9jayksdGhpcy5fcGFydGlhbEJ5dGVzPTAsdD1uLnV0aWwuY3JlYXRlQnVmZmVyKHQpLHRoaXMuX2FEYXRhTGVuZ3RoPW8oOCp0Lmxlbmd0aCgpKTt2YXIgYT10Lmxlbmd0aCgpJXRoaXMuYmxvY2tTaXplO2ZvcihhJiZ0LmZpbGxXaXRoQnl0ZSgwLHRoaXMuYmxvY2tTaXplLWEpLHRoaXMuX3M9WzAsMCwwLDBdO3QubGVuZ3RoKCk+MDspdGhpcy5fcz10aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksdGhpcy5fcyxbdC5nZXRJbnQzMigpLHQuZ2V0SW50MzIoKSx0LmdldEludDMyKCksdC5nZXRJbnQzMigpXSl9LGkuZ2NtLnByb3RvdHlwZS5lbmNyeXB0PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1lLmxlbmd0aCgpO2lmKDA9PT1uKXJldHVybiEwO2lmKHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jayx0aGlzLl9vdXRCbG9jayksMD09PXRoaXMuX3BhcnRpYWxCeXRlcyYmbj49dGhpcy5ibG9ja1NpemUpe2Zvcih2YXIgaT0wO2k8dGhpcy5faW50czsrK2kpdC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXV49ZS5nZXRJbnQzMigpKTt0aGlzLl9jaXBoZXJMZW5ndGgrPXRoaXMuYmxvY2tTaXplfWVsc2V7dmFyIGE9KHRoaXMuYmxvY2tTaXplLW4pJXRoaXMuYmxvY2tTaXplO2E+MCYmKGE9dGhpcy5ibG9ja1NpemUtYSksdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO2ZvcihpPTA7aTx0aGlzLl9pbnRzOysraSl0aGlzLl9wYXJ0aWFsT3V0cHV0LnB1dEludDMyKGUuZ2V0SW50MzIoKV50aGlzLl9vdXRCbG9ja1tpXSk7aWYoYTw9MHx8cil7aWYocil7dmFyIG89biV0aGlzLmJsb2NrU2l6ZTt0aGlzLl9jaXBoZXJMZW5ndGgrPW8sdGhpcy5fcGFydGlhbE91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZS1vKX1lbHNlIHRoaXMuX2NpcGhlckxlbmd0aCs9dGhpcy5ibG9ja1NpemU7Zm9yKGk9MDtpPHRoaXMuX2ludHM7KytpKXRoaXMuX291dEJsb2NrW2ldPXRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0SW50MzIoKTt0aGlzLl9wYXJ0aWFsT3V0cHV0LnJlYWQtPXRoaXMuYmxvY2tTaXplfWlmKHRoaXMuX3BhcnRpYWxCeXRlcz4wJiZ0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyksYT4wJiYhcilyZXR1cm4gZS5yZWFkLT10aGlzLmJsb2NrU2l6ZSx0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoYS10aGlzLl9wYXJ0aWFsQnl0ZXMpKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9YSwhMDt0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMobi10aGlzLl9wYXJ0aWFsQnl0ZXMpKSx0aGlzLl9wYXJ0aWFsQnl0ZXM9MH10aGlzLl9zPXRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSx0aGlzLl9zLHRoaXMuX291dEJsb2NrKSxzKHRoaXMuX2luQmxvY2spfSxpLmdjbS5wcm90b3R5cGUuZGVjcnlwdD1mdW5jdGlvbihlLHQscil7dmFyIG49ZS5sZW5ndGgoKTtpZihuPHRoaXMuYmxvY2tTaXplJiYhKHImJm4+MCkpcmV0dXJuITA7dGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLHRoaXMuX291dEJsb2NrKSxzKHRoaXMuX2luQmxvY2spLHRoaXMuX2hhc2hCbG9ja1swXT1lLmdldEludDMyKCksdGhpcy5faGFzaEJsb2NrWzFdPWUuZ2V0SW50MzIoKSx0aGlzLl9oYXNoQmxvY2tbMl09ZS5nZXRJbnQzMigpLHRoaXMuX2hhc2hCbG9ja1szXT1lLmdldEludDMyKCksdGhpcy5fcz10aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksdGhpcy5fcyx0aGlzLl9oYXNoQmxvY2spO2Zvcih2YXIgaT0wO2k8dGhpcy5faW50czsrK2kpdC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXV50aGlzLl9oYXNoQmxvY2tbaV0pO248dGhpcy5ibG9ja1NpemU/dGhpcy5fY2lwaGVyTGVuZ3RoKz1uJXRoaXMuYmxvY2tTaXplOnRoaXMuX2NpcGhlckxlbmd0aCs9dGhpcy5ibG9ja1NpemV9LGkuZ2NtLnByb3RvdHlwZS5hZnRlckZpbmlzaD1mdW5jdGlvbihlLHQpe3ZhciByPSEwO3QuZGVjcnlwdCYmdC5vdmVyZmxvdyYmZS50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZS10Lm92ZXJmbG93KSx0aGlzLnRhZz1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7dmFyIGk9dGhpcy5fYURhdGFMZW5ndGguY29uY2F0KG8oOCp0aGlzLl9jaXBoZXJMZW5ndGgpKTt0aGlzLl9zPXRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSx0aGlzLl9zLGkpO3ZhciBhPVtdO3RoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5fajAsYSk7Zm9yKHZhciBzPTA7czx0aGlzLl9pbnRzOysrcyl0aGlzLnRhZy5wdXRJbnQzMih0aGlzLl9zW3NdXmFbc10pO3JldHVybiB0aGlzLnRhZy50cnVuY2F0ZSh0aGlzLnRhZy5sZW5ndGgoKSUodGhpcy5fdGFnTGVuZ3RoLzgpKSx0LmRlY3J5cHQmJnRoaXMudGFnLmJ5dGVzKCkhPT10aGlzLl90YWcmJihyPSExKSxyfSxpLmdjbS5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9WzAsMCwwLDBdLG49dC5zbGljZSgwKSxpPTA7aTwxMjg7KytpKXtlW2kvMzJ8MF0mMTw8MzEtaSUzMiYmKHJbMF1ePW5bMF0sclsxXV49blsxXSxyWzJdXj1uWzJdLHJbM11ePW5bM10pLHRoaXMucG93KG4sbil9cmV0dXJuIHJ9LGkuZ2NtLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9MSZlWzNdLG49MztuPjA7LS1uKXRbbl09ZVtuXT4+PjF8KDEmZVtuLTFdKTw8MzE7dFswXT1lWzBdPj4+MSxyJiYodFswXV49dGhpcy5fUil9LGkuZ2NtLnByb3RvdHlwZS50YWJsZU11bHRpcGx5PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bMCwwLDAsMF0scj0wO3I8MzI7KytyKXt2YXIgbj1lW3IvOHwwXT4+PjQqKDctciU4KSYxNSxpPXRoaXMuX21bcl1bbl07dFswXV49aVswXSx0WzFdXj1pWzFdLHRbMl1ePWlbMl0sdFszXV49aVszXX1yZXR1cm4gdH0saS5nY20ucHJvdG90eXBlLmdoYXNoPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdFswXV49clswXSx0WzFdXj1yWzFdLHRbMl1ePXJbMl0sdFszXV49clszXSx0aGlzLnRhYmxlTXVsdGlwbHkodCl9LGkuZ2NtLnByb3RvdHlwZS5nZW5lcmF0ZUhhc2hUYWJsZT1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj04L3Qsbj00KnIsaT0xNipyLGE9bmV3IEFycmF5KGkpLHM9MDtzPGk7KytzKXt2YXIgbz1bMCwwLDAsMF0sdT0obi0xLXMlbikqdDtvW3MvbnwwXT0xPDx0LTE8PHUsYVtzXT10aGlzLmdlbmVyYXRlU3ViSGFzaFRhYmxlKHRoaXMubXVsdGlwbHkobyxlKSx0KX1yZXR1cm4gYX0saS5nY20ucHJvdG90eXBlLmdlbmVyYXRlU3ViSGFzaFRhYmxlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9MTw8dCxuPXI+Pj4xLGk9bmV3IEFycmF5KHIpO2lbbl09ZS5zbGljZSgwKTtmb3IodmFyIGE9bj4+PjE7YT4wOyl0aGlzLnBvdyhpWzIqYV0saVthXT1bXSksYT4+PTE7Zm9yKGE9MjthPG47KXtmb3IodmFyIHM9MTtzPGE7KytzKXt2YXIgbz1pW2FdLHU9aVtzXTtpW2Erc109W29bMF1edVswXSxvWzFdXnVbMV0sb1syXV51WzJdLG9bM11edVszXV19YSo9Mn1mb3IoaVswXT1bMCwwLDAsMF0sYT1uKzE7YTxyOysrYSl7dmFyIGM9aVthXm5dO2lbYV09W2VbMF1eY1swXSxlWzFdXmNbMV0sZVsyXV5jWzJdLGVbM11eY1szXV19cmV0dXJuIGl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zZWVkV29yZHNMaXN0PVtcImFiYW5kb25cIixcImFiaWxpdHlcIixcImFibGVcIixcImFib3V0XCIsXCJhYm92ZVwiLFwiYWJzZW50XCIsXCJhYnNvcmJcIixcImFic3RyYWN0XCIsXCJhYnN1cmRcIixcImFidXNlXCIsXCJhY2Nlc3NcIixcImFjY2lkZW50XCIsXCJhY2NvdW50XCIsXCJhY2N1c2VcIixcImFjaGlldmVcIixcImFjaWRcIixcImFjb3VzdGljXCIsXCJhY3F1aXJlXCIsXCJhY3Jvc3NcIixcImFjdFwiLFwiYWN0aW9uXCIsXCJhY3RvclwiLFwiYWN0cmVzc1wiLFwiYWN0dWFsXCIsXCJhZGFwdFwiLFwiYWRkXCIsXCJhZGRpY3RcIixcImFkZHJlc3NcIixcImFkanVzdFwiLFwiYWRtaXRcIixcImFkdWx0XCIsXCJhZHZhbmNlXCIsXCJhZHZpY2VcIixcImFlcm9iaWNcIixcImFmZmFpclwiLFwiYWZmb3JkXCIsXCJhZnJhaWRcIixcImFnYWluXCIsXCJhZ2VcIixcImFnZW50XCIsXCJhZ3JlZVwiLFwiYWhlYWRcIixcImFpbVwiLFwiYWlyXCIsXCJhaXJwb3J0XCIsXCJhaXNsZVwiLFwiYWxhcm1cIixcImFsYnVtXCIsXCJhbGNvaG9sXCIsXCJhbGVydFwiLFwiYWxpZW5cIixcImFsbFwiLFwiYWxsZXlcIixcImFsbG93XCIsXCJhbG1vc3RcIixcImFsb25lXCIsXCJhbHBoYVwiLFwiYWxyZWFkeVwiLFwiYWxzb1wiLFwiYWx0ZXJcIixcImFsd2F5c1wiLFwiYW1hdGV1clwiLFwiYW1hemluZ1wiLFwiYW1vbmdcIixcImFtb3VudFwiLFwiYW11c2VkXCIsXCJhbmFseXN0XCIsXCJhbmNob3JcIixcImFuY2llbnRcIixcImFuZ2VyXCIsXCJhbmdsZVwiLFwiYW5ncnlcIixcImFuaW1hbFwiLFwiYW5rbGVcIixcImFubm91bmNlXCIsXCJhbm51YWxcIixcImFub3RoZXJcIixcImFuc3dlclwiLFwiYW50ZW5uYVwiLFwiYW50aXF1ZVwiLFwiYW54aWV0eVwiLFwiYW55XCIsXCJhcGFydFwiLFwiYXBvbG9neVwiLFwiYXBwZWFyXCIsXCJhcHBsZVwiLFwiYXBwcm92ZVwiLFwiYXByaWxcIixcImFyY2hcIixcImFyY3RpY1wiLFwiYXJlYVwiLFwiYXJlbmFcIixcImFyZ3VlXCIsXCJhcm1cIixcImFybWVkXCIsXCJhcm1vclwiLFwiYXJteVwiLFwiYXJvdW5kXCIsXCJhcnJhbmdlXCIsXCJhcnJlc3RcIixcImFycml2ZVwiLFwiYXJyb3dcIixcImFydFwiLFwiYXJ0ZWZhY3RcIixcImFydGlzdFwiLFwiYXJ0d29ya1wiLFwiYXNrXCIsXCJhc3BlY3RcIixcImFzc2F1bHRcIixcImFzc2V0XCIsXCJhc3Npc3RcIixcImFzc3VtZVwiLFwiYXN0aG1hXCIsXCJhdGhsZXRlXCIsXCJhdG9tXCIsXCJhdHRhY2tcIixcImF0dGVuZFwiLFwiYXR0aXR1ZGVcIixcImF0dHJhY3RcIixcImF1Y3Rpb25cIixcImF1ZGl0XCIsXCJhdWd1c3RcIixcImF1bnRcIixcImF1dGhvclwiLFwiYXV0b1wiLFwiYXV0dW1uXCIsXCJhdmVyYWdlXCIsXCJhdm9jYWRvXCIsXCJhdm9pZFwiLFwiYXdha2VcIixcImF3YXJlXCIsXCJhd2F5XCIsXCJhd2Vzb21lXCIsXCJhd2Z1bFwiLFwiYXdrd2FyZFwiLFwiYXhpc1wiLFwiYmFieVwiLFwiYmFjaGVsb3JcIixcImJhY29uXCIsXCJiYWRnZVwiLFwiYmFnXCIsXCJiYWxhbmNlXCIsXCJiYWxjb255XCIsXCJiYWxsXCIsXCJiYW1ib29cIixcImJhbmFuYVwiLFwiYmFubmVyXCIsXCJiYXJcIixcImJhcmVseVwiLFwiYmFyZ2FpblwiLFwiYmFycmVsXCIsXCJiYXNlXCIsXCJiYXNpY1wiLFwiYmFza2V0XCIsXCJiYXR0bGVcIixcImJlYWNoXCIsXCJiZWFuXCIsXCJiZWF1dHlcIixcImJlY2F1c2VcIixcImJlY29tZVwiLFwiYmVlZlwiLFwiYmVmb3JlXCIsXCJiZWdpblwiLFwiYmVoYXZlXCIsXCJiZWhpbmRcIixcImJlbGlldmVcIixcImJlbG93XCIsXCJiZWx0XCIsXCJiZW5jaFwiLFwiYmVuZWZpdFwiLFwiYmVzdFwiLFwiYmV0cmF5XCIsXCJiZXR0ZXJcIixcImJldHdlZW5cIixcImJleW9uZFwiLFwiYmljeWNsZVwiLFwiYmlkXCIsXCJiaWtlXCIsXCJiaW5kXCIsXCJiaW9sb2d5XCIsXCJiaXJkXCIsXCJiaXJ0aFwiLFwiYml0dGVyXCIsXCJibGFja1wiLFwiYmxhZGVcIixcImJsYW1lXCIsXCJibGFua2V0XCIsXCJibGFzdFwiLFwiYmxlYWtcIixcImJsZXNzXCIsXCJibGluZFwiLFwiYmxvb2RcIixcImJsb3Nzb21cIixcImJsb3VzZVwiLFwiYmx1ZVwiLFwiYmx1clwiLFwiYmx1c2hcIixcImJvYXJkXCIsXCJib2F0XCIsXCJib2R5XCIsXCJib2lsXCIsXCJib21iXCIsXCJib25lXCIsXCJib251c1wiLFwiYm9va1wiLFwiYm9vc3RcIixcImJvcmRlclwiLFwiYm9yaW5nXCIsXCJib3Jyb3dcIixcImJvc3NcIixcImJvdHRvbVwiLFwiYm91bmNlXCIsXCJib3hcIixcImJveVwiLFwiYnJhY2tldFwiLFwiYnJhaW5cIixcImJyYW5kXCIsXCJicmFzc1wiLFwiYnJhdmVcIixcImJyZWFkXCIsXCJicmVlemVcIixcImJyaWNrXCIsXCJicmlkZ2VcIixcImJyaWVmXCIsXCJicmlnaHRcIixcImJyaW5nXCIsXCJicmlza1wiLFwiYnJvY2NvbGlcIixcImJyb2tlblwiLFwiYnJvbnplXCIsXCJicm9vbVwiLFwiYnJvdGhlclwiLFwiYnJvd25cIixcImJydXNoXCIsXCJidWJibGVcIixcImJ1ZGR5XCIsXCJidWRnZXRcIixcImJ1ZmZhbG9cIixcImJ1aWxkXCIsXCJidWxiXCIsXCJidWxrXCIsXCJidWxsZXRcIixcImJ1bmRsZVwiLFwiYnVua2VyXCIsXCJidXJkZW5cIixcImJ1cmdlclwiLFwiYnVyc3RcIixcImJ1c1wiLFwiYnVzaW5lc3NcIixcImJ1c3lcIixcImJ1dHRlclwiLFwiYnV5ZXJcIixcImJ1enpcIixcImNhYmJhZ2VcIixcImNhYmluXCIsXCJjYWJsZVwiLFwiY2FjdHVzXCIsXCJjYWdlXCIsXCJjYWtlXCIsXCJjYWxsXCIsXCJjYWxtXCIsXCJjYW1lcmFcIixcImNhbXBcIixcImNhblwiLFwiY2FuYWxcIixcImNhbmNlbFwiLFwiY2FuZHlcIixcImNhbm5vblwiLFwiY2Fub2VcIixcImNhbnZhc1wiLFwiY2FueW9uXCIsXCJjYXBhYmxlXCIsXCJjYXBpdGFsXCIsXCJjYXB0YWluXCIsXCJjYXJcIixcImNhcmJvblwiLFwiY2FyZFwiLFwiY2FyZ29cIixcImNhcnBldFwiLFwiY2FycnlcIixcImNhcnRcIixcImNhc2VcIixcImNhc2hcIixcImNhc2lub1wiLFwiY2FzdGxlXCIsXCJjYXN1YWxcIixcImNhdFwiLFwiY2F0YWxvZ1wiLFwiY2F0Y2hcIixcImNhdGVnb3J5XCIsXCJjYXR0bGVcIixcImNhdWdodFwiLFwiY2F1c2VcIixcImNhdXRpb25cIixcImNhdmVcIixcImNlaWxpbmdcIixcImNlbGVyeVwiLFwiY2VtZW50XCIsXCJjZW5zdXNcIixcImNlbnR1cnlcIixcImNlcmVhbFwiLFwiY2VydGFpblwiLFwiY2hhaXJcIixcImNoYWxrXCIsXCJjaGFtcGlvblwiLFwiY2hhbmdlXCIsXCJjaGFvc1wiLFwiY2hhcHRlclwiLFwiY2hhcmdlXCIsXCJjaGFzZVwiLFwiY2hhdFwiLFwiY2hlYXBcIixcImNoZWNrXCIsXCJjaGVlc2VcIixcImNoZWZcIixcImNoZXJyeVwiLFwiY2hlc3RcIixcImNoaWNrZW5cIixcImNoaWVmXCIsXCJjaGlsZFwiLFwiY2hpbW5leVwiLFwiY2hvaWNlXCIsXCJjaG9vc2VcIixcImNocm9uaWNcIixcImNodWNrbGVcIixcImNodW5rXCIsXCJjaHVyblwiLFwiY2lnYXJcIixcImNpbm5hbW9uXCIsXCJjaXJjbGVcIixcImNpdGl6ZW5cIixcImNpdHlcIixcImNpdmlsXCIsXCJjbGFpbVwiLFwiY2xhcFwiLFwiY2xhcmlmeVwiLFwiY2xhd1wiLFwiY2xheVwiLFwiY2xlYW5cIixcImNsZXJrXCIsXCJjbGV2ZXJcIixcImNsaWNrXCIsXCJjbGllbnRcIixcImNsaWZmXCIsXCJjbGltYlwiLFwiY2xpbmljXCIsXCJjbGlwXCIsXCJjbG9ja1wiLFwiY2xvZ1wiLFwiY2xvc2VcIixcImNsb3RoXCIsXCJjbG91ZFwiLFwiY2xvd25cIixcImNsdWJcIixcImNsdW1wXCIsXCJjbHVzdGVyXCIsXCJjbHV0Y2hcIixcImNvYWNoXCIsXCJjb2FzdFwiLFwiY29jb251dFwiLFwiY29kZVwiLFwiY29mZmVlXCIsXCJjb2lsXCIsXCJjb2luXCIsXCJjb2xsZWN0XCIsXCJjb2xvclwiLFwiY29sdW1uXCIsXCJjb21iaW5lXCIsXCJjb21lXCIsXCJjb21mb3J0XCIsXCJjb21pY1wiLFwiY29tbW9uXCIsXCJjb21wYW55XCIsXCJjb25jZXJ0XCIsXCJjb25kdWN0XCIsXCJjb25maXJtXCIsXCJjb25ncmVzc1wiLFwiY29ubmVjdFwiLFwiY29uc2lkZXJcIixcImNvbnRyb2xcIixcImNvbnZpbmNlXCIsXCJjb29rXCIsXCJjb29sXCIsXCJjb3BwZXJcIixcImNvcHlcIixcImNvcmFsXCIsXCJjb3JlXCIsXCJjb3JuXCIsXCJjb3JyZWN0XCIsXCJjb3N0XCIsXCJjb3R0b25cIixcImNvdWNoXCIsXCJjb3VudHJ5XCIsXCJjb3VwbGVcIixcImNvdXJzZVwiLFwiY291c2luXCIsXCJjb3ZlclwiLFwiY295b3RlXCIsXCJjcmFja1wiLFwiY3JhZGxlXCIsXCJjcmFmdFwiLFwiY3JhbVwiLFwiY3JhbmVcIixcImNyYXNoXCIsXCJjcmF0ZXJcIixcImNyYXdsXCIsXCJjcmF6eVwiLFwiY3JlYW1cIixcImNyZWRpdFwiLFwiY3JlZWtcIixcImNyZXdcIixcImNyaWNrZXRcIixcImNyaW1lXCIsXCJjcmlzcFwiLFwiY3JpdGljXCIsXCJjcm9wXCIsXCJjcm9zc1wiLFwiY3JvdWNoXCIsXCJjcm93ZFwiLFwiY3J1Y2lhbFwiLFwiY3J1ZWxcIixcImNydWlzZVwiLFwiY3J1bWJsZVwiLFwiY3J1bmNoXCIsXCJjcnVzaFwiLFwiY3J5XCIsXCJjcnlzdGFsXCIsXCJjdWJlXCIsXCJjdWx0dXJlXCIsXCJjdXBcIixcImN1cGJvYXJkXCIsXCJjdXJpb3VzXCIsXCJjdXJyZW50XCIsXCJjdXJ0YWluXCIsXCJjdXJ2ZVwiLFwiY3VzaGlvblwiLFwiY3VzdG9tXCIsXCJjdXRlXCIsXCJjeWNsZVwiLFwiZGFkXCIsXCJkYW1hZ2VcIixcImRhbXBcIixcImRhbmNlXCIsXCJkYW5nZXJcIixcImRhcmluZ1wiLFwiZGFzaFwiLFwiZGF1Z2h0ZXJcIixcImRhd25cIixcImRheVwiLFwiZGVhbFwiLFwiZGViYXRlXCIsXCJkZWJyaXNcIixcImRlY2FkZVwiLFwiZGVjZW1iZXJcIixcImRlY2lkZVwiLFwiZGVjbGluZVwiLFwiZGVjb3JhdGVcIixcImRlY3JlYXNlXCIsXCJkZWVyXCIsXCJkZWZlbnNlXCIsXCJkZWZpbmVcIixcImRlZnlcIixcImRlZ3JlZVwiLFwiZGVsYXlcIixcImRlbGl2ZXJcIixcImRlbWFuZFwiLFwiZGVtaXNlXCIsXCJkZW5pYWxcIixcImRlbnRpc3RcIixcImRlbnlcIixcImRlcGFydFwiLFwiZGVwZW5kXCIsXCJkZXBvc2l0XCIsXCJkZXB0aFwiLFwiZGVwdXR5XCIsXCJkZXJpdmVcIixcImRlc2NyaWJlXCIsXCJkZXNlcnRcIixcImRlc2lnblwiLFwiZGVza1wiLFwiZGVzcGFpclwiLFwiZGVzdHJveVwiLFwiZGV0YWlsXCIsXCJkZXRlY3RcIixcImRldmVsb3BcIixcImRldmljZVwiLFwiZGV2b3RlXCIsXCJkaWFncmFtXCIsXCJkaWFsXCIsXCJkaWFtb25kXCIsXCJkaWFyeVwiLFwiZGljZVwiLFwiZGllc2VsXCIsXCJkaWV0XCIsXCJkaWZmZXJcIixcImRpZ2l0YWxcIixcImRpZ25pdHlcIixcImRpbGVtbWFcIixcImRpbm5lclwiLFwiZGlub3NhdXJcIixcImRpcmVjdFwiLFwiZGlydFwiLFwiZGlzYWdyZWVcIixcImRpc2NvdmVyXCIsXCJkaXNlYXNlXCIsXCJkaXNoXCIsXCJkaXNtaXNzXCIsXCJkaXNvcmRlclwiLFwiZGlzcGxheVwiLFwiZGlzdGFuY2VcIixcImRpdmVydFwiLFwiZGl2aWRlXCIsXCJkaXZvcmNlXCIsXCJkaXp6eVwiLFwiZG9jdG9yXCIsXCJkb2N1bWVudFwiLFwiZG9nXCIsXCJkb2xsXCIsXCJkb2xwaGluXCIsXCJkb21haW5cIixcImRvbmF0ZVwiLFwiZG9ua2V5XCIsXCJkb25vclwiLFwiZG9vclwiLFwiZG9zZVwiLFwiZG91YmxlXCIsXCJkb3ZlXCIsXCJkcmFmdFwiLFwiZHJhZ29uXCIsXCJkcmFtYVwiLFwiZHJhc3RpY1wiLFwiZHJhd1wiLFwiZHJlYW1cIixcImRyZXNzXCIsXCJkcmlmdFwiLFwiZHJpbGxcIixcImRyaW5rXCIsXCJkcmlwXCIsXCJkcml2ZVwiLFwiZHJvcFwiLFwiZHJ1bVwiLFwiZHJ5XCIsXCJkdWNrXCIsXCJkdW1iXCIsXCJkdW5lXCIsXCJkdXJpbmdcIixcImR1c3RcIixcImR1dGNoXCIsXCJkdXR5XCIsXCJkd2FyZlwiLFwiZHluYW1pY1wiLFwiZWFnZXJcIixcImVhZ2xlXCIsXCJlYXJseVwiLFwiZWFyblwiLFwiZWFydGhcIixcImVhc2lseVwiLFwiZWFzdFwiLFwiZWFzeVwiLFwiZWNob1wiLFwiZWNvbG9neVwiLFwiZWNvbm9teVwiLFwiZWRnZVwiLFwiZWRpdFwiLFwiZWR1Y2F0ZVwiLFwiZWZmb3J0XCIsXCJlZ2dcIixcImVpZ2h0XCIsXCJlaXRoZXJcIixcImVsYm93XCIsXCJlbGRlclwiLFwiZWxlY3RyaWNcIixcImVsZWdhbnRcIixcImVsZW1lbnRcIixcImVsZXBoYW50XCIsXCJlbGV2YXRvclwiLFwiZWxpdGVcIixcImVsc2VcIixcImVtYmFya1wiLFwiZW1ib2R5XCIsXCJlbWJyYWNlXCIsXCJlbWVyZ2VcIixcImVtb3Rpb25cIixcImVtcGxveVwiLFwiZW1wb3dlclwiLFwiZW1wdHlcIixcImVuYWJsZVwiLFwiZW5hY3RcIixcImVuZFwiLFwiZW5kbGVzc1wiLFwiZW5kb3JzZVwiLFwiZW5lbXlcIixcImVuZXJneVwiLFwiZW5mb3JjZVwiLFwiZW5nYWdlXCIsXCJlbmdpbmVcIixcImVuaGFuY2VcIixcImVuam95XCIsXCJlbmxpc3RcIixcImVub3VnaFwiLFwiZW5yaWNoXCIsXCJlbnJvbGxcIixcImVuc3VyZVwiLFwiZW50ZXJcIixcImVudGlyZVwiLFwiZW50cnlcIixcImVudmVsb3BlXCIsXCJlcGlzb2RlXCIsXCJlcXVhbFwiLFwiZXF1aXBcIixcImVyYVwiLFwiZXJhc2VcIixcImVyb2RlXCIsXCJlcm9zaW9uXCIsXCJlcnJvclwiLFwiZXJ1cHRcIixcImVzY2FwZVwiLFwiZXNzYXlcIixcImVzc2VuY2VcIixcImVzdGF0ZVwiLFwiZXRlcm5hbFwiLFwiZXRoaWNzXCIsXCJldmlkZW5jZVwiLFwiZXZpbFwiLFwiZXZva2VcIixcImV2b2x2ZVwiLFwiZXhhY3RcIixcImV4YW1wbGVcIixcImV4Y2Vzc1wiLFwiZXhjaGFuZ2VcIixcImV4Y2l0ZVwiLFwiZXhjbHVkZVwiLFwiZXhjdXNlXCIsXCJleGVjdXRlXCIsXCJleGVyY2lzZVwiLFwiZXhoYXVzdFwiLFwiZXhoaWJpdFwiLFwiZXhpbGVcIixcImV4aXN0XCIsXCJleGl0XCIsXCJleG90aWNcIixcImV4cGFuZFwiLFwiZXhwZWN0XCIsXCJleHBpcmVcIixcImV4cGxhaW5cIixcImV4cG9zZVwiLFwiZXhwcmVzc1wiLFwiZXh0ZW5kXCIsXCJleHRyYVwiLFwiZXllXCIsXCJleWVicm93XCIsXCJmYWJyaWNcIixcImZhY2VcIixcImZhY3VsdHlcIixcImZhZGVcIixcImZhaW50XCIsXCJmYWl0aFwiLFwiZmFsbFwiLFwiZmFsc2VcIixcImZhbWVcIixcImZhbWlseVwiLFwiZmFtb3VzXCIsXCJmYW5cIixcImZhbmN5XCIsXCJmYW50YXN5XCIsXCJmYXJtXCIsXCJmYXNoaW9uXCIsXCJmYXRcIixcImZhdGFsXCIsXCJmYXRoZXJcIixcImZhdGlndWVcIixcImZhdWx0XCIsXCJmYXZvcml0ZVwiLFwiZmVhdHVyZVwiLFwiZmVicnVhcnlcIixcImZlZGVyYWxcIixcImZlZVwiLFwiZmVlZFwiLFwiZmVlbFwiLFwiZmVtYWxlXCIsXCJmZW5jZVwiLFwiZmVzdGl2YWxcIixcImZldGNoXCIsXCJmZXZlclwiLFwiZmV3XCIsXCJmaWJlclwiLFwiZmljdGlvblwiLFwiZmllbGRcIixcImZpZ3VyZVwiLFwiZmlsZVwiLFwiZmlsbVwiLFwiZmlsdGVyXCIsXCJmaW5hbFwiLFwiZmluZFwiLFwiZmluZVwiLFwiZmluZ2VyXCIsXCJmaW5pc2hcIixcImZpcmVcIixcImZpcm1cIixcImZpcnN0XCIsXCJmaXNjYWxcIixcImZpc2hcIixcImZpdFwiLFwiZml0bmVzc1wiLFwiZml4XCIsXCJmbGFnXCIsXCJmbGFtZVwiLFwiZmxhc2hcIixcImZsYXRcIixcImZsYXZvclwiLFwiZmxlZVwiLFwiZmxpZ2h0XCIsXCJmbGlwXCIsXCJmbG9hdFwiLFwiZmxvY2tcIixcImZsb29yXCIsXCJmbG93ZXJcIixcImZsdWlkXCIsXCJmbHVzaFwiLFwiZmx5XCIsXCJmb2FtXCIsXCJmb2N1c1wiLFwiZm9nXCIsXCJmb2lsXCIsXCJmb2xkXCIsXCJmb2xsb3dcIixcImZvb2RcIixcImZvb3RcIixcImZvcmNlXCIsXCJmb3Jlc3RcIixcImZvcmdldFwiLFwiZm9ya1wiLFwiZm9ydHVuZVwiLFwiZm9ydW1cIixcImZvcndhcmRcIixcImZvc3NpbFwiLFwiZm9zdGVyXCIsXCJmb3VuZFwiLFwiZm94XCIsXCJmcmFnaWxlXCIsXCJmcmFtZVwiLFwiZnJlcXVlbnRcIixcImZyZXNoXCIsXCJmcmllbmRcIixcImZyaW5nZVwiLFwiZnJvZ1wiLFwiZnJvbnRcIixcImZyb3N0XCIsXCJmcm93blwiLFwiZnJvemVuXCIsXCJmcnVpdFwiLFwiZnVlbFwiLFwiZnVuXCIsXCJmdW5ueVwiLFwiZnVybmFjZVwiLFwiZnVyeVwiLFwiZnV0dXJlXCIsXCJnYWRnZXRcIixcImdhaW5cIixcImdhbGF4eVwiLFwiZ2FsbGVyeVwiLFwiZ2FtZVwiLFwiZ2FwXCIsXCJnYXJhZ2VcIixcImdhcmJhZ2VcIixcImdhcmRlblwiLFwiZ2FybGljXCIsXCJnYXJtZW50XCIsXCJnYXNcIixcImdhc3BcIixcImdhdGVcIixcImdhdGhlclwiLFwiZ2F1Z2VcIixcImdhemVcIixcImdlbmVyYWxcIixcImdlbml1c1wiLFwiZ2VucmVcIixcImdlbnRsZVwiLFwiZ2VudWluZVwiLFwiZ2VzdHVyZVwiLFwiZ2hvc3RcIixcImdpYW50XCIsXCJnaWZ0XCIsXCJnaWdnbGVcIixcImdpbmdlclwiLFwiZ2lyYWZmZVwiLFwiZ2lybFwiLFwiZ2l2ZVwiLFwiZ2xhZFwiLFwiZ2xhbmNlXCIsXCJnbGFyZVwiLFwiZ2xhc3NcIixcImdsaWRlXCIsXCJnbGltcHNlXCIsXCJnbG9iZVwiLFwiZ2xvb21cIixcImdsb3J5XCIsXCJnbG92ZVwiLFwiZ2xvd1wiLFwiZ2x1ZVwiLFwiZ29hdFwiLFwiZ29kZGVzc1wiLFwiZ29sZFwiLFwiZ29vZFwiLFwiZ29vc2VcIixcImdvcmlsbGFcIixcImdvc3BlbFwiLFwiZ29zc2lwXCIsXCJnb3Zlcm5cIixcImdvd25cIixcImdyYWJcIixcImdyYWNlXCIsXCJncmFpblwiLFwiZ3JhbnRcIixcImdyYXBlXCIsXCJncmFzc1wiLFwiZ3Jhdml0eVwiLFwiZ3JlYXRcIixcImdyZWVuXCIsXCJncmlkXCIsXCJncmllZlwiLFwiZ3JpdFwiLFwiZ3JvY2VyeVwiLFwiZ3JvdXBcIixcImdyb3dcIixcImdydW50XCIsXCJndWFyZFwiLFwiZ3Vlc3NcIixcImd1aWRlXCIsXCJndWlsdFwiLFwiZ3VpdGFyXCIsXCJndW5cIixcImd5bVwiLFwiaGFiaXRcIixcImhhaXJcIixcImhhbGZcIixcImhhbW1lclwiLFwiaGFtc3RlclwiLFwiaGFuZFwiLFwiaGFwcHlcIixcImhhcmJvclwiLFwiaGFyZFwiLFwiaGFyc2hcIixcImhhcnZlc3RcIixcImhhdFwiLFwiaGF2ZVwiLFwiaGF3a1wiLFwiaGF6YXJkXCIsXCJoZWFkXCIsXCJoZWFsdGhcIixcImhlYXJ0XCIsXCJoZWF2eVwiLFwiaGVkZ2Vob2dcIixcImhlaWdodFwiLFwiaGVsbG9cIixcImhlbG1ldFwiLFwiaGVscFwiLFwiaGVuXCIsXCJoZXJvXCIsXCJoaWRkZW5cIixcImhpZ2hcIixcImhpbGxcIixcImhpbnRcIixcImhpcFwiLFwiaGlyZVwiLFwiaGlzdG9yeVwiLFwiaG9iYnlcIixcImhvY2tleVwiLFwiaG9sZFwiLFwiaG9sZVwiLFwiaG9saWRheVwiLFwiaG9sbG93XCIsXCJob21lXCIsXCJob25leVwiLFwiaG9vZFwiLFwiaG9wZVwiLFwiaG9yblwiLFwiaG9ycm9yXCIsXCJob3JzZVwiLFwiaG9zcGl0YWxcIixcImhvc3RcIixcImhvdGVsXCIsXCJob3VyXCIsXCJob3ZlclwiLFwiaHViXCIsXCJodWdlXCIsXCJodW1hblwiLFwiaHVtYmxlXCIsXCJodW1vclwiLFwiaHVuZHJlZFwiLFwiaHVuZ3J5XCIsXCJodW50XCIsXCJodXJkbGVcIixcImh1cnJ5XCIsXCJodXJ0XCIsXCJodXNiYW5kXCIsXCJoeWJyaWRcIixcImljZVwiLFwiaWNvblwiLFwiaWRlYVwiLFwiaWRlbnRpZnlcIixcImlkbGVcIixcImlnbm9yZVwiLFwiaWxsXCIsXCJpbGxlZ2FsXCIsXCJpbGxuZXNzXCIsXCJpbWFnZVwiLFwiaW1pdGF0ZVwiLFwiaW1tZW5zZVwiLFwiaW1tdW5lXCIsXCJpbXBhY3RcIixcImltcG9zZVwiLFwiaW1wcm92ZVwiLFwiaW1wdWxzZVwiLFwiaW5jaFwiLFwiaW5jbHVkZVwiLFwiaW5jb21lXCIsXCJpbmNyZWFzZVwiLFwiaW5kZXhcIixcImluZGljYXRlXCIsXCJpbmRvb3JcIixcImluZHVzdHJ5XCIsXCJpbmZhbnRcIixcImluZmxpY3RcIixcImluZm9ybVwiLFwiaW5oYWxlXCIsXCJpbmhlcml0XCIsXCJpbml0aWFsXCIsXCJpbmplY3RcIixcImluanVyeVwiLFwiaW5tYXRlXCIsXCJpbm5lclwiLFwiaW5ub2NlbnRcIixcImlucHV0XCIsXCJpbnF1aXJ5XCIsXCJpbnNhbmVcIixcImluc2VjdFwiLFwiaW5zaWRlXCIsXCJpbnNwaXJlXCIsXCJpbnN0YWxsXCIsXCJpbnRhY3RcIixcImludGVyZXN0XCIsXCJpbnRvXCIsXCJpbnZlc3RcIixcImludml0ZVwiLFwiaW52b2x2ZVwiLFwiaXJvblwiLFwiaXNsYW5kXCIsXCJpc29sYXRlXCIsXCJpc3N1ZVwiLFwiaXRlbVwiLFwiaXZvcnlcIixcImphY2tldFwiLFwiamFndWFyXCIsXCJqYXJcIixcImphenpcIixcImplYWxvdXNcIixcImplYW5zXCIsXCJqZWxseVwiLFwiamV3ZWxcIixcImpvYlwiLFwiam9pblwiLFwiam9rZVwiLFwiam91cm5leVwiLFwiam95XCIsXCJqdWRnZVwiLFwianVpY2VcIixcImp1bXBcIixcImp1bmdsZVwiLFwianVuaW9yXCIsXCJqdW5rXCIsXCJqdXN0XCIsXCJrYW5nYXJvb1wiLFwia2VlblwiLFwia2VlcFwiLFwia2V0Y2h1cFwiLFwia2V5XCIsXCJraWNrXCIsXCJraWRcIixcImtpZG5leVwiLFwia2luZFwiLFwia2luZ2RvbVwiLFwia2lzc1wiLFwia2l0XCIsXCJraXRjaGVuXCIsXCJraXRlXCIsXCJraXR0ZW5cIixcImtpd2lcIixcImtuZWVcIixcImtuaWZlXCIsXCJrbm9ja1wiLFwia25vd1wiLFwibGFiXCIsXCJsYWJlbFwiLFwibGFib3JcIixcImxhZGRlclwiLFwibGFkeVwiLFwibGFrZVwiLFwibGFtcFwiLFwibGFuZ3VhZ2VcIixcImxhcHRvcFwiLFwibGFyZ2VcIixcImxhdGVyXCIsXCJsYXRpblwiLFwibGF1Z2hcIixcImxhdW5kcnlcIixcImxhdmFcIixcImxhd1wiLFwibGF3blwiLFwibGF3c3VpdFwiLFwibGF5ZXJcIixcImxhenlcIixcImxlYWRlclwiLFwibGVhZlwiLFwibGVhcm5cIixcImxlYXZlXCIsXCJsZWN0dXJlXCIsXCJsZWZ0XCIsXCJsZWdcIixcImxlZ2FsXCIsXCJsZWdlbmRcIixcImxlaXN1cmVcIixcImxlbW9uXCIsXCJsZW5kXCIsXCJsZW5ndGhcIixcImxlbnNcIixcImxlb3BhcmRcIixcImxlc3NvblwiLFwibGV0dGVyXCIsXCJsZXZlbFwiLFwibGlhclwiLFwibGliZXJ0eVwiLFwibGlicmFyeVwiLFwibGljZW5zZVwiLFwibGlmZVwiLFwibGlmdFwiLFwibGlnaHRcIixcImxpa2VcIixcImxpbWJcIixcImxpbWl0XCIsXCJsaW5rXCIsXCJsaW9uXCIsXCJsaXF1aWRcIixcImxpc3RcIixcImxpdHRsZVwiLFwibGl2ZVwiLFwibGl6YXJkXCIsXCJsb2FkXCIsXCJsb2FuXCIsXCJsb2JzdGVyXCIsXCJsb2NhbFwiLFwibG9ja1wiLFwibG9naWNcIixcImxvbmVseVwiLFwibG9uZ1wiLFwibG9vcFwiLFwibG90dGVyeVwiLFwibG91ZFwiLFwibG91bmdlXCIsXCJsb3ZlXCIsXCJsb3lhbFwiLFwibHVja3lcIixcImx1Z2dhZ2VcIixcImx1bWJlclwiLFwibHVuYXJcIixcImx1bmNoXCIsXCJsdXh1cnlcIixcImx5cmljc1wiLFwibWFjaGluZVwiLFwibWFkXCIsXCJtYWdpY1wiLFwibWFnbmV0XCIsXCJtYWlkXCIsXCJtYWlsXCIsXCJtYWluXCIsXCJtYWpvclwiLFwibWFrZVwiLFwibWFtbWFsXCIsXCJtYW5cIixcIm1hbmFnZVwiLFwibWFuZGF0ZVwiLFwibWFuZ29cIixcIm1hbnNpb25cIixcIm1hbnVhbFwiLFwibWFwbGVcIixcIm1hcmJsZVwiLFwibWFyY2hcIixcIm1hcmdpblwiLFwibWFyaW5lXCIsXCJtYXJrZXRcIixcIm1hcnJpYWdlXCIsXCJtYXNrXCIsXCJtYXNzXCIsXCJtYXN0ZXJcIixcIm1hdGNoXCIsXCJtYXRlcmlhbFwiLFwibWF0aFwiLFwibWF0cml4XCIsXCJtYXR0ZXJcIixcIm1heGltdW1cIixcIm1hemVcIixcIm1lYWRvd1wiLFwibWVhblwiLFwibWVhc3VyZVwiLFwibWVhdFwiLFwibWVjaGFuaWNcIixcIm1lZGFsXCIsXCJtZWRpYVwiLFwibWVsb2R5XCIsXCJtZWx0XCIsXCJtZW1iZXJcIixcIm1lbW9yeVwiLFwibWVudGlvblwiLFwibWVudVwiLFwibWVyY3lcIixcIm1lcmdlXCIsXCJtZXJpdFwiLFwibWVycnlcIixcIm1lc2hcIixcIm1lc3NhZ2VcIixcIm1ldGFsXCIsXCJtZXRob2RcIixcIm1pZGRsZVwiLFwibWlkbmlnaHRcIixcIm1pbGtcIixcIm1pbGxpb25cIixcIm1pbWljXCIsXCJtaW5kXCIsXCJtaW5pbXVtXCIsXCJtaW5vclwiLFwibWludXRlXCIsXCJtaXJhY2xlXCIsXCJtaXJyb3JcIixcIm1pc2VyeVwiLFwibWlzc1wiLFwibWlzdGFrZVwiLFwibWl4XCIsXCJtaXhlZFwiLFwibWl4dHVyZVwiLFwibW9iaWxlXCIsXCJtb2RlbFwiLFwibW9kaWZ5XCIsXCJtb21cIixcIm1vbWVudFwiLFwibW9uaXRvclwiLFwibW9ua2V5XCIsXCJtb25zdGVyXCIsXCJtb250aFwiLFwibW9vblwiLFwibW9yYWxcIixcIm1vcmVcIixcIm1vcm5pbmdcIixcIm1vc3F1aXRvXCIsXCJtb3RoZXJcIixcIm1vdGlvblwiLFwibW90b3JcIixcIm1vdW50YWluXCIsXCJtb3VzZVwiLFwibW92ZVwiLFwibW92aWVcIixcIm11Y2hcIixcIm11ZmZpblwiLFwibXVsZVwiLFwibXVsdGlwbHlcIixcIm11c2NsZVwiLFwibXVzZXVtXCIsXCJtdXNocm9vbVwiLFwibXVzaWNcIixcIm11c3RcIixcIm11dHVhbFwiLFwibXlzZWxmXCIsXCJteXN0ZXJ5XCIsXCJteXRoXCIsXCJuYWl2ZVwiLFwibmFtZVwiLFwibmFwa2luXCIsXCJuYXJyb3dcIixcIm5hc3R5XCIsXCJuYXRpb25cIixcIm5hdHVyZVwiLFwibmVhclwiLFwibmVja1wiLFwibmVlZFwiLFwibmVnYXRpdmVcIixcIm5lZ2xlY3RcIixcIm5laXRoZXJcIixcIm5lcGhld1wiLFwibmVydmVcIixcIm5lc3RcIixcIm5ldFwiLFwibmV0d29ya1wiLFwibmV1dHJhbFwiLFwibmV2ZXJcIixcIm5ld3NcIixcIm5leHRcIixcIm5pY2VcIixcIm5pZ2h0XCIsXCJub2JsZVwiLFwibm9pc2VcIixcIm5vbWluZWVcIixcIm5vb2RsZVwiLFwibm9ybWFsXCIsXCJub3J0aFwiLFwibm9zZVwiLFwibm90YWJsZVwiLFwibm90ZVwiLFwibm90aGluZ1wiLFwibm90aWNlXCIsXCJub3ZlbFwiLFwibm93XCIsXCJudWNsZWFyXCIsXCJudW1iZXJcIixcIm51cnNlXCIsXCJudXRcIixcIm9ha1wiLFwib2JleVwiLFwib2JqZWN0XCIsXCJvYmxpZ2VcIixcIm9ic2N1cmVcIixcIm9ic2VydmVcIixcIm9idGFpblwiLFwib2J2aW91c1wiLFwib2NjdXJcIixcIm9jZWFuXCIsXCJvY3RvYmVyXCIsXCJvZG9yXCIsXCJvZmZcIixcIm9mZmVyXCIsXCJvZmZpY2VcIixcIm9mdGVuXCIsXCJvaWxcIixcIm9rYXlcIixcIm9sZFwiLFwib2xpdmVcIixcIm9seW1waWNcIixcIm9taXRcIixcIm9uY2VcIixcIm9uZVwiLFwib25pb25cIixcIm9ubGluZVwiLFwib25seVwiLFwib3BlblwiLFwib3BlcmFcIixcIm9waW5pb25cIixcIm9wcG9zZVwiLFwib3B0aW9uXCIsXCJvcmFuZ2VcIixcIm9yYml0XCIsXCJvcmNoYXJkXCIsXCJvcmRlclwiLFwib3JkaW5hcnlcIixcIm9yZ2FuXCIsXCJvcmllbnRcIixcIm9yaWdpbmFsXCIsXCJvcnBoYW5cIixcIm9zdHJpY2hcIixcIm90aGVyXCIsXCJvdXRkb29yXCIsXCJvdXRlclwiLFwib3V0cHV0XCIsXCJvdXRzaWRlXCIsXCJvdmFsXCIsXCJvdmVuXCIsXCJvdmVyXCIsXCJvd25cIixcIm93bmVyXCIsXCJveHlnZW5cIixcIm95c3RlclwiLFwib3pvbmVcIixcInBhY3RcIixcInBhZGRsZVwiLFwicGFnZVwiLFwicGFpclwiLFwicGFsYWNlXCIsXCJwYWxtXCIsXCJwYW5kYVwiLFwicGFuZWxcIixcInBhbmljXCIsXCJwYW50aGVyXCIsXCJwYXBlclwiLFwicGFyYWRlXCIsXCJwYXJlbnRcIixcInBhcmtcIixcInBhcnJvdFwiLFwicGFydHlcIixcInBhc3NcIixcInBhdGNoXCIsXCJwYXRoXCIsXCJwYXRpZW50XCIsXCJwYXRyb2xcIixcInBhdHRlcm5cIixcInBhdXNlXCIsXCJwYXZlXCIsXCJwYXltZW50XCIsXCJwZWFjZVwiLFwicGVhbnV0XCIsXCJwZWFyXCIsXCJwZWFzYW50XCIsXCJwZWxpY2FuXCIsXCJwZW5cIixcInBlbmFsdHlcIixcInBlbmNpbFwiLFwicGVvcGxlXCIsXCJwZXBwZXJcIixcInBlcmZlY3RcIixcInBlcm1pdFwiLFwicGVyc29uXCIsXCJwZXRcIixcInBob25lXCIsXCJwaG90b1wiLFwicGhyYXNlXCIsXCJwaHlzaWNhbFwiLFwicGlhbm9cIixcInBpY25pY1wiLFwicGljdHVyZVwiLFwicGllY2VcIixcInBpZ1wiLFwicGlnZW9uXCIsXCJwaWxsXCIsXCJwaWxvdFwiLFwicGlua1wiLFwicGlvbmVlclwiLFwicGlwZVwiLFwicGlzdG9sXCIsXCJwaXRjaFwiLFwicGl6emFcIixcInBsYWNlXCIsXCJwbGFuZXRcIixcInBsYXN0aWNcIixcInBsYXRlXCIsXCJwbGF5XCIsXCJwbGVhc2VcIixcInBsZWRnZVwiLFwicGx1Y2tcIixcInBsdWdcIixcInBsdW5nZVwiLFwicG9lbVwiLFwicG9ldFwiLFwicG9pbnRcIixcInBvbGFyXCIsXCJwb2xlXCIsXCJwb2xpY2VcIixcInBvbmRcIixcInBvbnlcIixcInBvb2xcIixcInBvcHVsYXJcIixcInBvcnRpb25cIixcInBvc2l0aW9uXCIsXCJwb3NzaWJsZVwiLFwicG9zdFwiLFwicG90YXRvXCIsXCJwb3R0ZXJ5XCIsXCJwb3ZlcnR5XCIsXCJwb3dkZXJcIixcInBvd2VyXCIsXCJwcmFjdGljZVwiLFwicHJhaXNlXCIsXCJwcmVkaWN0XCIsXCJwcmVmZXJcIixcInByZXBhcmVcIixcInByZXNlbnRcIixcInByZXR0eVwiLFwicHJldmVudFwiLFwicHJpY2VcIixcInByaWRlXCIsXCJwcmltYXJ5XCIsXCJwcmludFwiLFwicHJpb3JpdHlcIixcInByaXNvblwiLFwicHJpdmF0ZVwiLFwicHJpemVcIixcInByb2JsZW1cIixcInByb2Nlc3NcIixcInByb2R1Y2VcIixcInByb2ZpdFwiLFwicHJvZ3JhbVwiLFwicHJvamVjdFwiLFwicHJvbW90ZVwiLFwicHJvb2ZcIixcInByb3BlcnR5XCIsXCJwcm9zcGVyXCIsXCJwcm90ZWN0XCIsXCJwcm91ZFwiLFwicHJvdmlkZVwiLFwicHVibGljXCIsXCJwdWRkaW5nXCIsXCJwdWxsXCIsXCJwdWxwXCIsXCJwdWxzZVwiLFwicHVtcGtpblwiLFwicHVuY2hcIixcInB1cGlsXCIsXCJwdXBweVwiLFwicHVyY2hhc2VcIixcInB1cml0eVwiLFwicHVycG9zZVwiLFwicHVyc2VcIixcInB1c2hcIixcInB1dFwiLFwicHV6emxlXCIsXCJweXJhbWlkXCIsXCJxdWFsaXR5XCIsXCJxdWFudHVtXCIsXCJxdWFydGVyXCIsXCJxdWVzdGlvblwiLFwicXVpY2tcIixcInF1aXRcIixcInF1aXpcIixcInF1b3RlXCIsXCJyYWJiaXRcIixcInJhY2Nvb25cIixcInJhY2VcIixcInJhY2tcIixcInJhZGFyXCIsXCJyYWRpb1wiLFwicmFpbFwiLFwicmFpblwiLFwicmFpc2VcIixcInJhbGx5XCIsXCJyYW1wXCIsXCJyYW5jaFwiLFwicmFuZG9tXCIsXCJyYW5nZVwiLFwicmFwaWRcIixcInJhcmVcIixcInJhdGVcIixcInJhdGhlclwiLFwicmF2ZW5cIixcInJhd1wiLFwicmF6b3JcIixcInJlYWR5XCIsXCJyZWFsXCIsXCJyZWFzb25cIixcInJlYmVsXCIsXCJyZWJ1aWxkXCIsXCJyZWNhbGxcIixcInJlY2VpdmVcIixcInJlY2lwZVwiLFwicmVjb3JkXCIsXCJyZWN5Y2xlXCIsXCJyZWR1Y2VcIixcInJlZmxlY3RcIixcInJlZm9ybVwiLFwicmVmdXNlXCIsXCJyZWdpb25cIixcInJlZ3JldFwiLFwicmVndWxhclwiLFwicmVqZWN0XCIsXCJyZWxheFwiLFwicmVsZWFzZVwiLFwicmVsaWVmXCIsXCJyZWx5XCIsXCJyZW1haW5cIixcInJlbWVtYmVyXCIsXCJyZW1pbmRcIixcInJlbW92ZVwiLFwicmVuZGVyXCIsXCJyZW5ld1wiLFwicmVudFwiLFwicmVvcGVuXCIsXCJyZXBhaXJcIixcInJlcGVhdFwiLFwicmVwbGFjZVwiLFwicmVwb3J0XCIsXCJyZXF1aXJlXCIsXCJyZXNjdWVcIixcInJlc2VtYmxlXCIsXCJyZXNpc3RcIixcInJlc291cmNlXCIsXCJyZXNwb25zZVwiLFwicmVzdWx0XCIsXCJyZXRpcmVcIixcInJldHJlYXRcIixcInJldHVyblwiLFwicmV1bmlvblwiLFwicmV2ZWFsXCIsXCJyZXZpZXdcIixcInJld2FyZFwiLFwicmh5dGhtXCIsXCJyaWJcIixcInJpYmJvblwiLFwicmljZVwiLFwicmljaFwiLFwicmlkZVwiLFwicmlkZ2VcIixcInJpZmxlXCIsXCJyaWdodFwiLFwicmlnaWRcIixcInJpbmdcIixcInJpb3RcIixcInJpcHBsZVwiLFwicmlza1wiLFwicml0dWFsXCIsXCJyaXZhbFwiLFwicml2ZXJcIixcInJvYWRcIixcInJvYXN0XCIsXCJyb2JvdFwiLFwicm9idXN0XCIsXCJyb2NrZXRcIixcInJvbWFuY2VcIixcInJvb2ZcIixcInJvb2tpZVwiLFwicm9vbVwiLFwicm9zZVwiLFwicm90YXRlXCIsXCJyb3VnaFwiLFwicm91bmRcIixcInJvdXRlXCIsXCJyb3lhbFwiLFwicnViYmVyXCIsXCJydWRlXCIsXCJydWdcIixcInJ1bGVcIixcInJ1blwiLFwicnVud2F5XCIsXCJydXJhbFwiLFwic2FkXCIsXCJzYWRkbGVcIixcInNhZG5lc3NcIixcInNhZmVcIixcInNhaWxcIixcInNhbGFkXCIsXCJzYWxtb25cIixcInNhbG9uXCIsXCJzYWx0XCIsXCJzYWx1dGVcIixcInNhbWVcIixcInNhbXBsZVwiLFwic2FuZFwiLFwic2F0aXNmeVwiLFwic2F0b3NoaVwiLFwic2F1Y2VcIixcInNhdXNhZ2VcIixcInNhdmVcIixcInNheVwiLFwic2NhbGVcIixcInNjYW5cIixcInNjYXJlXCIsXCJzY2F0dGVyXCIsXCJzY2VuZVwiLFwic2NoZW1lXCIsXCJzY2hvb2xcIixcInNjaWVuY2VcIixcInNjaXNzb3JzXCIsXCJzY29ycGlvblwiLFwic2NvdXRcIixcInNjcmFwXCIsXCJzY3JlZW5cIixcInNjcmlwdFwiLFwic2NydWJcIixcInNlYVwiLFwic2VhcmNoXCIsXCJzZWFzb25cIixcInNlYXRcIixcInNlY29uZFwiLFwic2VjcmV0XCIsXCJzZWN0aW9uXCIsXCJzZWN1cml0eVwiLFwic2VlZFwiLFwic2Vla1wiLFwic2VnbWVudFwiLFwic2VsZWN0XCIsXCJzZWxsXCIsXCJzZW1pbmFyXCIsXCJzZW5pb3JcIixcInNlbnNlXCIsXCJzZW50ZW5jZVwiLFwic2VyaWVzXCIsXCJzZXJ2aWNlXCIsXCJzZXNzaW9uXCIsXCJzZXR0bGVcIixcInNldHVwXCIsXCJzZXZlblwiLFwic2hhZG93XCIsXCJzaGFmdFwiLFwic2hhbGxvd1wiLFwic2hhcmVcIixcInNoZWRcIixcInNoZWxsXCIsXCJzaGVyaWZmXCIsXCJzaGllbGRcIixcInNoaWZ0XCIsXCJzaGluZVwiLFwic2hpcFwiLFwic2hpdmVyXCIsXCJzaG9ja1wiLFwic2hvZVwiLFwic2hvb3RcIixcInNob3BcIixcInNob3J0XCIsXCJzaG91bGRlclwiLFwic2hvdmVcIixcInNocmltcFwiLFwic2hydWdcIixcInNodWZmbGVcIixcInNoeVwiLFwic2libGluZ1wiLFwic2lja1wiLFwic2lkZVwiLFwic2llZ2VcIixcInNpZ2h0XCIsXCJzaWduXCIsXCJzaWxlbnRcIixcInNpbGtcIixcInNpbGx5XCIsXCJzaWx2ZXJcIixcInNpbWlsYXJcIixcInNpbXBsZVwiLFwic2luY2VcIixcInNpbmdcIixcInNpcmVuXCIsXCJzaXN0ZXJcIixcInNpdHVhdGVcIixcInNpeFwiLFwic2l6ZVwiLFwic2thdGVcIixcInNrZXRjaFwiLFwic2tpXCIsXCJza2lsbFwiLFwic2tpblwiLFwic2tpcnRcIixcInNrdWxsXCIsXCJzbGFiXCIsXCJzbGFtXCIsXCJzbGVlcFwiLFwic2xlbmRlclwiLFwic2xpY2VcIixcInNsaWRlXCIsXCJzbGlnaHRcIixcInNsaW1cIixcInNsb2dhblwiLFwic2xvdFwiLFwic2xvd1wiLFwic2x1c2hcIixcInNtYWxsXCIsXCJzbWFydFwiLFwic21pbGVcIixcInNtb2tlXCIsXCJzbW9vdGhcIixcInNuYWNrXCIsXCJzbmFrZVwiLFwic25hcFwiLFwic25pZmZcIixcInNub3dcIixcInNvYXBcIixcInNvY2NlclwiLFwic29jaWFsXCIsXCJzb2NrXCIsXCJzb2RhXCIsXCJzb2Z0XCIsXCJzb2xhclwiLFwic29sZGllclwiLFwic29saWRcIixcInNvbHV0aW9uXCIsXCJzb2x2ZVwiLFwic29tZW9uZVwiLFwic29uZ1wiLFwic29vblwiLFwic29ycnlcIixcInNvcnRcIixcInNvdWxcIixcInNvdW5kXCIsXCJzb3VwXCIsXCJzb3VyY2VcIixcInNvdXRoXCIsXCJzcGFjZVwiLFwic3BhcmVcIixcInNwYXRpYWxcIixcInNwYXduXCIsXCJzcGVha1wiLFwic3BlY2lhbFwiLFwic3BlZWRcIixcInNwZWxsXCIsXCJzcGVuZFwiLFwic3BoZXJlXCIsXCJzcGljZVwiLFwic3BpZGVyXCIsXCJzcGlrZVwiLFwic3BpblwiLFwic3Bpcml0XCIsXCJzcGxpdFwiLFwic3BvaWxcIixcInNwb25zb3JcIixcInNwb29uXCIsXCJzcG9ydFwiLFwic3BvdFwiLFwic3ByYXlcIixcInNwcmVhZFwiLFwic3ByaW5nXCIsXCJzcHlcIixcInNxdWFyZVwiLFwic3F1ZWV6ZVwiLFwic3F1aXJyZWxcIixcInN0YWJsZVwiLFwic3RhZGl1bVwiLFwic3RhZmZcIixcInN0YWdlXCIsXCJzdGFpcnNcIixcInN0YW1wXCIsXCJzdGFuZFwiLFwic3RhcnRcIixcInN0YXRlXCIsXCJzdGF5XCIsXCJzdGVha1wiLFwic3RlZWxcIixcInN0ZW1cIixcInN0ZXBcIixcInN0ZXJlb1wiLFwic3RpY2tcIixcInN0aWxsXCIsXCJzdGluZ1wiLFwic3RvY2tcIixcInN0b21hY2hcIixcInN0b25lXCIsXCJzdG9vbFwiLFwic3RvcnlcIixcInN0b3ZlXCIsXCJzdHJhdGVneVwiLFwic3RyZWV0XCIsXCJzdHJpa2VcIixcInN0cm9uZ1wiLFwic3RydWdnbGVcIixcInN0dWRlbnRcIixcInN0dWZmXCIsXCJzdHVtYmxlXCIsXCJzdHlsZVwiLFwic3ViamVjdFwiLFwic3VibWl0XCIsXCJzdWJ3YXlcIixcInN1Y2Nlc3NcIixcInN1Y2hcIixcInN1ZGRlblwiLFwic3VmZmVyXCIsXCJzdWdhclwiLFwic3VnZ2VzdFwiLFwic3VpdFwiLFwic3VtbWVyXCIsXCJzdW5cIixcInN1bm55XCIsXCJzdW5zZXRcIixcInN1cGVyXCIsXCJzdXBwbHlcIixcInN1cHJlbWVcIixcInN1cmVcIixcInN1cmZhY2VcIixcInN1cmdlXCIsXCJzdXJwcmlzZVwiLFwic3Vycm91bmRcIixcInN1cnZleVwiLFwic3VzcGVjdFwiLFwic3VzdGFpblwiLFwic3dhbGxvd1wiLFwic3dhbXBcIixcInN3YXBcIixcInN3YXJtXCIsXCJzd2VhclwiLFwic3dlZXRcIixcInN3aWZ0XCIsXCJzd2ltXCIsXCJzd2luZ1wiLFwic3dpdGNoXCIsXCJzd29yZFwiLFwic3ltYm9sXCIsXCJzeW1wdG9tXCIsXCJzeXJ1cFwiLFwic3lzdGVtXCIsXCJ0YWJsZVwiLFwidGFja2xlXCIsXCJ0YWdcIixcInRhaWxcIixcInRhbGVudFwiLFwidGFsa1wiLFwidGFua1wiLFwidGFwZVwiLFwidGFyZ2V0XCIsXCJ0YXNrXCIsXCJ0YXN0ZVwiLFwidGF0dG9vXCIsXCJ0YXhpXCIsXCJ0ZWFjaFwiLFwidGVhbVwiLFwidGVsbFwiLFwidGVuXCIsXCJ0ZW5hbnRcIixcInRlbm5pc1wiLFwidGVudFwiLFwidGVybVwiLFwidGVzdFwiLFwidGV4dFwiLFwidGhhbmtcIixcInRoYXRcIixcInRoZW1lXCIsXCJ0aGVuXCIsXCJ0aGVvcnlcIixcInRoZXJlXCIsXCJ0aGV5XCIsXCJ0aGluZ1wiLFwidGhpc1wiLFwidGhvdWdodFwiLFwidGhyZWVcIixcInRocml2ZVwiLFwidGhyb3dcIixcInRodW1iXCIsXCJ0aHVuZGVyXCIsXCJ0aWNrZXRcIixcInRpZGVcIixcInRpZ2VyXCIsXCJ0aWx0XCIsXCJ0aW1iZXJcIixcInRpbWVcIixcInRpbnlcIixcInRpcFwiLFwidGlyZWRcIixcInRpc3N1ZVwiLFwidGl0bGVcIixcInRvYXN0XCIsXCJ0b2JhY2NvXCIsXCJ0b2RheVwiLFwidG9kZGxlclwiLFwidG9lXCIsXCJ0b2dldGhlclwiLFwidG9pbGV0XCIsXCJ0b2tlblwiLFwidG9tYXRvXCIsXCJ0b21vcnJvd1wiLFwidG9uZVwiLFwidG9uZ3VlXCIsXCJ0b25pZ2h0XCIsXCJ0b29sXCIsXCJ0b290aFwiLFwidG9wXCIsXCJ0b3BpY1wiLFwidG9wcGxlXCIsXCJ0b3JjaFwiLFwidG9ybmFkb1wiLFwidG9ydG9pc2VcIixcInRvc3NcIixcInRvdGFsXCIsXCJ0b3VyaXN0XCIsXCJ0b3dhcmRcIixcInRvd2VyXCIsXCJ0b3duXCIsXCJ0b3lcIixcInRyYWNrXCIsXCJ0cmFkZVwiLFwidHJhZmZpY1wiLFwidHJhZ2ljXCIsXCJ0cmFpblwiLFwidHJhbnNmZXJcIixcInRyYXBcIixcInRyYXNoXCIsXCJ0cmF2ZWxcIixcInRyYXlcIixcInRyZWF0XCIsXCJ0cmVlXCIsXCJ0cmVuZFwiLFwidHJpYWxcIixcInRyaWJlXCIsXCJ0cmlja1wiLFwidHJpZ2dlclwiLFwidHJpbVwiLFwidHJpcFwiLFwidHJvcGh5XCIsXCJ0cm91YmxlXCIsXCJ0cnVja1wiLFwidHJ1ZVwiLFwidHJ1bHlcIixcInRydW1wZXRcIixcInRydXN0XCIsXCJ0cnV0aFwiLFwidHJ5XCIsXCJ0dWJlXCIsXCJ0dWl0aW9uXCIsXCJ0dW1ibGVcIixcInR1bmFcIixcInR1bm5lbFwiLFwidHVya2V5XCIsXCJ0dXJuXCIsXCJ0dXJ0bGVcIixcInR3ZWx2ZVwiLFwidHdlbnR5XCIsXCJ0d2ljZVwiLFwidHdpblwiLFwidHdpc3RcIixcInR3b1wiLFwidHlwZVwiLFwidHlwaWNhbFwiLFwidWdseVwiLFwidW1icmVsbGFcIixcInVuYWJsZVwiLFwidW5hd2FyZVwiLFwidW5jbGVcIixcInVuY292ZXJcIixcInVuZGVyXCIsXCJ1bmRvXCIsXCJ1bmZhaXJcIixcInVuZm9sZFwiLFwidW5oYXBweVwiLFwidW5pZm9ybVwiLFwidW5pcXVlXCIsXCJ1bml0XCIsXCJ1bml2ZXJzZVwiLFwidW5rbm93blwiLFwidW5sb2NrXCIsXCJ1bnRpbFwiLFwidW51c3VhbFwiLFwidW52ZWlsXCIsXCJ1cGRhdGVcIixcInVwZ3JhZGVcIixcInVwaG9sZFwiLFwidXBvblwiLFwidXBwZXJcIixcInVwc2V0XCIsXCJ1cmJhblwiLFwidXJnZVwiLFwidXNhZ2VcIixcInVzZVwiLFwidXNlZFwiLFwidXNlZnVsXCIsXCJ1c2VsZXNzXCIsXCJ1c3VhbFwiLFwidXRpbGl0eVwiLFwidmFjYW50XCIsXCJ2YWN1dW1cIixcInZhZ3VlXCIsXCJ2YWxpZFwiLFwidmFsbGV5XCIsXCJ2YWx2ZVwiLFwidmFuXCIsXCJ2YW5pc2hcIixcInZhcG9yXCIsXCJ2YXJpb3VzXCIsXCJ2YXN0XCIsXCJ2YXVsdFwiLFwidmVoaWNsZVwiLFwidmVsdmV0XCIsXCJ2ZW5kb3JcIixcInZlbnR1cmVcIixcInZlbnVlXCIsXCJ2ZXJiXCIsXCJ2ZXJpZnlcIixcInZlcnNpb25cIixcInZlcnlcIixcInZlc3NlbFwiLFwidmV0ZXJhblwiLFwidmlhYmxlXCIsXCJ2aWJyYW50XCIsXCJ2aWNpb3VzXCIsXCJ2aWN0b3J5XCIsXCJ2aWRlb1wiLFwidmlld1wiLFwidmlsbGFnZVwiLFwidmludGFnZVwiLFwidmlvbGluXCIsXCJ2aXJ0dWFsXCIsXCJ2aXJ1c1wiLFwidmlzYVwiLFwidmlzaXRcIixcInZpc3VhbFwiLFwidml0YWxcIixcInZpdmlkXCIsXCJ2b2NhbFwiLFwidm9pY2VcIixcInZvaWRcIixcInZvbGNhbm9cIixcInZvbHVtZVwiLFwidm90ZVwiLFwidm95YWdlXCIsXCJ3YWdlXCIsXCJ3YWdvblwiLFwid2FpdFwiLFwid2Fsa1wiLFwid2FsbFwiLFwid2FsbnV0XCIsXCJ3YW50XCIsXCJ3YXJmYXJlXCIsXCJ3YXJtXCIsXCJ3YXJyaW9yXCIsXCJ3YXNoXCIsXCJ3YXNwXCIsXCJ3YXN0ZVwiLFwid2F0ZXJcIixcIndhdmVcIixcIndheVwiLFwid2VhbHRoXCIsXCJ3ZWFwb25cIixcIndlYXJcIixcIndlYXNlbFwiLFwid2VhdGhlclwiLFwid2ViXCIsXCJ3ZWRkaW5nXCIsXCJ3ZWVrZW5kXCIsXCJ3ZWlyZFwiLFwid2VsY29tZVwiLFwid2VzdFwiLFwid2V0XCIsXCJ3aGFsZVwiLFwid2hhdFwiLFwid2hlYXRcIixcIndoZWVsXCIsXCJ3aGVuXCIsXCJ3aGVyZVwiLFwid2hpcFwiLFwid2hpc3BlclwiLFwid2lkZVwiLFwid2lkdGhcIixcIndpZmVcIixcIndpbGRcIixcIndpbGxcIixcIndpblwiLFwid2luZG93XCIsXCJ3aW5lXCIsXCJ3aW5nXCIsXCJ3aW5rXCIsXCJ3aW5uZXJcIixcIndpbnRlclwiLFwid2lyZVwiLFwid2lzZG9tXCIsXCJ3aXNlXCIsXCJ3aXNoXCIsXCJ3aXRuZXNzXCIsXCJ3b2xmXCIsXCJ3b21hblwiLFwid29uZGVyXCIsXCJ3b29kXCIsXCJ3b29sXCIsXCJ3b3JkXCIsXCJ3b3JrXCIsXCJ3b3JsZFwiLFwid29ycnlcIixcIndvcnRoXCIsXCJ3cmFwXCIsXCJ3cmVja1wiLFwid3Jlc3RsZVwiLFwid3Jpc3RcIixcIndyaXRlXCIsXCJ3cm9uZ1wiLFwieWFyZFwiLFwieWVhclwiLFwieWVsbG93XCIsXCJ5b3VcIixcInlvdW5nXCIsXCJ5b3V0aFwiLFwiemVicmFcIixcInplcm9cIixcInpvbmVcIixcInpvb1wiXX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLHQpe3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCFyKXJldHVybiBlO3ZhciBuLGksYT1yLmNhbGwoZSkscz1bXTt0cnl7Zm9yKDsodm9pZCAwPT09dHx8dC0tID4wKSYmIShuPWEubmV4dCgpKS5kb25lOylzLnB1c2gobi52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7biYmIW4uZG9uZSYmKHI9YS5yZXR1cm4pJiZyLmNhbGwoYSl9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBzfSxpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH0sYT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcz1pKHIoMzApKSxvPWkocigyKSksdT1yKDIyKSxjPXIoMTEpLGw9cigxNCksZj1yKDE5KSxoPWEocigyNCkpLHA9cigxMCk7dC5hZXNFbmNyeXB0PWZ1bmN0aW9uKGUsdCxyLG4pe3ZvaWQgMD09PXImJihyPVwiQ0JDXCIpO3ZhciBpPXMuY3JlYXRlQ2lwaGVyKFwiQUVTLVwiK3IscC5ieXRlc1RvU3RyaW5nKGMuX2Zyb21Jbih0KSxcInJhd1wiKSk7cmV0dXJuIGkuc3RhcnQoe2l2Om4mJm8uY3JlYXRlQnVmZmVyKHAuYnl0ZXNUb1N0cmluZyhjLl9mcm9tSW4obiksXCJyYXdcIikpfSksaS51cGRhdGUoby5jcmVhdGVCdWZmZXIocC5ieXRlc1RvU3RyaW5nKGUsXCJyYXdcIikpKSxpLmZpbmlzaCgpLHAuc3RyaW5nVG9CeXRlcyhpLm91dHB1dC5nZXRCeXRlcygpLFwicmF3XCIpfSx0LmFlc0RlY3J5cHQ9ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09ciYmKHI9XCJDQkNcIik7dmFyIGk9cy5jcmVhdGVEZWNpcGhlcihcIkFFUy1cIityLHAuYnl0ZXNUb1N0cmluZyhjLl9mcm9tSW4odCksXCJyYXdcIikpO2kuc3RhcnQoe2l2Om4mJm8uY3JlYXRlQnVmZmVyKHAuYnl0ZXNUb1N0cmluZyhjLl9mcm9tSW4obiksXCJyYXdcIikpfSk7dmFyIGE9by5jcmVhdGVCdWZmZXIocC5ieXRlc1RvU3RyaW5nKGMuX2Zyb21JbihlKSxcInJhd1wiKSk7aWYoaS51cGRhdGUoYSksIWkuZmluaXNoKCkpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZGF0YSB3aXRoIHByb3ZpZGVkIGtleVwiKTtyZXR1cm4gcC5zdHJpbmdUb0J5dGVzKGkub3V0cHV0LmdldEJ5dGVzKCksXCJyYXdcIil9LHQubWVzc2FnZUVuY3J5cHQ9ZnVuY3Rpb24oZSxyKXt2YXIgbj1VaW50OEFycmF5LmZyb20oWzFdKSxpPXUucmFuZG9tQnl0ZXMoMzIpLGE9dS5yYW5kb21CeXRlcygxNikscz1wLnN0cmluZ1RvQnl0ZXMociksbz10LmFlc0VuY3J5cHQocyxpLFwiQ1RSXCIsYSksYz10LmFlc0VuY3J5cHQoaSxlLFwiRUNCXCIpLGg9bC5obWFjU0hBMjU2KHMsaSksZD1sLmhtYWNTSEEyNTYoZi5jb25jYXQoaSxhKSxlKTtyZXR1cm4gZi5jb25jYXQobixjLGQsaCxhLG8pfSx0Lm1lc3NhZ2VEZWNyeXB0PWZ1bmN0aW9uKGUscil7dmFyIGk9bihmLnNwbGl0KHIsMSw0OCwzMiwzMiwxNiksNiksYT0oaVswXSxpWzFdKSxzPWlbMl0sbz1pWzNdLHU9aVs0XSxoPWlbNV0sZD10LmFlc0RlY3J5cHQoYSxlLFwiRUNCXCIpO2lmKCFjLl9mcm9tSW4obC5obWFjU0hBMjU2KGYuY29uY2F0KGQsdSksYy5fZnJvbUluKGUpKSkuZXZlcnkoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU9PT1zW3RdfSkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO3ZhciB5PXQuYWVzRGVjcnlwdChoLGQsXCJDVFJcIix1KTtpZighYy5fZnJvbUluKGwuaG1hY1NIQTI1Nih5LGQpKS5ldmVyeSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT09PW9bdF19KSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlXCIpO3JldHVybiBwLmJ5dGVzVG9TdHJpbmcoeSl9LHQuc2hhcmVkS2V5PWZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1oLmRlZmF1bHQuc2hhcmVkS2V5KGMuX2Zyb21JbihlKSxjLl9mcm9tSW4odCkpLGk9bC5zaGEyNTYoYy5fZnJvbVJhd0luKHIpKTtyZXR1cm4gbC5obWFjU0hBMjU2KG4saSl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG49cigxMSksaT1yKDEwKTt0LlNlZWQ9e2lzU2VlZFdpdGhOb25jZTpmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09ZS5ub25jZX0sdG9CaW5hcnk6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuU2VlZC5pc1NlZWRXaXRoTm9uY2UoZSk/e3NlZWQ6dC5TZWVkLnRvQmluYXJ5KGUuc2VlZCkuc2VlZCxub25jZTplLm5vbmNlfTp7c2VlZDpuLl9mcm9tUmF3SW4oZSksbm9uY2U6dm9pZCAwfX0sdG9TdHJpbmc6ZnVuY3Rpb24oZSl7cmV0dXJuIGkuYnl0ZXNUb1N0cmluZyh0LlNlZWQudG9CaW5hcnkoZSkuc2VlZCl9fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoMjApLGk9cigyMCk7dC5DaGFpZElkPXt0b051bWJlcjpmdW5jdGlvbihlKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9lLmNoYXJDb2RlQXQoMCk6ZX0saXNNYWlubmV0OmZ1bmN0aW9uKGUpe3JldHVybiB0LkNoYWlkSWQudG9OdW1iZXIoZSk9PT1uLk1BSU5fTkVUX0NIQUlOX0lEfSxpc1Rlc3RuZXQ6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuQ2hhaWRJZC50b051bWJlcihlKT09PWkuVEVTVF9ORVRfQ0hBSU5fSUR9fX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7aWYocigyOSkscigxNSkscig1OCkscig5KSxyKDE2KSxyKDU5KSxyKDM1KSxyKDEyKSxyKDEwMCkscigyNSkscigyKSx2b2lkIDA9PT1pKXZhciBpPW4uanNibi5CaWdJbnRlZ2VyO3ZhciBhPW4uYXNuMSxzPW4ucGtpPW4ucGtpfHx7fTtlLmV4cG9ydHM9cy5wYmU9bi5wYmU9bi5wYmV8fHt9O3ZhciBvPXMub2lkcyx1PXtuYW1lOlwiRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5lbmNyeXB0aW9uQWxnb3JpdGhtXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImVuY3J5cHRpb25PaWRcIn0se25hbWU6XCJBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnNcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImVuY3J5cHRpb25QYXJhbXNcIn1dfSx7bmFtZTpcIkVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLmVuY3J5cHRlZERhdGFcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5PQ1RFVFNUUklORyxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiZW5jcnlwdGVkRGF0YVwifV19LGM9e25hbWU6XCJQQkVTMkFsZ29yaXRobXNcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmNcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJQQkVTMkFsZ29yaXRobXMua2V5RGVyaXZhdGlvbkZ1bmMub2lkXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJrZGZPaWRcIn0se25hbWU6XCJQQkVTMkFsZ29yaXRobXMucGFyYW1zXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5zYWx0XCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuT0NURVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImtkZlNhbHRcIn0se25hbWU6XCJQQkVTMkFsZ29yaXRobXMucGFyYW1zLml0ZXJhdGlvbkNvdW50XCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwia2RmSXRlcmF0aW9uQ291bnRcIn0se25hbWU6XCJQQkVTMkFsZ29yaXRobXMucGFyYW1zLmtleUxlbmd0aFwiLHRhZ0NsYXNzOmEuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6YS5UeXBlLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsb3B0aW9uYWw6ITAsY2FwdHVyZTpcImtleUxlbmd0aFwifSx7bmFtZTpcIlBCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsb3B0aW9uYWw6ITAsdmFsdWU6W3tuYW1lOlwiUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5wcmYuYWxnb3JpdGhtXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJwcmZPaWRcIn1dfV19XX0se25hbWU6XCJQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZVwiLHRhZ0NsYXNzOmEuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6YS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIlBCRVMyQWxnb3JpdGhtcy5lbmNyeXB0aW9uU2NoZW1lLm9pZFwiLHRhZ0NsYXNzOmEuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6YS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiZW5jT2lkXCJ9LHtuYW1lOlwiUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUuaXZcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5PQ1RFVFNUUklORyxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiZW5jSXZcIn1dfV19LGw9e25hbWU6XCJwa2NzLTEyUGJlUGFyYW1zXCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwicGtjcy0xMlBiZVBhcmFtcy5zYWx0XCIsdGFnQ2xhc3M6YS5DbGFzcy5VTklWRVJTQUwsdHlwZTphLlR5cGUuT0NURVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInNhbHRcIn0se25hbWU6XCJwa2NzLTEyUGJlUGFyYW1zLml0ZXJhdGlvbnNcIix0YWdDbGFzczphLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmEuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJpdGVyYXRpb25zXCJ9XX07ZnVuY3Rpb24gZihlLHQpe3JldHVybiBlLnN0YXJ0KCkudXBkYXRlKHQpLmRpZ2VzdCgpLmdldEJ5dGVzKCl9ZnVuY3Rpb24gaChlKXt2YXIgdDtpZihlKXtpZighKHQ9cy5vaWRzW2EuZGVyVG9PaWQoZSldKSl7dmFyIHI9bmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUFJGIE9JRC5cIik7dGhyb3cgci5vaWQ9ZSxyLnN1cHBvcnRlZD1bXCJobWFjV2l0aFNIQTFcIixcImhtYWNXaXRoU0hBMjI0XCIsXCJobWFjV2l0aFNIQTI1NlwiLFwiaG1hY1dpdGhTSEEzODRcIixcImhtYWNXaXRoU0hBNTEyXCJdLHJ9fWVsc2UgdD1cImhtYWNXaXRoU0hBMVwiO3JldHVybiBwKHQpfWZ1bmN0aW9uIHAoZSl7dmFyIHQ9bi5tZDtzd2l0Y2goZSl7Y2FzZVwiaG1hY1dpdGhTSEEyMjRcIjp0PW4ubWQuc2hhNTEyO2Nhc2VcImhtYWNXaXRoU0hBMVwiOmNhc2VcImhtYWNXaXRoU0hBMjU2XCI6Y2FzZVwiaG1hY1dpdGhTSEEzODRcIjpjYXNlXCJobWFjV2l0aFNIQTUxMlwiOmU9ZS5zdWJzdHIoOCkudG9Mb3dlckNhc2UoKTticmVhaztkZWZhdWx0OnZhciByPW5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFBSRiBhbGdvcml0aG0uXCIpO3Rocm93IHIuYWxnb3JpdGhtPWUsci5zdXBwb3J0ZWQ9W1wiaG1hY1dpdGhTSEExXCIsXCJobWFjV2l0aFNIQTIyNFwiLFwiaG1hY1dpdGhTSEEyNTZcIixcImhtYWNXaXRoU0hBMzg0XCIsXCJobWFjV2l0aFNIQTUxMlwiXSxyfWlmKCEodCYmZSBpbiB0KSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGhhc2ggYWxnb3JpdGhtOiBcIitlKTtyZXR1cm4gdFtlXS5jcmVhdGUoKX1zLmVuY3J5cHRQcml2YXRlS2V5SW5mbz1mdW5jdGlvbihlLHQscil7KHI9cnx8e30pLnNhbHRTaXplPXIuc2FsdFNpemV8fDgsci5jb3VudD1yLmNvdW50fHwyMDQ4LHIuYWxnb3JpdGhtPXIuYWxnb3JpdGhtfHxcImFlczEyOFwiLHIucHJmQWxnb3JpdGhtPXIucHJmQWxnb3JpdGhtfHxcInNoYTFcIjt2YXIgaSx1LGMsbD1uLnJhbmRvbS5nZXRCeXRlc1N5bmMoci5zYWx0U2l6ZSksZj1yLmNvdW50LGg9YS5pbnRlZ2VyVG9EZXIoZik7aWYoMD09PXIuYWxnb3JpdGhtLmluZGV4T2YoXCJhZXNcIil8fFwiZGVzXCI9PT1yLmFsZ29yaXRobSl7dmFyIGQseSxnO3N3aXRjaChyLmFsZ29yaXRobSl7Y2FzZVwiYWVzMTI4XCI6aT0xNixkPTE2LHk9b1tcImFlczEyOC1DQkNcIl0sZz1uLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcImFlczE5MlwiOmk9MjQsZD0xNix5PW9bXCJhZXMxOTItQ0JDXCJdLGc9bi5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjticmVhaztjYXNlXCJhZXMyNTZcIjppPTMyLGQ9MTYseT1vW1wiYWVzMjU2LUNCQ1wiXSxnPW4uYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiZGVzXCI6aT04LGQ9OCx5PW8uZGVzQ0JDLGc9bi5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjticmVhaztkZWZhdWx0OnRocm93KFQ9bmV3IEVycm9yKFwiQ2Fubm90IGVuY3J5cHQgcHJpdmF0ZSBrZXkuIFVua25vd24gZW5jcnlwdGlvbiBhbGdvcml0aG0uXCIpKS5hbGdvcml0aG09ci5hbGdvcml0aG0sVH12YXIgbT1cImhtYWNXaXRoXCIrci5wcmZBbGdvcml0aG0udG9VcHBlckNhc2UoKSx2PXAobSksYj1uLnBrY3M1LnBia2RmMih0LGwsZixpLHYpLEU9bi5yYW5kb20uZ2V0Qnl0ZXNTeW5jKGQpOyhDPWcoYikpLnN0YXJ0KEUpLEMudXBkYXRlKGEudG9EZXIoZSkpLEMuZmluaXNoKCksYz1DLm91dHB1dC5nZXRCeXRlcygpO3ZhciBTPWZ1bmN0aW9uKGUsdCxyLGkpe3ZhciBvPWEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5TRVFVRU5DRSwhMCxbYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLk9DVEVUU1RSSU5HLCExLGUpLGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5JTlRFR0VSLCExLHQuZ2V0Qnl0ZXMoKSldKTtcImhtYWNXaXRoU0hBMVwiIT09aSYmby52YWx1ZS5wdXNoKGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5JTlRFR0VSLCExLG4udXRpbC5oZXhUb0J5dGVzKHIudG9TdHJpbmcoMTYpKSksYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLlNFUVVFTkNFLCEwLFthLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuT0lELCExLGEub2lkVG9EZXIocy5vaWRzW2ldKS5nZXRCeXRlcygpKSxhLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuTlVMTCwhMSxcIlwiKV0pKTtyZXR1cm4gb30obCxoLGksbSk7dT1hLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuU0VRVUVOQ0UsITAsW2EuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5PSUQsITEsYS5vaWRUb0RlcihvLnBrY3M1UEJFUzIpLmdldEJ5dGVzKCkpLGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5TRVFVRU5DRSwhMCxbYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLlNFUVVFTkNFLCEwLFthLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuT0lELCExLGEub2lkVG9EZXIoby5wa2NzNVBCS0RGMikuZ2V0Qnl0ZXMoKSksU10pLGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5TRVFVRU5DRSwhMCxbYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLk9JRCwhMSxhLm9pZFRvRGVyKHkpLmdldEJ5dGVzKCkpLGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5PQ1RFVFNUUklORywhMSxFKV0pXSldKX1lbHNle3ZhciBUO2lmKFwiM2Rlc1wiIT09ci5hbGdvcml0aG0pdGhyb3coVD1uZXcgRXJyb3IoXCJDYW5ub3QgZW5jcnlwdCBwcml2YXRlIGtleS4gVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobS5cIikpLmFsZ29yaXRobT1yLmFsZ29yaXRobSxUO2k9MjQ7dmFyIEMsQT1uZXcgbi51dGlsLkJ5dGVCdWZmZXIobCk7Yj1zLnBiZS5nZW5lcmF0ZVBrY3MxMktleSh0LEEsMSxmLGkpLEU9cy5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkodCxBLDIsZixpKTsoQz1uLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGIpKS5zdGFydChFKSxDLnVwZGF0ZShhLnRvRGVyKGUpKSxDLmZpbmlzaCgpLGM9Qy5vdXRwdXQuZ2V0Qnl0ZXMoKSx1PWEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5TRVFVRU5DRSwhMCxbYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLk9JRCwhMSxhLm9pZFRvRGVyKG9bXCJwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDXCJdKS5nZXRCeXRlcygpKSxhLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuU0VRVUVOQ0UsITAsW2EuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5PQ1RFVFNUUklORywhMSxsKSxhLmNyZWF0ZShhLkNsYXNzLlVOSVZFUlNBTCxhLlR5cGUuSU5URUdFUiwhMSxoLmdldEJ5dGVzKCkpXSldKX1yZXR1cm4gYS5jcmVhdGUoYS5DbGFzcy5VTklWRVJTQUwsYS5UeXBlLlNFUVVFTkNFLCEwLFt1LGEuY3JlYXRlKGEuQ2xhc3MuVU5JVkVSU0FMLGEuVHlwZS5PQ1RFVFNUUklORywhMSxjKV0pfSxzLmRlY3J5cHRQcml2YXRlS2V5SW5mbz1mdW5jdGlvbihlLHQpe3ZhciByPW51bGwsaT17fSxvPVtdO2lmKCFhLnZhbGlkYXRlKGUsdSxpLG8pKXt2YXIgYz1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBzdXBwb3J0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXCIpO3Rocm93IGMuZXJyb3JzPW8sY312YXIgbD1hLmRlclRvT2lkKGkuZW5jcnlwdGlvbk9pZCksZj1zLnBiZS5nZXRDaXBoZXIobCxpLmVuY3J5cHRpb25QYXJhbXMsdCksaD1uLnV0aWwuY3JlYXRlQnVmZmVyKGkuZW5jcnlwdGVkRGF0YSk7cmV0dXJuIGYudXBkYXRlKGgpLGYuZmluaXNoKCkmJihyPWEuZnJvbURlcihmLm91dHB1dCkpLHJ9LHMuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9e3R5cGU6XCJFTkNSWVBURUQgUFJJVkFURSBLRVlcIixib2R5OmEudG9EZXIoZSkuZ2V0Qnl0ZXMoKX07cmV0dXJuIG4ucGVtLmVuY29kZShyLHttYXhsaW5lOnR9KX0scy5lbmNyeXB0ZWRQcml2YXRlS2V5RnJvbVBlbT1mdW5jdGlvbihlKXt2YXIgdD1uLnBlbS5kZWNvZGUoZSlbMF07aWYoXCJFTkNSWVBURUQgUFJJVkFURSBLRVlcIiE9PXQudHlwZSl7dmFyIHI9bmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBoZWFkZXIgdHlwZSBpcyBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLicpO3Rocm93IHIuaGVhZGVyVHlwZT10LnR5cGUscn1pZih0LnByb2NUeXBlJiZcIkVOQ1JZUFRFRFwiPT09dC5wcm9jVHlwZS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IGVuY3J5cHRlZCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC5cIik7cmV0dXJuIGEuZnJvbURlcih0LmJvZHkpfSxzLmVuY3J5cHRSc2FQcml2YXRlS2V5PWZ1bmN0aW9uKGUsdCxyKXtpZighKHI9cnx8e30pLmxlZ2FjeSl7dmFyIGk9cy53cmFwUnNhUHJpdmF0ZUtleShzLnByaXZhdGVLZXlUb0FzbjEoZSkpO3JldHVybiBpPXMuZW5jcnlwdFByaXZhdGVLZXlJbmZvKGksdCxyKSxzLmVuY3J5cHRlZFByaXZhdGVLZXlUb1BlbShpKX12YXIgbyx1LGMsbDtzd2l0Y2goci5hbGdvcml0aG0pe2Nhc2VcImFlczEyOFwiOm89XCJBRVMtMTI4LUNCQ1wiLGM9MTYsdT1uLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpLGw9bi5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjticmVhaztjYXNlXCJhZXMxOTJcIjpvPVwiQUVTLTE5Mi1DQkNcIixjPTI0LHU9bi5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KSxsPW4uYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiYWVzMjU2XCI6bz1cIkFFUy0yNTYtQ0JDXCIsYz0zMix1PW4ucmFuZG9tLmdldEJ5dGVzU3luYygxNiksbD1uLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcIjNkZXNcIjpvPVwiREVTLUVERTMtQ0JDXCIsYz0yNCx1PW4ucmFuZG9tLmdldEJ5dGVzU3luYyg4KSxsPW4uZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiZGVzXCI6bz1cIkRFUy1DQkNcIixjPTgsdT1uLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCksbD1uLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO2JyZWFrO2RlZmF1bHQ6dmFyIGY9bmV3IEVycm9yKCdDb3VsZCBub3QgZW5jcnlwdCBSU0EgcHJpdmF0ZSBrZXk7IHVuc3VwcG9ydGVkIGVuY3J5cHRpb24gYWxnb3JpdGhtIFwiJytyLmFsZ29yaXRobSsnXCIuJyk7dGhyb3cgZi5hbGdvcml0aG09ci5hbGdvcml0aG0sZn12YXIgaD1sKG4ucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyh0LHUuc3Vic3RyKDAsOCksYykpO2guc3RhcnQodSksaC51cGRhdGUoYS50b0RlcihzLnByaXZhdGVLZXlUb0FzbjEoZSkpKSxoLmZpbmlzaCgpO3ZhciBwPXt0eXBlOlwiUlNBIFBSSVZBVEUgS0VZXCIscHJvY1R5cGU6e3ZlcnNpb246XCI0XCIsdHlwZTpcIkVOQ1JZUFRFRFwifSxkZWtJbmZvOnthbGdvcml0aG06byxwYXJhbWV0ZXJzOm4udXRpbC5ieXRlc1RvSGV4KHUpLnRvVXBwZXJDYXNlKCl9LGJvZHk6aC5vdXRwdXQuZ2V0Qnl0ZXMoKX07cmV0dXJuIG4ucGVtLmVuY29kZShwKX0scy5kZWNyeXB0UnNhUHJpdmF0ZUtleT1mdW5jdGlvbihlLHQpe3ZhciByPW51bGwsaT1uLnBlbS5kZWNvZGUoZSlbMF07aWYoXCJFTkNSWVBURUQgUFJJVkFURSBLRVlcIiE9PWkudHlwZSYmXCJQUklWQVRFIEtFWVwiIT09aS50eXBlJiZcIlJTQSBQUklWQVRFIEtFWVwiIT09aS50eXBlKXRocm93KGM9bmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLCBcIlBSSVZBVEUgS0VZXCIsIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJykpLmhlYWRlclR5cGU9YyxjO2lmKGkucHJvY1R5cGUmJlwiRU5DUllQVEVEXCI9PT1pLnByb2NUeXBlLnR5cGUpe3ZhciBvLHU7c3dpdGNoKGkuZGVrSW5mby5hbGdvcml0aG0pe2Nhc2VcIkRFUy1DQkNcIjpvPTgsdT1uLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcIkRFUy1FREUzLUNCQ1wiOm89MjQsdT1uLmRlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcIkFFUy0xMjgtQ0JDXCI6bz0xNix1PW4uYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiQUVTLTE5Mi1DQkNcIjpvPTI0LHU9bi5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjticmVhaztjYXNlXCJBRVMtMjU2LUNCQ1wiOm89MzIsdT1uLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcIlJDMi00MC1DQkNcIjpvPTUsdT1mdW5jdGlvbihlKXtyZXR1cm4gbi5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihlLDQwKX07YnJlYWs7Y2FzZVwiUkMyLTY0LUNCQ1wiOm89OCx1PWZ1bmN0aW9uKGUpe3JldHVybiBuLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGUsNjQpfTticmVhaztjYXNlXCJSQzItMTI4LUNCQ1wiOm89MTYsdT1mdW5jdGlvbihlKXtyZXR1cm4gbi5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihlLDEyOCl9O2JyZWFrO2RlZmF1bHQ6dmFyIGM7dGhyb3coYz1uZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNyeXB0IHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCBlbmNyeXB0aW9uIGFsZ29yaXRobSBcIicraS5kZWtJbmZvLmFsZ29yaXRobSsnXCIuJykpLmFsZ29yaXRobT1pLmRla0luZm8uYWxnb3JpdGhtLGN9dmFyIGw9bi51dGlsLmhleFRvQnl0ZXMoaS5kZWtJbmZvLnBhcmFtZXRlcnMpLGY9dShuLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXModCxsLnN1YnN0cigwLDgpLG8pKTtpZihmLnN0YXJ0KGwpLGYudXBkYXRlKG4udXRpbC5jcmVhdGVCdWZmZXIoaS5ib2R5KSksIWYuZmluaXNoKCkpcmV0dXJuIHI7cj1mLm91dHB1dC5nZXRCeXRlcygpfWVsc2Ugcj1pLmJvZHk7cmV0dXJuIG51bGwhPT0ocj1cIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiPT09aS50eXBlP3MuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGEuZnJvbURlcihyKSx0KTphLmZyb21EZXIocikpJiYocj1zLnByaXZhdGVLZXlGcm9tQXNuMShyKSkscn0scy5wYmUuZ2VuZXJhdGVQa2NzMTJLZXk9ZnVuY3Rpb24oZSx0LHIsaSxhLHMpe3ZhciBvLHU7aWYobnVsbD09cyl7aWYoIShcInNoYTFcImluIG4ubWQpKXRocm93IG5ldyBFcnJvcignXCJzaGExXCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7cz1uLm1kLnNoYTEuY3JlYXRlKCl9dmFyIGM9cy5kaWdlc3RMZW5ndGgsbD1zLmJsb2NrTGVuZ3RoLGY9bmV3IG4udXRpbC5CeXRlQnVmZmVyLGg9bmV3IG4udXRpbC5CeXRlQnVmZmVyO2lmKG51bGwhPWUpe2Zvcih1PTA7dTxlLmxlbmd0aDt1KyspaC5wdXRJbnQxNihlLmNoYXJDb2RlQXQodSkpO2gucHV0SW50MTYoMCl9dmFyIHA9aC5sZW5ndGgoKSxkPXQubGVuZ3RoKCkseT1uZXcgbi51dGlsLkJ5dGVCdWZmZXI7eS5maWxsV2l0aEJ5dGUocixsKTt2YXIgZz1sKk1hdGguY2VpbChkL2wpLG09bmV3IG4udXRpbC5CeXRlQnVmZmVyO2Zvcih1PTA7dTxnO3UrKyltLnB1dEJ5dGUodC5hdCh1JWQpKTt2YXIgdj1sKk1hdGguY2VpbChwL2wpLGI9bmV3IG4udXRpbC5CeXRlQnVmZmVyO2Zvcih1PTA7dTx2O3UrKyliLnB1dEJ5dGUoaC5hdCh1JXApKTt2YXIgRT1tO0UucHV0QnVmZmVyKGIpO2Zvcih2YXIgUz1NYXRoLmNlaWwoYS9jKSxUPTE7VDw9UztUKyspe3ZhciBDPW5ldyBuLnV0aWwuQnl0ZUJ1ZmZlcjtDLnB1dEJ5dGVzKHkuYnl0ZXMoKSksQy5wdXRCeXRlcyhFLmJ5dGVzKCkpO2Zvcih2YXIgQT0wO0E8aTtBKyspcy5zdGFydCgpLHMudXBkYXRlKEMuZ2V0Qnl0ZXMoKSksQz1zLmRpZ2VzdCgpO3ZhciBJPW5ldyBuLnV0aWwuQnl0ZUJ1ZmZlcjtmb3IodT0wO3U8bDt1KyspSS5wdXRCeXRlKEMuYXQodSVjKSk7dmFyIHc9TWF0aC5jZWlsKGQvbCkrTWF0aC5jZWlsKHAvbCksQj1uZXcgbi51dGlsLkJ5dGVCdWZmZXI7Zm9yKG89MDtvPHc7bysrKXt2YXIgTj1uZXcgbi51dGlsLkJ5dGVCdWZmZXIoRS5nZXRCeXRlcyhsKSksUj01MTE7Zm9yKHU9SS5sZW5ndGgoKS0xO3U+PTA7dS0tKVI+Pj04LFIrPUkuYXQodSkrTi5hdCh1KSxOLnNldEF0KHUsMjU1JlIpO0IucHV0QnVmZmVyKE4pfUU9QixmLnB1dEJ1ZmZlcihDKX1yZXR1cm4gZi50cnVuY2F0ZShmLmxlbmd0aCgpLWEpLGZ9LHMucGJlLmdldENpcGhlcj1mdW5jdGlvbihlLHQscil7c3dpdGNoKGUpe2Nhc2Ugcy5vaWRzLnBrY3M1UEJFUzI6cmV0dXJuIHMucGJlLmdldENpcGhlckZvclBCRVMyKGUsdCxyKTtjYXNlIHMub2lkc1tcInBiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkNcIl06Y2FzZSBzLm9pZHNbXCJwYmV3aXRoU0hBQW5kNDBCaXRSQzItQ0JDXCJdOnJldHVybiBzLnBiZS5nZXRDaXBoZXJGb3JQS0NTMTJQQkUoZSx0LHIpO2RlZmF1bHQ6dmFyIG49bmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgZW5jcnlwdGVkIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuXCIpO3Rocm93IG4ub2lkPWUsbi5zdXBwb3J0ZWRPaWRzPVtcInBrY3M1UEJFUzJcIixcInBiZVdpdGhTSEFBbmQzLUtleVRyaXBsZURFUy1DQkNcIixcInBiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkNcIl0sbn19LHMucGJlLmdldENpcGhlckZvclBCRVMyPWZ1bmN0aW9uKGUsdCxyKXt2YXIgaSxvPXt9LHU9W107aWYoIWEudmFsaWRhdGUodCxjLG8sdSkpdGhyb3coaT1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlwiKSkuZXJyb3JzPXUsaTtpZigoZT1hLmRlclRvT2lkKG8ua2RmT2lkKSkhPT1zLm9pZHMucGtjczVQQktERjIpdGhyb3coaT1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuIFVuc3VwcG9ydGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIE9JRC5cIikpLm9pZD1lLGkuc3VwcG9ydGVkT2lkcz1bXCJwa2NzNVBCS0RGMlwiXSxpO2lmKChlPWEuZGVyVG9PaWQoby5lbmNPaWQpKSE9PXMub2lkc1tcImFlczEyOC1DQkNcIl0mJmUhPT1zLm9pZHNbXCJhZXMxOTItQ0JDXCJdJiZlIT09cy5vaWRzW1wiYWVzMjU2LUNCQ1wiXSYmZSE9PXMub2lkc1tcImRlcy1FREUzLUNCQ1wiXSYmZSE9PXMub2lkcy5kZXNDQkMpdGhyb3coaT1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuIFVuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lIE9JRC5cIikpLm9pZD1lLGkuc3VwcG9ydGVkT2lkcz1bXCJhZXMxMjgtQ0JDXCIsXCJhZXMxOTItQ0JDXCIsXCJhZXMyNTYtQ0JDXCIsXCJkZXMtRURFMy1DQkNcIixcImRlc0NCQ1wiXSxpO3ZhciBsLGYscD1vLmtkZlNhbHQsZD1uLnV0aWwuY3JlYXRlQnVmZmVyKG8ua2RmSXRlcmF0aW9uQ291bnQpO3N3aXRjaChkPWQuZ2V0SW50KGQubGVuZ3RoKCk8PDMpLHMub2lkc1tlXSl7Y2FzZVwiYWVzMTI4LUNCQ1wiOmw9MTYsZj1uLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO2JyZWFrO2Nhc2VcImFlczE5Mi1DQkNcIjpsPTI0LGY9bi5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjticmVhaztjYXNlXCJhZXMyNTYtQ0JDXCI6bD0zMixmPW4uYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiZGVzLUVERTMtQ0JDXCI6bD0yNCxmPW4uZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7YnJlYWs7Y2FzZVwiZGVzQ0JDXCI6bD04LGY9bi5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcn12YXIgeT1oKG8ucHJmT2lkKSxnPW4ucGtjczUucGJrZGYyKHIscCxkLGwseSksbT1vLmVuY0l2LHY9ZihnKTtyZXR1cm4gdi5zdGFydChtKSx2fSxzLnBiZS5nZXRDaXBoZXJGb3JQS0NTMTJQQkU9ZnVuY3Rpb24oZSx0LHIpe3ZhciBpPXt9LG89W107aWYoIWEudmFsaWRhdGUodCxsLGksbykpdGhyb3coeT1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlwiKSkuZXJyb3JzPW8seTt2YXIgdSxjLGYscD1uLnV0aWwuY3JlYXRlQnVmZmVyKGkuc2FsdCksZD1uLnV0aWwuY3JlYXRlQnVmZmVyKGkuaXRlcmF0aW9ucyk7c3dpdGNoKGQ9ZC5nZXRJbnQoZC5sZW5ndGgoKTw8MyksZSl7Y2FzZSBzLm9pZHNbXCJwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDXCJdOnU9MjQsYz04LGY9bi5kZXMuc3RhcnREZWNyeXB0aW5nO2JyZWFrO2Nhc2Ugcy5vaWRzW1wicGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQ1wiXTp1PTUsYz04LGY9ZnVuY3Rpb24oZSx0KXt2YXIgcj1uLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGUsNDApO3JldHVybiByLnN0YXJ0KHQsbnVsbCkscn07YnJlYWs7ZGVmYXVsdDp2YXIgeTt0aHJvdyh5PW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MgIzEyIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuXCIpKS5vaWQ9ZSx5fXZhciBnPWgoaS5wcmZPaWQpLG09cy5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocixwLDEsZCx1LGcpO3JldHVybiBnLnN0YXJ0KCksZihtLHMucGJlLmdlbmVyYXRlUGtjczEyS2V5KHIscCwyLGQsYyxnKSl9LHMucGJlLm9wZW5zc2xEZXJpdmVCeXRlcz1mdW5jdGlvbihlLHQscixpKXtpZihudWxsPT1pKXtpZighKFwibWQ1XCJpbiBuLm1kKSl0aHJvdyBuZXcgRXJyb3IoJ1wibWQ1XCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7aT1uLm1kLm1kNS5jcmVhdGUoKX1udWxsPT09dCYmKHQ9XCJcIik7Zm9yKHZhciBhPVtmKGksZSt0KV0scz0xNixvPTE7czxyOysrbyxzKz0xNilhLnB1c2goZihpLGFbby0xXStlK3QpKTtyZXR1cm4gYS5qb2luKFwiXCIpLnN1YnN0cigwLHIpfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7ZnVuY3Rpb24gaShlLHQpe24uY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKGUsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuLmRlcy5BbGdvcml0aG0oZSx0KX0pKX1yKDMwKSxyKDUyKSxyKDIpLGUuZXhwb3J0cz1uLmRlcz1uLmRlc3x8e30sbi5kZXMuc3RhcnRFbmNyeXB0aW5nPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPWQoe2tleTplLG91dHB1dDpyLGRlY3J5cHQ6ITEsbW9kZTpufHwobnVsbD09PXQ/XCJFQ0JcIjpcIkNCQ1wiKX0pO3JldHVybiBpLnN0YXJ0KHQpLGl9LG4uZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZCh7a2V5OmUsb3V0cHV0Om51bGwsZGVjcnlwdDohMSxtb2RlOnR9KX0sbi5kZXMuc3RhcnREZWNyeXB0aW5nPWZ1bmN0aW9uKGUsdCxyLG4pe3ZhciBpPWQoe2tleTplLG91dHB1dDpyLGRlY3J5cHQ6ITAsbW9kZTpufHwobnVsbD09PXQ/XCJFQ0JcIjpcIkNCQ1wiKX0pO3JldHVybiBpLnN0YXJ0KHQpLGl9LG4uZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZCh7a2V5OmUsb3V0cHV0Om51bGwsZGVjcnlwdDohMCxtb2RlOnR9KX0sbi5kZXMuQWxnb3JpdGhtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcztyLm5hbWU9ZSxyLm1vZGU9bmV3IHQoe2Jsb2NrU2l6ZTo4LGNpcGhlcjp7ZW5jcnlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBwKHIuX2tleXMsZSx0LCExKX0sZGVjcnlwdDpmdW5jdGlvbihlLHQpe3JldHVybiBwKHIuX2tleXMsZSx0LCEwKX19fSksci5faW5pdD0hMX0sbi5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKGUpe2lmKCF0aGlzLl9pbml0KXt2YXIgdD1uLnV0aWwuY3JlYXRlQnVmZmVyKGUua2V5KTtpZigwPT09dGhpcy5uYW1lLmluZGV4T2YoXCIzREVTXCIpJiYyNCE9PXQubGVuZ3RoKCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiBcIis4KnQubGVuZ3RoKCkpO3RoaXMuX2tleXM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9WzAsNCw1MzY4NzA5MTIsNTM2ODcwOTE2LDY1NTM2LDY1NTQwLDUzNjkzNjQ0OCw1MzY5MzY0NTIsNTEyLDUxNiw1MzY4NzE0MjQsNTM2ODcxNDI4LDY2MDQ4LDY2MDUyLDUzNjkzNjk2MCw1MzY5MzY5NjRdLG49WzAsMSwxMDQ4NTc2LDEwNDg1NzcsNjcxMDg4NjQsNjcxMDg4NjUsNjgxNTc0NDAsNjgxNTc0NDEsMjU2LDI1NywxMDQ4ODMyLDEwNDg4MzMsNjcxMDkxMjAsNjcxMDkxMjEsNjgxNTc2OTYsNjgxNTc2OTddLGk9WzAsOCwyMDQ4LDIwNTYsMTY3NzcyMTYsMTY3NzcyMjQsMTY3NzkyNjQsMTY3NzkyNzIsMCw4LDIwNDgsMjA1NiwxNjc3NzIxNiwxNjc3NzIyNCwxNjc3OTI2NCwxNjc3OTI3Ml0sYT1bMCwyMDk3MTUyLDEzNDIxNzcyOCwxMzYzMTQ4ODAsODE5MiwyMTA1MzQ0LDEzNDIyNTkyMCwxMzYzMjMwNzIsMTMxMDcyLDIyMjgyMjQsMTM0MzQ4ODAwLDEzNjQ0NTk1MiwxMzkyNjQsMjIzNjQxNiwxMzQzNTY5OTIsMTM2NDU0MTQ0XSxzPVswLDI2MjE0NCwxNiwyNjIxNjAsMCwyNjIxNDQsMTYsMjYyMTYwLDQwOTYsMjY2MjQwLDQxMTIsMjY2MjU2LDQwOTYsMjY2MjQwLDQxMTIsMjY2MjU2XSxvPVswLDEwMjQsMzIsMTA1NiwwLDEwMjQsMzIsMTA1NiwzMzU1NDQzMiwzMzU1NTQ1NiwzMzU1NDQ2NCwzMzU1NTQ4OCwzMzU1NDQzMiwzMzU1NTQ1NiwzMzU1NDQ2NCwzMzU1NTQ4OF0sdT1bMCwyNjg0MzU0NTYsNTI0Mjg4LDI2ODk1OTc0NCwyLDI2ODQzNTQ1OCw1MjQyOTAsMjY4OTU5NzQ2LDAsMjY4NDM1NDU2LDUyNDI4OCwyNjg5NTk3NDQsMiwyNjg0MzU0NTgsNTI0MjkwLDI2ODk1OTc0Nl0sYz1bMCw2NTUzNiwyMDQ4LDY3NTg0LDUzNjg3MDkxMiw1MzY5MzY0NDgsNTM2ODcyOTYwLDUzNjkzODQ5NiwxMzEwNzIsMTk2NjA4LDEzMzEyMCwxOTg2NTYsNTM3MDAxOTg0LDUzNzA2NzUyMCw1MzcwMDQwMzIsNTM3MDY5NTY4XSxsPVswLDI2MjE0NCwwLDI2MjE0NCwyLDI2MjE0NiwyLDI2MjE0NiwzMzU1NDQzMiwzMzgxNjU3NiwzMzU1NDQzMiwzMzgxNjU3NiwzMzU1NDQzNCwzMzgxNjU3OCwzMzU1NDQzNCwzMzgxNjU3OF0sZj1bMCwyNjg0MzU0NTYsOCwyNjg0MzU0NjQsMCwyNjg0MzU0NTYsOCwyNjg0MzU0NjQsMTAyNCwyNjg0MzY0ODAsMTAzMiwyNjg0MzY0ODgsMTAyNCwyNjg0MzY0ODAsMTAzMiwyNjg0MzY0ODhdLGg9WzAsMzIsMCwzMiwxMDQ4NTc2LDEwNDg2MDgsMTA0ODU3NiwxMDQ4NjA4LDgxOTIsODIyNCw4MTkyLDgyMjQsMTA1Njc2OCwxMDU2ODAwLDEwNTY3NjgsMTA1NjgwMF0scD1bMCwxNjc3NzIxNiw1MTIsMTY3Nzc3MjgsMjA5NzE1MiwxODg3NDM2OCwyMDk3NjY0LDE4ODc0ODgwLDY3MTA4ODY0LDgzODg2MDgwLDY3MTA5Mzc2LDgzODg2NTkyLDY5MjA2MDE2LDg1OTgzMjMyLDY5MjA2NTI4LDg1OTgzNzQ0XSxkPVswLDQwOTYsMTM0MjE3NzI4LDEzNDIyMTgyNCw1MjQyODgsNTI4Mzg0LDEzNDc0MjAxNiwxMzQ3NDYxMTIsMTYsNDExMiwxMzQyMTc3NDQsMTM0MjIxODQwLDUyNDMwNCw1Mjg0MDAsMTM0NzQyMDMyLDEzNDc0NjEyOF0seT1bMCw0LDI1NiwyNjAsMCw0LDI1NiwyNjAsMSw1LDI1NywyNjEsMSw1LDI1NywyNjFdLGc9ZS5sZW5ndGgoKT44PzM6MSxtPVtdLHY9WzAsMCwxLDEsMSwxLDEsMSwwLDEsMSwxLDEsMSwxLDBdLGI9MCxFPTA7RTxnO0UrKyl7dmFyIFM9ZS5nZXRJbnQzMigpLFQ9ZS5nZXRJbnQzMigpO1NePSh0PTI1MjY0NTEzNSYoUz4+PjReVCkpPDw0LFNePXQ9NjU1MzUmKChUXj10KT4+Pi0xNl5TKSxTXj0odD04NTg5OTM0NTkmKFM+Pj4yXihUXj10PDwtMTYpKSk8PDIsU149dD02NTUzNSYoKFRePXQpPj4+LTE2XlMpLFNePSh0PTE0MzE2NTU3NjUmKFM+Pj4xXihUXj10PDwtMTYpKSk8PDEsU149dD0xNjcxMTkzNSYoKFRePXQpPj4+OF5TKSx0PShTXj0odD0xNDMxNjU1NzY1JihTPj4+MV4oVF49dDw8OCkpKTw8MSk8PDh8KFRePXQpPj4+MjAmMjQwLFM9VDw8MjR8VDw8OCYxNjcxMTY4MHxUPj4+OCY2NTI4MHxUPj4+MjQmMjQwLFQ9dDtmb3IodmFyIEM9MDtDPHYubGVuZ3RoOysrQyl7dltDXT8oUz1TPDwyfFM+Pj4yNixUPVQ8PDJ8VD4+PjI2KTooUz1TPDwxfFM+Pj4yNyxUPVQ8PDF8VD4+PjI3KTt2YXIgQT1yWyhTJj0tMTUpPj4+MjhdfG5bUz4+PjI0JjE1XXxpW1M+Pj4yMCYxNV18YVtTPj4+MTYmMTVdfHNbUz4+PjEyJjE1XXxvW1M+Pj44JjE1XXx1W1M+Pj40JjE1XSxJPWNbKFQmPS0xNSk+Pj4yOF18bFtUPj4+MjQmMTVdfGZbVD4+PjIwJjE1XXxoW1Q+Pj4xNiYxNV18cFtUPj4+MTImMTVdfGRbVD4+PjgmMTVdfHlbVD4+PjQmMTVdO3Q9NjU1MzUmKEk+Pj4xNl5BKSxtW2IrK109QV50LG1bYisrXT1JXnQ8PDE2fX1yZXR1cm4gbX0odCksdGhpcy5faW5pdD0hMH19LGkoXCJERVMtRUNCXCIsbi5jaXBoZXIubW9kZXMuZWNiKSxpKFwiREVTLUNCQ1wiLG4uY2lwaGVyLm1vZGVzLmNiYyksaShcIkRFUy1DRkJcIixuLmNpcGhlci5tb2Rlcy5jZmIpLGkoXCJERVMtT0ZCXCIsbi5jaXBoZXIubW9kZXMub2ZiKSxpKFwiREVTLUNUUlwiLG4uY2lwaGVyLm1vZGVzLmN0ciksaShcIjNERVMtRUNCXCIsbi5jaXBoZXIubW9kZXMuZWNiKSxpKFwiM0RFUy1DQkNcIixuLmNpcGhlci5tb2Rlcy5jYmMpLGkoXCIzREVTLUNGQlwiLG4uY2lwaGVyLm1vZGVzLmNmYiksaShcIjNERVMtT0ZCXCIsbi5jaXBoZXIubW9kZXMub2ZiKSxpKFwiM0RFUy1DVFJcIixuLmNpcGhlci5tb2Rlcy5jdHIpO3ZhciBhPVsxNjg0Mzc3NiwwLDY1NTM2LDE2ODQzNzgwLDE2ODQyNzU2LDY2NTY0LDQsNjU1MzYsMTAyNCwxNjg0Mzc3NiwxNjg0Mzc4MCwxMDI0LDE2Nzc4MjQ0LDE2ODQyNzU2LDE2Nzc3MjE2LDQsMTAyOCwxNjc3ODI0MCwxNjc3ODI0MCw2NjU2MCw2NjU2MCwxNjg0Mjc1MiwxNjg0Mjc1MiwxNjc3ODI0NCw2NTU0MCwxNjc3NzIyMCwxNjc3NzIyMCw2NTU0MCwwLDEwMjgsNjY1NjQsMTY3NzcyMTYsNjU1MzYsMTY4NDM3ODAsNCwxNjg0Mjc1MiwxNjg0Mzc3NiwxNjc3NzIxNiwxNjc3NzIxNiwxMDI0LDE2ODQyNzU2LDY1NTM2LDY2NTYwLDE2Nzc3MjIwLDEwMjQsNCwxNjc3ODI0NCw2NjU2NCwxNjg0Mzc4MCw2NTU0MCwxNjg0Mjc1MiwxNjc3ODI0NCwxNjc3NzIyMCwxMDI4LDY2NTY0LDE2ODQzNzc2LDEwMjgsMTY3NzgyNDAsMTY3NzgyNDAsMCw2NTU0MCw2NjU2MCwwLDE2ODQyNzU2XSxzPVstMjE0NjQwMjI3MiwtMjE0NzQ1MDg4MCwzMjc2OCwxMDgxMzc2LDEwNDg1NzYsMzIsLTIxNDY0MzUwNDAsLTIxNDc0NTA4NDgsLTIxNDc0ODM2MTYsLTIxNDY0MDIyNzIsLTIxNDY0MDIzMDQsLTIxNDc0ODM2NDgsLTIxNDc0NTA4ODAsMTA0ODU3NiwzMiwtMjE0NjQzNTA0MCwxMDgxMzQ0LDEwNDg2MDgsLTIxNDc0NTA4NDgsMCwtMjE0NzQ4MzY0OCwzMjc2OCwxMDgxMzc2LC0yMTQ2NDM1MDcyLDEwNDg2MDgsLTIxNDc0ODM2MTYsMCwxMDgxMzQ0LDMyODAwLC0yMTQ2NDAyMzA0LC0yMTQ2NDM1MDcyLDMyODAwLDAsMTA4MTM3NiwtMjE0NjQzNTA0MCwxMDQ4NTc2LC0yMTQ3NDUwODQ4LC0yMTQ2NDM1MDcyLC0yMTQ2NDAyMzA0LDMyNzY4LC0yMTQ2NDM1MDcyLC0yMTQ3NDUwODgwLDMyLC0yMTQ2NDAyMjcyLDEwODEzNzYsMzIsMzI3NjgsLTIxNDc0ODM2NDgsMzI4MDAsLTIxNDY0MDIzMDQsMTA0ODU3NiwtMjE0NzQ4MzYxNiwxMDQ4NjA4LC0yMTQ3NDUwODQ4LC0yMTQ3NDgzNjE2LDEwNDg2MDgsMTA4MTM0NCwwLC0yMTQ3NDUwODgwLDMyODAwLC0yMTQ3NDgzNjQ4LC0yMTQ2NDM1MDQwLC0yMTQ2NDAyMjcyLDEwODEzNDRdLG89WzUyMCwxMzQzNDkzMTIsMCwxMzQzNDg4MDgsMTM0MjE4MjQwLDAsMTMxNTkyLDEzNDIxODI0MCwxMzEwODAsMTM0MjE3NzM2LDEzNDIxNzczNiwxMzEwNzIsMTM0MzQ5MzIwLDEzMTA4MCwxMzQzNDg4MDAsNTIwLDEzNDIxNzcyOCw4LDEzNDM0OTMxMiw1MTIsMTMxNTg0LDEzNDM0ODgwMCwxMzQzNDg4MDgsMTMxNTkyLDEzNDIxODI0OCwxMzE1ODQsMTMxMDcyLDEzNDIxODI0OCw4LDEzNDM0OTMyMCw1MTIsMTM0MjE3NzI4LDEzNDM0OTMxMiwxMzQyMTc3MjgsMTMxMDgwLDUyMCwxMzEwNzIsMTM0MzQ5MzEyLDEzNDIxODI0MCwwLDUxMiwxMzEwODAsMTM0MzQ5MzIwLDEzNDIxODI0MCwxMzQyMTc3MzYsNTEyLDAsMTM0MzQ4ODA4LDEzNDIxODI0OCwxMzEwNzIsMTM0MjE3NzI4LDEzNDM0OTMyMCw4LDEzMTU5MiwxMzE1ODQsMTM0MjE3NzM2LDEzNDM0ODgwMCwxMzQyMTgyNDgsNTIwLDEzNDM0ODgwMCwxMzE1OTIsOCwxMzQzNDg4MDgsMTMxNTg0XSx1PVs4Mzk2ODAxLDgzMjEsODMyMSwxMjgsODM5NjkyOCw4Mzg4NzM3LDgzODg2MDksODE5MywwLDgzOTY4MDAsODM5NjgwMCw4Mzk2OTI5LDEyOSwwLDgzODg3MzYsODM4ODYwOSwxLDgxOTIsODM4ODYwOCw4Mzk2ODAxLDEyOCw4Mzg4NjA4LDgxOTMsODMyMCw4Mzg4NzM3LDEsODMyMCw4Mzg4NzM2LDgxOTIsODM5NjkyOCw4Mzk2OTI5LDEyOSw4Mzg4NzM2LDgzODg2MDksODM5NjgwMCw4Mzk2OTI5LDEyOSwwLDAsODM5NjgwMCw4MzIwLDgzODg3MzYsODM4ODczNywxLDgzOTY4MDEsODMyMSw4MzIxLDEyOCw4Mzk2OTI5LDEyOSwxLDgxOTIsODM4ODYwOSw4MTkzLDgzOTY5MjgsODM4ODczNyw4MTkzLDgzMjAsODM4ODYwOCw4Mzk2ODAxLDEyOCw4Mzg4NjA4LDgxOTIsODM5NjkyOF0sYz1bMjU2LDM0MDc4OTc2LDM0MDc4NzIwLDExMDcyOTY1MTIsNTI0Mjg4LDI1NiwxMDczNzQxODI0LDM0MDc4NzIwLDEwNzQyNjYzNjgsNTI0Mjg4LDMzNTU0Njg4LDEwNzQyNjYzNjgsMTEwNzI5NjUxMiwxMTA3ODIwNTQ0LDUyNDU0NCwxMDczNzQxODI0LDMzNTU0NDMyLDEwNzQyNjYxMTIsMTA3NDI2NjExMiwwLDEwNzM3NDIwODAsMTEwNzgyMDgwMCwxMTA3ODIwODAwLDMzNTU0Njg4LDExMDc4MjA1NDQsMTA3Mzc0MjA4MCwwLDExMDcyOTYyNTYsMzQwNzg5NzYsMzM1NTQ0MzIsMTEwNzI5NjI1Niw1MjQ1NDQsNTI0Mjg4LDExMDcyOTY1MTIsMjU2LDMzNTU0NDMyLDEwNzM3NDE4MjQsMzQwNzg3MjAsMTEwNzI5NjUxMiwxMDc0MjY2MzY4LDMzNTU0Njg4LDEwNzM3NDE4MjQsMTEwNzgyMDU0NCwzNDA3ODk3NiwxMDc0MjY2MzY4LDI1NiwzMzU1NDQzMiwxMTA3ODIwNTQ0LDExMDc4MjA4MDAsNTI0NTQ0LDExMDcyOTYyNTYsMTEwNzgyMDgwMCwzNDA3ODcyMCwwLDEwNzQyNjYxMTIsMTEwNzI5NjI1Niw1MjQ1NDQsMzM1NTQ2ODgsMTA3Mzc0MjA4MCw1MjQyODgsMCwxMDc0MjY2MTEyLDM0MDc4OTc2LDEwNzM3NDIwODBdLGw9WzUzNjg3MDkyOCw1NDEwNjUyMTYsMTYzODQsNTQxMDgxNjE2LDU0MTA2NTIxNiwxNiw1NDEwODE2MTYsNDE5NDMwNCw1MzY4ODcyOTYsNDIxMDcwNCw0MTk0MzA0LDUzNjg3MDkyOCw0MTk0MzIwLDUzNjg4NzI5Niw1MzY4NzA5MTIsMTY0MDAsMCw0MTk0MzIwLDUzNjg4NzMxMiwxNjM4NCw0MjEwNjg4LDUzNjg4NzMxMiwxNiw1NDEwNjUyMzIsNTQxMDY1MjMyLDAsNDIxMDcwNCw1NDEwODE2MDAsMTY0MDAsNDIxMDY4OCw1NDEwODE2MDAsNTM2ODcwOTEyLDUzNjg4NzI5NiwxNiw1NDEwNjUyMzIsNDIxMDY4OCw1NDEwODE2MTYsNDE5NDMwNCwxNjQwMCw1MzY4NzA5MjgsNDE5NDMwNCw1MzY4ODcyOTYsNTM2ODcwOTEyLDE2NDAwLDUzNjg3MDkyOCw1NDEwODE2MTYsNDIxMDY4OCw1NDEwNjUyMTYsNDIxMDcwNCw1NDEwODE2MDAsMCw1NDEwNjUyMzIsMTYsMTYzODQsNTQxMDY1MjE2LDQyMTA3MDQsMTYzODQsNDE5NDMyMCw1MzY4ODczMTIsMCw1NDEwODE2MDAsNTM2ODcwOTEyLDQxOTQzMjAsNTM2ODg3MzEyXSxmPVsyMDk3MTUyLDY5MjA2MDE4LDY3MTEwOTE0LDAsMjA0OCw2NzExMDkxNCwyMDk5MjAyLDY5MjA4MDY0LDY5MjA4MDY2LDIwOTcxNTIsMCw2NzEwODg2NiwyLDY3MTA4ODY0LDY5MjA2MDE4LDIwNTAsNjcxMTA5MTIsMjA5OTIwMiwyMDk3MTU0LDY3MTEwOTEyLDY3MTA4ODY2LDY5MjA2MDE2LDY5MjA4MDY0LDIwOTcxNTQsNjkyMDYwMTYsMjA0OCwyMDUwLDY5MjA4MDY2LDIwOTkyMDAsMiw2NzEwODg2NCwyMDk5MjAwLDY3MTA4ODY0LDIwOTkyMDAsMjA5NzE1Miw2NzExMDkxNCw2NzExMDkxNCw2OTIwNjAxOCw2OTIwNjAxOCwyLDIwOTcxNTQsNjcxMDg4NjQsNjcxMTA5MTIsMjA5NzE1Miw2OTIwODA2NCwyMDUwLDIwOTkyMDIsNjkyMDgwNjQsMjA1MCw2NzEwODg2Niw2OTIwODA2Niw2OTIwNjAxNiwyMDk5MjAwLDAsMiw2OTIwODA2NiwwLDIwOTkyMDIsNjkyMDYwMTYsMjA0OCw2NzEwODg2Niw2NzExMDkxMiwyMDQ4LDIwOTcxNTRdLGg9WzI2ODQzOTYxNiw0MDk2LDI2MjE0NCwyNjg3MDE3NjAsMjY4NDM1NDU2LDI2ODQzOTYxNiw2NCwyNjg0MzU0NTYsMjYyMjA4LDI2ODY5NzYwMCwyNjg3MDE3NjAsMjY2MjQwLDI2ODcwMTY5NiwyNjYzMDQsNDA5Niw2NCwyNjg2OTc2MDAsMjY4NDM1NTIwLDI2ODQzOTU1Miw0MTYwLDI2NjI0MCwyNjIyMDgsMjY4Njk3NjY0LDI2ODcwMTY5Niw0MTYwLDAsMCwyNjg2OTc2NjQsMjY4NDM1NTIwLDI2ODQzOTU1MiwyNjYzMDQsMjYyMTQ0LDI2NjMwNCwyNjIxNDQsMjY4NzAxNjk2LDQwOTYsNjQsMjY4Njk3NjY0LDQwOTYsMjY2MzA0LDI2ODQzOTU1Miw2NCwyNjg0MzU1MjAsMjY4Njk3NjAwLDI2ODY5NzY2NCwyNjg0MzU0NTYsMjYyMTQ0LDI2ODQzOTYxNiwwLDI2ODcwMTc2MCwyNjIyMDgsMjY4NDM1NTIwLDI2ODY5NzYwMCwyNjg0Mzk1NTIsMjY4NDM5NjE2LDAsMjY4NzAxNzYwLDI2NjI0MCwyNjYyNDAsNDE2MCw0MTYwLDI2MjIwOCwyNjg0MzU0NTYsMjY4NzAxNjk2XTtmdW5jdGlvbiBwKGUsdCxyLG4pe3ZhciBpLHAsZD0zMj09PWUubGVuZ3RoPzM6OTtpPTM9PT1kP24/WzMwLC0yLC0yXTpbMCwzMiwyXTpuP1s5NCw2MiwtMiwzMiw2NCwyLDMwLC0yLC0yXTpbMCwzMiwyLDYyLDMwLC0yLDY0LDk2LDJdO3ZhciB5PXRbMF0sZz10WzFdO3lePShwPTI1MjY0NTEzNSYoeT4+PjReZykpPDw0LHlePShwPTY1NTM1Jih5Pj4+MTZeKGdePXApKSk8PDE2LHlePXA9ODU4OTkzNDU5JigoZ149cCk+Pj4yXnkpLHlePXA9MTY3MTE5MzUmKChnXj1wPDwyKT4+PjheeSkseT0oeV49KHA9MTQzMTY1NTc2NSYoeT4+PjFeKGdePXA8PDgpKSk8PDEpPDwxfHk+Pj4zMSxnPShnXj1wKTw8MXxnPj4+MzE7Zm9yKHZhciBtPTA7bTxkO20rPTMpe2Zvcih2YXIgdj1pW20rMV0sYj1pW20rMl0sRT1pW21dO0UhPXY7RSs9Yil7dmFyIFM9Z15lW0VdLFQ9KGc+Pj40fGc8PDI4KV5lW0UrMV07cD15LHk9ZyxnPXBeKHNbUz4+PjI0JjYzXXx1W1M+Pj4xNiY2M118bFtTPj4+OCY2M118aFs2MyZTXXxhW1Q+Pj4yNCY2M118b1tUPj4+MTYmNjNdfGNbVD4+PjgmNjNdfGZbNjMmVF0pfXA9eSx5PWcsZz1wfWc9Zz4+PjF8Zzw8MzEsZ149cD0xNDMxNjU1NzY1JigoeT15Pj4+MXx5PDwzMSk+Pj4xXmcpLGdePShwPTE2NzExOTM1JihnPj4+OF4oeV49cDw8MSkpKTw8OCxnXj0ocD04NTg5OTM0NTkmKGc+Pj4yXih5Xj1wKSkpPDwyLGdePXA9NjU1MzUmKCh5Xj1wKT4+PjE2XmcpLGdePXA9MjUyNjQ1MTM1JigoeV49cDw8MTYpPj4+NF5nKSx5Xj1wPDw0LHJbMF09eSxyWzFdPWd9ZnVuY3Rpb24gZChlKXt2YXIgdCxyPVwiREVTLVwiKygoZT1lfHx7fSkubW9kZXx8XCJDQkNcIikudG9VcHBlckNhc2UoKSxpPSh0PWUuZGVjcnlwdD9uLmNpcGhlci5jcmVhdGVEZWNpcGhlcihyLGUua2V5KTpuLmNpcGhlci5jcmVhdGVDaXBoZXIocixlLmtleSkpLnN0YXJ0O3JldHVybiB0LnN0YXJ0PWZ1bmN0aW9uKGUscil7dmFyIGE9bnVsbDtyIGluc3RhbmNlb2Ygbi51dGlsLkJ5dGVCdWZmZXImJihhPXIscj17fSksKHI9cnx8e30pLm91dHB1dD1hLHIuaXY9ZSxpLmNhbGwodCxyKX0sdH19LGZ1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24odCl7dmFyIG49cigxKTtyKDMyKSxyKDkpLHIoMik7dmFyIGksYT1uLnBrY3M1PW4ucGtjczV8fHt9O24udXRpbC5pc05vZGVqcyYmIW4ub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCYmKGk9cigzMSkpLGUuZXhwb3J0cz1uLnBia2RmMj1hLnBia2RmMj1mdW5jdGlvbihlLHIsYSxzLG8sdSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbyYmKHU9byxvPW51bGwpLG4udXRpbC5pc05vZGVqcyYmIW4ub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCYmaS5wYmtkZjImJihudWxsPT09b3x8XCJvYmplY3RcIiE9dHlwZW9mIG8pJiYoaS5wYmtkZjJTeW5jLmxlbmd0aD40fHwhb3x8XCJzaGExXCI9PT1vKSlyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgbyYmKG89XCJzaGExXCIpLGU9dC5mcm9tKGUsXCJiaW5hcnlcIikscj10LmZyb20ocixcImJpbmFyeVwiKSx1PzQ9PT1pLnBia2RmMlN5bmMubGVuZ3RoP2kucGJrZGYyKGUscixhLHMsKGZ1bmN0aW9uKGUsdCl7aWYoZSlyZXR1cm4gdShlKTt1KG51bGwsdC50b1N0cmluZyhcImJpbmFyeVwiKSl9KSk6aS5wYmtkZjIoZSxyLGEscyxvLChmdW5jdGlvbihlLHQpe2lmKGUpcmV0dXJuIHUoZSk7dShudWxsLHQudG9TdHJpbmcoXCJiaW5hcnlcIikpfSkpOjQ9PT1pLnBia2RmMlN5bmMubGVuZ3RoP2kucGJrZGYyU3luYyhlLHIsYSxzKS50b1N0cmluZyhcImJpbmFyeVwiKTppLnBia2RmMlN5bmMoZSxyLGEscyxvKS50b1N0cmluZyhcImJpbmFyeVwiKTtpZihudWxsPT1vJiYobz1cInNoYTFcIiksXCJzdHJpbmdcIj09dHlwZW9mIG8pe2lmKCEobyBpbiBuLm1kLmFsZ29yaXRobXMpKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFzaCBhbGdvcml0aG06IFwiK28pO289bi5tZFtvXS5jcmVhdGUoKX12YXIgYz1vLmRpZ2VzdExlbmd0aDtpZihzPjQyOTQ5NjcyOTUqYyl7dmFyIGw9bmV3IEVycm9yKFwiRGVyaXZlZCBrZXkgaXMgdG9vIGxvbmcuXCIpO2lmKHUpcmV0dXJuIHUobCk7dGhyb3cgbH12YXIgZj1NYXRoLmNlaWwocy9jKSxoPXMtKGYtMSkqYyxwPW4uaG1hYy5jcmVhdGUoKTtwLnN0YXJ0KG8sZSk7dmFyIGQseSxnLG09XCJcIjtpZighdSl7Zm9yKHZhciB2PTE7djw9ZjsrK3Ype3Auc3RhcnQobnVsbCxudWxsKSxwLnVwZGF0ZShyKSxwLnVwZGF0ZShuLnV0aWwuaW50MzJUb0J5dGVzKHYpKSxkPWc9cC5kaWdlc3QoKS5nZXRCeXRlcygpO2Zvcih2YXIgYj0yO2I8PWE7KytiKXAuc3RhcnQobnVsbCxudWxsKSxwLnVwZGF0ZShnKSx5PXAuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxkPW4udXRpbC54b3JCeXRlcyhkLHksYyksZz15O20rPXY8Zj9kOmQuc3Vic3RyKDAsaCl9cmV0dXJuIG19dj0xO2Z1bmN0aW9uIEUoKXtpZih2PmYpcmV0dXJuIHUobnVsbCxtKTtwLnN0YXJ0KG51bGwsbnVsbCkscC51cGRhdGUocikscC51cGRhdGUobi51dGlsLmludDMyVG9CeXRlcyh2KSksZD1nPXAuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxiPTIsUygpfWZ1bmN0aW9uIFMoKXtpZihiPD1hKXJldHVybiBwLnN0YXJ0KG51bGwsbnVsbCkscC51cGRhdGUoZykseT1wLmRpZ2VzdCgpLmdldEJ5dGVzKCksZD1uLnV0aWwueG9yQnl0ZXMoZCx5LGMpLGc9eSwrK2Isbi51dGlsLnNldEltbWVkaWF0ZShTKTttKz12PGY/ZDpkLnN1YnN0cigwLGgpLCsrdixFKCl9RSgpfX0pLmNhbGwodGhpcyxyKDEzKS5CdWZmZXIpfSxmdW5jdGlvbihlLHQscil7dmFyIG4saT1yKDEpO2UuZXhwb3J0cz1pLmpzYm49aS5qc2JufHx7fTtmdW5jdGlvbiBhKGUsdCxyKXt0aGlzLmRhdGE9W10sbnVsbCE9ZSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlP3RoaXMuZnJvbU51bWJlcihlLHQscik6bnVsbD09dCYmXCJzdHJpbmdcIiE9dHlwZW9mIGU/dGhpcy5mcm9tU3RyaW5nKGUsMjU2KTp0aGlzLmZyb21TdHJpbmcoZSx0KSl9ZnVuY3Rpb24gcygpe3JldHVybiBuZXcgYShudWxsKX1mdW5jdGlvbiBvKGUsdCxyLG4saSxhKXtmb3IodmFyIHM9MTYzODMmdCxvPXQ+PjE0Oy0tYT49MDspe3ZhciB1PTE2MzgzJnRoaXMuZGF0YVtlXSxjPXRoaXMuZGF0YVtlKytdPj4xNCxsPW8qdStjKnM7aT0oKHU9cyp1KygoMTYzODMmbCk8PDE0KStyLmRhdGFbbl0raSk+PjI4KSsobD4+MTQpK28qYyxyLmRhdGFbbisrXT0yNjg0MzU0NTUmdX1yZXR1cm4gaX1pLmpzYm4uQmlnSW50ZWdlcj1hLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3I/KGEucHJvdG90eXBlLmFtPW8sbj0yOCk6XCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcIj09bmF2aWdhdG9yLmFwcE5hbWU/KGEucHJvdG90eXBlLmFtPWZ1bmN0aW9uKGUsdCxyLG4saSxhKXtmb3IodmFyIHM9MzI3NjcmdCxvPXQ+PjE1Oy0tYT49MDspe3ZhciB1PTMyNzY3JnRoaXMuZGF0YVtlXSxjPXRoaXMuZGF0YVtlKytdPj4xNSxsPW8qdStjKnM7aT0oKHU9cyp1KygoMzI3NjcmbCk8PDE1KStyLmRhdGFbbl0rKDEwNzM3NDE4MjMmaSkpPj4+MzApKyhsPj4+MTUpK28qYysoaT4+PjMwKSxyLmRhdGFbbisrXT0xMDczNzQxODIzJnV9cmV0dXJuIGl9LG49MzApOlwiTmV0c2NhcGVcIiE9bmF2aWdhdG9yLmFwcE5hbWU/KGEucHJvdG90eXBlLmFtPWZ1bmN0aW9uKGUsdCxyLG4saSxhKXtmb3IoOy0tYT49MDspe3ZhciBzPXQqdGhpcy5kYXRhW2UrK10rci5kYXRhW25dK2k7aT1NYXRoLmZsb29yKHMvNjcxMDg4NjQpLHIuZGF0YVtuKytdPTY3MTA4ODYzJnN9cmV0dXJuIGl9LG49MjYpOihhLnByb3RvdHlwZS5hbT1vLG49MjgpLGEucHJvdG90eXBlLkRCPW4sYS5wcm90b3R5cGUuRE09KDE8PG4pLTEsYS5wcm90b3R5cGUuRFY9MTw8bjthLnByb3RvdHlwZS5GVj1NYXRoLnBvdygyLDUyKSxhLnByb3RvdHlwZS5GMT01Mi1uLGEucHJvdG90eXBlLkYyPTIqbi01Mjt2YXIgdSxjLGw9XCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixmPW5ldyBBcnJheTtmb3IodT1cIjBcIi5jaGFyQ29kZUF0KDApLGM9MDtjPD05OysrYylmW3UrK109Yztmb3IodT1cImFcIi5jaGFyQ29kZUF0KDApLGM9MTA7YzwzNjsrK2MpZlt1KytdPWM7Zm9yKHU9XCJBXCIuY2hhckNvZGVBdCgwKSxjPTEwO2M8MzY7KytjKWZbdSsrXT1jO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGwuY2hhckF0KGUpfWZ1bmN0aW9uIHAoZSx0KXt2YXIgcj1mW2UuY2hhckNvZGVBdCh0KV07cmV0dXJuIG51bGw9PXI/LTE6cn1mdW5jdGlvbiBkKGUpe3ZhciB0PXMoKTtyZXR1cm4gdC5mcm9tSW50KGUpLHR9ZnVuY3Rpb24geShlKXt2YXIgdCxyPTE7cmV0dXJuIDAhPSh0PWU+Pj4xNikmJihlPXQscis9MTYpLDAhPSh0PWU+PjgpJiYoZT10LHIrPTgpLDAhPSh0PWU+PjQpJiYoZT10LHIrPTQpLDAhPSh0PWU+PjIpJiYoZT10LHIrPTIpLDAhPSh0PWU+PjEpJiYoZT10LHIrPTEpLHJ9ZnVuY3Rpb24gZyhlKXt0aGlzLm09ZX1mdW5jdGlvbiBtKGUpe3RoaXMubT1lLHRoaXMubXA9ZS5pbnZEaWdpdCgpLHRoaXMubXBsPTMyNzY3JnRoaXMubXAsdGhpcy5tcGg9dGhpcy5tcD4+MTUsdGhpcy51bT0oMTw8ZS5EQi0xNSktMSx0aGlzLm10Mj0yKmUudH1mdW5jdGlvbiB2KGUsdCl7cmV0dXJuIGUmdH1mdW5jdGlvbiBiKGUsdCl7cmV0dXJuIGV8dH1mdW5jdGlvbiBFKGUsdCl7cmV0dXJuIGVedH1mdW5jdGlvbiBTKGUsdCl7cmV0dXJuIGUmfnR9ZnVuY3Rpb24gVChlKXtpZigwPT1lKXJldHVybi0xO3ZhciB0PTA7cmV0dXJuIDA9PSg2NTUzNSZlKSYmKGU+Pj0xNix0Kz0xNiksMD09KDI1NSZlKSYmKGU+Pj04LHQrPTgpLDA9PSgxNSZlKSYmKGU+Pj00LHQrPTQpLDA9PSgzJmUpJiYoZT4+PTIsdCs9MiksMD09KDEmZSkmJisrdCx0fWZ1bmN0aW9uIEMoZSl7Zm9yKHZhciB0PTA7MCE9ZTspZSY9ZS0xLCsrdDtyZXR1cm4gdH1mdW5jdGlvbiBBKCl7fWZ1bmN0aW9uIEkoZSl7cmV0dXJuIGV9ZnVuY3Rpb24gdyhlKXt0aGlzLnIyPXMoKSx0aGlzLnEzPXMoKSxhLk9ORS5kbFNoaWZ0VG8oMiplLnQsdGhpcy5yMiksdGhpcy5tdT10aGlzLnIyLmRpdmlkZShlKSx0aGlzLm09ZX1nLnByb3RvdHlwZS5jb252ZXJ0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnM8MHx8ZS5jb21wYXJlVG8odGhpcy5tKT49MD9lLm1vZCh0aGlzLm0pOmV9LGcucHJvdG90eXBlLnJldmVydD1mdW5jdGlvbihlKXtyZXR1cm4gZX0sZy5wcm90b3R5cGUucmVkdWNlPWZ1bmN0aW9uKGUpe2UuZGl2UmVtVG8odGhpcy5tLG51bGwsZSl9LGcucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uKGUsdCxyKXtlLm11bHRpcGx5VG8odCxyKSx0aGlzLnJlZHVjZShyKX0sZy5wcm90b3R5cGUuc3FyVG89ZnVuY3Rpb24oZSx0KXtlLnNxdWFyZVRvKHQpLHRoaXMucmVkdWNlKHQpfSxtLnByb3RvdHlwZS5jb252ZXJ0PWZ1bmN0aW9uKGUpe3ZhciB0PXMoKTtyZXR1cm4gZS5hYnMoKS5kbFNoaWZ0VG8odGhpcy5tLnQsdCksdC5kaXZSZW1Ubyh0aGlzLm0sbnVsbCx0KSxlLnM8MCYmdC5jb21wYXJlVG8oYS5aRVJPKT4wJiZ0aGlzLm0uc3ViVG8odCx0KSx0fSxtLnByb3RvdHlwZS5yZXZlcnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9cygpO3JldHVybiBlLmNvcHlUbyh0KSx0aGlzLnJlZHVjZSh0KSx0fSxtLnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24oZSl7Zm9yKDtlLnQ8PXRoaXMubXQyOyllLmRhdGFbZS50KytdPTA7Zm9yKHZhciB0PTA7dDx0aGlzLm0udDsrK3Qpe3ZhciByPTMyNzY3JmUuZGF0YVt0XSxuPXIqdGhpcy5tcGwrKChyKnRoaXMubXBoKyhlLmRhdGFbdF0+PjE1KSp0aGlzLm1wbCZ0aGlzLnVtKTw8MTUpJmUuRE07Zm9yKHI9dCt0aGlzLm0udCxlLmRhdGFbcl0rPXRoaXMubS5hbSgwLG4sZSx0LDAsdGhpcy5tLnQpO2UuZGF0YVtyXT49ZS5EVjspZS5kYXRhW3JdLT1lLkRWLGUuZGF0YVsrK3JdKyt9ZS5jbGFtcCgpLGUuZHJTaGlmdFRvKHRoaXMubS50LGUpLGUuY29tcGFyZVRvKHRoaXMubSk+PTAmJmUuc3ViVG8odGhpcy5tLGUpfSxtLnByb3RvdHlwZS5tdWxUbz1mdW5jdGlvbihlLHQscil7ZS5tdWx0aXBseVRvKHQsciksdGhpcy5yZWR1Y2Uocil9LG0ucHJvdG90eXBlLnNxclRvPWZ1bmN0aW9uKGUsdCl7ZS5zcXVhcmVUbyh0KSx0aGlzLnJlZHVjZSh0KX0sYS5wcm90b3R5cGUuY29weVRvPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLnQtMTt0Pj0wOy0tdCllLmRhdGFbdF09dGhpcy5kYXRhW3RdO2UudD10aGlzLnQsZS5zPXRoaXMuc30sYS5wcm90b3R5cGUuZnJvbUludD1mdW5jdGlvbihlKXt0aGlzLnQ9MSx0aGlzLnM9ZTwwPy0xOjAsZT4wP3RoaXMuZGF0YVswXT1lOmU8LTE/dGhpcy5kYXRhWzBdPWUrdGhpcy5EVjp0aGlzLnQ9MH0sYS5wcm90b3R5cGUuZnJvbVN0cmluZz1mdW5jdGlvbihlLHQpe3ZhciByO2lmKDE2PT10KXI9NDtlbHNlIGlmKDg9PXQpcj0zO2Vsc2UgaWYoMjU2PT10KXI9ODtlbHNlIGlmKDI9PXQpcj0xO2Vsc2UgaWYoMzI9PXQpcj01O2Vsc2V7aWYoNCE9dClyZXR1cm4gdm9pZCB0aGlzLmZyb21SYWRpeChlLHQpO3I9Mn10aGlzLnQ9MCx0aGlzLnM9MDtmb3IodmFyIG49ZS5sZW5ndGgsaT0hMSxzPTA7LS1uPj0wOyl7dmFyIG89OD09cj8yNTUmZVtuXTpwKGUsbik7bzwwP1wiLVwiPT1lLmNoYXJBdChuKSYmKGk9ITApOihpPSExLDA9PXM/dGhpcy5kYXRhW3RoaXMudCsrXT1vOnMrcj50aGlzLkRCPyh0aGlzLmRhdGFbdGhpcy50LTFdfD0obyYoMTw8dGhpcy5EQi1zKS0xKTw8cyx0aGlzLmRhdGFbdGhpcy50KytdPW8+PnRoaXMuREItcyk6dGhpcy5kYXRhW3RoaXMudC0xXXw9bzw8cywocys9cik+PXRoaXMuREImJihzLT10aGlzLkRCKSl9OD09ciYmMCE9KDEyOCZlWzBdKSYmKHRoaXMucz0tMSxzPjAmJih0aGlzLmRhdGFbdGhpcy50LTFdfD0oMTw8dGhpcy5EQi1zKS0xPDxzKSksdGhpcy5jbGFtcCgpLGkmJmEuWkVSTy5zdWJUbyh0aGlzLHRoaXMpfSxhLnByb3RvdHlwZS5jbGFtcD1mdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLnMmdGhpcy5ETTt0aGlzLnQ+MCYmdGhpcy5kYXRhW3RoaXMudC0xXT09ZTspLS10aGlzLnR9LGEucHJvdG90eXBlLmRsU2hpZnRUbz1mdW5jdGlvbihlLHQpe3ZhciByO2ZvcihyPXRoaXMudC0xO3I+PTA7LS1yKXQuZGF0YVtyK2VdPXRoaXMuZGF0YVtyXTtmb3Iocj1lLTE7cj49MDstLXIpdC5kYXRhW3JdPTA7dC50PXRoaXMudCtlLHQucz10aGlzLnN9LGEucHJvdG90eXBlLmRyU2hpZnRUbz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj1lO3I8dGhpcy50Oysrcil0LmRhdGFbci1lXT10aGlzLmRhdGFbcl07dC50PU1hdGgubWF4KHRoaXMudC1lLDApLHQucz10aGlzLnN9LGEucHJvdG90eXBlLmxTaGlmdFRvPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj1lJXRoaXMuREIsaT10aGlzLkRCLW4sYT0oMTw8aSktMSxzPU1hdGguZmxvb3IoZS90aGlzLkRCKSxvPXRoaXMuczw8biZ0aGlzLkRNO2ZvcihyPXRoaXMudC0xO3I+PTA7LS1yKXQuZGF0YVtyK3MrMV09dGhpcy5kYXRhW3JdPj5pfG8sbz0odGhpcy5kYXRhW3JdJmEpPDxuO2ZvcihyPXMtMTtyPj0wOy0tcil0LmRhdGFbcl09MDt0LmRhdGFbc109byx0LnQ9dGhpcy50K3MrMSx0LnM9dGhpcy5zLHQuY2xhbXAoKX0sYS5wcm90b3R5cGUuclNoaWZ0VG89ZnVuY3Rpb24oZSx0KXt0LnM9dGhpcy5zO3ZhciByPU1hdGguZmxvb3IoZS90aGlzLkRCKTtpZihyPj10aGlzLnQpdC50PTA7ZWxzZXt2YXIgbj1lJXRoaXMuREIsaT10aGlzLkRCLW4sYT0oMTw8biktMTt0LmRhdGFbMF09dGhpcy5kYXRhW3JdPj5uO2Zvcih2YXIgcz1yKzE7czx0aGlzLnQ7KytzKXQuZGF0YVtzLXItMV18PSh0aGlzLmRhdGFbc10mYSk8PGksdC5kYXRhW3Mtcl09dGhpcy5kYXRhW3NdPj5uO24+MCYmKHQuZGF0YVt0aGlzLnQtci0xXXw9KHRoaXMucyZhKTw8aSksdC50PXRoaXMudC1yLHQuY2xhbXAoKX19LGEucHJvdG90eXBlLnN1YlRvPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPTAsbj0wLGk9TWF0aC5taW4oZS50LHRoaXMudCk7cjxpOyluKz10aGlzLmRhdGFbcl0tZS5kYXRhW3JdLHQuZGF0YVtyKytdPW4mdGhpcy5ETSxuPj49dGhpcy5EQjtpZihlLnQ8dGhpcy50KXtmb3Iobi09ZS5zO3I8dGhpcy50OyluKz10aGlzLmRhdGFbcl0sdC5kYXRhW3IrK109biZ0aGlzLkRNLG4+Pj10aGlzLkRCO24rPXRoaXMuc31lbHNle2ZvcihuKz10aGlzLnM7cjxlLnQ7KW4tPWUuZGF0YVtyXSx0LmRhdGFbcisrXT1uJnRoaXMuRE0sbj4+PXRoaXMuREI7bi09ZS5zfXQucz1uPDA/LTE6MCxuPC0xP3QuZGF0YVtyKytdPXRoaXMuRFYrbjpuPjAmJih0LmRhdGFbcisrXT1uKSx0LnQ9cix0LmNsYW1wKCl9LGEucHJvdG90eXBlLm11bHRpcGx5VG89ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmFicygpLG49ZS5hYnMoKSxpPXIudDtmb3IodC50PWkrbi50Oy0taT49MDspdC5kYXRhW2ldPTA7Zm9yKGk9MDtpPG4udDsrK2kpdC5kYXRhW2krci50XT1yLmFtKDAsbi5kYXRhW2ldLHQsaSwwLHIudCk7dC5zPTAsdC5jbGFtcCgpLHRoaXMucyE9ZS5zJiZhLlpFUk8uc3ViVG8odCx0KX0sYS5wcm90b3R5cGUuc3F1YXJlVG89ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMuYWJzKCkscj1lLnQ9Mip0LnQ7LS1yPj0wOyllLmRhdGFbcl09MDtmb3Iocj0wO3I8dC50LTE7KytyKXt2YXIgbj10LmFtKHIsdC5kYXRhW3JdLGUsMipyLDAsMSk7KGUuZGF0YVtyK3QudF0rPXQuYW0ocisxLDIqdC5kYXRhW3JdLGUsMipyKzEsbix0LnQtci0xKSk+PXQuRFYmJihlLmRhdGFbcit0LnRdLT10LkRWLGUuZGF0YVtyK3QudCsxXT0xKX1lLnQ+MCYmKGUuZGF0YVtlLnQtMV0rPXQuYW0ocix0LmRhdGFbcl0sZSwyKnIsMCwxKSksZS5zPTAsZS5jbGFtcCgpfSxhLnByb3RvdHlwZS5kaXZSZW1Ubz1mdW5jdGlvbihlLHQscil7dmFyIG49ZS5hYnMoKTtpZighKG4udDw9MCkpe3ZhciBpPXRoaXMuYWJzKCk7aWYoaS50PG4udClyZXR1cm4gbnVsbCE9dCYmdC5mcm9tSW50KDApLHZvaWQobnVsbCE9ciYmdGhpcy5jb3B5VG8ocikpO251bGw9PXImJihyPXMoKSk7dmFyIG89cygpLHU9dGhpcy5zLGM9ZS5zLGw9dGhpcy5EQi15KG4uZGF0YVtuLnQtMV0pO2w+MD8obi5sU2hpZnRUbyhsLG8pLGkubFNoaWZ0VG8obCxyKSk6KG4uY29weVRvKG8pLGkuY29weVRvKHIpKTt2YXIgZj1vLnQsaD1vLmRhdGFbZi0xXTtpZigwIT1oKXt2YXIgcD1oKigxPDx0aGlzLkYxKSsoZj4xP28uZGF0YVtmLTJdPj50aGlzLkYyOjApLGQ9dGhpcy5GVi9wLGc9KDE8PHRoaXMuRjEpL3AsbT0xPDx0aGlzLkYyLHY9ci50LGI9di1mLEU9bnVsbD09dD9zKCk6dDtmb3Ioby5kbFNoaWZ0VG8oYixFKSxyLmNvbXBhcmVUbyhFKT49MCYmKHIuZGF0YVtyLnQrK109MSxyLnN1YlRvKEUscikpLGEuT05FLmRsU2hpZnRUbyhmLEUpLEUuc3ViVG8obyxvKTtvLnQ8Zjspby5kYXRhW28udCsrXT0wO2Zvcig7LS1iPj0wOyl7dmFyIFM9ci5kYXRhWy0tdl09PWg/dGhpcy5ETTpNYXRoLmZsb29yKHIuZGF0YVt2XSpkKyhyLmRhdGFbdi0xXSttKSpnKTtpZigoci5kYXRhW3ZdKz1vLmFtKDAsUyxyLGIsMCxmKSk8Uylmb3Ioby5kbFNoaWZ0VG8oYixFKSxyLnN1YlRvKEUscik7ci5kYXRhW3ZdPC0tUzspci5zdWJUbyhFLHIpfW51bGwhPXQmJihyLmRyU2hpZnRUbyhmLHQpLHUhPWMmJmEuWkVSTy5zdWJUbyh0LHQpKSxyLnQ9ZixyLmNsYW1wKCksbD4wJiZyLnJTaGlmdFRvKGwsciksdTwwJiZhLlpFUk8uc3ViVG8ocixyKX19fSxhLnByb3RvdHlwZS5pbnZEaWdpdD1mdW5jdGlvbigpe2lmKHRoaXMudDwxKXJldHVybiAwO3ZhciBlPXRoaXMuZGF0YVswXTtpZigwPT0oMSZlKSlyZXR1cm4gMDt2YXIgdD0zJmU7cmV0dXJuKHQ9KHQ9KHQ9KHQ9dCooMi0oMTUmZSkqdCkmMTUpKigyLSgyNTUmZSkqdCkmMjU1KSooMi0oKDY1NTM1JmUpKnQmNjU1MzUpKSY2NTUzNSkqKDItZSp0JXRoaXMuRFYpJXRoaXMuRFYpPjA/dGhpcy5EVi10Oi10fSxhLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4gMD09KHRoaXMudD4wPzEmdGhpcy5kYXRhWzBdOnRoaXMucyl9LGEucHJvdG90eXBlLmV4cD1mdW5jdGlvbihlLHQpe2lmKGU+NDI5NDk2NzI5NXx8ZTwxKXJldHVybiBhLk9ORTt2YXIgcj1zKCksbj1zKCksaT10LmNvbnZlcnQodGhpcyksbz15KGUpLTE7Zm9yKGkuY29weVRvKHIpOy0tbz49MDspaWYodC5zcXJUbyhyLG4pLChlJjE8PG8pPjApdC5tdWxUbyhuLGkscik7ZWxzZXt2YXIgdT1yO3I9bixuPXV9cmV0dXJuIHQucmV2ZXJ0KHIpfSxhLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihlKXtpZih0aGlzLnM8MClyZXR1cm5cIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGUpO3ZhciB0O2lmKDE2PT1lKXQ9NDtlbHNlIGlmKDg9PWUpdD0zO2Vsc2UgaWYoMj09ZSl0PTE7ZWxzZSBpZigzMj09ZSl0PTU7ZWxzZXtpZig0IT1lKXJldHVybiB0aGlzLnRvUmFkaXgoZSk7dD0yfXZhciByLG49KDE8PHQpLTEsaT0hMSxhPVwiXCIscz10aGlzLnQsbz10aGlzLkRCLXMqdGhpcy5EQiV0O2lmKHMtLSA+MClmb3Iobzx0aGlzLkRCJiYocj10aGlzLmRhdGFbc10+Pm8pPjAmJihpPSEwLGE9aChyKSk7cz49MDspbzx0PyhyPSh0aGlzLmRhdGFbc10mKDE8PG8pLTEpPDx0LW8scnw9dGhpcy5kYXRhWy0tc10+PihvKz10aGlzLkRCLXQpKToocj10aGlzLmRhdGFbc10+PihvLT10KSZuLG88PTAmJihvKz10aGlzLkRCLC0tcykpLHI+MCYmKGk9ITApLGkmJihhKz1oKHIpKTtyZXR1cm4gaT9hOlwiMFwifSxhLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXt2YXIgZT1zKCk7cmV0dXJuIGEuWkVSTy5zdWJUbyh0aGlzLGUpLGV9LGEucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MD90aGlzLm5lZ2F0ZSgpOnRoaXN9LGEucHJvdG90eXBlLmNvbXBhcmVUbz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnMtZS5zO2lmKDAhPXQpcmV0dXJuIHQ7dmFyIHI9dGhpcy50O2lmKDAhPSh0PXItZS50KSlyZXR1cm4gdGhpcy5zPDA/LXQ6dDtmb3IoOy0tcj49MDspaWYoMCE9KHQ9dGhpcy5kYXRhW3JdLWUuZGF0YVtyXSkpcmV0dXJuIHQ7cmV0dXJuIDB9LGEucHJvdG90eXBlLmJpdExlbmd0aD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnQ8PTA/MDp0aGlzLkRCKih0aGlzLnQtMSkreSh0aGlzLmRhdGFbdGhpcy50LTFdXnRoaXMucyZ0aGlzLkRNKX0sYS5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKGUpe3ZhciB0PXMoKTtyZXR1cm4gdGhpcy5hYnMoKS5kaXZSZW1UbyhlLG51bGwsdCksdGhpcy5zPDAmJnQuY29tcGFyZVRvKGEuWkVSTyk+MCYmZS5zdWJUbyh0LHQpLHR9LGEucHJvdG90eXBlLm1vZFBvd0ludD1mdW5jdGlvbihlLHQpe3ZhciByO3JldHVybiByPWU8MjU2fHx0LmlzRXZlbigpP25ldyBnKHQpOm5ldyBtKHQpLHRoaXMuZXhwKGUscil9LGEuWkVSTz1kKDApLGEuT05FPWQoMSksQS5wcm90b3R5cGUuY29udmVydD1JLEEucHJvdG90eXBlLnJldmVydD1JLEEucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uKGUsdCxyKXtlLm11bHRpcGx5VG8odCxyKX0sQS5wcm90b3R5cGUuc3FyVG89ZnVuY3Rpb24oZSx0KXtlLnNxdWFyZVRvKHQpfSx3LnByb3RvdHlwZS5jb252ZXJ0PWZ1bmN0aW9uKGUpe2lmKGUuczwwfHxlLnQ+Mip0aGlzLm0udClyZXR1cm4gZS5tb2QodGhpcy5tKTtpZihlLmNvbXBhcmVUbyh0aGlzLm0pPDApcmV0dXJuIGU7dmFyIHQ9cygpO3JldHVybiBlLmNvcHlUbyh0KSx0aGlzLnJlZHVjZSh0KSx0fSx3LnByb3RvdHlwZS5yZXZlcnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHcucHJvdG90eXBlLnJlZHVjZT1mdW5jdGlvbihlKXtmb3IoZS5kclNoaWZ0VG8odGhpcy5tLnQtMSx0aGlzLnIyKSxlLnQ+dGhpcy5tLnQrMSYmKGUudD10aGlzLm0udCsxLGUuY2xhbXAoKSksdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpLHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMyx0aGlzLm0udCsxLHRoaXMucjIpO2UuY29tcGFyZVRvKHRoaXMucjIpPDA7KWUuZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO2ZvcihlLnN1YlRvKHRoaXMucjIsZSk7ZS5jb21wYXJlVG8odGhpcy5tKT49MDspZS5zdWJUbyh0aGlzLm0sZSl9LHcucHJvdG90eXBlLm11bFRvPWZ1bmN0aW9uKGUsdCxyKXtlLm11bHRpcGx5VG8odCxyKSx0aGlzLnJlZHVjZShyKX0sdy5wcm90b3R5cGUuc3FyVG89ZnVuY3Rpb24oZSx0KXtlLnNxdWFyZVRvKHQpLHRoaXMucmVkdWNlKHQpfTt2YXIgQj1bMiwzLDUsNywxMSwxMywxNywxOSwyMywyOSwzMSwzNyw0MSw0Myw0Nyw1Myw1OSw2MSw2Nyw3MSw3Myw3OSw4Myw4OSw5NywxMDEsMTAzLDEwNywxMDksMTEzLDEyNywxMzEsMTM3LDEzOSwxNDksMTUxLDE1NywxNjMsMTY3LDE3MywxNzksMTgxLDE5MSwxOTMsMTk3LDE5OSwyMTEsMjIzLDIyNywyMjksMjMzLDIzOSwyNDEsMjUxLDI1NywyNjMsMjY5LDI3MSwyNzcsMjgxLDI4MywyOTMsMzA3LDMxMSwzMTMsMzE3LDMzMSwzMzcsMzQ3LDM0OSwzNTMsMzU5LDM2NywzNzMsMzc5LDM4MywzODksMzk3LDQwMSw0MDksNDE5LDQyMSw0MzEsNDMzLDQzOSw0NDMsNDQ5LDQ1Nyw0NjEsNDYzLDQ2Nyw0NzksNDg3LDQ5MSw0OTksNTAzLDUwOV0sTj0oMTw8MjYpL0JbQi5sZW5ndGgtMV07YS5wcm90b3R5cGUuY2h1bmtTaXplPWZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLmZsb29yKE1hdGguTE4yKnRoaXMuREIvTWF0aC5sb2coZSkpfSxhLnByb3RvdHlwZS50b1JhZGl4PWZ1bmN0aW9uKGUpe2lmKG51bGw9PWUmJihlPTEwKSwwPT10aGlzLnNpZ251bSgpfHxlPDJ8fGU+MzYpcmV0dXJuXCIwXCI7dmFyIHQ9dGhpcy5jaHVua1NpemUoZSkscj1NYXRoLnBvdyhlLHQpLG49ZChyKSxpPXMoKSxhPXMoKSxvPVwiXCI7Zm9yKHRoaXMuZGl2UmVtVG8obixpLGEpO2kuc2lnbnVtKCk+MDspbz0ocithLmludFZhbHVlKCkpLnRvU3RyaW5nKGUpLnN1YnN0cigxKStvLGkuZGl2UmVtVG8obixpLGEpO3JldHVybiBhLmludFZhbHVlKCkudG9TdHJpbmcoZSkrb30sYS5wcm90b3R5cGUuZnJvbVJhZGl4PWZ1bmN0aW9uKGUsdCl7dGhpcy5mcm9tSW50KDApLG51bGw9PXQmJih0PTEwKTtmb3IodmFyIHI9dGhpcy5jaHVua1NpemUodCksbj1NYXRoLnBvdyh0LHIpLGk9ITEscz0wLG89MCx1PTA7dTxlLmxlbmd0aDsrK3Upe3ZhciBjPXAoZSx1KTtjPDA/XCItXCI9PWUuY2hhckF0KHUpJiYwPT10aGlzLnNpZ251bSgpJiYoaT0hMCk6KG89dCpvK2MsKytzPj1yJiYodGhpcy5kTXVsdGlwbHkobiksdGhpcy5kQWRkT2Zmc2V0KG8sMCkscz0wLG89MCkpfXM+MCYmKHRoaXMuZE11bHRpcGx5KE1hdGgucG93KHQscykpLHRoaXMuZEFkZE9mZnNldChvLDApKSxpJiZhLlpFUk8uc3ViVG8odGhpcyx0aGlzKX0sYS5wcm90b3R5cGUuZnJvbU51bWJlcj1mdW5jdGlvbihlLHQscil7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpaWYoZTwyKXRoaXMuZnJvbUludCgxKTtlbHNlIGZvcih0aGlzLmZyb21OdW1iZXIoZSxyKSx0aGlzLnRlc3RCaXQoZS0xKXx8dGhpcy5iaXR3aXNlVG8oYS5PTkUuc2hpZnRMZWZ0KGUtMSksYix0aGlzKSx0aGlzLmlzRXZlbigpJiZ0aGlzLmRBZGRPZmZzZXQoMSwwKTshdGhpcy5pc1Byb2JhYmxlUHJpbWUodCk7KXRoaXMuZEFkZE9mZnNldCgyLDApLHRoaXMuYml0TGVuZ3RoKCk+ZSYmdGhpcy5zdWJUbyhhLk9ORS5zaGlmdExlZnQoZS0xKSx0aGlzKTtlbHNle3ZhciBuPW5ldyBBcnJheSxpPTcmZTtuLmxlbmd0aD0xKyhlPj4zKSx0Lm5leHRCeXRlcyhuKSxpPjA/blswXSY9KDE8PGkpLTE6blswXT0wLHRoaXMuZnJvbVN0cmluZyhuLDI1Nil9fSxhLnByb3RvdHlwZS5iaXR3aXNlVG89ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGksYT1NYXRoLm1pbihlLnQsdGhpcy50KTtmb3Iobj0wO248YTsrK24pci5kYXRhW25dPXQodGhpcy5kYXRhW25dLGUuZGF0YVtuXSk7aWYoZS50PHRoaXMudCl7Zm9yKGk9ZS5zJnRoaXMuRE0sbj1hO248dGhpcy50OysrbilyLmRhdGFbbl09dCh0aGlzLmRhdGFbbl0saSk7ci50PXRoaXMudH1lbHNle2ZvcihpPXRoaXMucyZ0aGlzLkRNLG49YTtuPGUudDsrK24pci5kYXRhW25dPXQoaSxlLmRhdGFbbl0pO3IudD1lLnR9ci5zPXQodGhpcy5zLGUucyksci5jbGFtcCgpfSxhLnByb3RvdHlwZS5jaGFuZ2VCaXQ9ZnVuY3Rpb24oZSx0KXt2YXIgcj1hLk9ORS5zaGlmdExlZnQoZSk7cmV0dXJuIHRoaXMuYml0d2lzZVRvKHIsdCxyKSxyfSxhLnByb3RvdHlwZS5hZGRUbz1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj0wLG49MCxpPU1hdGgubWluKGUudCx0aGlzLnQpO3I8aTspbis9dGhpcy5kYXRhW3JdK2UuZGF0YVtyXSx0LmRhdGFbcisrXT1uJnRoaXMuRE0sbj4+PXRoaXMuREI7aWYoZS50PHRoaXMudCl7Zm9yKG4rPWUucztyPHRoaXMudDspbis9dGhpcy5kYXRhW3JdLHQuZGF0YVtyKytdPW4mdGhpcy5ETSxuPj49dGhpcy5EQjtuKz10aGlzLnN9ZWxzZXtmb3Iobis9dGhpcy5zO3I8ZS50OyluKz1lLmRhdGFbcl0sdC5kYXRhW3IrK109biZ0aGlzLkRNLG4+Pj10aGlzLkRCO24rPWUuc310LnM9bjwwPy0xOjAsbj4wP3QuZGF0YVtyKytdPW46bjwtMSYmKHQuZGF0YVtyKytdPXRoaXMuRFYrbiksdC50PXIsdC5jbGFtcCgpfSxhLnByb3RvdHlwZS5kTXVsdGlwbHk9ZnVuY3Rpb24oZSl7dGhpcy5kYXRhW3RoaXMudF09dGhpcy5hbSgwLGUtMSx0aGlzLDAsMCx0aGlzLnQpLCsrdGhpcy50LHRoaXMuY2xhbXAoKX0sYS5wcm90b3R5cGUuZEFkZE9mZnNldD1mdW5jdGlvbihlLHQpe2lmKDAhPWUpe2Zvcig7dGhpcy50PD10Oyl0aGlzLmRhdGFbdGhpcy50KytdPTA7Zm9yKHRoaXMuZGF0YVt0XSs9ZTt0aGlzLmRhdGFbdF0+PXRoaXMuRFY7KXRoaXMuZGF0YVt0XS09dGhpcy5EViwrK3Q+PXRoaXMudCYmKHRoaXMuZGF0YVt0aGlzLnQrK109MCksKyt0aGlzLmRhdGFbdF19fSxhLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG89ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGk9TWF0aC5taW4odGhpcy50K2UudCx0KTtmb3Ioci5zPTAsci50PWk7aT4wOylyLmRhdGFbLS1pXT0wO2ZvcihuPXIudC10aGlzLnQ7aTxuOysraSlyLmRhdGFbaSt0aGlzLnRdPXRoaXMuYW0oMCxlLmRhdGFbaV0scixpLDAsdGhpcy50KTtmb3Iobj1NYXRoLm1pbihlLnQsdCk7aTxuOysraSl0aGlzLmFtKDAsZS5kYXRhW2ldLHIsaSwwLHQtaSk7ci5jbGFtcCgpfSxhLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG89ZnVuY3Rpb24oZSx0LHIpey0tdDt2YXIgbj1yLnQ9dGhpcy50K2UudC10O2ZvcihyLnM9MDstLW4+PTA7KXIuZGF0YVtuXT0wO2ZvcihuPU1hdGgubWF4KHQtdGhpcy50LDApO248ZS50OysrbilyLmRhdGFbdGhpcy50K24tdF09dGhpcy5hbSh0LW4sZS5kYXRhW25dLHIsMCwwLHRoaXMudCtuLXQpO3IuY2xhbXAoKSxyLmRyU2hpZnRUbygxLHIpfSxhLnByb3RvdHlwZS5tb2RJbnQ9ZnVuY3Rpb24oZSl7aWYoZTw9MClyZXR1cm4gMDt2YXIgdD10aGlzLkRWJWUscj10aGlzLnM8MD9lLTE6MDtpZih0aGlzLnQ+MClpZigwPT10KXI9dGhpcy5kYXRhWzBdJWU7ZWxzZSBmb3IodmFyIG49dGhpcy50LTE7bj49MDstLW4pcj0odCpyK3RoaXMuZGF0YVtuXSklZTtyZXR1cm4gcn0sYS5wcm90b3R5cGUubWlsbGVyUmFiaW49ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zdWJ0cmFjdChhLk9ORSkscj10LmdldExvd2VzdFNldEJpdCgpO2lmKHI8PTApcmV0dXJuITE7Zm9yKHZhciBuLGk9dC5zaGlmdFJpZ2h0KHIpLHM9e25leHRCeXRlczpmdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoOysrdCllW3RdPU1hdGguZmxvb3IoMjU2Kk1hdGgucmFuZG9tKCkpfX0sbz0wO288ZTsrK28pe2Rve249bmV3IGEodGhpcy5iaXRMZW5ndGgoKSxzKX13aGlsZShuLmNvbXBhcmVUbyhhLk9ORSk8PTB8fG4uY29tcGFyZVRvKHQpPj0wKTt2YXIgdT1uLm1vZFBvdyhpLHRoaXMpO2lmKDAhPXUuY29tcGFyZVRvKGEuT05FKSYmMCE9dS5jb21wYXJlVG8odCkpe2Zvcih2YXIgYz0xO2MrKzxyJiYwIT11LmNvbXBhcmVUbyh0KTspaWYoMD09KHU9dS5tb2RQb3dJbnQoMix0aGlzKSkuY29tcGFyZVRvKGEuT05FKSlyZXR1cm4hMTtpZigwIT11LmNvbXBhcmVUbyh0KSlyZXR1cm4hMX19cmV0dXJuITB9LGEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGU9cygpO3JldHVybiB0aGlzLmNvcHlUbyhlKSxlfSxhLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe2lmKHRoaXMuczwwKXtpZigxPT10aGlzLnQpcmV0dXJuIHRoaXMuZGF0YVswXS10aGlzLkRWO2lmKDA9PXRoaXMudClyZXR1cm4tMX1lbHNle2lmKDE9PXRoaXMudClyZXR1cm4gdGhpcy5kYXRhWzBdO2lmKDA9PXRoaXMudClyZXR1cm4gMH1yZXR1cm4odGhpcy5kYXRhWzFdJigxPDwzMi10aGlzLkRCKS0xKTw8dGhpcy5EQnx0aGlzLmRhdGFbMF19LGEucHJvdG90eXBlLmJ5dGVWYWx1ZT1mdW5jdGlvbigpe3JldHVybiAwPT10aGlzLnQ/dGhpcy5zOnRoaXMuZGF0YVswXTw8MjQ+PjI0fSxhLnByb3RvdHlwZS5zaG9ydFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PXRoaXMudD90aGlzLnM6dGhpcy5kYXRhWzBdPDwxNj4+MTZ9LGEucHJvdG90eXBlLnNpZ251bT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MD8tMTp0aGlzLnQ8PTB8fDE9PXRoaXMudCYmdGhpcy5kYXRhWzBdPD0wPzA6MX0sYS5wcm90b3R5cGUudG9CeXRlQXJyYXk9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnQsdD1uZXcgQXJyYXk7dFswXT10aGlzLnM7dmFyIHIsbj10aGlzLkRCLWUqdGhpcy5EQiU4LGk9MDtpZihlLS0gPjApZm9yKG48dGhpcy5EQiYmKHI9dGhpcy5kYXRhW2VdPj5uKSE9KHRoaXMucyZ0aGlzLkRNKT4+biYmKHRbaSsrXT1yfHRoaXMuczw8dGhpcy5EQi1uKTtlPj0wOyluPDg/KHI9KHRoaXMuZGF0YVtlXSYoMTw8biktMSk8PDgtbixyfD10aGlzLmRhdGFbLS1lXT4+KG4rPXRoaXMuREItOCkpOihyPXRoaXMuZGF0YVtlXT4+KG4tPTgpJjI1NSxuPD0wJiYobis9dGhpcy5EQiwtLWUpKSwwIT0oMTI4JnIpJiYocnw9LTI1NiksMD09aSYmKDEyOCZ0aGlzLnMpIT0oMTI4JnIpJiYrK2ksKGk+MHx8ciE9dGhpcy5zKSYmKHRbaSsrXT1yKTtyZXR1cm4gdH0sYS5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiAwPT10aGlzLmNvbXBhcmVUbyhlKX0sYS5wcm90b3R5cGUubWluPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXBhcmVUbyhlKTwwP3RoaXM6ZX0sYS5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXBhcmVUbyhlKT4wP3RoaXM6ZX0sYS5wcm90b3R5cGUuYW5kPWZ1bmN0aW9uKGUpe3ZhciB0PXMoKTtyZXR1cm4gdGhpcy5iaXR3aXNlVG8oZSx2LHQpLHR9LGEucHJvdG90eXBlLm9yPWZ1bmN0aW9uKGUpe3ZhciB0PXMoKTtyZXR1cm4gdGhpcy5iaXR3aXNlVG8oZSxiLHQpLHR9LGEucHJvdG90eXBlLnhvcj1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMuYml0d2lzZVRvKGUsRSx0KSx0fSxhLnByb3RvdHlwZS5hbmROb3Q9ZnVuY3Rpb24oZSl7dmFyIHQ9cygpO3JldHVybiB0aGlzLmJpdHdpc2VUbyhlLFMsdCksdH0sYS5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXMoKSx0PTA7dDx0aGlzLnQ7Kyt0KWUuZGF0YVt0XT10aGlzLkRNJn50aGlzLmRhdGFbdF07cmV0dXJuIGUudD10aGlzLnQsZS5zPX50aGlzLnMsZX0sYS5wcm90b3R5cGUuc2hpZnRMZWZ0PWZ1bmN0aW9uKGUpe3ZhciB0PXMoKTtyZXR1cm4gZTwwP3RoaXMuclNoaWZ0VG8oLWUsdCk6dGhpcy5sU2hpZnRUbyhlLHQpLHR9LGEucHJvdG90eXBlLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9cygpO3JldHVybiBlPDA/dGhpcy5sU2hpZnRUbygtZSx0KTp0aGlzLnJTaGlmdFRvKGUsdCksdH0sYS5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTA7ZTx0aGlzLnQ7KytlKWlmKDAhPXRoaXMuZGF0YVtlXSlyZXR1cm4gZSp0aGlzLkRCK1QodGhpcy5kYXRhW2VdKTtyZXR1cm4gdGhpcy5zPDA/dGhpcy50KnRoaXMuREI6LTF9LGEucHJvdG90eXBlLmJpdENvdW50PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPTAsdD10aGlzLnMmdGhpcy5ETSxyPTA7cjx0aGlzLnQ7KytyKWUrPUModGhpcy5kYXRhW3JdXnQpO3JldHVybiBlfSxhLnByb3RvdHlwZS50ZXN0Qml0PWZ1bmN0aW9uKGUpe3ZhciB0PU1hdGguZmxvb3IoZS90aGlzLkRCKTtyZXR1cm4gdD49dGhpcy50PzAhPXRoaXMuczowIT0odGhpcy5kYXRhW3RdJjE8PGUldGhpcy5EQil9LGEucHJvdG90eXBlLnNldEJpdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jaGFuZ2VCaXQoZSxiKX0sYS5wcm90b3R5cGUuY2xlYXJCaXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2hhbmdlQml0KGUsUyl9LGEucHJvdG90eXBlLmZsaXBCaXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY2hhbmdlQml0KGUsRSl9LGEucHJvdG90eXBlLmFkZD1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMuYWRkVG8oZSx0KSx0fSxhLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMuc3ViVG8oZSx0KSx0fSxhLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMubXVsdGlwbHlUbyhlLHQpLHR9LGEucHJvdG90eXBlLmRpdmlkZT1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMuZGl2UmVtVG8oZSx0LG51bGwpLHR9LGEucHJvdG90eXBlLnJlbWFpbmRlcj1mdW5jdGlvbihlKXt2YXIgdD1zKCk7cmV0dXJuIHRoaXMuZGl2UmVtVG8oZSxudWxsLHQpLHR9LGEucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlcj1mdW5jdGlvbihlKXt2YXIgdD1zKCkscj1zKCk7cmV0dXJuIHRoaXMuZGl2UmVtVG8oZSx0LHIpLG5ldyBBcnJheSh0LHIpfSxhLnByb3RvdHlwZS5tb2RQb3c9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGk9ZS5iaXRMZW5ndGgoKSxhPWQoMSk7aWYoaTw9MClyZXR1cm4gYTtyPWk8MTg/MTppPDQ4PzM6aTwxNDQ/NDppPDc2OD81OjYsbj1pPDg/bmV3IGcodCk6dC5pc0V2ZW4oKT9uZXcgdyh0KTpuZXcgbSh0KTt2YXIgbz1uZXcgQXJyYXksdT0zLGM9ci0xLGw9KDE8PHIpLTE7aWYob1sxXT1uLmNvbnZlcnQodGhpcykscj4xKXt2YXIgZj1zKCk7Zm9yKG4uc3FyVG8ob1sxXSxmKTt1PD1sOylvW3VdPXMoKSxuLm11bFRvKGYsb1t1LTJdLG9bdV0pLHUrPTJ9dmFyIGgscCx2PWUudC0xLGI9ITAsRT1zKCk7Zm9yKGk9eShlLmRhdGFbdl0pLTE7dj49MDspe2ZvcihpPj1jP2g9ZS5kYXRhW3ZdPj5pLWMmbDooaD0oZS5kYXRhW3ZdJigxPDxpKzEpLTEpPDxjLWksdj4wJiYoaHw9ZS5kYXRhW3YtMV0+PnRoaXMuREIraS1jKSksdT1yOzA9PSgxJmgpOyloPj49MSwtLXU7aWYoKGktPXUpPDAmJihpKz10aGlzLkRCLC0tdiksYilvW2hdLmNvcHlUbyhhKSxiPSExO2Vsc2V7Zm9yKDt1PjE7KW4uc3FyVG8oYSxFKSxuLnNxclRvKEUsYSksdS09Mjt1PjA/bi5zcXJUbyhhLEUpOihwPWEsYT1FLEU9cCksbi5tdWxUbyhFLG9baF0sYSl9Zm9yKDt2Pj0wJiYwPT0oZS5kYXRhW3ZdJjE8PGkpOyluLnNxclRvKGEsRSkscD1hLGE9RSxFPXAsLS1pPDAmJihpPXRoaXMuREItMSwtLXYpfXJldHVybiBuLnJldmVydChhKX0sYS5wcm90b3R5cGUubW9kSW52ZXJzZT1mdW5jdGlvbihlKXt2YXIgdD1lLmlzRXZlbigpO2lmKHRoaXMuaXNFdmVuKCkmJnR8fDA9PWUuc2lnbnVtKCkpcmV0dXJuIGEuWkVSTztmb3IodmFyIHI9ZS5jbG9uZSgpLG49dGhpcy5jbG9uZSgpLGk9ZCgxKSxzPWQoMCksbz1kKDApLHU9ZCgxKTswIT1yLnNpZ251bSgpOyl7Zm9yKDtyLmlzRXZlbigpOylyLnJTaGlmdFRvKDEsciksdD8oaS5pc0V2ZW4oKSYmcy5pc0V2ZW4oKXx8KGkuYWRkVG8odGhpcyxpKSxzLnN1YlRvKGUscykpLGkuclNoaWZ0VG8oMSxpKSk6cy5pc0V2ZW4oKXx8cy5zdWJUbyhlLHMpLHMuclNoaWZ0VG8oMSxzKTtmb3IoO24uaXNFdmVuKCk7KW4uclNoaWZ0VG8oMSxuKSx0PyhvLmlzRXZlbigpJiZ1LmlzRXZlbigpfHwoby5hZGRUbyh0aGlzLG8pLHUuc3ViVG8oZSx1KSksby5yU2hpZnRUbygxLG8pKTp1LmlzRXZlbigpfHx1LnN1YlRvKGUsdSksdS5yU2hpZnRUbygxLHUpO3IuY29tcGFyZVRvKG4pPj0wPyhyLnN1YlRvKG4sciksdCYmaS5zdWJUbyhvLGkpLHMuc3ViVG8odSxzKSk6KG4uc3ViVG8ocixuKSx0JiZvLnN1YlRvKGksbyksdS5zdWJUbyhzLHUpKX1yZXR1cm4gMCE9bi5jb21wYXJlVG8oYS5PTkUpP2EuWkVSTzp1LmNvbXBhcmVUbyhlKT49MD91LnN1YnRyYWN0KGUpOnUuc2lnbnVtKCk8MD8odS5hZGRUbyhlLHUpLHUuc2lnbnVtKCk8MD91LmFkZChlKTp1KTp1fSxhLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZXhwKGUsbmV3IEEpfSxhLnByb3RvdHlwZS5nY2Q9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zPDA/dGhpcy5uZWdhdGUoKTp0aGlzLmNsb25lKCkscj1lLnM8MD9lLm5lZ2F0ZSgpOmUuY2xvbmUoKTtpZih0LmNvbXBhcmVUbyhyKTwwKXt2YXIgbj10O3Q9cixyPW59dmFyIGk9dC5nZXRMb3dlc3RTZXRCaXQoKSxhPXIuZ2V0TG93ZXN0U2V0Qml0KCk7aWYoYTwwKXJldHVybiB0O2ZvcihpPGEmJihhPWkpLGE+MCYmKHQuclNoaWZ0VG8oYSx0KSxyLnJTaGlmdFRvKGEscikpO3Quc2lnbnVtKCk+MDspKGk9dC5nZXRMb3dlc3RTZXRCaXQoKSk+MCYmdC5yU2hpZnRUbyhpLHQpLChpPXIuZ2V0TG93ZXN0U2V0Qml0KCkpPjAmJnIuclNoaWZ0VG8oaSxyKSx0LmNvbXBhcmVUbyhyKT49MD8odC5zdWJUbyhyLHQpLHQuclNoaWZ0VG8oMSx0KSk6KHIuc3ViVG8odCxyKSxyLnJTaGlmdFRvKDEscikpO3JldHVybiBhPjAmJnIubFNoaWZ0VG8oYSxyKSxyfSxhLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU9ZnVuY3Rpb24oZSl7dmFyIHQscj10aGlzLmFicygpO2lmKDE9PXIudCYmci5kYXRhWzBdPD1CW0IubGVuZ3RoLTFdKXtmb3IodD0wO3Q8Qi5sZW5ndGg7Kyt0KWlmKHIuZGF0YVswXT09Qlt0XSlyZXR1cm4hMDtyZXR1cm4hMX1pZihyLmlzRXZlbigpKXJldHVybiExO2Zvcih0PTE7dDxCLmxlbmd0aDspe2Zvcih2YXIgbj1CW3RdLGk9dCsxO2k8Qi5sZW5ndGgmJm48Tjspbio9QltpKytdO2ZvcihuPXIubW9kSW50KG4pO3Q8aTspaWYobiVCW3QrK109PTApcmV0dXJuITF9cmV0dXJuIHIubWlsbGVyUmFiaW4oZSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDkpLHIoMik7dmFyIGk9ZS5leHBvcnRzPW4uc2hhMT1uLnNoYTF8fHt9O24ubWQuc2hhMT1uLm1kLmFsZ29yaXRobXMuc2hhMT1pLGkuY3JlYXRlPWZ1bmN0aW9uKCl7c3x8KGE9U3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpLGErPW4udXRpbC5maWxsU3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoMCksNjQpLHM9ITApO3ZhciBlPW51bGwsdD1uLnV0aWwuY3JlYXRlQnVmZmVyKCkscj1uZXcgQXJyYXkoODApLGk9e2FsZ29yaXRobTpcInNoYTFcIixibG9ja0xlbmd0aDo2NCxkaWdlc3RMZW5ndGg6MjAsbWVzc2FnZUxlbmd0aDowLGZ1bGxNZXNzYWdlTGVuZ3RoOm51bGwsbWVzc2FnZUxlbmd0aFNpemU6OCxzdGFydDpmdW5jdGlvbigpe2kubWVzc2FnZUxlbmd0aD0wLGkuZnVsbE1lc3NhZ2VMZW5ndGg9aS5tZXNzYWdlTGVuZ3RoNjQ9W107Zm9yKHZhciByPWkubWVzc2FnZUxlbmd0aFNpemUvNCxhPTA7YTxyOysrYSlpLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7cmV0dXJuIHQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLGU9e2gwOjE3MzI1ODQxOTMsaDE6NDAyMzIzMzQxNyxoMjoyNTYyMzgzMTAyLGgzOjI3MTczMzg3OCxoNDozMjg1Mzc3NTIwfSxpfX07cmV0dXJuIGkuc3RhcnQoKSxpLnVwZGF0ZT1mdW5jdGlvbihhLHMpe1widXRmOFwiPT09cyYmKGE9bi51dGlsLmVuY29kZVV0ZjgoYSkpO3ZhciB1PWEubGVuZ3RoO2kubWVzc2FnZUxlbmd0aCs9dSx1PVt1LzQyOTQ5NjcyOTY+Pj4wLHU+Pj4wXTtmb3IodmFyIGM9aS5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGgtMTtjPj0wOy0tYylpLmZ1bGxNZXNzYWdlTGVuZ3RoW2NdKz11WzFdLHVbMV09dVswXSsoaS5mdWxsTWVzc2FnZUxlbmd0aFtjXS80Mjk0OTY3Mjk2Pj4+MCksaS5mdWxsTWVzc2FnZUxlbmd0aFtjXT1pLmZ1bGxNZXNzYWdlTGVuZ3RoW2NdPj4+MCx1WzBdPXVbMV0vNDI5NDk2NzI5Nj4+PjA7cmV0dXJuIHQucHV0Qnl0ZXMoYSksbyhlLHIsdCksKHQucmVhZD4yMDQ4fHwwPT09dC5sZW5ndGgoKSkmJnQuY29tcGFjdCgpLGl9LGkuZGlnZXN0PWZ1bmN0aW9uKCl7dmFyIHM9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO3MucHV0Qnl0ZXModC5ieXRlcygpKTt2YXIgdSxjPWkuZnVsbE1lc3NhZ2VMZW5ndGhbaS5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGgtMV0raS5tZXNzYWdlTGVuZ3RoU2l6ZSZpLmJsb2NrTGVuZ3RoLTE7cy5wdXRCeXRlcyhhLnN1YnN0cigwLGkuYmxvY2tMZW5ndGgtYykpO2Zvcih2YXIgbD04KmkuZnVsbE1lc3NhZ2VMZW5ndGhbMF0sZj0wO2Y8aS5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGgtMTsrK2YpbCs9KHU9OCppLmZ1bGxNZXNzYWdlTGVuZ3RoW2YrMV0pLzQyOTQ5NjcyOTY+Pj4wLHMucHV0SW50MzIobD4+PjApLGw9dT4+PjA7cy5wdXRJbnQzMihsKTt2YXIgaD17aDA6ZS5oMCxoMTplLmgxLGgyOmUuaDIsaDM6ZS5oMyxoNDplLmg0fTtvKGgscixzKTt2YXIgcD1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7cmV0dXJuIHAucHV0SW50MzIoaC5oMCkscC5wdXRJbnQzMihoLmgxKSxwLnB1dEludDMyKGguaDIpLHAucHV0SW50MzIoaC5oMykscC5wdXRJbnQzMihoLmg0KSxwfSxpfTt2YXIgYT1udWxsLHM9ITE7ZnVuY3Rpb24gbyhlLHQscil7Zm9yKHZhciBuLGksYSxzLG8sdSxjLGw9ci5sZW5ndGgoKTtsPj02NDspe2ZvcihpPWUuaDAsYT1lLmgxLHM9ZS5oMixvPWUuaDMsdT1lLmg0LGM9MDtjPDE2OysrYyluPXIuZ2V0SW50MzIoKSx0W2NdPW4sbj0oaTw8NXxpPj4+MjcpKyhvXmEmKHNebykpK3UrMTUxODUwMDI0OStuLHU9byxvPXMscz0oYTw8MzB8YT4+PjIpPj4+MCxhPWksaT1uO2Zvcig7YzwyMDsrK2Mpbj0obj10W2MtM11edFtjLThdXnRbYy0xNF1edFtjLTE2XSk8PDF8bj4+PjMxLHRbY109bixuPShpPDw1fGk+Pj4yNykrKG9eYSYoc15vKSkrdSsxNTE4NTAwMjQ5K24sdT1vLG89cyxzPShhPDwzMHxhPj4+Mik+Pj4wLGE9aSxpPW47Zm9yKDtjPDMyOysrYyluPShuPXRbYy0zXV50W2MtOF1edFtjLTE0XV50W2MtMTZdKTw8MXxuPj4+MzEsdFtjXT1uLG49KGk8PDV8aT4+PjI3KSsoYV5zXm8pK3UrMTg1OTc3NTM5MytuLHU9byxvPXMscz0oYTw8MzB8YT4+PjIpPj4+MCxhPWksaT1uO2Zvcig7Yzw0MDsrK2Mpbj0obj10W2MtNl1edFtjLTE2XV50W2MtMjhdXnRbYy0zMl0pPDwyfG4+Pj4zMCx0W2NdPW4sbj0oaTw8NXxpPj4+MjcpKyhhXnNebykrdSsxODU5Nzc1MzkzK24sdT1vLG89cyxzPShhPDwzMHxhPj4+Mik+Pj4wLGE9aSxpPW47Zm9yKDtjPDYwOysrYyluPShuPXRbYy02XV50W2MtMTZdXnRbYy0yOF1edFtjLTMyXSk8PDJ8bj4+PjMwLHRbY109bixuPShpPDw1fGk+Pj4yNykrKGEmc3xvJihhXnMpKSt1KzI0MDA5NTk3MDgrbix1PW8sbz1zLHM9KGE8PDMwfGE+Pj4yKT4+PjAsYT1pLGk9bjtmb3IoO2M8ODA7KytjKW49KG49dFtjLTZdXnRbYy0xNl1edFtjLTI4XV50W2MtMzJdKTw8MnxuPj4+MzAsdFtjXT1uLG49KGk8PDV8aT4+PjI3KSsoYV5zXm8pK3UrMzM5NTQ2OTc4MituLHU9byxvPXMscz0oYTw8MzB8YT4+PjIpPj4+MCxhPWksaT1uO2UuaDA9ZS5oMCtpfDAsZS5oMT1lLmgxK2F8MCxlLmgyPWUuaDIrc3wwLGUuaDM9ZS5oMytvfDAsZS5oND1lLmg0K3V8MCxsLT02NH19fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDI5KSxyKDE1KSxyKDU4KSxyKDkpLHIoMTA1KSxyKDE2KSxyKDM1KSxyKDYzKSxyKDI1KSxyKDIpO3ZhciBpPW4uYXNuMSxhPWUuZXhwb3J0cz1uLnBraT1uLnBraXx8e30scz1hLm9pZHMsbz17fTtvLkNOPXMuY29tbW9uTmFtZSxvLmNvbW1vbk5hbWU9XCJDTlwiLG8uQz1zLmNvdW50cnlOYW1lLG8uY291bnRyeU5hbWU9XCJDXCIsby5MPXMubG9jYWxpdHlOYW1lLG8ubG9jYWxpdHlOYW1lPVwiTFwiLG8uU1Q9cy5zdGF0ZU9yUHJvdmluY2VOYW1lLG8uc3RhdGVPclByb3ZpbmNlTmFtZT1cIlNUXCIsby5PPXMub3JnYW5pemF0aW9uTmFtZSxvLm9yZ2FuaXphdGlvbk5hbWU9XCJPXCIsby5PVT1zLm9yZ2FuaXphdGlvbmFsVW5pdE5hbWUsby5vcmdhbml6YXRpb25hbFVuaXROYW1lPVwiT1VcIixvLkU9cy5lbWFpbEFkZHJlc3Msby5lbWFpbEFkZHJlc3M9XCJFXCI7dmFyIHU9bi5wa2kucnNhLnB1YmxpY0tleVZhbGlkYXRvcixjPXtuYW1lOlwiQ2VydGlmaWNhdGVcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLGNhcHR1cmVBc24xOlwidGJzQ2VydGlmaWNhdGVcIix2YWx1ZTpbe25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uXCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MCxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCx2YWx1ZTpbe25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uLmludGVnZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJjZXJ0VmVyc2lvblwifV19LHtuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiY2VydFNlcmlhbE51bWJlclwifSx7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5hbGdvcml0aG1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNlcnRpbmZvU2lnbmF0dXJlT2lkXCJ9LHtuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnNcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCxvcHRpb25hbDohMCxjYXB0dXJlQXNuMTpcImNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zXCJ9XX0se25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImNlcnRJc3N1ZXJcIn0se25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAodXRjKVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlVUQ1RJTUUsY29uc3RydWN0ZWQ6ITEsb3B0aW9uYWw6ITAsY2FwdHVyZTpcImNlcnRWYWxpZGl0eTFVVENUaW1lXCJ9LHtuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlIChnZW5lcmFsaXplZClcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5HRU5FUkFMSVpFRFRJTUUsY29uc3RydWN0ZWQ6ITEsb3B0aW9uYWw6ITAsY2FwdHVyZTpcImNlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWVcIn0se25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAodXRjKVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlVUQ1RJTUUsY29uc3RydWN0ZWQ6ITEsb3B0aW9uYWw6ITAsY2FwdHVyZTpcImNlcnRWYWxpZGl0eTNVVENUaW1lXCJ9LHtuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKGdlbmVyYWxpemVkKVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLkdFTkVSQUxJWkVEVElNRSxjb25zdHJ1Y3RlZDohMSxvcHRpb25hbDohMCxjYXB0dXJlOlwiY2VydFZhbGlkaXR5NEdlbmVyYWxpemVkVGltZVwifV19LHtuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLGNhcHR1cmVBc24xOlwiY2VydFN1YmplY3RcIn0sdSx7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlEXCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MSxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCx2YWx1ZTpbe25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZFwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLkJJVFNUUklORyxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlQml0U3RyaW5nVmFsdWU6XCJjZXJ0SXNzdWVyVW5pcXVlSWRcIn1dfSx7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RVbmlxdWVJRFwiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx0eXBlOjIsY29uc3RydWN0ZWQ6ITAsb3B0aW9uYWw6ITAsdmFsdWU6W3tuYW1lOlwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuQklUU1RSSU5HLGNvbnN0cnVjdGVkOiExLGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTpcImNlcnRTdWJqZWN0VW5pcXVlSWRcIn1dfSx7bmFtZTpcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnNcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsdHlwZTozLGNvbnN0cnVjdGVkOiEwLGNhcHR1cmVBc24xOlwiY2VydEV4dGVuc2lvbnNcIixvcHRpb25hbDohMH1dfSx7bmFtZTpcIkNlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkNlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNlcnRTaWduYXR1cmVPaWRcIn0se25hbWU6XCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVyc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLG9wdGlvbmFsOiEwLGNhcHR1cmVBc24xOlwiY2VydFNpZ25hdHVyZVBhcmFtc1wifV19LHtuYW1lOlwiQ2VydGlmaWNhdGUuc2lnbmF0dXJlVmFsdWVcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5CSVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZUJpdFN0cmluZ1ZhbHVlOlwiY2VydFNpZ25hdHVyZVwifV19LGw9e25hbWU6XCJyc2Fwc3NcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJyc2Fwc3MuaGFzaEFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx0eXBlOjAsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwicnNhcHNzLmhhc2hBbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllclwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5DbGFzcy5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCx2YWx1ZTpbe25hbWU6XCJyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiaGFzaE9pZFwifV19XX0se25hbWU6XCJyc2Fwc3MubWFza0dlbkFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx0eXBlOjEsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwicnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllclwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5DbGFzcy5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCx2YWx1ZTpbe25hbWU6XCJyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwibWFza0dlbk9pZFwifSx7bmFtZTpcInJzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwicnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5wYXJhbXMuYWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJtYXNrR2VuSGFzaE9pZFwifV19XX1dfSx7bmFtZTpcInJzYXBzcy5zYWx0TGVuZ3RoXCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MixvcHRpb25hbDohMCx2YWx1ZTpbe25hbWU6XCJyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLkNsYXNzLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInNhbHRMZW5ndGhcIn1dfSx7bmFtZTpcInJzYXBzcy50cmFpbGVyRmllbGRcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsdHlwZTozLG9wdGlvbmFsOiEwLHZhbHVlOlt7bmFtZTpcInJzYXBzcy50cmFpbGVyLnRyYWlsZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuQ2xhc3MuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwidHJhaWxlclwifV19XX0sZj17bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLGNhcHR1cmVBc24xOlwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXCIsdmFsdWU6W3tuYW1lOlwiQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmludGVnZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9WZXJzaW9uXCJ9LHtuYW1lOlwiQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3RcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1N1YmplY3RcIn0sdSx7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzXCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MCxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCxjYXB0dXJlOlwiY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlc1wiLHZhbHVlOlt7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudHlwZVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMX0se25hbWU6XCJDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uYXR0cmlidXRlcy52YWx1ZVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFVCxjb25zdHJ1Y3RlZDohMH1dfV19XX0saD17bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0XCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsY2FwdHVyZUFzbjE6XCJjc3JcIix2YWx1ZTpbZix7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNzclNpZ25hdHVyZU9pZFwifSx7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZUFsZ29yaXRobS5wYXJhbWV0ZXJzXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsb3B0aW9uYWw6ITAsY2FwdHVyZUFzbjE6XCJjc3JTaWduYXR1cmVQYXJhbXNcIn1dfSx7bmFtZTpcIkNlcnRpZmljYXRpb25SZXF1ZXN0LnNpZ25hdHVyZVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLkJJVFNUUklORyxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlQml0U3RyaW5nVmFsdWU6XCJjc3JTaWduYXR1cmVcIn1dfTtmdW5jdGlvbiBwKGUsdCl7XCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXtzaG9ydE5hbWU6dH0pO2Zvcih2YXIgcixuPW51bGwsaT0wO251bGw9PT1uJiZpPGUuYXR0cmlidXRlcy5sZW5ndGg7KytpKXI9ZS5hdHRyaWJ1dGVzW2ldLHQudHlwZSYmdC50eXBlPT09ci50eXBlP249cjp0Lm5hbWUmJnQubmFtZT09PXIubmFtZT9uPXI6dC5zaG9ydE5hbWUmJnQuc2hvcnROYW1lPT09ci5zaG9ydE5hbWUmJihuPXIpO3JldHVybiBufWEuUkROQXR0cmlidXRlc0FzQXJyYXk9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIsbixhLHU9W10sYz0wO2M8ZS52YWx1ZS5sZW5ndGg7KytjKXtyPWUudmFsdWVbY107Zm9yKHZhciBsPTA7bDxyLnZhbHVlLmxlbmd0aDsrK2wpYT17fSxuPXIudmFsdWVbbF0sYS50eXBlPWkuZGVyVG9PaWQobi52YWx1ZVswXS52YWx1ZSksYS52YWx1ZT1uLnZhbHVlWzFdLnZhbHVlLGEudmFsdWVUYWdDbGFzcz1uLnZhbHVlWzFdLnR5cGUsYS50eXBlIGluIHMmJihhLm5hbWU9c1thLnR5cGVdLGEubmFtZSBpbiBvJiYoYS5zaG9ydE5hbWU9b1thLm5hbWVdKSksdCYmKHQudXBkYXRlKGEudHlwZSksdC51cGRhdGUoYS52YWx1ZSkpLHUucHVzaChhKX1yZXR1cm4gdX0sYS5DUklBdHRyaWJ1dGVzQXNBcnJheT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS5sZW5ndGg7KytyKWZvcih2YXIgbj1lW3JdLHU9aS5kZXJUb09pZChuLnZhbHVlWzBdLnZhbHVlKSxjPW4udmFsdWVbMV0udmFsdWUsbD0wO2w8Yy5sZW5ndGg7KytsKXt2YXIgZj17fTtpZihmLnR5cGU9dSxmLnZhbHVlPWNbbF0udmFsdWUsZi52YWx1ZVRhZ0NsYXNzPWNbbF0udHlwZSxmLnR5cGUgaW4gcyYmKGYubmFtZT1zW2YudHlwZV0sZi5uYW1lIGluIG8mJihmLnNob3J0TmFtZT1vW2YubmFtZV0pKSxmLnR5cGU9PT1zLmV4dGVuc2lvblJlcXVlc3Qpe2YuZXh0ZW5zaW9ucz1bXTtmb3IodmFyIGg9MDtoPGYudmFsdWUubGVuZ3RoOysraClmLmV4dGVuc2lvbnMucHVzaChhLmNlcnRpZmljYXRlRXh0ZW5zaW9uRnJvbUFzbjEoZi52YWx1ZVtoXSkpfXQucHVzaChmKX1yZXR1cm4gdH07dmFyIGQ9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXt9O2lmKGUhPT1zW1wiUlNBU1NBLVBTU1wiXSlyZXR1cm4gbjtyJiYobj17aGFzaDp7YWxnb3JpdGhtT2lkOnMuc2hhMX0sbWdmOnthbGdvcml0aG1PaWQ6cy5tZ2YxLGhhc2g6e2FsZ29yaXRobU9pZDpzLnNoYTF9fSxzYWx0TGVuZ3RoOjIwfSk7dmFyIGE9e30sbz1bXTtpZighaS52YWxpZGF0ZSh0LGwsYSxvKSl7dmFyIHU9bmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgUlNBU1NBLVBTUyBwYXJhbWV0ZXIgYmxvY2suXCIpO3Rocm93IHUuZXJyb3JzPW8sdX1yZXR1cm4gdm9pZCAwIT09YS5oYXNoT2lkJiYobi5oYXNoPW4uaGFzaHx8e30sbi5oYXNoLmFsZ29yaXRobU9pZD1pLmRlclRvT2lkKGEuaGFzaE9pZCkpLHZvaWQgMCE9PWEubWFza0dlbk9pZCYmKG4ubWdmPW4ubWdmfHx7fSxuLm1nZi5hbGdvcml0aG1PaWQ9aS5kZXJUb09pZChhLm1hc2tHZW5PaWQpLG4ubWdmLmhhc2g9bi5tZ2YuaGFzaHx8e30sbi5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ9aS5kZXJUb09pZChhLm1hc2tHZW5IYXNoT2lkKSksdm9pZCAwIT09YS5zYWx0TGVuZ3RoJiYobi5zYWx0TGVuZ3RoPWEuc2FsdExlbmd0aC5jaGFyQ29kZUF0KDApKSxufTtmdW5jdGlvbiB5KGUpe2Zvcih2YXIgdCxyLGE9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtdKSxzPWUuYXR0cmlidXRlcyxvPTA7bzxzLmxlbmd0aDsrK28pe3ZhciB1PSh0PXNbb10pLnZhbHVlLGM9aS5UeXBlLlBSSU5UQUJMRVNUUklORztcInZhbHVlVGFnQ2xhc3NcImluIHQmJihjPXQudmFsdWVUYWdDbGFzcyk9PT1pLlR5cGUuVVRGOCYmKHU9bi51dGlsLmVuY29kZVV0ZjgodSkpLHI9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFVCwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIodC50eXBlKS5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxjLCExLHUpXSldKSxhLnZhbHVlLnB1c2gocil9cmV0dXJuIGF9ZnVuY3Rpb24gZyhlKXtmb3IodmFyIHQscj0wO3I8ZS5sZW5ndGg7KytyKXtpZih2b2lkIDA9PT0odD1lW3JdKS5uYW1lJiYodC50eXBlJiZ0LnR5cGUgaW4gYS5vaWRzP3QubmFtZT1hLm9pZHNbdC50eXBlXTp0LnNob3J0TmFtZSYmdC5zaG9ydE5hbWUgaW4gbyYmKHQubmFtZT1hLm9pZHNbb1t0LnNob3J0TmFtZV1dKSksdm9pZCAwPT09dC50eXBlKXtpZighKHQubmFtZSYmdC5uYW1lIGluIGEub2lkcykpdGhyb3codT1uZXcgRXJyb3IoXCJBdHRyaWJ1dGUgdHlwZSBub3Qgc3BlY2lmaWVkLlwiKSkuYXR0cmlidXRlPXQsdTt0LnR5cGU9YS5vaWRzW3QubmFtZV19aWYodm9pZCAwPT09dC5zaG9ydE5hbWUmJnQubmFtZSYmdC5uYW1lIGluIG8mJih0LnNob3J0TmFtZT1vW3QubmFtZV0pLHQudHlwZT09PXMuZXh0ZW5zaW9uUmVxdWVzdCYmKHQudmFsdWVDb25zdHJ1Y3RlZD0hMCx0LnZhbHVlVGFnQ2xhc3M9aS5UeXBlLlNFUVVFTkNFLCF0LnZhbHVlJiZ0LmV4dGVuc2lvbnMpKXt0LnZhbHVlPVtdO2Zvcih2YXIgbj0wO248dC5leHRlbnNpb25zLmxlbmd0aDsrK24pdC52YWx1ZS5wdXNoKGEuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEobSh0LmV4dGVuc2lvbnNbbl0pKSl9dmFyIHU7aWYodm9pZCAwPT09dC52YWx1ZSl0aHJvdyh1PW5ldyBFcnJvcihcIkF0dHJpYnV0ZSB2YWx1ZSBub3Qgc3BlY2lmaWVkLlwiKSkuYXR0cmlidXRlPXQsdX19ZnVuY3Rpb24gbShlLHQpe2lmKHQ9dHx8e30sdm9pZCAwPT09ZS5uYW1lJiZlLmlkJiZlLmlkIGluIGEub2lkcyYmKGUubmFtZT1hLm9pZHNbZS5pZF0pLHZvaWQgMD09PWUuaWQpe2lmKCEoZS5uYW1lJiZlLm5hbWUgaW4gYS5vaWRzKSl0aHJvdyhTPW5ldyBFcnJvcihcIkV4dGVuc2lvbiBJRCBub3Qgc3BlY2lmaWVkLlwiKSkuZXh0ZW5zaW9uPWUsUztlLmlkPWEub2lkc1tlLm5hbWVdfWlmKHZvaWQgMCE9PWUudmFsdWUpcmV0dXJuIGU7aWYoXCJrZXlVc2FnZVwiPT09ZS5uYW1lKXt2YXIgcj0wLG89MCx1PTA7ZS5kaWdpdGFsU2lnbmF0dXJlJiYob3w9MTI4LHI9NyksZS5ub25SZXB1ZGlhdGlvbiYmKG98PTY0LHI9NiksZS5rZXlFbmNpcGhlcm1lbnQmJihvfD0zMixyPTUpLGUuZGF0YUVuY2lwaGVybWVudCYmKG98PTE2LHI9NCksZS5rZXlBZ3JlZW1lbnQmJihvfD04LHI9MyksZS5rZXlDZXJ0U2lnbiYmKG98PTQscj0yKSxlLmNSTFNpZ24mJihvfD0yLHI9MSksZS5lbmNpcGhlck9ubHkmJihvfD0xLHI9MCksZS5kZWNpcGhlck9ubHkmJih1fD0xMjgscj03KTt2YXIgYz1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpOzAhPT11P2MrPVN0cmluZy5mcm9tQ2hhckNvZGUobykrU3RyaW5nLmZyb21DaGFyQ29kZSh1KTowIT09byYmKGMrPVN0cmluZy5mcm9tQ2hhckNvZGUobykpLGUudmFsdWU9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLkJJVFNUUklORywhMSxjKX1lbHNlIGlmKFwiYmFzaWNDb25zdHJhaW50c1wiPT09ZS5uYW1lKWUudmFsdWU9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtdKSxlLmNBJiZlLnZhbHVlLnZhbHVlLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLkJPT0xFQU4sITEsU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUpKSksXCJwYXRoTGVuQ29uc3RyYWludFwiaW4gZSYmZS52YWx1ZS52YWx1ZS5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5JTlRFR0VSLCExLGkuaW50ZWdlclRvRGVyKGUucGF0aExlbkNvbnN0cmFpbnQpLmdldEJ5dGVzKCkpKTtlbHNlIGlmKFwiZXh0S2V5VXNhZ2VcIj09PWUubmFtZSl7ZS52YWx1ZT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW10pO3ZhciBsPWUudmFsdWUudmFsdWU7Zm9yKHZhciBmIGluIGUpITA9PT1lW2ZdJiYoZiBpbiBzP2wucHVzaChpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoc1tmXSkuZ2V0Qnl0ZXMoKSkpOi0xIT09Zi5pbmRleE9mKFwiLlwiKSYmbC5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihmKS5nZXRCeXRlcygpKSkpfWVsc2UgaWYoXCJuc0NlcnRUeXBlXCI9PT1lLm5hbWUpe3I9MCxvPTA7ZS5jbGllbnQmJihvfD0xMjgscj03KSxlLnNlcnZlciYmKG98PTY0LHI9NiksZS5lbWFpbCYmKG98PTMyLHI9NSksZS5vYmpzaWduJiYob3w9MTYscj00KSxlLnJlc2VydmVkJiYob3w9OCxyPTMpLGUuc3NsQ0EmJihvfD00LHI9MiksZS5lbWFpbENBJiYob3w9MixyPTEpLGUub2JqQ0EmJihvfD0xLHI9MCk7Yz1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpOzAhPT1vJiYoYys9U3RyaW5nLmZyb21DaGFyQ29kZShvKSksZS52YWx1ZT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuQklUU1RSSU5HLCExLGMpfWVsc2UgaWYoXCJzdWJqZWN0QWx0TmFtZVwiPT09ZS5uYW1lfHxcImlzc3VlckFsdE5hbWVcIj09PWUubmFtZSl7ZS52YWx1ZT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW10pO2Zvcih2YXIgaD0wO2g8ZS5hbHROYW1lcy5sZW5ndGg7KytoKXtjPSh2PWUuYWx0TmFtZXNbaF0pLnZhbHVlO2lmKDc9PT12LnR5cGUmJnYuaXApe2lmKG51bGw9PT0oYz1uLnV0aWwuYnl0ZXNGcm9tSVAodi5pcCkpKXRocm93KFM9bmV3IEVycm9yKCdFeHRlbnNpb24gXCJpcFwiIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQdjQgb3IgSVB2NiBhZGRyZXNzLicpKS5leHRlbnNpb249ZSxTfWVsc2UgOD09PXYudHlwZSYmKGM9di5vaWQ/aS5vaWRUb0RlcihpLm9pZFRvRGVyKHYub2lkKSk6aS5vaWRUb0RlcihjKSk7ZS52YWx1ZS52YWx1ZS5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx2LnR5cGUsITEsYykpfX1lbHNlIGlmKFwibnNDb21tZW50XCI9PT1lLm5hbWUmJnQuY2VydCl7aWYoIS9eW1xceDAwLVxceDdGXSokLy50ZXN0KGUuY29tbWVudCl8fGUuY29tbWVudC5sZW5ndGg8MXx8ZS5jb21tZW50Lmxlbmd0aD4xMjgpdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwibnNDb21tZW50XCIgY29udGVudC4nKTtlLnZhbHVlPWkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5JQTVTVFJJTkcsITEsZS5jb21tZW50KX1lbHNlIGlmKFwic3ViamVjdEtleUlkZW50aWZpZXJcIj09PWUubmFtZSYmdC5jZXJ0KXt2YXIgcD10LmNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllcigpO2Uuc3ViamVjdEtleUlkZW50aWZpZXI9cC50b0hleCgpLGUudmFsdWU9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9DVEVUU1RSSU5HLCExLHAuZ2V0Qnl0ZXMoKSl9ZWxzZSBpZihcImF1dGhvcml0eUtleUlkZW50aWZpZXJcIj09PWUubmFtZSYmdC5jZXJ0KXtlLnZhbHVlPWkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbXSk7bD1lLnZhbHVlLnZhbHVlO2lmKGUua2V5SWRlbnRpZmllcil7dmFyIGQ9ITA9PT1lLmtleUlkZW50aWZpZXI/dC5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpOmUua2V5SWRlbnRpZmllcjtsLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITEsZCkpfWlmKGUuYXV0aG9yaXR5Q2VydElzc3Vlcil7dmFyIGc9W2kuY3JlYXRlKGkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyw0LCEwLFt5KCEwPT09ZS5hdXRob3JpdHlDZXJ0SXNzdWVyP3QuY2VydC5pc3N1ZXI6ZS5hdXRob3JpdHlDZXJ0SXNzdWVyKV0pXTtsLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDEsITAsZykpfWlmKGUuc2VyaWFsTnVtYmVyKXt2YXIgbT1uLnV0aWwuaGV4VG9CeXRlcyghMD09PWUuc2VyaWFsTnVtYmVyP3QuY2VydC5zZXJpYWxOdW1iZXI6ZS5zZXJpYWxOdW1iZXIpO2wucHVzaChpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMiwhMSxtKSl9fWVsc2UgaWYoXCJjUkxEaXN0cmlidXRpb25Qb2ludHNcIj09PWUubmFtZSl7ZS52YWx1ZT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW10pO2w9ZS52YWx1ZS52YWx1ZTt2YXIgdixiPWkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbXSksRT1pLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMCwhMCxbXSk7Zm9yKGg9MDtoPGUuYWx0TmFtZXMubGVuZ3RoOysraCl7Yz0odj1lLmFsdE5hbWVzW2hdKS52YWx1ZTtpZig3PT09di50eXBlJiZ2LmlwKXtpZihudWxsPT09KGM9bi51dGlsLmJ5dGVzRnJvbUlQKHYuaXApKSl0aHJvdyhTPW5ldyBFcnJvcignRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nKSkuZXh0ZW5zaW9uPWUsU31lbHNlIDg9PT12LnR5cGUmJihjPXYub2lkP2kub2lkVG9EZXIoaS5vaWRUb0Rlcih2Lm9pZCkpOmkub2lkVG9EZXIoYykpO0UudmFsdWUucHVzaChpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsdi50eXBlLCExLGMpKX1iLnZhbHVlLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW0VdKSksbC5wdXNoKGIpfXZhciBTO2lmKHZvaWQgMD09PWUudmFsdWUpdGhyb3coUz1uZXcgRXJyb3IoXCJFeHRlbnNpb24gdmFsdWUgbm90IHNwZWNpZmllZC5cIikpLmV4dGVuc2lvbj1lLFM7cmV0dXJuIGV9ZnVuY3Rpb24gdihlLHQpe3N3aXRjaChlKXtjYXNlIHNbXCJSU0FTU0EtUFNTXCJdOnZhciByPVtdO3JldHVybiB2b2lkIDAhPT10Lmhhc2guYWxnb3JpdGhtT2lkJiZyLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKHQuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5OVUxMLCExLFwiXCIpXSldKSksdm9pZCAwIT09dC5tZ2YuYWxnb3JpdGhtT2lkJiZyLnB1c2goaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDEsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKHQubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIodC5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5OVUxMLCExLFwiXCIpXSldKV0pKSx2b2lkIDAhPT10LnNhbHRMZW5ndGgmJnIucHVzaChpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMiwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLklOVEVHRVIsITEsaS5pbnRlZ2VyVG9EZXIodC5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKV0pKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAscik7ZGVmYXVsdDpyZXR1cm4gaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk5VTEwsITEsXCJcIil9fWZ1bmN0aW9uIGIoZSl7dmFyIHQ9aS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW10pO2lmKDA9PT1lLmF0dHJpYnV0ZXMubGVuZ3RoKXJldHVybiB0O2Zvcih2YXIgcj1lLmF0dHJpYnV0ZXMsYT0wO2E8ci5sZW5ndGg7KythKXt2YXIgcz1yW2FdLG89cy52YWx1ZSx1PWkuVHlwZS5VVEY4O1widmFsdWVUYWdDbGFzc1wiaW4gcyYmKHU9cy52YWx1ZVRhZ0NsYXNzKSx1PT09aS5UeXBlLlVURjgmJihvPW4udXRpbC5lbmNvZGVVdGY4KG8pKTt2YXIgYz0hMTtcInZhbHVlQ29uc3RydWN0ZWRcImluIHMmJihjPXMudmFsdWVDb25zdHJ1Y3RlZCk7dmFyIGw9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIocy50eXBlKS5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VULCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCx1LGMsbyldKV0pO3QudmFsdWUucHVzaChsKX1yZXR1cm4gdH1hLmNlcnRpZmljYXRlRnJvbVBlbT1mdW5jdGlvbihlLHQscil7dmFyIHM9bi5wZW0uZGVjb2RlKGUpWzBdO2lmKFwiQ0VSVElGSUNBVEVcIiE9PXMudHlwZSYmXCJYNTA5IENFUlRJRklDQVRFXCIhPT1zLnR5cGUmJlwiVFJVU1RFRCBDRVJUSUZJQ0FURVwiIT09cy50eXBlKXt2YXIgbz1uZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiQ0VSVElGSUNBVEVcIiwgXCJYNTA5IENFUlRJRklDQVRFXCIsIG9yIFwiVFJVU1RFRCBDRVJUSUZJQ0FURVwiLicpO3Rocm93IG8uaGVhZGVyVHlwZT1zLnR5cGUsb31pZihzLnByb2NUeXBlJiZcIkVOQ1JZUFRFRFwiPT09cy5wcm9jVHlwZS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLlwiKTt2YXIgdT1pLmZyb21EZXIocy5ib2R5LHIpO3JldHVybiBhLmNlcnRpZmljYXRlRnJvbUFzbjEodSx0KX0sYS5jZXJ0aWZpY2F0ZVRvUGVtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9e3R5cGU6XCJDRVJUSUZJQ0FURVwiLGJvZHk6aS50b0RlcihhLmNlcnRpZmljYXRlVG9Bc24xKGUpKS5nZXRCeXRlcygpfTtyZXR1cm4gbi5wZW0uZW5jb2RlKHIse21heGxpbmU6dH0pfSxhLnB1YmxpY0tleUZyb21QZW09ZnVuY3Rpb24oZSl7dmFyIHQ9bi5wZW0uZGVjb2RlKGUpWzBdO2lmKFwiUFVCTElDIEtFWVwiIT09dC50eXBlJiZcIlJTQSBQVUJMSUMgS0VZXCIhPT10LnR5cGUpe3ZhciByPW5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIlBVQkxJQyBLRVlcIiBvciBcIlJTQSBQVUJMSUMgS0VZXCIuJyk7dGhyb3cgci5oZWFkZXJUeXBlPXQudHlwZSxyfWlmKHQucHJvY1R5cGUmJlwiRU5DUllQVEVEXCI9PT10LnByb2NUeXBlLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC5cIik7dmFyIHM9aS5mcm9tRGVyKHQuYm9keSk7cmV0dXJuIGEucHVibGljS2V5RnJvbUFzbjEocyl9LGEucHVibGljS2V5VG9QZW09ZnVuY3Rpb24oZSx0KXt2YXIgcj17dHlwZTpcIlBVQkxJQyBLRVlcIixib2R5OmkudG9EZXIoYS5wdWJsaWNLZXlUb0FzbjEoZSkpLmdldEJ5dGVzKCl9O3JldHVybiBuLnBlbS5lbmNvZGUocix7bWF4bGluZTp0fSl9LGEucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW09ZnVuY3Rpb24oZSx0KXt2YXIgcj17dHlwZTpcIlJTQSBQVUJMSUMgS0VZXCIsYm9keTppLnRvRGVyKGEucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoZSkpLmdldEJ5dGVzKCl9O3JldHVybiBuLnBlbS5lbmNvZGUocix7bWF4bGluZTp0fSl9LGEuZ2V0UHVibGljS2V5RmluZ2VycHJpbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgcixzPSh0PXR8fHt9KS5tZHx8bi5tZC5zaGExLmNyZWF0ZSgpO3N3aXRjaCh0LnR5cGV8fFwiUlNBUHVibGljS2V5XCIpe2Nhc2VcIlJTQVB1YmxpY0tleVwiOnI9aS50b0RlcihhLnB1YmxpY0tleVRvUlNBUHVibGljS2V5KGUpKS5nZXRCeXRlcygpO2JyZWFrO2Nhc2VcIlN1YmplY3RQdWJsaWNLZXlJbmZvXCI6cj1pLnRvRGVyKGEucHVibGljS2V5VG9Bc24xKGUpKS5nZXRCeXRlcygpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbmdlcnByaW50IHR5cGUgXCInK3QudHlwZSsnXCIuJyl9cy5zdGFydCgpLHMudXBkYXRlKHIpO3ZhciBvPXMuZGlnZXN0KCk7aWYoXCJoZXhcIj09PXQuZW5jb2Rpbmcpe3ZhciB1PW8udG9IZXgoKTtyZXR1cm4gdC5kZWxpbWl0ZXI/dS5tYXRjaCgvLnsyfS9nKS5qb2luKHQuZGVsaW1pdGVyKTp1fWlmKFwiYmluYXJ5XCI9PT10LmVuY29kaW5nKXJldHVybiBvLmdldEJ5dGVzKCk7aWYodC5lbmNvZGluZyl0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgXCInK3QuZW5jb2RpbmcrJ1wiLicpO3JldHVybiBvfSxhLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbVBlbT1mdW5jdGlvbihlLHQscil7dmFyIHM9bi5wZW0uZGVjb2RlKGUpWzBdO2lmKFwiQ0VSVElGSUNBVEUgUkVRVUVTVFwiIT09cy50eXBlKXt2YXIgbz1uZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlIGlzIG5vdCBcIkNFUlRJRklDQVRFIFJFUVVFU1RcIi4nKTt0aHJvdyBvLmhlYWRlclR5cGU9cy50eXBlLG99aWYocy5wcm9jVHlwZSYmXCJFTkNSWVBURURcIj09PXMucHJvY1R5cGUudHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuXCIpO3ZhciB1PWkuZnJvbURlcihzLmJvZHkscik7cmV0dXJuIGEuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMSh1LHQpfSxhLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9QZW09ZnVuY3Rpb24oZSx0KXt2YXIgcj17dHlwZTpcIkNFUlRJRklDQVRFIFJFUVVFU1RcIixib2R5OmkudG9EZXIoYS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMShlKSkuZ2V0Qnl0ZXMoKX07cmV0dXJuIG4ucGVtLmVuY29kZShyLHttYXhsaW5lOnR9KX0sYS5jcmVhdGVDZXJ0aWZpY2F0ZT1mdW5jdGlvbigpe3ZhciBlPXt2ZXJzaW9uOjIsc2VyaWFsTnVtYmVyOlwiMDBcIixzaWduYXR1cmVPaWQ6bnVsbCxzaWduYXR1cmU6bnVsbCxzaWdpbmZvOnt9fTtyZXR1cm4gZS5zaWdpbmZvLmFsZ29yaXRobU9pZD1udWxsLGUudmFsaWRpdHk9e30sZS52YWxpZGl0eS5ub3RCZWZvcmU9bmV3IERhdGUsZS52YWxpZGl0eS5ub3RBZnRlcj1uZXcgRGF0ZSxlLmlzc3Vlcj17fSxlLmlzc3Vlci5nZXRGaWVsZD1mdW5jdGlvbih0KXtyZXR1cm4gcChlLmlzc3Vlcix0KX0sZS5pc3N1ZXIuYWRkRmllbGQ9ZnVuY3Rpb24odCl7ZyhbdF0pLGUuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaCh0KX0sZS5pc3N1ZXIuYXR0cmlidXRlcz1bXSxlLmlzc3Vlci5oYXNoPW51bGwsZS5zdWJqZWN0PXt9LGUuc3ViamVjdC5nZXRGaWVsZD1mdW5jdGlvbih0KXtyZXR1cm4gcChlLnN1YmplY3QsdCl9LGUuc3ViamVjdC5hZGRGaWVsZD1mdW5jdGlvbih0KXtnKFt0XSksZS5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaCh0KX0sZS5zdWJqZWN0LmF0dHJpYnV0ZXM9W10sZS5zdWJqZWN0Lmhhc2g9bnVsbCxlLmV4dGVuc2lvbnM9W10sZS5wdWJsaWNLZXk9bnVsbCxlLm1kPW51bGwsZS5zZXRTdWJqZWN0PWZ1bmN0aW9uKHQscil7Zyh0KSxlLnN1YmplY3QuYXR0cmlidXRlcz10LGRlbGV0ZSBlLnN1YmplY3QudW5pcXVlSWQsciYmKGUuc3ViamVjdC51bmlxdWVJZD1yKSxlLnN1YmplY3QuaGFzaD1udWxsfSxlLnNldElzc3Vlcj1mdW5jdGlvbih0LHIpe2codCksZS5pc3N1ZXIuYXR0cmlidXRlcz10LGRlbGV0ZSBlLmlzc3Vlci51bmlxdWVJZCxyJiYoZS5pc3N1ZXIudW5pcXVlSWQ9ciksZS5pc3N1ZXIuaGFzaD1udWxsfSxlLnNldEV4dGVuc2lvbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDsrK3IpbSh0W3JdLHtjZXJ0OmV9KTtlLmV4dGVuc2lvbnM9dH0sZS5nZXRFeHRlbnNpb249ZnVuY3Rpb24odCl7XCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PXtuYW1lOnR9KTtmb3IodmFyIHIsbj1udWxsLGk9MDtudWxsPT09biYmaTxlLmV4dGVuc2lvbnMubGVuZ3RoOysraSlyPWUuZXh0ZW5zaW9uc1tpXSx0LmlkJiZyLmlkPT09dC5pZD9uPXI6dC5uYW1lJiZyLm5hbWU9PT10Lm5hbWUmJihuPXIpO3JldHVybiBufSxlLnNpZ249ZnVuY3Rpb24odCxyKXtlLm1kPXJ8fG4ubWQuc2hhMS5jcmVhdGUoKTt2YXIgbz1zW2UubWQuYWxnb3JpdGhtK1wiV2l0aFJTQUVuY3J5cHRpb25cIl07aWYoIW8pe3ZhciB1PW5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRlIGRpZ2VzdC4gVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELlwiKTt0aHJvdyB1LmFsZ29yaXRobT1lLm1kLmFsZ29yaXRobSx1fWUuc2lnbmF0dXJlT2lkPWUuc2lnaW5mby5hbGdvcml0aG1PaWQ9byxlLnRic0NlcnRpZmljYXRlPWEuZ2V0VEJTQ2VydGlmaWNhdGUoZSk7dmFyIGM9aS50b0RlcihlLnRic0NlcnRpZmljYXRlKTtlLm1kLnVwZGF0ZShjLmdldEJ5dGVzKCkpLGUuc2lnbmF0dXJlPXQuc2lnbihlLm1kKX0sZS52ZXJpZnk9ZnVuY3Rpb24odCl7dmFyIHI9ITE7aWYoIWUuaXNzdWVkKHQpKXt2YXIgbz10Lmlzc3Vlcix1PWUuc3ViamVjdDt0aHJvdyh5PW5ldyBFcnJvcihcIlRoZSBwYXJlbnQgY2VydGlmaWNhdGUgZGlkIG5vdCBpc3N1ZSB0aGUgZ2l2ZW4gY2hpbGQgY2VydGlmaWNhdGU7IHRoZSBjaGlsZCBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBkb2VzIG5vdCBtYXRjaCB0aGUgcGFyZW50J3Mgc3ViamVjdC5cIikpLmV4cGVjdGVkSXNzdWVyPW8uYXR0cmlidXRlcyx5LmFjdHVhbElzc3Vlcj11LmF0dHJpYnV0ZXMseX12YXIgYz10Lm1kO2lmKG51bGw9PT1jKXtpZih0LnNpZ25hdHVyZU9pZCBpbiBzKXN3aXRjaChzW3Quc2lnbmF0dXJlT2lkXSl7Y2FzZVwic2hhMVdpdGhSU0FFbmNyeXB0aW9uXCI6Yz1uLm1kLnNoYTEuY3JlYXRlKCk7YnJlYWs7Y2FzZVwibWQ1V2l0aFJTQUVuY3J5cHRpb25cIjpjPW4ubWQubWQ1LmNyZWF0ZSgpO2JyZWFrO2Nhc2VcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6Yz1uLm1kLnNoYTI1Ni5jcmVhdGUoKTticmVhaztjYXNlXCJzaGEzODRXaXRoUlNBRW5jcnlwdGlvblwiOmM9bi5tZC5zaGEzODQuY3JlYXRlKCk7YnJlYWs7Y2FzZVwic2hhNTEyV2l0aFJTQUVuY3J5cHRpb25cIjpjPW4ubWQuc2hhNTEyLmNyZWF0ZSgpO2JyZWFrO2Nhc2VcIlJTQVNTQS1QU1NcIjpjPW4ubWQuc2hhMjU2LmNyZWF0ZSgpfWlmKG51bGw9PT1jKXRocm93KHk9bmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiBVbmtub3duIHNpZ25hdHVyZSBPSUQuXCIpKS5zaWduYXR1cmVPaWQ9dC5zaWduYXR1cmVPaWQseTt2YXIgbD10LnRic0NlcnRpZmljYXRlfHxhLmdldFRCU0NlcnRpZmljYXRlKHQpLGY9aS50b0RlcihsKTtjLnVwZGF0ZShmLmdldEJ5dGVzKCkpfWlmKG51bGwhPT1jKXt2YXIgaDtzd2l0Y2godC5zaWduYXR1cmVPaWQpe2Nhc2Ugcy5zaGExV2l0aFJTQUVuY3J5cHRpb246aD12b2lkIDA7YnJlYWs7Y2FzZSBzW1wiUlNBU1NBLVBTU1wiXTp2YXIgcCxkLHk7aWYodm9pZCAwPT09KHA9c1t0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkXSl8fHZvaWQgMD09PW4ubWRbcF0pdGhyb3coeT1uZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBNR0YgaGFzaCBmdW5jdGlvbi5cIikpLm9pZD10LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkLHkubmFtZT1wLHk7aWYodm9pZCAwPT09KGQ9c1t0LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZF0pfHx2b2lkIDA9PT1uLm1nZltkXSl0aHJvdyh5PW5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi5cIikpLm9pZD10LnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZCx5Lm5hbWU9ZCx5O2lmKGQ9bi5tZ2ZbZF0uY3JlYXRlKG4ubWRbcF0uY3JlYXRlKCkpLHZvaWQgMD09PShwPXNbdC5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkXSl8fHZvaWQgMD09PW4ubWRbcF0pdGhyb3d7bWVzc2FnZTpcIlVuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi5cIixvaWQ6dC5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkLG5hbWU6cH07aD1uLnBzcy5jcmVhdGUobi5tZFtwXS5jcmVhdGUoKSxkLHQuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKX1yPWUucHVibGljS2V5LnZlcmlmeShjLmRpZ2VzdCgpLmdldEJ5dGVzKCksdC5zaWduYXR1cmUsaCl9cmV0dXJuIHJ9LGUuaXNJc3N1ZXI9ZnVuY3Rpb24odCl7dmFyIHI9ITEsbj1lLmlzc3VlcixpPXQuc3ViamVjdDtpZihuLmhhc2gmJmkuaGFzaClyPW4uaGFzaD09PWkuaGFzaDtlbHNlIGlmKG4uYXR0cmlidXRlcy5sZW5ndGg9PT1pLmF0dHJpYnV0ZXMubGVuZ3RoKXt2YXIgYSxzO3I9ITA7Zm9yKHZhciBvPTA7ciYmbzxuLmF0dHJpYnV0ZXMubGVuZ3RoOysrbylhPW4uYXR0cmlidXRlc1tvXSxzPWkuYXR0cmlidXRlc1tvXSxhLnR5cGU9PT1zLnR5cGUmJmEudmFsdWU9PT1zLnZhbHVlfHwocj0hMSl9cmV0dXJuIHJ9LGUuaXNzdWVkPWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzSXNzdWVyKGUpfSxlLmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXI9ZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRQdWJsaWNLZXlGaW5nZXJwcmludChlLnB1YmxpY0tleSx7dHlwZTpcIlJTQVB1YmxpY0tleVwifSl9LGUudmVyaWZ5U3ViamVjdEtleUlkZW50aWZpZXI9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9cy5zdWJqZWN0S2V5SWRlbnRpZmllcixyPTA7cjxlLmV4dGVuc2lvbnMubGVuZ3RoOysrcil7dmFyIGk9ZS5leHRlbnNpb25zW3JdO2lmKGkuaWQ9PT10KXt2YXIgYT1lLmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpO3JldHVybiBuLnV0aWwuaGV4VG9CeXRlcyhpLnN1YmplY3RLZXlJZGVudGlmaWVyKT09PWF9fXJldHVybiExfSxlfSxhLmNlcnRpZmljYXRlRnJvbUFzbjE9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fSxvPVtdO2lmKCFpLnZhbGlkYXRlKGUsYyxyLG8pKXRocm93KGg9bmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgWC41MDkgY2VydGlmaWNhdGUuIEFTTi4xIG9iamVjdCBpcyBub3QgYW4gWDUwOXYzIENlcnRpZmljYXRlLlwiKSkuZXJyb3JzPW8saDtpZihpLmRlclRvT2lkKHIucHVibGljS2V5T2lkKSE9PWEub2lkcy5yc2FFbmNyeXB0aW9uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLlwiKTt2YXIgdT1hLmNyZWF0ZUNlcnRpZmljYXRlKCk7dS52ZXJzaW9uPXIuY2VydFZlcnNpb24/ci5jZXJ0VmVyc2lvbi5jaGFyQ29kZUF0KDApOjA7dmFyIGw9bi51dGlsLmNyZWF0ZUJ1ZmZlcihyLmNlcnRTZXJpYWxOdW1iZXIpO3Uuc2VyaWFsTnVtYmVyPWwudG9IZXgoKSx1LnNpZ25hdHVyZU9pZD1uLmFzbjEuZGVyVG9PaWQoci5jZXJ0U2lnbmF0dXJlT2lkKSx1LnNpZ25hdHVyZVBhcmFtZXRlcnM9ZCh1LnNpZ25hdHVyZU9pZCxyLmNlcnRTaWduYXR1cmVQYXJhbXMsITApLHUuc2lnaW5mby5hbGdvcml0aG1PaWQ9bi5hc24xLmRlclRvT2lkKHIuY2VydGluZm9TaWduYXR1cmVPaWQpLHUuc2lnaW5mby5wYXJhbWV0ZXJzPWQodS5zaWdpbmZvLmFsZ29yaXRobU9pZCxyLmNlcnRpbmZvU2lnbmF0dXJlUGFyYW1zLCExKSx1LnNpZ25hdHVyZT1yLmNlcnRTaWduYXR1cmU7dmFyIGY9W107aWYodm9pZCAwIT09ci5jZXJ0VmFsaWRpdHkxVVRDVGltZSYmZi5wdXNoKGkudXRjVGltZVRvRGF0ZShyLmNlcnRWYWxpZGl0eTFVVENUaW1lKSksdm9pZCAwIT09ci5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lJiZmLnB1c2goaS5nZW5lcmFsaXplZFRpbWVUb0RhdGUoci5jZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lKSksdm9pZCAwIT09ci5jZXJ0VmFsaWRpdHkzVVRDVGltZSYmZi5wdXNoKGkudXRjVGltZVRvRGF0ZShyLmNlcnRWYWxpZGl0eTNVVENUaW1lKSksdm9pZCAwIT09ci5jZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lJiZmLnB1c2goaS5nZW5lcmFsaXplZFRpbWVUb0RhdGUoci5jZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lKSksZi5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IG1vcmUgdGhhbiB0d28gdGltZXMgd2VyZSBwcm92aWRlZCBpbiB0aGUgY2VydGlmaWNhdGUuXCIpO2lmKGYubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlYWQgbm90QmVmb3JlL25vdEFmdGVyIHZhbGlkaXR5IHRpbWVzOyB0aGV5IHdlcmUgbm90IHByb3ZpZGVkIGFzIGVpdGhlciBVVENUaW1lIG9yIEdlbmVyYWxpemVkVGltZS5cIik7aWYodS52YWxpZGl0eS5ub3RCZWZvcmU9ZlswXSx1LnZhbGlkaXR5Lm5vdEFmdGVyPWZbMV0sdS50YnNDZXJ0aWZpY2F0ZT1yLnRic0NlcnRpZmljYXRlLHQpe3ZhciBoO2lmKHUubWQ9bnVsbCx1LnNpZ25hdHVyZU9pZCBpbiBzKXN3aXRjaChzW3Uuc2lnbmF0dXJlT2lkXSl7Y2FzZVwic2hhMVdpdGhSU0FFbmNyeXB0aW9uXCI6dS5tZD1uLm1kLnNoYTEuY3JlYXRlKCk7YnJlYWs7Y2FzZVwibWQ1V2l0aFJTQUVuY3J5cHRpb25cIjp1Lm1kPW4ubWQubWQ1LmNyZWF0ZSgpO2JyZWFrO2Nhc2VcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6dS5tZD1uLm1kLnNoYTI1Ni5jcmVhdGUoKTticmVhaztjYXNlXCJzaGEzODRXaXRoUlNBRW5jcnlwdGlvblwiOnUubWQ9bi5tZC5zaGEzODQuY3JlYXRlKCk7YnJlYWs7Y2FzZVwic2hhNTEyV2l0aFJTQUVuY3J5cHRpb25cIjp1Lm1kPW4ubWQuc2hhNTEyLmNyZWF0ZSgpO2JyZWFrO2Nhc2VcIlJTQVNTQS1QU1NcIjp1Lm1kPW4ubWQuc2hhMjU2LmNyZWF0ZSgpfWlmKG51bGw9PT11Lm1kKXRocm93KGg9bmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiBVbmtub3duIHNpZ25hdHVyZSBPSUQuXCIpKS5zaWduYXR1cmVPaWQ9dS5zaWduYXR1cmVPaWQsaDt2YXIgeT1pLnRvRGVyKHUudGJzQ2VydGlmaWNhdGUpO3UubWQudXBkYXRlKHkuZ2V0Qnl0ZXMoKSl9dmFyIG09bi5tZC5zaGExLmNyZWF0ZSgpO3UuaXNzdWVyLmdldEZpZWxkPWZ1bmN0aW9uKGUpe3JldHVybiBwKHUuaXNzdWVyLGUpfSx1Lmlzc3Vlci5hZGRGaWVsZD1mdW5jdGlvbihlKXtnKFtlXSksdS5pc3N1ZXIuYXR0cmlidXRlcy5wdXNoKGUpfSx1Lmlzc3Vlci5hdHRyaWJ1dGVzPWEuUkROQXR0cmlidXRlc0FzQXJyYXkoci5jZXJ0SXNzdWVyLG0pLHIuY2VydElzc3VlclVuaXF1ZUlkJiYodS5pc3N1ZXIudW5pcXVlSWQ9ci5jZXJ0SXNzdWVyVW5pcXVlSWQpLHUuaXNzdWVyLmhhc2g9bS5kaWdlc3QoKS50b0hleCgpO3ZhciB2PW4ubWQuc2hhMS5jcmVhdGUoKTtyZXR1cm4gdS5zdWJqZWN0LmdldEZpZWxkPWZ1bmN0aW9uKGUpe3JldHVybiBwKHUuc3ViamVjdCxlKX0sdS5zdWJqZWN0LmFkZEZpZWxkPWZ1bmN0aW9uKGUpe2coW2VdKSx1LnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGUpfSx1LnN1YmplY3QuYXR0cmlidXRlcz1hLlJETkF0dHJpYnV0ZXNBc0FycmF5KHIuY2VydFN1YmplY3Qsdiksci5jZXJ0U3ViamVjdFVuaXF1ZUlkJiYodS5zdWJqZWN0LnVuaXF1ZUlkPXIuY2VydFN1YmplY3RVbmlxdWVJZCksdS5zdWJqZWN0Lmhhc2g9di5kaWdlc3QoKS50b0hleCgpLHIuY2VydEV4dGVuc2lvbnM/dS5leHRlbnNpb25zPWEuY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEoci5jZXJ0RXh0ZW5zaW9ucyk6dS5leHRlbnNpb25zPVtdLHUucHVibGljS2V5PWEucHVibGljS2V5RnJvbUFzbjEoci5zdWJqZWN0UHVibGljS2V5SW5mbyksdX0sYS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9W10scj0wO3I8ZS52YWx1ZS5sZW5ndGg7KytyKWZvcih2YXIgbj1lLnZhbHVlW3JdLGk9MDtpPG4udmFsdWUubGVuZ3RoOysraSl0LnB1c2goYS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKG4udmFsdWVbaV0pKTtyZXR1cm4gdH0sYS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xPWZ1bmN0aW9uKGUpe3ZhciB0PXt9O2lmKHQuaWQ9aS5kZXJUb09pZChlLnZhbHVlWzBdLnZhbHVlKSx0LmNyaXRpY2FsPSExLGUudmFsdWVbMV0udHlwZT09PWkuVHlwZS5CT09MRUFOPyh0LmNyaXRpY2FsPTAhPT1lLnZhbHVlWzFdLnZhbHVlLmNoYXJDb2RlQXQoMCksdC52YWx1ZT1lLnZhbHVlWzJdLnZhbHVlKTp0LnZhbHVlPWUudmFsdWVbMV0udmFsdWUsdC5pZCBpbiBzKWlmKHQubmFtZT1zW3QuaWRdLFwia2V5VXNhZ2VcIj09PXQubmFtZSl7dmFyIHI9MCxhPTA7KHU9aS5mcm9tRGVyKHQudmFsdWUpKS52YWx1ZS5sZW5ndGg+MSYmKHI9dS52YWx1ZS5jaGFyQ29kZUF0KDEpLGE9dS52YWx1ZS5sZW5ndGg+Mj91LnZhbHVlLmNoYXJDb2RlQXQoMik6MCksdC5kaWdpdGFsU2lnbmF0dXJlPTEyOD09KDEyOCZyKSx0Lm5vblJlcHVkaWF0aW9uPTY0PT0oNjQmciksdC5rZXlFbmNpcGhlcm1lbnQ9MzI9PSgzMiZyKSx0LmRhdGFFbmNpcGhlcm1lbnQ9MTY9PSgxNiZyKSx0LmtleUFncmVlbWVudD04PT0oOCZyKSx0LmtleUNlcnRTaWduPTQ9PSg0JnIpLHQuY1JMU2lnbj0yPT0oMiZyKSx0LmVuY2lwaGVyT25seT0xPT0oMSZyKSx0LmRlY2lwaGVyT25seT0xMjg9PSgxMjgmYSl9ZWxzZSBpZihcImJhc2ljQ29uc3RyYWludHNcIj09PXQubmFtZSl7KHU9aS5mcm9tRGVyKHQudmFsdWUpKS52YWx1ZS5sZW5ndGg+MCYmdS52YWx1ZVswXS50eXBlPT09aS5UeXBlLkJPT0xFQU4/dC5jQT0wIT09dS52YWx1ZVswXS52YWx1ZS5jaGFyQ29kZUF0KDApOnQuY0E9ITE7dmFyIG89bnVsbDt1LnZhbHVlLmxlbmd0aD4wJiZ1LnZhbHVlWzBdLnR5cGU9PT1pLlR5cGUuSU5URUdFUj9vPXUudmFsdWVbMF0udmFsdWU6dS52YWx1ZS5sZW5ndGg+MSYmKG89dS52YWx1ZVsxXS52YWx1ZSksbnVsbCE9PW8mJih0LnBhdGhMZW5Db25zdHJhaW50PWkuZGVyVG9JbnRlZ2VyKG8pKX1lbHNlIGlmKFwiZXh0S2V5VXNhZ2VcIj09PXQubmFtZSlmb3IodmFyIHU9aS5mcm9tRGVyKHQudmFsdWUpLGM9MDtjPHUudmFsdWUubGVuZ3RoOysrYyl7dmFyIGw9aS5kZXJUb09pZCh1LnZhbHVlW2NdLnZhbHVlKTtsIGluIHM/dFtzW2xdXT0hMDp0W2xdPSEwfWVsc2UgaWYoXCJuc0NlcnRUeXBlXCI9PT10Lm5hbWUpe3I9MDsodT1pLmZyb21EZXIodC52YWx1ZSkpLnZhbHVlLmxlbmd0aD4xJiYocj11LnZhbHVlLmNoYXJDb2RlQXQoMSkpLHQuY2xpZW50PTEyOD09KDEyOCZyKSx0LnNlcnZlcj02ND09KDY0JnIpLHQuZW1haWw9MzI9PSgzMiZyKSx0Lm9ianNpZ249MTY9PSgxNiZyKSx0LnJlc2VydmVkPTg9PSg4JnIpLHQuc3NsQ0E9ND09KDQmciksdC5lbWFpbENBPTI9PSgyJnIpLHQub2JqQ0E9MT09KDEmcil9ZWxzZSBpZihcInN1YmplY3RBbHROYW1lXCI9PT10Lm5hbWV8fFwiaXNzdWVyQWx0TmFtZVwiPT09dC5uYW1lKXt2YXIgZjt0LmFsdE5hbWVzPVtdO3U9aS5mcm9tRGVyKHQudmFsdWUpO2Zvcih2YXIgaD0wO2g8dS52YWx1ZS5sZW5ndGg7KytoKXt2YXIgcD17dHlwZTooZj11LnZhbHVlW2hdKS50eXBlLHZhbHVlOmYudmFsdWV9O3N3aXRjaCh0LmFsdE5hbWVzLnB1c2gocCksZi50eXBlKXtjYXNlIDE6Y2FzZSAyOmNhc2UgNjpicmVhaztjYXNlIDc6cC5pcD1uLnV0aWwuYnl0ZXNUb0lQKGYudmFsdWUpO2JyZWFrO2Nhc2UgODpwLm9pZD1pLmRlclRvT2lkKGYudmFsdWUpfX19ZWxzZSBpZihcInN1YmplY3RLZXlJZGVudGlmaWVyXCI9PT10Lm5hbWUpe3U9aS5mcm9tRGVyKHQudmFsdWUpO3Quc3ViamVjdEtleUlkZW50aWZpZXI9bi51dGlsLmJ5dGVzVG9IZXgodS52YWx1ZSl9cmV0dXJuIHR9LGEuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMT1mdW5jdGlvbihlLHQpe3ZhciByPXt9LG89W107aWYoIWkudmFsaWRhdGUoZSxoLHIsbykpdGhyb3coYz1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBQS0NTIzEwIGNlcnRpZmljYXRlIHJlcXVlc3QuIEFTTi4xIG9iamVjdCBpcyBub3QgYSBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlwiKSkuZXJyb3JzPW8sYztpZihpLmRlclRvT2lkKHIucHVibGljS2V5T2lkKSE9PWEub2lkcy5yc2FFbmNyeXB0aW9uKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWFkIHB1YmxpYyBrZXkuIE9JRCBpcyBub3QgUlNBLlwiKTt2YXIgdT1hLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0KCk7aWYodS52ZXJzaW9uPXIuY3NyVmVyc2lvbj9yLmNzclZlcnNpb24uY2hhckNvZGVBdCgwKTowLHUuc2lnbmF0dXJlT2lkPW4uYXNuMS5kZXJUb09pZChyLmNzclNpZ25hdHVyZU9pZCksdS5zaWduYXR1cmVQYXJhbWV0ZXJzPWQodS5zaWduYXR1cmVPaWQsci5jc3JTaWduYXR1cmVQYXJhbXMsITApLHUuc2lnaW5mby5hbGdvcml0aG1PaWQ9bi5hc24xLmRlclRvT2lkKHIuY3NyU2lnbmF0dXJlT2lkKSx1LnNpZ2luZm8ucGFyYW1ldGVycz1kKHUuc2lnaW5mby5hbGdvcml0aG1PaWQsci5jc3JTaWduYXR1cmVQYXJhbXMsITEpLHUuc2lnbmF0dXJlPXIuY3NyU2lnbmF0dXJlLHUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvPXIuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLHQpe3ZhciBjO2lmKHUubWQ9bnVsbCx1LnNpZ25hdHVyZU9pZCBpbiBzKXN3aXRjaChzW3Uuc2lnbmF0dXJlT2lkXSl7Y2FzZVwic2hhMVdpdGhSU0FFbmNyeXB0aW9uXCI6dS5tZD1uLm1kLnNoYTEuY3JlYXRlKCk7YnJlYWs7Y2FzZVwibWQ1V2l0aFJTQUVuY3J5cHRpb25cIjp1Lm1kPW4ubWQubWQ1LmNyZWF0ZSgpO2JyZWFrO2Nhc2VcInNoYTI1NldpdGhSU0FFbmNyeXB0aW9uXCI6dS5tZD1uLm1kLnNoYTI1Ni5jcmVhdGUoKTticmVhaztjYXNlXCJzaGEzODRXaXRoUlNBRW5jcnlwdGlvblwiOnUubWQ9bi5tZC5zaGEzODQuY3JlYXRlKCk7YnJlYWs7Y2FzZVwic2hhNTEyV2l0aFJTQUVuY3J5cHRpb25cIjp1Lm1kPW4ubWQuc2hhNTEyLmNyZWF0ZSgpO2JyZWFrO2Nhc2VcIlJTQVNTQS1QU1NcIjp1Lm1kPW4ubWQuc2hhMjU2LmNyZWF0ZSgpfWlmKG51bGw9PT11Lm1kKXRocm93KGM9bmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gVW5rbm93biBzaWduYXR1cmUgT0lELlwiKSkuc2lnbmF0dXJlT2lkPXUuc2lnbmF0dXJlT2lkLGM7dmFyIGw9aS50b0Rlcih1LmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7dS5tZC51cGRhdGUobC5nZXRCeXRlcygpKX12YXIgZj1uLm1kLnNoYTEuY3JlYXRlKCk7cmV0dXJuIHUuc3ViamVjdC5nZXRGaWVsZD1mdW5jdGlvbihlKXtyZXR1cm4gcCh1LnN1YmplY3QsZSl9LHUuc3ViamVjdC5hZGRGaWVsZD1mdW5jdGlvbihlKXtnKFtlXSksdS5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChlKX0sdS5zdWJqZWN0LmF0dHJpYnV0ZXM9YS5SRE5BdHRyaWJ1dGVzQXNBcnJheShyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1N1YmplY3QsZiksdS5zdWJqZWN0Lmhhc2g9Zi5kaWdlc3QoKS50b0hleCgpLHUucHVibGljS2V5PWEucHVibGljS2V5RnJvbUFzbjEoci5zdWJqZWN0UHVibGljS2V5SW5mbyksdS5nZXRBdHRyaWJ1dGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHAodSxlKX0sdS5hZGRBdHRyaWJ1dGU9ZnVuY3Rpb24oZSl7ZyhbZV0pLHUuYXR0cmlidXRlcy5wdXNoKGUpfSx1LmF0dHJpYnV0ZXM9YS5DUklBdHRyaWJ1dGVzQXNBcnJheShyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb0F0dHJpYnV0ZXN8fFtdKSx1fSxhLmNyZWF0ZUNlcnRpZmljYXRpb25SZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIGU9e3ZlcnNpb246MCxzaWduYXR1cmVPaWQ6bnVsbCxzaWduYXR1cmU6bnVsbCxzaWdpbmZvOnt9fTtyZXR1cm4gZS5zaWdpbmZvLmFsZ29yaXRobU9pZD1udWxsLGUuc3ViamVjdD17fSxlLnN1YmplY3QuZ2V0RmllbGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHAoZS5zdWJqZWN0LHQpfSxlLnN1YmplY3QuYWRkRmllbGQ9ZnVuY3Rpb24odCl7ZyhbdF0pLGUuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2godCl9LGUuc3ViamVjdC5hdHRyaWJ1dGVzPVtdLGUuc3ViamVjdC5oYXNoPW51bGwsZS5wdWJsaWNLZXk9bnVsbCxlLmF0dHJpYnV0ZXM9W10sZS5nZXRBdHRyaWJ1dGU9ZnVuY3Rpb24odCl7cmV0dXJuIHAoZSx0KX0sZS5hZGRBdHRyaWJ1dGU9ZnVuY3Rpb24odCl7ZyhbdF0pLGUuYXR0cmlidXRlcy5wdXNoKHQpfSxlLm1kPW51bGwsZS5zZXRTdWJqZWN0PWZ1bmN0aW9uKHQpe2codCksZS5zdWJqZWN0LmF0dHJpYnV0ZXM9dCxlLnN1YmplY3QuaGFzaD1udWxsfSxlLnNldEF0dHJpYnV0ZXM9ZnVuY3Rpb24odCl7Zyh0KSxlLmF0dHJpYnV0ZXM9dH0sZS5zaWduPWZ1bmN0aW9uKHQscil7ZS5tZD1yfHxuLm1kLnNoYTEuY3JlYXRlKCk7dmFyIG89c1tlLm1kLmFsZ29yaXRobStcIldpdGhSU0FFbmNyeXB0aW9uXCJdO2lmKCFvKXt2YXIgdT1uZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZGlnZXN0LiBVbmtub3duIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSBPSUQuXCIpO3Rocm93IHUuYWxnb3JpdGhtPWUubWQuYWxnb3JpdGhtLHV9ZS5zaWduYXR1cmVPaWQ9ZS5zaWdpbmZvLmFsZ29yaXRobU9pZD1vLGUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvPWEuZ2V0Q2VydGlmaWNhdGlvblJlcXVlc3RJbmZvKGUpO3ZhciBjPWkudG9EZXIoZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8pO2UubWQudXBkYXRlKGMuZ2V0Qnl0ZXMoKSksZS5zaWduYXR1cmU9dC5zaWduKGUubWQpfSxlLnZlcmlmeT1mdW5jdGlvbigpe3ZhciB0PSExLHI9ZS5tZDtpZihudWxsPT09cil7aWYoZS5zaWduYXR1cmVPaWQgaW4gcylzd2l0Y2goc1tlLnNpZ25hdHVyZU9pZF0pe2Nhc2VcInNoYTFXaXRoUlNBRW5jcnlwdGlvblwiOnI9bi5tZC5zaGExLmNyZWF0ZSgpO2JyZWFrO2Nhc2VcIm1kNVdpdGhSU0FFbmNyeXB0aW9uXCI6cj1uLm1kLm1kNS5jcmVhdGUoKTticmVhaztjYXNlXCJzaGEyNTZXaXRoUlNBRW5jcnlwdGlvblwiOnI9bi5tZC5zaGEyNTYuY3JlYXRlKCk7YnJlYWs7Y2FzZVwic2hhMzg0V2l0aFJTQUVuY3J5cHRpb25cIjpyPW4ubWQuc2hhMzg0LmNyZWF0ZSgpO2JyZWFrO2Nhc2VcInNoYTUxMldpdGhSU0FFbmNyeXB0aW9uXCI6cj1uLm1kLnNoYTUxMi5jcmVhdGUoKTticmVhaztjYXNlXCJSU0FTU0EtUFNTXCI6cj1uLm1kLnNoYTI1Ni5jcmVhdGUoKX1pZihudWxsPT09cil0aHJvdyhoPW5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuIFVua25vd24gc2lnbmF0dXJlIE9JRC5cIikpLnNpZ25hdHVyZU9pZD1lLnNpZ25hdHVyZU9pZCxoO3ZhciBvPWUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvfHxhLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhlKSx1PWkudG9EZXIobyk7ci51cGRhdGUodS5nZXRCeXRlcygpKX1pZihudWxsIT09cil7dmFyIGM7c3dpdGNoKGUuc2lnbmF0dXJlT2lkKXtjYXNlIHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOmJyZWFrO2Nhc2Ugc1tcIlJTQVNTQS1QU1NcIl06dmFyIGwsZixoO2lmKHZvaWQgMD09PShsPXNbZS5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5oYXNoLmFsZ29yaXRobU9pZF0pfHx2b2lkIDA9PT1uLm1kW2xdKXRocm93KGg9bmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgTUdGIGhhc2ggZnVuY3Rpb24uXCIpKS5vaWQ9ZS5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5oYXNoLmFsZ29yaXRobU9pZCxoLm5hbWU9bCxoO2lmKHZvaWQgMD09PShmPXNbZS5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWRdKXx8dm9pZCAwPT09bi5tZ2ZbZl0pdGhyb3coaD1uZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBNR0YgZnVuY3Rpb24uXCIpKS5vaWQ9ZS5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWQsaC5uYW1lPWYsaDtpZihmPW4ubWdmW2ZdLmNyZWF0ZShuLm1kW2xdLmNyZWF0ZSgpKSx2b2lkIDA9PT0obD1zW2Uuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZF0pfHx2b2lkIDA9PT1uLm1kW2xdKXRocm93KGg9bmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgUlNBU1NBLVBTUyBoYXNoIGZ1bmN0aW9uLlwiKSkub2lkPWUuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZCxoLm5hbWU9bCxoO2M9bi5wc3MuY3JlYXRlKG4ubWRbbF0uY3JlYXRlKCksZixlLnNpZ25hdHVyZVBhcmFtZXRlcnMuc2FsdExlbmd0aCl9dD1lLnB1YmxpY0tleS52ZXJpZnkoci5kaWdlc3QoKS5nZXRCeXRlcygpLGUuc2lnbmF0dXJlLGMpfXJldHVybiB0fSxlfTt2YXIgRT1uZXcgRGF0ZShcIjE5NTAtMDEtMDFUMDA6MDA6MDBaXCIpLFM9bmV3IERhdGUoXCIyMDUwLTAxLTAxVDAwOjAwOjAwWlwiKTtmdW5jdGlvbiBUKGUpe3JldHVybiBlPj1FJiZlPFM/aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlVUQ1RJTUUsITEsaS5kYXRlVG9VdGNUaW1lKGUpKTppLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuR0VORVJBTElaRURUSU1FLCExLGkuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGUpKX1hLmdldFRCU0NlcnRpZmljYXRlPWZ1bmN0aW9uKGUpe3ZhciB0PVQoZS52YWxpZGl0eS5ub3RCZWZvcmUpLHI9VChlLnZhbGlkaXR5Lm5vdEFmdGVyKSxzPWkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5JTlRFR0VSLCExLGkuaW50ZWdlclRvRGVyKGUudmVyc2lvbikuZ2V0Qnl0ZXMoKSldKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuSU5URUdFUiwhMSxuLnV0aWwuaGV4VG9CeXRlcyhlLnNlcmlhbE51bWJlcikpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKGUuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLHYoZS5zaWdpbmZvLmFsZ29yaXRobU9pZCxlLnNpZ2luZm8ucGFyYW1ldGVycyldKSx5KGUuaXNzdWVyKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW3Qscl0pLHkoZS5zdWJqZWN0KSxhLnB1YmxpY0tleVRvQXNuMShlLnB1YmxpY0tleSldKTtyZXR1cm4gZS5pc3N1ZXIudW5pcXVlSWQmJnMudmFsdWUucHVzaChpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLkJJVFNUUklORywhMSxTdHJpbmcuZnJvbUNoYXJDb2RlKDApK2UuaXNzdWVyLnVuaXF1ZUlkKV0pKSxlLnN1YmplY3QudW5pcXVlSWQmJnMudmFsdWUucHVzaChpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMiwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLkJJVFNUUklORywhMSxTdHJpbmcuZnJvbUNoYXJDb2RlKDApK2Uuc3ViamVjdC51bmlxdWVJZCldKSksZS5leHRlbnNpb25zLmxlbmd0aD4wJiZzLnZhbHVlLnB1c2goYS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoZS5leHRlbnNpb25zKSksc30sYS5nZXRDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm89ZnVuY3Rpb24oZSl7cmV0dXJuIGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLklOVEVHRVIsITEsaS5pbnRlZ2VyVG9EZXIoZS52ZXJzaW9uKS5nZXRCeXRlcygpKSx5KGUuc3ViamVjdCksYS5wdWJsaWNLZXlUb0FzbjEoZS5wdWJsaWNLZXkpLGIoZSldKX0sYS5kaXN0aW5ndWlzaGVkTmFtZVRvQXNuMT1mdW5jdGlvbihlKXtyZXR1cm4geShlKX0sYS5jZXJ0aWZpY2F0ZVRvQXNuMT1mdW5jdGlvbihlKXt2YXIgdD1lLnRic0NlcnRpZmljYXRlfHxhLmdldFRCU0NlcnRpZmljYXRlKGUpO3JldHVybiBpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW3QsaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoZS5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLHYoZS5zaWduYXR1cmVPaWQsZS5zaWduYXR1cmVQYXJhbWV0ZXJzKV0pLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5CSVRTVFJJTkcsITEsU3RyaW5nLmZyb21DaGFyQ29kZSgwKStlLnNpZ25hdHVyZSldKX0sYS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjE9ZnVuY3Rpb24oZSl7dmFyIHQ9aS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDMsITAsW10pLHI9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtdKTt0LnZhbHVlLnB1c2gocik7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pci52YWx1ZS5wdXNoKGEuY2VydGlmaWNhdGVFeHRlbnNpb25Ub0FzbjEoZVtuXSkpO3JldHVybiB0fSxhLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xPWZ1bmN0aW9uKGUpe3ZhciB0PWkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbXSk7dC52YWx1ZS5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihlLmlkKS5nZXRCeXRlcygpKSksZS5jcml0aWNhbCYmdC52YWx1ZS5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5CT09MRUFOLCExLFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1KSkpO3ZhciByPWUudmFsdWU7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGUudmFsdWUmJihyPWkudG9EZXIocikuZ2V0Qnl0ZXMoKSksdC52YWx1ZS5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PQ1RFVFNUUklORywhMSxyKSksdH0sYS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMT1mdW5jdGlvbihlKXt2YXIgdD1lLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb3x8YS5nZXRDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8oZSk7cmV0dXJuIGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbdCxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihlLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksdihlLnNpZ25hdHVyZU9pZCxlLnNpZ25hdHVyZVBhcmFtZXRlcnMpXSksaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLkJJVFNUUklORywhMSxTdHJpbmcuZnJvbUNoYXJDb2RlKDApK2Uuc2lnbmF0dXJlKV0pfSxhLmNyZWF0ZUNhU3RvcmU9ZnVuY3Rpb24oZSl7dmFyIHQ9e2NlcnRzOnt9fTtmdW5jdGlvbiByKGUpe3JldHVybiBzKGUpLHQuY2VydHNbZS5oYXNoXXx8bnVsbH1mdW5jdGlvbiBzKGUpe2lmKCFlLmhhc2gpe3ZhciB0PW4ubWQuc2hhMS5jcmVhdGUoKTtlLmF0dHJpYnV0ZXM9YS5SRE5BdHRyaWJ1dGVzQXNBcnJheSh5KGUpLHQpLGUuaGFzaD10LmRpZ2VzdCgpLnRvSGV4KCl9fWlmKHQuZ2V0SXNzdWVyPWZ1bmN0aW9uKGUpe3JldHVybiByKGUuaXNzdWVyKX0sdC5hZGRDZXJ0aWZpY2F0ZT1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bi5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGUpKSxzKGUuc3ViamVjdCksIXQuaGFzQ2VydGlmaWNhdGUoZSkpaWYoZS5zdWJqZWN0Lmhhc2ggaW4gdC5jZXJ0cyl7dmFyIHI9dC5jZXJ0c1tlLnN1YmplY3QuaGFzaF07bi51dGlsLmlzQXJyYXkocil8fChyPVtyXSksci5wdXNoKGUpLHQuY2VydHNbZS5zdWJqZWN0Lmhhc2hdPXJ9ZWxzZSB0LmNlcnRzW2Uuc3ViamVjdC5oYXNoXT1lfSx0Lmhhc0NlcnRpZmljYXRlPWZ1bmN0aW9uKGUpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1uLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oZSkpO3ZhciB0PXIoZS5zdWJqZWN0KTtpZighdClyZXR1cm4hMTtuLnV0aWwuaXNBcnJheSh0KXx8KHQ9W3RdKTtmb3IodmFyIHM9aS50b0RlcihhLmNlcnRpZmljYXRlVG9Bc24xKGUpKS5nZXRCeXRlcygpLG89MDtvPHQubGVuZ3RoOysrbyl7aWYocz09PWkudG9EZXIoYS5jZXJ0aWZpY2F0ZVRvQXNuMSh0W29dKSkuZ2V0Qnl0ZXMoKSlyZXR1cm4hMH1yZXR1cm4hMX0sdC5saXN0QWxsQ2VydGlmaWNhdGVzPWZ1bmN0aW9uKCl7dmFyIGU9W107Zm9yKHZhciByIGluIHQuY2VydHMpaWYodC5jZXJ0cy5oYXNPd25Qcm9wZXJ0eShyKSl7dmFyIGk9dC5jZXJ0c1tyXTtpZihuLnV0aWwuaXNBcnJheShpKSlmb3IodmFyIGE9MDthPGkubGVuZ3RoOysrYSllLnB1c2goaVthXSk7ZWxzZSBlLnB1c2goaSl9cmV0dXJuIGV9LHQucmVtb3ZlQ2VydGlmaWNhdGU9ZnVuY3Rpb24oZSl7dmFyIG87aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPW4ucGtpLmNlcnRpZmljYXRlRnJvbVBlbShlKSkscyhlLnN1YmplY3QpLCF0Lmhhc0NlcnRpZmljYXRlKGUpKXJldHVybiBudWxsO3ZhciB1PXIoZS5zdWJqZWN0KTtpZighbi51dGlsLmlzQXJyYXkodSkpcmV0dXJuIG89dC5jZXJ0c1tlLnN1YmplY3QuaGFzaF0sZGVsZXRlIHQuY2VydHNbZS5zdWJqZWN0Lmhhc2hdLG87Zm9yKHZhciBjPWkudG9EZXIoYS5jZXJ0aWZpY2F0ZVRvQXNuMShlKSkuZ2V0Qnl0ZXMoKSxsPTA7bDx1Lmxlbmd0aDsrK2wpe2M9PT1pLnRvRGVyKGEuY2VydGlmaWNhdGVUb0FzbjEodVtsXSkpLmdldEJ5dGVzKCkmJihvPXVbbF0sdS5zcGxpY2UobCwxKSl9cmV0dXJuIDA9PT11Lmxlbmd0aCYmZGVsZXRlIHQuY2VydHNbZS5zdWJqZWN0Lmhhc2hdLG99LGUpZm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe3ZhciB1PWVbb107dC5hZGRDZXJ0aWZpY2F0ZSh1KX1yZXR1cm4gdH0sYS5jZXJ0aWZpY2F0ZUVycm9yPXtiYWRfY2VydGlmaWNhdGU6XCJmb3JnZS5wa2kuQmFkQ2VydGlmaWNhdGVcIix1bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZTpcImZvcmdlLnBraS5VbnN1cHBvcnRlZENlcnRpZmljYXRlXCIsY2VydGlmaWNhdGVfcmV2b2tlZDpcImZvcmdlLnBraS5DZXJ0aWZpY2F0ZVJldm9rZWRcIixjZXJ0aWZpY2F0ZV9leHBpcmVkOlwiZm9yZ2UucGtpLkNlcnRpZmljYXRlRXhwaXJlZFwiLGNlcnRpZmljYXRlX3Vua25vd246XCJmb3JnZS5wa2kuQ2VydGlmaWNhdGVVbmtub3duXCIsdW5rbm93bl9jYTpcImZvcmdlLnBraS5Vbmtub3duQ2VydGlmaWNhdGVBdXRob3JpdHlcIn0sYS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluPWZ1bmN0aW9uKGUsdCxyKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiYocj17dmVyaWZ5OnJ9KSxyPXJ8fHt9O3ZhciBpPSh0PXQuc2xpY2UoMCkpLnNsaWNlKDApLHM9ci52YWxpZGl0eUNoZWNrRGF0ZTt2b2lkIDA9PT1zJiYocz1uZXcgRGF0ZSk7dmFyIG89ITAsdT1udWxsLGM9MDtkb3t2YXIgbD10LnNoaWZ0KCksZj1udWxsLGg9ITE7aWYocyYmKHM8bC52YWxpZGl0eS5ub3RCZWZvcmV8fHM+bC52YWxpZGl0eS5ub3RBZnRlcikmJih1PXttZXNzYWdlOlwiQ2VydGlmaWNhdGUgaXMgbm90IHZhbGlkIHlldCBvciBoYXMgZXhwaXJlZC5cIixlcnJvcjphLmNlcnRpZmljYXRlRXJyb3IuY2VydGlmaWNhdGVfZXhwaXJlZCxub3RCZWZvcmU6bC52YWxpZGl0eS5ub3RCZWZvcmUsbm90QWZ0ZXI6bC52YWxpZGl0eS5ub3RBZnRlcixub3c6c30pLG51bGw9PT11KXtpZihudWxsPT09KGY9dFswXXx8ZS5nZXRJc3N1ZXIobCkpJiZsLmlzSXNzdWVyKGwpJiYoaD0hMCxmPWwpLGYpe3ZhciBwPWY7bi51dGlsLmlzQXJyYXkocCl8fChwPVtwXSk7Zm9yKHZhciBkPSExOyFkJiZwLmxlbmd0aD4wOyl7Zj1wLnNoaWZ0KCk7dHJ5e2Q9Zi52ZXJpZnkobCl9Y2F0Y2goZSl7fX1kfHwodT17bWVzc2FnZTpcIkNlcnRpZmljYXRlIHNpZ25hdHVyZSBpcyBpbnZhbGlkLlwiLGVycm9yOmEuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGV9KX1udWxsIT09dXx8ZiYmIWh8fGUuaGFzQ2VydGlmaWNhdGUobCl8fCh1PXttZXNzYWdlOlwiQ2VydGlmaWNhdGUgaXMgbm90IHRydXN0ZWQuXCIsZXJyb3I6YS5jZXJ0aWZpY2F0ZUVycm9yLnVua25vd25fY2F9KX1pZihudWxsPT09dSYmZiYmIWwuaXNJc3N1ZXIoZikmJih1PXttZXNzYWdlOlwiQ2VydGlmaWNhdGUgaXNzdWVyIGlzIGludmFsaWQuXCIsZXJyb3I6YS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZX0pLG51bGw9PT11KWZvcih2YXIgeT17a2V5VXNhZ2U6ITAsYmFzaWNDb25zdHJhaW50czohMH0sZz0wO251bGw9PT11JiZnPGwuZXh0ZW5zaW9ucy5sZW5ndGg7KytnKXt2YXIgbT1sLmV4dGVuc2lvbnNbZ107IW0uY3JpdGljYWx8fG0ubmFtZSBpbiB5fHwodT17bWVzc2FnZTpcIkNlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24uXCIsZXJyb3I6YS5jZXJ0aWZpY2F0ZUVycm9yLnVuc3VwcG9ydGVkX2NlcnRpZmljYXRlfSl9aWYobnVsbD09PXUmJighb3x8MD09PXQubGVuZ3RoJiYoIWZ8fGgpKSl7dmFyIHY9bC5nZXRFeHRlbnNpb24oXCJiYXNpY0NvbnN0cmFpbnRzXCIpLGI9bC5nZXRFeHRlbnNpb24oXCJrZXlVc2FnZVwiKTtpZihudWxsIT09YiYmKGIua2V5Q2VydFNpZ24mJm51bGwhPT12fHwodT17bWVzc2FnZTpcIkNlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3Qgb3IgaW5kaWNhdGUgdGhhdCB0aGUgY2VydGlmaWNhdGUgaXMgbm90IGEgQ0EuIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0aGUgb25seSBvbmUgaW4gdGhlIGNoYWluIG9yIGlzbid0IHRoZSBmaXJzdCB0aGVuIHRoZSBjZXJ0aWZpY2F0ZSBtdXN0IGJlIGEgdmFsaWQgQ0EuXCIsZXJyb3I6YS5jZXJ0aWZpY2F0ZUVycm9yLmJhZF9jZXJ0aWZpY2F0ZX0pKSxudWxsIT09dXx8bnVsbD09PXZ8fHYuY0F8fCh1PXttZXNzYWdlOlwiQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBpbmRpY2F0ZXMgdGhlIGNlcnRpZmljYXRlIGlzIG5vdCBhIENBLlwiLGVycm9yOmEuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGV9KSxudWxsPT09dSYmbnVsbCE9PWImJlwicGF0aExlbkNvbnN0cmFpbnRcImluIHYpYy0xPnYucGF0aExlbkNvbnN0cmFpbnQmJih1PXttZXNzYWdlOlwiQ2VydGlmaWNhdGUgYmFzaWNDb25zdHJhaW50cyBwYXRoTGVuQ29uc3RyYWludCB2aW9sYXRlZC5cIixlcnJvcjphLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlfSl9dmFyIEU9bnVsbD09PXV8fHUuZXJyb3IsUz1yLnZlcmlmeT9yLnZlcmlmeShFLGMsaSk6RTtpZighMCE9PVMpdGhyb3chMD09PUUmJih1PXttZXNzYWdlOlwiVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS5cIixlcnJvcjphLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlfSksKFN8fDA9PT1TKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBTfHxuLnV0aWwuaXNBcnJheShTKT9cInN0cmluZ1wiPT10eXBlb2YgUyYmKHUuZXJyb3I9Uyk6KFMubWVzc2FnZSYmKHUubWVzc2FnZT1TLm1lc3NhZ2UpLFMuZXJyb3ImJih1LmVycm9yPVMuZXJyb3IpKSksdTt1PW51bGwsbz0hMSwrK2N9d2hpbGUodC5sZW5ndGg+MCk7cmV0dXJuITB9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDEyKSxyKDIpLChlLmV4cG9ydHM9bi5wc3M9bi5wc3N8fHt9KS5jcmVhdGU9ZnVuY3Rpb24oZSl7Mz09PWFyZ3VtZW50cy5sZW5ndGgmJihlPXttZDphcmd1bWVudHNbMF0sbWdmOmFyZ3VtZW50c1sxXSxzYWx0TGVuZ3RoOmFyZ3VtZW50c1syXX0pO3ZhciB0LHI9ZS5tZCxpPWUubWdmLGE9ci5kaWdlc3RMZW5ndGgscz1lLnNhbHR8fG51bGw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHMmJihzPW4udXRpbC5jcmVhdGVCdWZmZXIocykpLFwic2FsdExlbmd0aFwiaW4gZSl0PWUuc2FsdExlbmd0aDtlbHNle2lmKG51bGw9PT1zKXRocm93IG5ldyBFcnJvcihcIlNhbHQgbGVuZ3RoIG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWMgc2FsdCBub3QgZ2l2ZW4uXCIpO3Q9cy5sZW5ndGgoKX1pZihudWxsIT09cyYmcy5sZW5ndGgoKSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiR2l2ZW4gc2FsdCBsZW5ndGggZG9lcyBub3QgbWF0Y2ggbGVuZ3RoIG9mIGdpdmVuIHNhbHQuXCIpO3ZhciBvPWUucHJuZ3x8bi5yYW5kb20sdT17ZW5jb2RlOmZ1bmN0aW9uKGUsdSl7dmFyIGMsbCxmPXUtMSxoPU1hdGguY2VpbChmLzgpLHA9ZS5kaWdlc3QoKS5nZXRCeXRlcygpO2lmKGg8YSt0KzIpdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBpcyB0b28gbG9uZyB0byBlbmNyeXB0LlwiKTtsPW51bGw9PT1zP28uZ2V0Qnl0ZXNTeW5jKHQpOnMuYnl0ZXMoKTt2YXIgZD1uZXcgbi51dGlsLkJ5dGVCdWZmZXI7ZC5maWxsV2l0aEJ5dGUoMCw4KSxkLnB1dEJ5dGVzKHApLGQucHV0Qnl0ZXMobCksci5zdGFydCgpLHIudXBkYXRlKGQuZ2V0Qnl0ZXMoKSk7dmFyIHk9ci5kaWdlc3QoKS5nZXRCeXRlcygpLGc9bmV3IG4udXRpbC5CeXRlQnVmZmVyO2cuZmlsbFdpdGhCeXRlKDAsaC10LWEtMiksZy5wdXRCeXRlKDEpLGcucHV0Qnl0ZXMobCk7dmFyIG09Zy5nZXRCeXRlcygpLHY9aC1hLTEsYj1pLmdlbmVyYXRlKHksdiksRT1cIlwiO2ZvcihjPTA7Yzx2O2MrKylFKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG0uY2hhckNvZGVBdChjKV5iLmNoYXJDb2RlQXQoYykpO3ZhciBTPTY1MjgwPj44KmgtZiYyNTU7cmV0dXJuKEU9U3RyaW5nLmZyb21DaGFyQ29kZShFLmNoYXJDb2RlQXQoMCkmflMpK0Uuc3Vic3RyKDEpKSt5K1N0cmluZy5mcm9tQ2hhckNvZGUoMTg4KX0sdmVyaWZ5OmZ1bmN0aW9uKGUscyxvKXt2YXIgdSxjPW8tMSxsPU1hdGguY2VpbChjLzgpO2lmKHM9cy5zdWJzdHIoLWwpLGw8YSt0KzIpdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IHBhcmFtZXRlcnMgdG8gUFNTIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24uXCIpO2lmKDE4OCE9PXMuY2hhckNvZGVBdChsLTEpKXRocm93IG5ldyBFcnJvcihcIkVuY29kZWQgbWVzc2FnZSBkb2VzIG5vdCBlbmQgaW4gMHhCQy5cIik7dmFyIGY9bC1hLTEsaD1zLnN1YnN0cigwLGYpLHA9cy5zdWJzdHIoZixhKSxkPTY1MjgwPj44KmwtYyYyNTU7aWYoMCE9KGguY2hhckNvZGVBdCgwKSZkKSl0aHJvdyBuZXcgRXJyb3IoXCJCaXRzIGJleW9uZCBrZXlzaXplIG5vdCB6ZXJvIGFzIGV4cGVjdGVkLlwiKTt2YXIgeT1pLmdlbmVyYXRlKHAsZiksZz1cIlwiO2Zvcih1PTA7dTxmO3UrKylnKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGguY2hhckNvZGVBdCh1KV55LmNoYXJDb2RlQXQodSkpO2c9U3RyaW5nLmZyb21DaGFyQ29kZShnLmNoYXJDb2RlQXQoMCkmfmQpK2cuc3Vic3RyKDEpO3ZhciBtPWwtYS10LTI7Zm9yKHU9MDt1PG07dSsrKWlmKDAhPT1nLmNoYXJDb2RlQXQodSkpdGhyb3cgbmV3IEVycm9yKFwiTGVmdG1vc3Qgb2N0ZXRzIG5vdCB6ZXJvIGFzIGV4cGVjdGVkXCIpO2lmKDEhPT1nLmNoYXJDb2RlQXQobSkpdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IFBTUyBzaWduYXR1cmUsIDB4MDEgbWFya2VyIG5vdCBmb3VuZFwiKTt2YXIgdj1nLnN1YnN0cigtdCksYj1uZXcgbi51dGlsLkJ5dGVCdWZmZXI7cmV0dXJuIGIuZmlsbFdpdGhCeXRlKDAsOCksYi5wdXRCeXRlcyhlKSxiLnB1dEJ5dGVzKHYpLHIuc3RhcnQoKSxyLnVwZGF0ZShiLmdldEJ5dGVzKCkpLHA9PT1yLmRpZ2VzdCgpLmdldEJ5dGVzKCl9fTtyZXR1cm4gdX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoOSkscigyKTt2YXIgaT1lLmV4cG9ydHM9bi5tZDU9bi5tZDV8fHt9O24ubWQubWQ1PW4ubWQuYWxnb3JpdGhtcy5tZDU9aSxpLmNyZWF0ZT1mdW5jdGlvbigpe2N8fGZ1bmN0aW9uKCl7YT1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCksYSs9bi51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgwKSw2NCkscz1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxLDYsMTEsMCw1LDEwLDE1LDQsOSwxNCwzLDgsMTMsMiw3LDEyLDUsOCwxMSwxNCwxLDQsNywxMCwxMywwLDMsNiw5LDEyLDE1LDIsMCw3LDE0LDUsMTIsMywxMCwxLDgsMTUsNiwxMyw0LDExLDIsOV0sbz1bNywxMiwxNywyMiw3LDEyLDE3LDIyLDcsMTIsMTcsMjIsNywxMiwxNywyMiw1LDksMTQsMjAsNSw5LDE0LDIwLDUsOSwxNCwyMCw1LDksMTQsMjAsNCwxMSwxNiwyMyw0LDExLDE2LDIzLDQsMTEsMTYsMjMsNCwxMSwxNiwyMyw2LDEwLDE1LDIxLDYsMTAsMTUsMjEsNiwxMCwxNSwyMSw2LDEwLDE1LDIxXSx1PW5ldyBBcnJheSg2NCk7Zm9yKHZhciBlPTA7ZTw2NDsrK2UpdVtlXT1NYXRoLmZsb29yKDQyOTQ5NjcyOTYqTWF0aC5hYnMoTWF0aC5zaW4oZSsxKSkpO2M9ITB9KCk7dmFyIGU9bnVsbCx0PW4udXRpbC5jcmVhdGVCdWZmZXIoKSxyPW5ldyBBcnJheSgxNiksaT17YWxnb3JpdGhtOlwibWQ1XCIsYmxvY2tMZW5ndGg6NjQsZGlnZXN0TGVuZ3RoOjE2LG1lc3NhZ2VMZW5ndGg6MCxmdWxsTWVzc2FnZUxlbmd0aDpudWxsLG1lc3NhZ2VMZW5ndGhTaXplOjgsc3RhcnQ6ZnVuY3Rpb24oKXtpLm1lc3NhZ2VMZW5ndGg9MCxpLmZ1bGxNZXNzYWdlTGVuZ3RoPWkubWVzc2FnZUxlbmd0aDY0PVtdO2Zvcih2YXIgcj1pLm1lc3NhZ2VMZW5ndGhTaXplLzQsYT0wO2E8cjsrK2EpaS5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO3JldHVybiB0PW4udXRpbC5jcmVhdGVCdWZmZXIoKSxlPXtoMDoxNzMyNTg0MTkzLGgxOjQwMjMyMzM0MTcsaDI6MjU2MjM4MzEwMixoMzoyNzE3MzM4Nzh9LGl9fTtyZXR1cm4gaS5zdGFydCgpLGkudXBkYXRlPWZ1bmN0aW9uKGEscyl7XCJ1dGY4XCI9PT1zJiYoYT1uLnV0aWwuZW5jb2RlVXRmOChhKSk7dmFyIG89YS5sZW5ndGg7aS5tZXNzYWdlTGVuZ3RoKz1vLG89W28vNDI5NDk2NzI5Nj4+PjAsbz4+PjBdO2Zvcih2YXIgdT1pLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aC0xO3U+PTA7LS11KWkuZnVsbE1lc3NhZ2VMZW5ndGhbdV0rPW9bMV0sb1sxXT1vWzBdKyhpLmZ1bGxNZXNzYWdlTGVuZ3RoW3VdLzQyOTQ5NjcyOTY+Pj4wKSxpLmZ1bGxNZXNzYWdlTGVuZ3RoW3VdPWkuZnVsbE1lc3NhZ2VMZW5ndGhbdV0+Pj4wLG9bMF09b1sxXS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gdC5wdXRCeXRlcyhhKSxsKGUscix0KSwodC5yZWFkPjIwNDh8fDA9PT10Lmxlbmd0aCgpKSYmdC5jb21wYWN0KCksaX0saS5kaWdlc3Q9ZnVuY3Rpb24oKXt2YXIgcz1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7cy5wdXRCeXRlcyh0LmJ5dGVzKCkpO3ZhciBvPWkuZnVsbE1lc3NhZ2VMZW5ndGhbaS5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGgtMV0raS5tZXNzYWdlTGVuZ3RoU2l6ZSZpLmJsb2NrTGVuZ3RoLTE7cy5wdXRCeXRlcyhhLnN1YnN0cigwLGkuYmxvY2tMZW5ndGgtbykpO2Zvcih2YXIgdSxjPTAsZj1pLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aC0xO2Y+PTA7LS1mKWM9KHU9OCppLmZ1bGxNZXNzYWdlTGVuZ3RoW2ZdK2MpLzQyOTQ5NjcyOTY+Pj4wLHMucHV0SW50MzJMZSh1Pj4+MCk7dmFyIGg9e2gwOmUuaDAsaDE6ZS5oMSxoMjplLmgyLGgzOmUuaDN9O2woaCxyLHMpO3ZhciBwPW4udXRpbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gcC5wdXRJbnQzMkxlKGguaDApLHAucHV0SW50MzJMZShoLmgxKSxwLnB1dEludDMyTGUoaC5oMikscC5wdXRJbnQzMkxlKGguaDMpLHB9LGl9O3ZhciBhPW51bGwscz1udWxsLG89bnVsbCx1PW51bGwsYz0hMTtmdW5jdGlvbiBsKGUsdCxyKXtmb3IodmFyIG4saSxhLGMsbCxmLGgscD1yLmxlbmd0aCgpO3A+PTY0Oyl7Zm9yKGk9ZS5oMCxhPWUuaDEsYz1lLmgyLGw9ZS5oMyxoPTA7aDwxNjsrK2gpdFtoXT1yLmdldEludDMyTGUoKSxuPWkrKGxeYSYoY15sKSkrdVtoXSt0W2hdLGk9bCxsPWMsYz1hLGErPW48PChmPW9baF0pfG4+Pj4zMi1mO2Zvcig7aDwzMjsrK2gpbj1pKyhjXmwmKGFeYykpK3VbaF0rdFtzW2hdXSxpPWwsbD1jLGM9YSxhKz1uPDwoZj1vW2hdKXxuPj4+MzItZjtmb3IoO2g8NDg7KytoKW49aSsoYV5jXmwpK3VbaF0rdFtzW2hdXSxpPWwsbD1jLGM9YSxhKz1uPDwoZj1vW2hdKXxuPj4+MzItZjtmb3IoO2g8NjQ7KytoKW49aSsoY14oYXx+bCkpK3VbaF0rdFtzW2hdXSxpPWwsbD1jLGM9YSxhKz1uPDwoZj1vW2hdKXxuPj4+MzItZjtlLmgwPWUuaDAraXwwLGUuaDE9ZS5oMSthfDAsZS5oMj1lLmgyK2N8MCxlLmgzPWUuaDMrbHwwLHAtPTY0fX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPVwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiLGk9bi5zcGxpdChcIlwiKS5yZWR1Y2UoKGUsdCxyKT0+KGVbdF09cixlKSx7fSk7dC5kZWZhdWx0PXtlbmNvZGUoZSl7aWYoIWUubGVuZ3RoKXJldHVyblwiXCI7Y29uc3QgdD1bMF07Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV08PD04O3RbMF0rPWVbcl07bGV0IG49MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdKz1uLG49dFtlXS81OHwwLHRbZV0lPTU4O2Zvcig7bjspdC5wdXNoKG4lNTgpLG49bi81OHwwfWZvcihsZXQgcj0wOzA9PT1lW3JdJiZyPGUubGVuZ3RoLTE7cisrKXQucHVzaCgwKTtyZXR1cm4gdC5yZXZlcnNlKCkubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbltlXX0pKS5qb2luKFwiXCIpfSxkZWNvZGUoZSl7aWYoIWUubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSgwKTtjb25zdCB0PVswXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbj1lW3JdO2lmKCEobiBpbiBpKSl0aHJvdyBuZXcgRXJyb3IoYFRoZXJlIGlzIG5vIGNoYXJhY3RlciBcIiR7bn1cIiBpbiB0aGUgQmFzZTU4IHNlcXVlbmNlIWApO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0qPTU4O3RbMF0rPWlbbl07bGV0IGE9MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdKz1hLGE9dFtlXT4+OCx0W2VdJj0yNTU7Zm9yKDthOyl0LnB1c2goMjU1JmEpLGE+Pj04fWZvcihsZXQgcj0wO1wiMVwiPT09ZVtyXSYmcjxlLmxlbmd0aC0xO3IrKyl0LnB1c2goMCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHQucmV2ZXJzZSgpKX19fSxmdW5jdGlvbihlLHQscil7IWZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3ZhciB0PS9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLHI9TWF0aC5jZWlsLG49TWF0aC5mbG9vcixpPVwiW0JpZ051bWJlciBFcnJvcl0gXCIsYT1pK1wiTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogXCIscz0xZTE0LG89MTQsdT05MDA3MTk5MjU0NzQwOTkxLGM9WzEsMTAsMTAwLDFlMywxZTQsMWU1LDFlNiwxZTcsMWU4LDFlOSwxZTEwLDFlMTEsMWUxMiwxZTEzXSxsPTFlNyxmPTFlOTtmdW5jdGlvbiBoKGUpe3ZhciB0PTB8ZTtyZXR1cm4gZT4wfHxlPT09dD90OnQtMX1mdW5jdGlvbiBwKGUpe2Zvcih2YXIgdCxyLG49MSxpPWUubGVuZ3RoLGE9ZVswXStcIlwiO248aTspe2Zvcih0PWVbbisrXStcIlwiLHI9by10Lmxlbmd0aDtyLS07dD1cIjBcIit0KTthKz10fWZvcihpPWEubGVuZ3RoOzQ4PT09YS5jaGFyQ29kZUF0KC0taSk7KTtyZXR1cm4gYS5zbGljZSgwLGkrMXx8MSl9ZnVuY3Rpb24gZChlLHQpe3ZhciByLG4saT1lLmMsYT10LmMscz1lLnMsbz10LnMsdT1lLmUsYz10LmU7aWYoIXN8fCFvKXJldHVybiBudWxsO2lmKHI9aSYmIWlbMF0sbj1hJiYhYVswXSxyfHxuKXJldHVybiByP24/MDotbzpzO2lmKHMhPW8pcmV0dXJuIHM7aWYocj1zPDAsbj11PT1jLCFpfHwhYSlyZXR1cm4gbj8wOiFpXnI/MTotMTtpZighbilyZXR1cm4gdT5jXnI/MTotMTtmb3Iobz0odT1pLmxlbmd0aCk8KGM9YS5sZW5ndGgpP3U6YyxzPTA7czxvO3MrKylpZihpW3NdIT1hW3NdKXJldHVybiBpW3NdPmFbc11ecj8xOi0xO3JldHVybiB1PT1jPzA6dT5jXnI/MTotMX1mdW5jdGlvbiB5KGUsdCxyLGEpe2lmKGU8dHx8ZT5yfHxlIT09bihlKSl0aHJvdyBFcnJvcihpKyhhfHxcIkFyZ3VtZW50XCIpKyhcIm51bWJlclwiPT10eXBlb2YgZT9lPHR8fGU+cj9cIiBvdXQgb2YgcmFuZ2U6IFwiOlwiIG5vdCBhbiBpbnRlZ2VyOiBcIjpcIiBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiBcIikrU3RyaW5nKGUpKX1mdW5jdGlvbiBnKGUpe3ZhciB0PWUuYy5sZW5ndGgtMTtyZXR1cm4gaChlLmUvbyk9PXQmJmUuY1t0XSUyIT0wfWZ1bmN0aW9uIG0oZSx0KXtyZXR1cm4oZS5sZW5ndGg+MT9lLmNoYXJBdCgwKStcIi5cIitlLnNsaWNlKDEpOmUpKyh0PDA/XCJlXCI6XCJlK1wiKSt0fWZ1bmN0aW9uIHYoZSx0LHIpe3ZhciBuLGk7aWYodDwwKXtmb3IoaT1yK1wiLlwiOysrdDtpKz1yKTtlPWkrZX1lbHNlIGlmKCsrdD4obj1lLmxlbmd0aCkpe2ZvcihpPXIsdC09bjstLXQ7aSs9cik7ZSs9aX1lbHNlIHQ8biYmKGU9ZS5zbGljZSgwLHQpK1wiLlwiK2Uuc2xpY2UodCkpO3JldHVybiBlfXZhciBiPWZ1bmN0aW9uIGUoYil7dmFyIEUsUyxULEMsQSxJLHcsQixOLFI9Ri5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOkYsdG9TdHJpbmc6bnVsbCx2YWx1ZU9mOm51bGx9LF89bmV3IEYoMSksUD0yMCxPPTQsaz0tNyxVPTIxLEw9LTFlNyxEPTFlNyxWPSExLHg9MSxLPTAsTT17cHJlZml4OlwiXCIsZ3JvdXBTaXplOjMsc2Vjb25kYXJ5R3JvdXBTaXplOjAsZ3JvdXBTZXBhcmF0b3I6XCIsXCIsZGVjaW1hbFNlcGFyYXRvcjpcIi5cIixmcmFjdGlvbkdyb3VwU2l6ZTowLGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6XCLCoFwiLHN1ZmZpeDpcIlwifSxqPVwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7ZnVuY3Rpb24gRihlLHIpe3ZhciBpLHMsYyxsLGYsaCxwLGQsZz10aGlzO2lmKCEoZyBpbnN0YW5jZW9mIEYpKXJldHVybiBuZXcgRihlLHIpO2lmKG51bGw9PXIpe2lmKGUmJiEwPT09ZS5faXNCaWdOdW1iZXIpcmV0dXJuIGcucz1lLnMsdm9pZCghZS5jfHxlLmU+RD9nLmM9Zy5lPW51bGw6ZS5lPEw/Zy5jPVtnLmU9MF06KGcuZT1lLmUsZy5jPWUuYy5zbGljZSgpKSk7aWYoKGg9XCJudW1iZXJcIj09dHlwZW9mIGUpJiYwKmU9PTApe2lmKGcucz0xL2U8MD8oZT0tZSwtMSk6MSxlPT09fn5lKXtmb3IobD0wLGY9ZTtmPj0xMDtmLz0xMCxsKyspO3JldHVybiB2b2lkKGw+RD9nLmM9Zy5lPW51bGw6KGcuZT1sLGcuYz1bZV0pKX1kPVN0cmluZyhlKX1lbHNle2lmKCF0LnRlc3QoZD1TdHJpbmcoZSkpKXJldHVybiBUKGcsZCxoKTtnLnM9NDU9PWQuY2hhckNvZGVBdCgwKT8oZD1kLnNsaWNlKDEpLC0xKToxfShsPWQuaW5kZXhPZihcIi5cIikpPi0xJiYoZD1kLnJlcGxhY2UoXCIuXCIsXCJcIikpLChmPWQuc2VhcmNoKC9lL2kpKT4wPyhsPDAmJihsPWYpLGwrPStkLnNsaWNlKGYrMSksZD1kLnN1YnN0cmluZygwLGYpKTpsPDAmJihsPWQubGVuZ3RoKX1lbHNle2lmKHkociwyLGoubGVuZ3RoLFwiQmFzZVwiKSwxMD09cilyZXR1cm4gSChnPW5ldyBGKGUpLFArZy5lKzEsTyk7aWYoZD1TdHJpbmcoZSksaD1cIm51bWJlclwiPT10eXBlb2YgZSl7aWYoMCplIT0wKXJldHVybiBUKGcsZCxoLHIpO2lmKGcucz0xL2U8MD8oZD1kLnNsaWNlKDEpLC0xKToxLEYuREVCVUcmJmQucmVwbGFjZSgvXjBcXC4wKnxcXC4vLFwiXCIpLmxlbmd0aD4xNSl0aHJvdyBFcnJvcihhK2UpfWVsc2UgZy5zPTQ1PT09ZC5jaGFyQ29kZUF0KDApPyhkPWQuc2xpY2UoMSksLTEpOjE7Zm9yKGk9ai5zbGljZSgwLHIpLGw9Zj0wLHA9ZC5sZW5ndGg7ZjxwO2YrKylpZihpLmluZGV4T2Yocz1kLmNoYXJBdChmKSk8MCl7aWYoXCIuXCI9PXMpe2lmKGY+bCl7bD1wO2NvbnRpbnVlfX1lbHNlIGlmKCFjJiYoZD09ZC50b1VwcGVyQ2FzZSgpJiYoZD1kLnRvTG93ZXJDYXNlKCkpfHxkPT1kLnRvTG93ZXJDYXNlKCkmJihkPWQudG9VcHBlckNhc2UoKSkpKXtjPSEwLGY9LTEsbD0wO2NvbnRpbnVlfXJldHVybiBUKGcsU3RyaW5nKGUpLGgscil9aD0hMSwobD0oZD1TKGQsciwxMCxnLnMpKS5pbmRleE9mKFwiLlwiKSk+LTE/ZD1kLnJlcGxhY2UoXCIuXCIsXCJcIik6bD1kLmxlbmd0aH1mb3IoZj0wOzQ4PT09ZC5jaGFyQ29kZUF0KGYpO2YrKyk7Zm9yKHA9ZC5sZW5ndGg7NDg9PT1kLmNoYXJDb2RlQXQoLS1wKTspO2lmKGQ9ZC5zbGljZShmLCsrcCkpe2lmKHAtPWYsaCYmRi5ERUJVRyYmcD4xNSYmKGU+dXx8ZSE9PW4oZSkpKXRocm93IEVycm9yKGErZy5zKmUpO2lmKChsPWwtZi0xKT5EKWcuYz1nLmU9bnVsbDtlbHNlIGlmKGw8TClnLmM9W2cuZT0wXTtlbHNle2lmKGcuZT1sLGcuYz1bXSxmPShsKzEpJW8sbDwwJiYoZis9byksZjxwKXtmb3IoZiYmZy5jLnB1c2goK2Quc2xpY2UoMCxmKSkscC09bztmPHA7KWcuYy5wdXNoKCtkLnNsaWNlKGYsZis9bykpO2Y9by0oZD1kLnNsaWNlKGYpKS5sZW5ndGh9ZWxzZSBmLT1wO2Zvcig7Zi0tO2QrPVwiMFwiKTtnLmMucHVzaCgrZCl9fWVsc2UgZy5jPVtnLmU9MF19ZnVuY3Rpb24gcShlLHQscixuKXt2YXIgaSxhLHMsbyx1O2lmKG51bGw9PXI/cj1POnkociwwLDgpLCFlLmMpcmV0dXJuIGUudG9TdHJpbmcoKTtpZihpPWUuY1swXSxzPWUuZSxudWxsPT10KXU9cChlLmMpLHU9MT09bnx8Mj09biYmKHM8PWt8fHM+PVUpP20odSxzKTp2KHUscyxcIjBcIik7ZWxzZSBpZihhPShlPUgobmV3IEYoZSksdCxyKSkuZSxvPSh1PXAoZS5jKSkubGVuZ3RoLDE9PW58fDI9PW4mJih0PD1hfHxhPD1rKSl7Zm9yKDtvPHQ7dSs9XCIwXCIsbysrKTt1PW0odSxhKX1lbHNlIGlmKHQtPXMsdT12KHUsYSxcIjBcIiksYSsxPm8pe2lmKC0tdD4wKWZvcih1Kz1cIi5cIjt0LS07dSs9XCIwXCIpO31lbHNlIGlmKCh0Kz1hLW8pPjApZm9yKGErMT09byYmKHUrPVwiLlwiKTt0LS07dSs9XCIwXCIpO3JldHVybiBlLnM8MCYmaT9cIi1cIit1OnV9ZnVuY3Rpb24geihlLHQpe2Zvcih2YXIgcixuPTEsaT1uZXcgRihlWzBdKTtuPGUubGVuZ3RoO24rKyl7aWYoIShyPW5ldyBGKGVbbl0pKS5zKXtpPXI7YnJlYWt9dC5jYWxsKGkscikmJihpPXIpfXJldHVybiBpfWZ1bmN0aW9uIEcoZSx0LHIpe2Zvcih2YXIgbj0xLGk9dC5sZW5ndGg7IXRbLS1pXTt0LnBvcCgpKTtmb3IoaT10WzBdO2k+PTEwO2kvPTEwLG4rKyk7cmV0dXJuKHI9bityKm8tMSk+RD9lLmM9ZS5lPW51bGw6cjxMP2UuYz1bZS5lPTBdOihlLmU9cixlLmM9dCksZX1mdW5jdGlvbiBIKGUsdCxpLGEpe3ZhciB1LGwsZixoLHAsZCx5LGc9ZS5jLG09YztpZihnKXtlOntmb3IodT0xLGg9Z1swXTtoPj0xMDtoLz0xMCx1KyspO2lmKChsPXQtdSk8MClsKz1vLGY9dCx5PShwPWdbZD0wXSkvbVt1LWYtMV0lMTB8MDtlbHNlIGlmKChkPXIoKGwrMSkvbykpPj1nLmxlbmd0aCl7aWYoIWEpYnJlYWsgZTtmb3IoO2cubGVuZ3RoPD1kO2cucHVzaCgwKSk7cD15PTAsdT0xLGY9KGwlPW8pLW8rMX1lbHNle2ZvcihwPWg9Z1tkXSx1PTE7aD49MTA7aC89MTAsdSsrKTt5PShmPShsJT1vKS1vK3UpPDA/MDpwL21bdS1mLTFdJTEwfDB9aWYoYT1hfHx0PDB8fG51bGwhPWdbZCsxXXx8KGY8MD9wOnAlbVt1LWYtMV0pLGE9aTw0Pyh5fHxhKSYmKDA9PWl8fGk9PShlLnM8MD8zOjIpKTp5PjV8fDU9PXkmJig0PT1pfHxhfHw2PT1pJiYobD4wP2Y+MD9wL21bdS1mXTowOmdbZC0xXSklMTAmMXx8aT09KGUuczwwPzg6NykpLHQ8MXx8IWdbMF0pcmV0dXJuIGcubGVuZ3RoPTAsYT8odC09ZS5lKzEsZ1swXT1tWyhvLXQlbyklb10sZS5lPS10fHwwKTpnWzBdPWUuZT0wLGU7aWYoMD09bD8oZy5sZW5ndGg9ZCxoPTEsZC0tKTooZy5sZW5ndGg9ZCsxLGg9bVtvLWxdLGdbZF09Zj4wP24ocC9tW3UtZl0lbVtmXSkqaDowKSxhKWZvcig7Oyl7aWYoMD09ZCl7Zm9yKGw9MSxmPWdbMF07Zj49MTA7Zi89MTAsbCsrKTtmb3IoZj1nWzBdKz1oLGg9MTtmPj0xMDtmLz0xMCxoKyspO2whPWgmJihlLmUrKyxnWzBdPT1zJiYoZ1swXT0xKSk7YnJlYWt9aWYoZ1tkXSs9aCxnW2RdIT1zKWJyZWFrO2dbZC0tXT0wLGg9MX1mb3IobD1nLmxlbmd0aDswPT09Z1stLWxdO2cucG9wKCkpO31lLmU+RD9lLmM9ZS5lPW51bGw6ZS5lPEwmJihlLmM9W2UuZT0wXSl9cmV0dXJuIGV9ZnVuY3Rpb24gWShlKXt2YXIgdCxyPWUuZTtyZXR1cm4gbnVsbD09PXI/ZS50b1N0cmluZygpOih0PXAoZS5jKSx0PXI8PWt8fHI+PVU/bSh0LHIpOnYodCxyLFwiMFwiKSxlLnM8MD9cIi1cIit0OnQpfXJldHVybiBGLmNsb25lPWUsRi5ST1VORF9VUD0wLEYuUk9VTkRfRE9XTj0xLEYuUk9VTkRfQ0VJTD0yLEYuUk9VTkRfRkxPT1I9MyxGLlJPVU5EX0hBTEZfVVA9NCxGLlJPVU5EX0hBTEZfRE9XTj01LEYuUk9VTkRfSEFMRl9FVkVOPTYsRi5ST1VORF9IQUxGX0NFSUw9NyxGLlJPVU5EX0hBTEZfRkxPT1I9OCxGLkVVQ0xJRD05LEYuY29uZmlnPUYuc2V0PWZ1bmN0aW9uKGUpe3ZhciB0LHI7aWYobnVsbCE9ZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgRXJyb3IoaStcIk9iamVjdCBleHBlY3RlZDogXCIrZSk7aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiREVDSU1BTF9QTEFDRVNcIikmJih5KHI9ZVt0XSwwLGYsdCksUD1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJST1VORElOR19NT0RFXCIpJiYoeShyPWVbdF0sMCw4LHQpLE89ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiRVhQT05FTlRJQUxfQVRcIikmJigocj1lW3RdKSYmci5wb3A/KHkoclswXSwtZiwwLHQpLHkoclsxXSwwLGYsdCksaz1yWzBdLFU9clsxXSk6KHkociwtZixmLHQpLGs9LShVPXI8MD8tcjpyKSkpLGUuaGFzT3duUHJvcGVydHkodD1cIlJBTkdFXCIpKWlmKChyPWVbdF0pJiZyLnBvcCl5KHJbMF0sLWYsLTEsdCkseShyWzFdLDEsZix0KSxMPXJbMF0sRD1yWzFdO2Vsc2V7aWYoeShyLC1mLGYsdCksIXIpdGhyb3cgRXJyb3IoaSt0K1wiIGNhbm5vdCBiZSB6ZXJvOiBcIityKTtMPS0oRD1yPDA/LXI6cil9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiQ1JZUFRPXCIpKXtpZigocj1lW3RdKSE9PSEhcil0aHJvdyBFcnJvcihpK3QrXCIgbm90IHRydWUgb3IgZmFsc2U6IFwiK3IpO2lmKHIpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjcnlwdG98fCFjcnlwdG98fCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiYhY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IFY9IXIsRXJyb3IoaStcImNyeXB0byB1bmF2YWlsYWJsZVwiKTtWPXJ9ZWxzZSBWPXJ9aWYoZS5oYXNPd25Qcm9wZXJ0eSh0PVwiTU9EVUxPX01PREVcIikmJih5KHI9ZVt0XSwwLDksdCkseD1yKSxlLmhhc093blByb3BlcnR5KHQ9XCJQT1dfUFJFQ0lTSU9OXCIpJiYoeShyPWVbdF0sMCxmLHQpLEs9ciksZS5oYXNPd25Qcm9wZXJ0eSh0PVwiRk9STUFUXCIpKXtpZihcIm9iamVjdFwiIT10eXBlb2Yocj1lW3RdKSl0aHJvdyBFcnJvcihpK3QrXCIgbm90IGFuIG9iamVjdDogXCIrcik7TT1yfWlmKGUuaGFzT3duUHJvcGVydHkodD1cIkFMUEhBQkVUXCIpKXtpZihcInN0cmluZ1wiIT10eXBlb2Yocj1lW3RdKXx8L14uJHxbKy0uXFxzXXwoLikuKlxcMS8udGVzdChyKSl0aHJvdyBFcnJvcihpK3QrXCIgaW52YWxpZDogXCIrcik7aj1yfX1yZXR1cm57REVDSU1BTF9QTEFDRVM6UCxST1VORElOR19NT0RFOk8sRVhQT05FTlRJQUxfQVQ6W2ssVV0sUkFOR0U6W0wsRF0sQ1JZUFRPOlYsTU9EVUxPX01PREU6eCxQT1dfUFJFQ0lTSU9OOkssRk9STUFUOk0sQUxQSEFCRVQ6an19LEYuaXNCaWdOdW1iZXI9ZnVuY3Rpb24oZSl7aWYoIWV8fCEwIT09ZS5faXNCaWdOdW1iZXIpcmV0dXJuITE7aWYoIUYuREVCVUcpcmV0dXJuITA7dmFyIHQscixhPWUuYyx1PWUuZSxjPWUucztlOmlmKFwiW29iamVjdCBBcnJheV1cIj09e30udG9TdHJpbmcuY2FsbChhKSl7aWYoKDE9PT1jfHwtMT09PWMpJiZ1Pj0tZiYmdTw9ZiYmdT09PW4odSkpe2lmKDA9PT1hWzBdKXtpZigwPT09dSYmMT09PWEubGVuZ3RoKXJldHVybiEwO2JyZWFrIGV9aWYoKHQ9KHUrMSklbyk8MSYmKHQrPW8pLFN0cmluZyhhWzBdKS5sZW5ndGg9PXQpe2Zvcih0PTA7dDxhLmxlbmd0aDt0KyspaWYoKHI9YVt0XSk8MHx8cj49c3x8ciE9PW4ocikpYnJlYWsgZTtpZigwIT09cilyZXR1cm4hMH19fWVsc2UgaWYobnVsbD09PWEmJm51bGw9PT11JiYobnVsbD09PWN8fDE9PT1jfHwtMT09PWMpKXJldHVybiEwO3Rocm93IEVycm9yKGkrXCJJbnZhbGlkIEJpZ051bWJlcjogXCIrZSl9LEYubWF4aW11bT1GLm1heD1mdW5jdGlvbigpe3JldHVybiB6KGFyZ3VtZW50cyxSLmx0KX0sRi5taW5pbXVtPUYubWluPWZ1bmN0aW9uKCl7cmV0dXJuIHooYXJndW1lbnRzLFIuZ3QpfSxGLnJhbmRvbT0oQz05MDA3MTk5MjU0NzQwOTkyKk1hdGgucmFuZG9tKCkmMjA5NzE1MT9mdW5jdGlvbigpe3JldHVybiBuKDkwMDcxOTkyNTQ3NDA5OTIqTWF0aC5yYW5kb20oKSl9OmZ1bmN0aW9uKCl7cmV0dXJuIDgzODg2MDgqKDEwNzM3NDE4MjQqTWF0aC5yYW5kb20oKXwwKSsoODM4ODYwOCpNYXRoLnJhbmRvbSgpfDApfSxmdW5jdGlvbihlKXt2YXIgdCxhLHMsdSxsLGg9MCxwPVtdLGQ9bmV3IEYoXyk7aWYobnVsbD09ZT9lPVA6eShlLDAsZiksdT1yKGUvbyksVilpZihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXtmb3IodD1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSh1Kj0yKSk7aDx1OykobD0xMzEwNzIqdFtoXSsodFtoKzFdPj4+MTEpKT49OWUxNT8oYT1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSksdFtoXT1hWzBdLHRbaCsxXT1hWzFdKToocC5wdXNoKGwlMWUxNCksaCs9Mik7aD11LzJ9ZWxzZXtpZighY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IFY9ITEsRXJyb3IoaStcImNyeXB0byB1bmF2YWlsYWJsZVwiKTtmb3IodD1jcnlwdG8ucmFuZG9tQnl0ZXModSo9Nyk7aDx1OykobD0yODE0NzQ5NzY3MTA2NTYqKDMxJnRbaF0pKzEwOTk1MTE2Mjc3NzYqdFtoKzFdKzQyOTQ5NjcyOTYqdFtoKzJdKzE2Nzc3MjE2KnRbaCszXSsodFtoKzRdPDwxNikrKHRbaCs1XTw8OCkrdFtoKzZdKT49OWUxNT9jcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSh0LGgpOihwLnB1c2gobCUxZTE0KSxoKz03KTtoPXUvN31pZighVilmb3IoO2g8dTspKGw9QygpKTw5ZTE1JiYocFtoKytdPWwlMWUxNCk7Zm9yKHU9cFstLWhdLGUlPW8sdSYmZSYmKGw9Y1tvLWVdLHBbaF09bih1L2wpKmwpOzA9PT1wW2hdO3AucG9wKCksaC0tKTtpZihoPDApcD1bcz0wXTtlbHNle2ZvcihzPS0xOzA9PT1wWzBdO3Auc3BsaWNlKDAsMSkscy09byk7Zm9yKGg9MSxsPXBbMF07bD49MTA7bC89MTAsaCsrKTtoPG8mJihzLT1vLWgpfXJldHVybiBkLmU9cyxkLmM9cCxkfSksRi5zdW09ZnVuY3Rpb24oKXtmb3IodmFyIGU9MSx0PWFyZ3VtZW50cyxyPW5ldyBGKHRbMF0pO2U8dC5sZW5ndGg7KXI9ci5wbHVzKHRbZSsrXSk7cmV0dXJuIHJ9LFM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxyLG4pe2Zvcih2YXIgaSxhLHM9WzBdLG89MCx1PWUubGVuZ3RoO288dTspe2ZvcihhPXMubGVuZ3RoO2EtLTtzW2FdKj10KTtmb3Ioc1swXSs9bi5pbmRleE9mKGUuY2hhckF0KG8rKykpLGk9MDtpPHMubGVuZ3RoO2krKylzW2ldPnItMSYmKG51bGw9PXNbaSsxXSYmKHNbaSsxXT0wKSxzW2krMV0rPXNbaV0vcnwwLHNbaV0lPXIpfXJldHVybiBzLnJldmVyc2UoKX1yZXR1cm4gZnVuY3Rpb24odCxyLG4saSxhKXt2YXIgcyxvLHUsYyxsLGYsaCxkLHk9dC5pbmRleE9mKFwiLlwiKSxnPVAsbT1PO2Zvcih5Pj0wJiYoYz1LLEs9MCx0PXQucmVwbGFjZShcIi5cIixcIlwiKSxmPShkPW5ldyBGKHIpKS5wb3codC5sZW5ndGgteSksSz1jLGQuYz1lKHYocChmLmMpLGYuZSxcIjBcIiksMTAsbixcIjAxMjM0NTY3ODlcIiksZC5lPWQuYy5sZW5ndGgpLHU9Yz0oaD1lKHQscixuLGE/KHM9aixcIjAxMjM0NTY3ODlcIik6KHM9XCIwMTIzNDU2Nzg5XCIsaikpKS5sZW5ndGg7MD09aFstLWNdO2gucG9wKCkpO2lmKCFoWzBdKXJldHVybiBzLmNoYXJBdCgwKTtpZih5PDA/LS11OihmLmM9aCxmLmU9dSxmLnM9aSxoPShmPUUoZixkLGcsbSxuKSkuYyxsPWYucix1PWYuZSkseT1oW289dStnKzFdLGM9bi8yLGw9bHx8bzwwfHxudWxsIT1oW28rMV0sbD1tPDQ/KG51bGwhPXl8fGwpJiYoMD09bXx8bT09KGYuczwwPzM6MikpOnk+Y3x8eT09YyYmKDQ9PW18fGx8fDY9PW0mJjEmaFtvLTFdfHxtPT0oZi5zPDA/ODo3KSksbzwxfHwhaFswXSl0PWw/dihzLmNoYXJBdCgxKSwtZyxzLmNoYXJBdCgwKSk6cy5jaGFyQXQoMCk7ZWxzZXtpZihoLmxlbmd0aD1vLGwpZm9yKC0tbjsrK2hbLS1vXT5uOyloW29dPTAsb3x8KCsrdSxoPVsxXS5jb25jYXQoaCkpO2ZvcihjPWgubGVuZ3RoOyFoWy0tY107KTtmb3IoeT0wLHQ9XCJcIjt5PD1jO3QrPXMuY2hhckF0KGhbeSsrXSkpO3Q9dih0LHUscy5jaGFyQXQoMCkpfXJldHVybiB0fX0oKSxFPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQscil7dmFyIG4saSxhLHMsbz0wLHU9ZS5sZW5ndGgsYz10JWwsZj10L2x8MDtmb3IoZT1lLnNsaWNlKCk7dS0tOylvPSgoaT1jKihhPWVbdV0lbCkrKG49ZiphKyhzPWVbdV0vbHwwKSpjKSVsKmwrbykvcnwwKSsobi9sfDApK2YqcyxlW3VdPWklcjtyZXR1cm4gbyYmKGU9W29dLmNvbmNhdChlKSksZX1mdW5jdGlvbiB0KGUsdCxyLG4pe3ZhciBpLGE7aWYociE9bilhPXI+bj8xOi0xO2Vsc2UgZm9yKGk9YT0wO2k8cjtpKyspaWYoZVtpXSE9dFtpXSl7YT1lW2ldPnRbaV0/MTotMTticmVha31yZXR1cm4gYX1mdW5jdGlvbiByKGUsdCxyLG4pe2Zvcih2YXIgaT0wO3ItLTspZVtyXS09aSxpPWVbcl08dFtyXT8xOjAsZVtyXT1pKm4rZVtyXS10W3JdO2Zvcig7IWVbMF0mJmUubGVuZ3RoPjE7ZS5zcGxpY2UoMCwxKSk7fXJldHVybiBmdW5jdGlvbihpLGEsdSxjLGwpe3ZhciBmLHAsZCx5LGcsbSx2LGIsRSxTLFQsQyxBLEksdyxCLE4sUj1pLnM9PWEucz8xOi0xLF89aS5jLFA9YS5jO2lmKCEoXyYmX1swXSYmUCYmUFswXSkpcmV0dXJuIG5ldyBGKGkucyYmYS5zJiYoXz8hUHx8X1swXSE9UFswXTpQKT9fJiYwPT1fWzBdfHwhUD8wKlI6Ui8wOk5hTik7Zm9yKEU9KGI9bmV3IEYoUikpLmM9W10sUj11KyhwPWkuZS1hLmUpKzEsbHx8KGw9cyxwPWgoaS5lL28pLWgoYS5lL28pLFI9Ui9vfDApLGQ9MDtQW2RdPT0oX1tkXXx8MCk7ZCsrKTtpZihQW2RdPihfW2RdfHwwKSYmcC0tLFI8MClFLnB1c2goMSkseT0hMDtlbHNle2ZvcihJPV8ubGVuZ3RoLEI9UC5sZW5ndGgsZD0wLFIrPTIsKGc9bihsLyhQWzBdKzEpKSk+MSYmKFA9ZShQLGcsbCksXz1lKF8sZyxsKSxCPVAubGVuZ3RoLEk9Xy5sZW5ndGgpLEE9QixUPShTPV8uc2xpY2UoMCxCKSkubGVuZ3RoO1Q8QjtTW1QrK109MCk7Tj1QLnNsaWNlKCksTj1bMF0uY29uY2F0KE4pLHc9UFswXSxQWzFdPj1sLzImJncrKztkb3tpZihnPTAsKGY9dChQLFMsQixUKSk8MCl7aWYoQz1TWzBdLEIhPVQmJihDPUMqbCsoU1sxXXx8MCkpLChnPW4oQy93KSk+MSlmb3IoZz49bCYmKGc9bC0xKSx2PShtPWUoUCxnLGwpKS5sZW5ndGgsVD1TLmxlbmd0aDsxPT10KG0sUyx2LFQpOylnLS0scihtLEI8dj9OOlAsdixsKSx2PW0ubGVuZ3RoLGY9MTtlbHNlIDA9PWcmJihmPWc9MSksdj0obT1QLnNsaWNlKCkpLmxlbmd0aDtpZih2PFQmJihtPVswXS5jb25jYXQobSkpLHIoUyxtLFQsbCksVD1TLmxlbmd0aCwtMT09Zilmb3IoO3QoUCxTLEIsVCk8MTspZysrLHIoUyxCPFQ/TjpQLFQsbCksVD1TLmxlbmd0aH1lbHNlIDA9PT1mJiYoZysrLFM9WzBdKTtFW2QrK109ZyxTWzBdP1NbVCsrXT1fW0FdfHwwOihTPVtfW0FdXSxUPTEpfXdoaWxlKChBKys8SXx8bnVsbCE9U1swXSkmJlItLSk7eT1udWxsIT1TWzBdLEVbMF18fEUuc3BsaWNlKDAsMSl9aWYobD09cyl7Zm9yKGQ9MSxSPUVbMF07Uj49MTA7Ui89MTAsZCsrKTtIKGIsdSsoYi5lPWQrcCpvLTEpKzEsYyx5KX1lbHNlIGIuZT1wLGIucj0reTtyZXR1cm4gYn19KCksQT0vXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLEk9L14oW14uXSspXFwuJC8sdz0vXlxcLihbXi5dKykkLyxCPS9eLT8oSW5maW5pdHl8TmFOKSQvLE49L15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nLFQ9ZnVuY3Rpb24oZSx0LHIsbil7dmFyIGEscz1yP3Q6dC5yZXBsYWNlKE4sXCJcIik7aWYoQi50ZXN0KHMpKWUucz1pc05hTihzKT9udWxsOnM8MD8tMToxO2Vsc2V7aWYoIXImJihzPXMucmVwbGFjZShBLChmdW5jdGlvbihlLHQscil7cmV0dXJuIGE9XCJ4XCI9PShyPXIudG9Mb3dlckNhc2UoKSk/MTY6XCJiXCI9PXI/Mjo4LG4mJm4hPWE/ZTp0fSkpLG4mJihhPW4scz1zLnJlcGxhY2UoSSxcIiQxXCIpLnJlcGxhY2UodyxcIjAuJDFcIikpLHQhPXMpKXJldHVybiBuZXcgRihzLGEpO2lmKEYuREVCVUcpdGhyb3cgRXJyb3IoaStcIk5vdCBhXCIrKG4/XCIgYmFzZSBcIituOlwiXCIpK1wiIG51bWJlcjogXCIrdCk7ZS5zPW51bGx9ZS5jPWUuZT1udWxsfSxSLmFic29sdXRlVmFsdWU9Ui5hYnM9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRih0aGlzKTtyZXR1cm4gZS5zPDAmJihlLnM9MSksZX0sUi5jb21wYXJlZFRvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGQodGhpcyxuZXcgRihlLHQpKX0sUi5kZWNpbWFsUGxhY2VzPVIuZHA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYT10aGlzO2lmKG51bGwhPWUpcmV0dXJuIHkoZSwwLGYpLG51bGw9PXQ/dD1POnkodCwwLDgpLEgobmV3IEYoYSksZSthLmUrMSx0KTtpZighKHI9YS5jKSlyZXR1cm4gbnVsbDtpZihuPSgoaT1yLmxlbmd0aC0xKS1oKHRoaXMuZS9vKSkqbyxpPXJbaV0pZm9yKDtpJTEwPT0wO2kvPTEwLG4tLSk7cmV0dXJuIG48MCYmKG49MCksbn0sUi5kaXZpZGVkQnk9Ui5kaXY9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gRSh0aGlzLG5ldyBGKGUsdCksUCxPKX0sUi5kaXZpZGVkVG9JbnRlZ2VyQnk9Ui5pZGl2PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEUodGhpcyxuZXcgRihlLHQpLDAsMSl9LFIuZXhwb25lbnRpYXRlZEJ5PVIucG93PWZ1bmN0aW9uKGUsdCl7dmFyIGEscyx1LGMsbCxmLGgscCxkPXRoaXM7aWYoKGU9bmV3IEYoZSkpLmMmJiFlLmlzSW50ZWdlcigpKXRocm93IEVycm9yKGkrXCJFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogXCIrWShlKSk7aWYobnVsbCE9dCYmKHQ9bmV3IEYodCkpLGw9ZS5lPjE0LCFkLmN8fCFkLmNbMF18fDE9PWQuY1swXSYmIWQuZSYmMT09ZC5jLmxlbmd0aHx8IWUuY3x8IWUuY1swXSlyZXR1cm4gcD1uZXcgRihNYXRoLnBvdygrWShkKSxsPzItZyhlKTorWShlKSkpLHQ/cC5tb2QodCk6cDtpZihmPWUuczwwLHQpe2lmKHQuYz8hdC5jWzBdOiF0LnMpcmV0dXJuIG5ldyBGKE5hTik7KHM9IWYmJmQuaXNJbnRlZ2VyKCkmJnQuaXNJbnRlZ2VyKCkpJiYoZD1kLm1vZCh0KSl9ZWxzZXtpZihlLmU+OSYmKGQuZT4wfHxkLmU8LTF8fCgwPT1kLmU/ZC5jWzBdPjF8fGwmJmQuY1sxXT49MjRlNzpkLmNbMF08OGUxM3x8bCYmZC5jWzBdPD05OTk5OTc1ZTcpKSlyZXR1cm4gYz1kLnM8MCYmZyhlKT8tMDowLGQuZT4tMSYmKGM9MS9jKSxuZXcgRihmPzEvYzpjKTtLJiYoYz1yKEsvbysyKSl9Zm9yKGw/KGE9bmV3IEYoLjUpLGYmJihlLnM9MSksaD1nKGUpKTpoPSh1PU1hdGguYWJzKCtZKGUpKSklMixwPW5ldyBGKF8pOzspe2lmKGgpe2lmKCEocD1wLnRpbWVzKGQpKS5jKWJyZWFrO2M/cC5jLmxlbmd0aD5jJiYocC5jLmxlbmd0aD1jKTpzJiYocD1wLm1vZCh0KSl9aWYodSl7aWYoMD09PSh1PW4odS8yKSkpYnJlYWs7aD11JTJ9ZWxzZSBpZihIKGU9ZS50aW1lcyhhKSxlLmUrMSwxKSxlLmU+MTQpaD1nKGUpO2Vsc2V7aWYoMD09KHU9K1koZSkpKWJyZWFrO2g9dSUyfWQ9ZC50aW1lcyhkKSxjP2QuYyYmZC5jLmxlbmd0aD5jJiYoZC5jLmxlbmd0aD1jKTpzJiYoZD1kLm1vZCh0KSl9cmV0dXJuIHM/cDooZiYmKHA9Xy5kaXYocCkpLHQ/cC5tb2QodCk6Yz9IKHAsSyxPLHZvaWQgMCk6cCl9LFIuaW50ZWdlclZhbHVlPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBGKHRoaXMpO3JldHVybiBudWxsPT1lP2U9Tzp5KGUsMCw4KSxIKHQsdC5lKzEsZSl9LFIuaXNFcXVhbFRvPVIuZXE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09PWQodGhpcyxuZXcgRihlLHQpKX0sUi5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jfSxSLmlzR3JlYXRlclRoYW49Ui5ndD1mdW5jdGlvbihlLHQpe3JldHVybiBkKHRoaXMsbmV3IEYoZSx0KSk+MH0sUi5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvPVIuZ3RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIDE9PT0odD1kKHRoaXMsbmV3IEYoZSx0KSkpfHwwPT09dH0sUi5pc0ludGVnZXI9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmaCh0aGlzLmUvbyk+dGhpcy5jLmxlbmd0aC0yfSxSLmlzTGVzc1RoYW49Ui5sdD1mdW5jdGlvbihlLHQpe3JldHVybiBkKHRoaXMsbmV3IEYoZSx0KSk8MH0sUi5pc0xlc3NUaGFuT3JFcXVhbFRvPVIubHRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuLTE9PT0odD1kKHRoaXMsbmV3IEYoZSx0KSkpfHwwPT09dH0sUi5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LFIuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM8MH0sUi5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucz4wfSxSLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiYwPT10aGlzLmNbMF19LFIubWludXM9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYSx1PXRoaXMsYz11LnM7aWYodD0oZT1uZXcgRihlLHQpKS5zLCFjfHwhdClyZXR1cm4gbmV3IEYoTmFOKTtpZihjIT10KXJldHVybiBlLnM9LXQsdS5wbHVzKGUpO3ZhciBsPXUuZS9vLGY9ZS5lL28scD11LmMsZD1lLmM7aWYoIWx8fCFmKXtpZighcHx8IWQpcmV0dXJuIHA/KGUucz0tdCxlKTpuZXcgRihkP3U6TmFOKTtpZighcFswXXx8IWRbMF0pcmV0dXJuIGRbMF0/KGUucz0tdCxlKTpuZXcgRihwWzBdP3U6Mz09Tz8tMDowKX1pZihsPWgobCksZj1oKGYpLHA9cC5zbGljZSgpLGM9bC1mKXtmb3IoKGE9YzwwKT8oYz0tYyxpPXApOihmPWwsaT1kKSxpLnJldmVyc2UoKSx0PWM7dC0tO2kucHVzaCgwKSk7aS5yZXZlcnNlKCl9ZWxzZSBmb3Iobj0oYT0oYz1wLmxlbmd0aCk8KHQ9ZC5sZW5ndGgpKT9jOnQsYz10PTA7dDxuO3QrKylpZihwW3RdIT1kW3RdKXthPXBbdF08ZFt0XTticmVha31pZihhJiYoaT1wLHA9ZCxkPWksZS5zPS1lLnMpLCh0PShuPWQubGVuZ3RoKS0ocj1wLmxlbmd0aCkpPjApZm9yKDt0LS07cFtyKytdPTApO2Zvcih0PXMtMTtuPmM7KXtpZihwWy0tbl08ZFtuXSl7Zm9yKHI9bjtyJiYhcFstLXJdO3Bbcl09dCk7LS1wW3JdLHBbbl0rPXN9cFtuXS09ZFtuXX1mb3IoOzA9PXBbMF07cC5zcGxpY2UoMCwxKSwtLWYpO3JldHVybiBwWzBdP0coZSxwLGYpOihlLnM9Mz09Tz8tMToxLGUuYz1bZS5lPTBdLGUpfSxSLm1vZHVsbz1SLm1vZD1mdW5jdGlvbihlLHQpe3ZhciByLG4saT10aGlzO3JldHVybiBlPW5ldyBGKGUsdCksIWkuY3x8IWUuc3x8ZS5jJiYhZS5jWzBdP25ldyBGKE5hTik6IWUuY3x8aS5jJiYhaS5jWzBdP25ldyBGKGkpOig5PT14PyhuPWUucyxlLnM9MSxyPUUoaSxlLDAsMyksZS5zPW4sci5zKj1uKTpyPUUoaSxlLDAseCksKGU9aS5taW51cyhyLnRpbWVzKGUpKSkuY1swXXx8MSE9eHx8KGUucz1pLnMpLGUpfSxSLm11bHRpcGxpZWRCeT1SLnRpbWVzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGEsdSxjLGYscCxkLHksZyxtLHYsYixFLFM9dGhpcyxUPVMuYyxDPShlPW5ldyBGKGUsdCkpLmM7aWYoIShUJiZDJiZUWzBdJiZDWzBdKSlyZXR1cm4hUy5zfHwhZS5zfHxUJiYhVFswXSYmIUN8fEMmJiFDWzBdJiYhVD9lLmM9ZS5lPWUucz1udWxsOihlLnMqPVMucyxUJiZDPyhlLmM9WzBdLGUuZT0wKTplLmM9ZS5lPW51bGwpLGU7Zm9yKG49aChTLmUvbykraChlLmUvbyksZS5zKj1TLnMsKGY9VC5sZW5ndGgpPCh5PUMubGVuZ3RoKSYmKHY9VCxUPUMsQz12LGk9ZixmPXkseT1pKSxpPWYreSx2PVtdO2ktLTt2LnB1c2goMCkpO2ZvcihiPXMsRT1sLGk9eTstLWk+PTA7KXtmb3Iocj0wLGc9Q1tpXSVFLG09Q1tpXS9FfDAsYT1pKyh1PWYpO2E+aTspcj0oKHA9ZyoocD1UWy0tdV0lRSkrKGM9bSpwKyhkPVRbdV0vRXwwKSpnKSVFKkUrdlthXStyKS9ifDApKyhjL0V8MCkrbSpkLHZbYS0tXT1wJWI7dlthXT1yfXJldHVybiByPysrbjp2LnNwbGljZSgwLDEpLEcoZSx2LG4pfSxSLm5lZ2F0ZWQ9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgRih0aGlzKTtyZXR1cm4gZS5zPS1lLnN8fG51bGwsZX0sUi5wbHVzPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj10aGlzLGk9bi5zO2lmKHQ9KGU9bmV3IEYoZSx0KSkucywhaXx8IXQpcmV0dXJuIG5ldyBGKE5hTik7aWYoaSE9dClyZXR1cm4gZS5zPS10LG4ubWludXMoZSk7dmFyIGE9bi5lL28sdT1lLmUvbyxjPW4uYyxsPWUuYztpZighYXx8IXUpe2lmKCFjfHwhbClyZXR1cm4gbmV3IEYoaS8wKTtpZighY1swXXx8IWxbMF0pcmV0dXJuIGxbMF0/ZTpuZXcgRihjWzBdP246MCppKX1pZihhPWgoYSksdT1oKHUpLGM9Yy5zbGljZSgpLGk9YS11KXtmb3IoaT4wPyh1PWEscj1sKTooaT0taSxyPWMpLHIucmV2ZXJzZSgpO2ktLTtyLnB1c2goMCkpO3IucmV2ZXJzZSgpfWZvcigoaT1jLmxlbmd0aCktKHQ9bC5sZW5ndGgpPDAmJihyPWwsbD1jLGM9cix0PWkpLGk9MDt0OylpPShjWy0tdF09Y1t0XStsW3RdK2kpL3N8MCxjW3RdPXM9PT1jW3RdPzA6Y1t0XSVzO3JldHVybiBpJiYoYz1baV0uY29uY2F0KGMpLCsrdSksRyhlLGMsdSl9LFIucHJlY2lzaW9uPVIuc2Q9ZnVuY3Rpb24oZSx0KXt2YXIgcixuLGksYT10aGlzO2lmKG51bGwhPWUmJmUhPT0hIWUpcmV0dXJuIHkoZSwxLGYpLG51bGw9PXQ/dD1POnkodCwwLDgpLEgobmV3IEYoYSksZSx0KTtpZighKHI9YS5jKSlyZXR1cm4gbnVsbDtpZihuPShpPXIubGVuZ3RoLTEpKm8rMSxpPXJbaV0pe2Zvcig7aSUxMD09MDtpLz0xMCxuLS0pO2ZvcihpPXJbMF07aT49MTA7aS89MTAsbisrKTt9cmV0dXJuIGUmJmEuZSsxPm4mJihuPWEuZSsxKSxufSxSLnNoaWZ0ZWRCeT1mdW5jdGlvbihlKXtyZXR1cm4geShlLC11LHUpLHRoaXMudGltZXMoXCIxZVwiK2UpfSxSLnNxdWFyZVJvb3Q9Ui5zcXJ0PWZ1bmN0aW9uKCl7dmFyIGUsdCxyLG4saSxhPXRoaXMscz1hLmMsbz1hLnMsdT1hLmUsYz1QKzQsbD1uZXcgRihcIjAuNVwiKTtpZigxIT09b3x8IXN8fCFzWzBdKXJldHVybiBuZXcgRighb3x8bzwwJiYoIXN8fHNbMF0pP05hTjpzP2E6MS8wKTtpZigwPT0obz1NYXRoLnNxcnQoK1koYSkpKXx8bz09MS8wPygoKHQ9cChzKSkubGVuZ3RoK3UpJTI9PTAmJih0Kz1cIjBcIiksbz1NYXRoLnNxcnQoK3QpLHU9aCgodSsxKS8yKS0odTwwfHx1JTIpLHI9bmV3IEYodD1vPT0xLzA/XCIxZVwiK3U6KHQ9by50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsdC5pbmRleE9mKFwiZVwiKSsxKSt1KSk6cj1uZXcgRihvK1wiXCIpLHIuY1swXSlmb3IoKG89KHU9ci5lKStjKTwzJiYobz0wKTs7KWlmKGk9cixyPWwudGltZXMoaS5wbHVzKEUoYSxpLGMsMSkpKSxwKGkuYykuc2xpY2UoMCxvKT09PSh0PXAoci5jKSkuc2xpY2UoMCxvKSl7aWYoci5lPHUmJi0tbyxcIjk5OTlcIiE9KHQ9dC5zbGljZShvLTMsbysxKSkmJihufHxcIjQ5OTlcIiE9dCkpeyt0JiYoK3Quc2xpY2UoMSl8fFwiNVwiIT10LmNoYXJBdCgwKSl8fChIKHIsci5lK1ArMiwxKSxlPSFyLnRpbWVzKHIpLmVxKGEpKTticmVha31pZighbiYmKEgoaSxpLmUrUCsyLDApLGkudGltZXMoaSkuZXEoYSkpKXtyPWk7YnJlYWt9Yys9NCxvKz00LG49MX1yZXR1cm4gSChyLHIuZStQKzEsTyxlKX0sUi50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG51bGwhPWUmJih5KGUsMCxmKSxlKyspLHEodGhpcyxlLHQsMSl9LFIudG9GaXhlZD1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiYoeShlLDAsZiksZT1lK3RoaXMuZSsxKSxxKHRoaXMsZSx0KX0sUi50b0Zvcm1hdD1mdW5jdGlvbihlLHQscil7dmFyIG4sYT10aGlzO2lmKG51bGw9PXIpbnVsbCE9ZSYmdCYmXCJvYmplY3RcIj09dHlwZW9mIHQ/KHI9dCx0PW51bGwpOmUmJlwib2JqZWN0XCI9PXR5cGVvZiBlPyhyPWUsZT10PW51bGwpOnI9TTtlbHNlIGlmKFwib2JqZWN0XCIhPXR5cGVvZiByKXRocm93IEVycm9yKGkrXCJBcmd1bWVudCBub3QgYW4gb2JqZWN0OiBcIityKTtpZihuPWEudG9GaXhlZChlLHQpLGEuYyl7dmFyIHMsbz1uLnNwbGl0KFwiLlwiKSx1PStyLmdyb3VwU2l6ZSxjPStyLnNlY29uZGFyeUdyb3VwU2l6ZSxsPXIuZ3JvdXBTZXBhcmF0b3J8fFwiXCIsZj1vWzBdLGg9b1sxXSxwPWEuczwwLGQ9cD9mLnNsaWNlKDEpOmYseT1kLmxlbmd0aDtpZihjJiYocz11LHU9YyxjPXMseS09cyksdT4wJiZ5PjApe2ZvcihzPXkldXx8dSxmPWQuc3Vic3RyKDAscyk7czx5O3MrPXUpZis9bCtkLnN1YnN0cihzLHUpO2M+MCYmKGYrPWwrZC5zbGljZShzKSkscCYmKGY9XCItXCIrZil9bj1oP2YrKHIuZGVjaW1hbFNlcGFyYXRvcnx8XCJcIikrKChjPStyLmZyYWN0aW9uR3JvdXBTaXplKT9oLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxke1wiK2MrXCJ9XFxcXEJcIixcImdcIiksXCIkJlwiKyhyLmZyYWN0aW9uR3JvdXBTZXBhcmF0b3J8fFwiXCIpKTpoKTpmfXJldHVybihyLnByZWZpeHx8XCJcIikrbisoci5zdWZmaXh8fFwiXCIpfSxSLnRvRnJhY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQscixuLGEscyx1LGwsZixoLGQseSxnLG09dGhpcyx2PW0uYztpZihudWxsIT1lJiYoIShsPW5ldyBGKGUpKS5pc0ludGVnZXIoKSYmKGwuY3x8MSE9PWwucyl8fGwubHQoXykpKXRocm93IEVycm9yKGkrXCJBcmd1bWVudCBcIisobC5pc0ludGVnZXIoKT9cIm91dCBvZiByYW5nZTogXCI6XCJub3QgYW4gaW50ZWdlcjogXCIpK1kobCkpO2lmKCF2KXJldHVybiBuZXcgRihtKTtmb3IodD1uZXcgRihfKSxoPXI9bmV3IEYoXyksbj1mPW5ldyBGKF8pLGc9cCh2KSxzPXQuZT1nLmxlbmd0aC1tLmUtMSx0LmNbMF09Y1sodT1zJW8pPDA/byt1OnVdLGU9IWV8fGwuY29tcGFyZWRUbyh0KT4wP3M+MD90Omg6bCx1PUQsRD0xLzAsbD1uZXcgRihnKSxmLmNbMF09MDtkPUUobCx0LDAsMSksMSE9KGE9ci5wbHVzKGQudGltZXMobikpKS5jb21wYXJlZFRvKGUpOylyPW4sbj1hLGg9Zi5wbHVzKGQudGltZXMoYT1oKSksZj1hLHQ9bC5taW51cyhkLnRpbWVzKGE9dCkpLGw9YTtyZXR1cm4gYT1FKGUubWludXMociksbiwwLDEpLGY9Zi5wbHVzKGEudGltZXMoaCkpLHI9ci5wbHVzKGEudGltZXMobikpLGYucz1oLnM9bS5zLHk9RShoLG4scyo9MixPKS5taW51cyhtKS5hYnMoKS5jb21wYXJlZFRvKEUoZixyLHMsTykubWludXMobSkuYWJzKCkpPDE/W2gsbl06W2Yscl0sRD11LHl9LFIudG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4rWSh0aGlzKX0sUi50b1ByZWNpc2lvbj1mdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT1lJiZ5KGUsMSxmKSxxKHRoaXMsZSx0LDIpfSxSLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe3ZhciB0LHI9dGhpcyxuPXIucyxpPXIuZTtyZXR1cm4gbnVsbD09PWk/bj8odD1cIkluZmluaXR5XCIsbjwwJiYodD1cIi1cIit0KSk6dD1cIk5hTlwiOihudWxsPT1lP3Q9aTw9a3x8aT49VT9tKHAoci5jKSxpKTp2KHAoci5jKSxpLFwiMFwiKToxMD09PWU/dD12KHAoKHI9SChuZXcgRihyKSxQK2krMSxPKSkuYyksci5lLFwiMFwiKTooeShlLDIsai5sZW5ndGgsXCJCYXNlXCIpLHQ9Uyh2KHAoci5jKSxpLFwiMFwiKSwxMCxlLG4sITApKSxuPDAmJnIuY1swXSYmKHQ9XCItXCIrdCkpLHR9LFIudmFsdWVPZj1SLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiBZKHRoaXMpfSxSLl9pc0JpZ051bWJlcj0hMCxSW1N5bWJvbC50b1N0cmluZ1RhZ109XCJCaWdOdW1iZXJcIixSW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV09Ui52YWx1ZU9mLG51bGwhPWImJkYuc2V0KGIpLEZ9KCksRT1mdW5jdGlvbigpe3JldHVybihFPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyPTEsbj1hcmd1bWVudHMubGVuZ3RoO3I8bjtyKyspZm9yKHZhciBpIGluIHQ9YXJndW1lbnRzW3JdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGkpJiYoZVtpXT10W2ldKTtyZXR1cm4gZX0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sUz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt0aGlzLmZvcm1hdD1lLkRFRkFVTFRfRk9STUFULGIuY29uZmlnKHtGT1JNQVQ6dGhpcy5mb3JtYXR9KX1yZXR1cm4gZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGUpe1wiRk9STUFUXCJpbiBlJiYodGhpcy5mb3JtYXQ9RSh7fSx0aGlzLmZvcm1hdCxlLkZPUk1BVCksZS5GT1JNQVQ9dGhpcy5mb3JtYXQpLGIuY29uZmlnKGUpfSxlLkRFRkFVTFRfRk9STUFUPXtwcmVmaXg6XCJcIixkZWNpbWFsU2VwYXJhdG9yOlwiLlwiLGdyb3VwU2VwYXJhdG9yOlwiLFwiLGdyb3VwU2l6ZTozLHNlY29uZGFyeUdyb3VwU2l6ZTowLGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6XCIgXCIsZnJhY3Rpb25Hcm91cFNpemU6MCxzdWZmaXg6XCJcIn0sZX0oKTtlLkJpZ051bWJlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7XCJvYmplY3RcIj09dHlwZW9mIHQmJmUuaXNCaWdOdW1iZXIodCk/dGhpcy5ibj10LmJuLnBsdXMoMCk6dGhpcy5ibj1lLnRvQmlnTnVtYmVySnModCl9cmV0dXJuIGUucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlKHRoaXMpfSxlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHRoaXMuYm4ucGx1cyhlLnRvQmlnTnVtYmVySnModCkpKX0sZS5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0aGlzLmJuLm1pbnVzKGUudG9CaWdOdW1iZXJKcyh0KSkpfSxlLnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHRoaXMuYm4udGltZXMoZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLmRpdj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodGhpcy5ibi5kaXYoZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodGhpcy5ibi5wb3coZS50b0JpZ051bWJlckpzKHQpKSl9LGUucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiBuZXcgZSh0aGlzLmJuLmFicygpKX0sZS5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0aGlzLmJuLm1vZChlLnRvQmlnTnVtYmVySnModCkpKX0sZS5wcm90b3R5cGUucm91bmRUbz1mdW5jdGlvbih0LHIpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1yJiYocj00KSxuZXcgZSh0aGlzLmJuLmRwKHR8fDAscikpfSxlLnByb3RvdHlwZS5lcT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ibi5lcShlLnRvQmlnTnVtYmVySnModCkpfSxlLnByb3RvdHlwZS5sdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ibi5sdChlLnRvQmlnTnVtYmVySnModCkpfSxlLnByb3RvdHlwZS5ndD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ibi5ndChlLnRvQmlnTnVtYmVySnModCkpfSxlLnByb3RvdHlwZS5sdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYm4ubHRlKGUudG9CaWdOdW1iZXJKcyh0KSl9LGUucHJvdG90eXBlLmd0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ibi5ndGUoZS50b0JpZ051bWJlckpzKHQpKX0sZS5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibi5pc05hTigpfSxlLnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJuLmlzRmluaXRlKCl9LGUucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxlLnByb3RvdHlwZS5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ3QoMCl9LGUucHJvdG90eXBlLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sdCgwKX0sZS5wcm90b3R5cGUuaXNJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ibi5pc0ludGVnZXIoKX0sZS5wcm90b3R5cGUuZ2V0RGVjaW1hbHNDb3VudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJuLmRwKCl9LGUucHJvdG90eXBlLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZCgyKS5lcSgwKX0sZS5wcm90b3R5cGUuaXNPZGQ9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0V2ZW4oKX0sZS5wcm90b3R5cGUudG9CeXRlcz1mdW5jdGlvbigpe2lmKCF0aGlzLmlzSW50KCkpdGhyb3cgbmV3IEVycm9yKFwiQ2FudCBjcmVhdGUgYnl0ZXMgZnJvbSBudW1iZXIgd2l0aCBkZWNpbWFscyFcIik7dmFyIHQ9dGhpcy5pc05lZ2F0aXZlKCkscj10P1wiMVwiOlwiMFwiLG49ZS5fdG9MZW5ndGgoNjQsdGhpcy5ibi5wbHVzKHIpLmFicygpLnRvU3RyaW5nKDIpLnJlcGxhY2UoXCItXCIsXCJcIikpLnNwbGl0KFwiXCIpLGk9W107ZG97aS5wdXNoKHBhcnNlSW50KG4uc3BsaWNlKDAsOCkuam9pbihcIlwiKSwyKSl9d2hpbGUobi5sZW5ndGgpO3JldHVybiB0P1VpbnQ4QXJyYXkuZnJvbShpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIDI1NS1lfSkpKTpVaW50OEFycmF5LmZyb20oaSl9LGUucHJvdG90eXBlLnRvRm9ybWF0PWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdGhpcy5ibi50b0Zvcm1hdChlLHQscil9LGUucHJvdG90eXBlLnRvRml4ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbD09ZT90aGlzLmJuLnRvRml4ZWQoKTp0aGlzLmJuLnRvRml4ZWQoZSx0KX0sZS5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0ZpeGVkKCl9LGUucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udG9OdW1iZXIoKX0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udG9GaXhlZCgpfSxlLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm4udmFsdWVPZigpfSxlLmZyb21CeXRlcz1mdW5jdGlvbih0KXtpZig4IT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnl0ZXMgbGVuZ3RoISBOZWVkIDggYnl0ZXMhXCIpO3ZhciByPXRbMF0+MTI3LG49QXJyYXkuZnJvbSh0KS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiByPzI1NS1lOmV9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZS5fdG9MZW5ndGgoOCx0LnRvU3RyaW5nKDIpKX0pKS5qb2luKFwiXCIpLGk9bmV3IGUobmV3IGIobiwyKSk7cmV0dXJuIHI/aS5tdWwoLTEpLnN1YigxKTppfSxlLm1heD1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxyPTA7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0W3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZS50b0JpZ051bWJlcih0KS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ3RlKHQpP2U6dH0pKX0sZS5taW49ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10scj0wO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGUudG9CaWdOdW1iZXIodCkucmVkdWNlKChmdW5jdGlvbihlLHQpe3JldHVybiBlLmx0ZSh0KT9lOnR9KSl9LGUuc3VtPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXRbcl09YXJndW1lbnRzW3JdO3JldHVybiBlLnRvQmlnTnVtYmVyKHQpLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5hZGQodCl9KSl9LGUuaXNCaWdOdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYodCBpbnN0YW5jZW9mIGV8fE9iamVjdC5lbnRyaWVzKGUucHJvdG90eXBlKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVyblwiX1wiIT09ZVswXS5jaGFyQXQoMCl9KSkuZXZlcnkoKGZ1bmN0aW9uKGUpe3ZhciByPWVbMF0sbj1lWzFdO3JldHVybiByIGluIHQmJnR5cGVvZiBuPT10eXBlb2YgdFtyXX0pKSl9LGUudG9CaWdOdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0pKTpuZXcgZSh0KX0sZS50b0JpZ051bWJlckpzPWZ1bmN0aW9uKHQpe3JldHVybiBiLmlzQmlnTnVtYmVyKHQpP3Q6dCBpbnN0YW5jZW9mIGU/dC5ibjpuZXcgYih0KX0sZS5fdG9MZW5ndGg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IEFycmF5KGUpLmZpbGwoXCIwXCIsMCxlKS5jb25jYXQodC5zcGxpdChcIlwiKSkuc2xpY2UoLWUpLmpvaW4oXCJcIil9LGUuTUFYX1ZBTFVFPW5ldyBlKFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKSxlLk1JTl9WQUxVRT1uZXcgZShcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLGUuTUFYX1VOU0lHTkVEX1ZBTFVFPW5ldyBlKFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIiksZS5jb25maWc9bmV3IFMsZX0oKSxmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7ZVtlLlJPVU5EX1VQPTBdPVwiUk9VTkRfVVBcIixlW2UuUk9VTkRfRE9XTj0xXT1cIlJPVU5EX0RPV05cIixlW2UuUk9VTkRfQ0VJTD0yXT1cIlJPVU5EX0NFSUxcIixlW2UuUk9VTkRfRkxPT1I9M109XCJST1VORF9GTE9PUlwiLGVbZS5ST1VORF9IQUxGX1VQPTRdPVwiUk9VTkRfSEFMRl9VUFwiLGVbZS5ST1VORF9IQUxGX0RPV049NV09XCJST1VORF9IQUxGX0RPV05cIixlW2UuUk9VTkRfSEFMRl9FVkVOPTZdPVwiUk9VTkRfSEFMRl9FVkVOXCIsZVtlLlJPVU5EX0hBTEZfQ0VJTD03XT1cIlJPVU5EX0hBTEZfQ0VJTFwiLGVbZS5ST1VORF9IQUxGX0ZMT09SPThdPVwiUk9VTkRfSEFMRl9GTE9PUlwifShlLlJPVU5EX01PREV8fChlLlJPVU5EX01PREU9e30pKX0oZS5CaWdOdW1iZXJ8fChlLkJpZ051bWJlcj17fSkpO3ZhciBUPWUuQmlnTnVtYmVyO2UuZGVmYXVsdD1ULE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSh0KX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigyNiksaT1yKDM2KSxhPXIoMjEpO3Quc2VyaWFsaXplckZyb21TY2hlbWE9KGUscik9PmE9PntsZXQgcyxvO2lmKFwiYXJyYXlcIj09PWUudHlwZSlyZXR1cm4gcz10LnNlcmlhbGl6ZXJGcm9tU2NoZW1hKGUuaXRlbXMsciksbz1pLmNvbmNhdCguLi5hLm1hcChlPT5zKGUpKSksaS5jb25jYXQoKGUudG9CeXRlc3x8bi5TSE9SVCkoYS5sZW5ndGgpLG8pO2lmKFwib2JqZWN0XCI9PT1lLnR5cGUpe2xldCBuPVVpbnQ4QXJyYXkuZnJvbShbXSk7aWYoZS5vcHRpb25hbCYmbnVsbD09YSlyZXR1cm4gVWludDhBcnJheS5mcm9tKFswXSk7aWYoZS5zY2hlbWEuZm9yRWFjaChlPT57Y29uc3RbdSxjXT1lO2xldCBsO2w9QXJyYXkuaXNBcnJheSh1KT91LnJlZHVjZSgoZSx0KT0+T2JqZWN0LmFzc2lnbih7fSxlLHtbdF06YVt0XX0pLHt9KTphW3VdLHM9dC5zZXJpYWxpemVyRnJvbVNjaGVtYShjLHIpLG89cyhsKSxuPWkuY29uY2F0KG4sbyl9KSxlLndpdGhMZW5ndGgpe2NvbnN0IHQ9ZS53aXRoTGVuZ3RoLnRvQnl0ZXMobi5sZW5ndGgpO249aS5jb25jYXQodCxuKX1yZXR1cm4gZS5vcHRpb25hbCYmKG49aS5jb25jYXQoWzFdLG4pKSxufWlmKFwiYW55T2ZcIj09PWUudHlwZSl7Y29uc3QgdT1hW2UuZGlzY3JpbWluYXRvckZpZWxkXSxjPWUuaXRlbUJ5S2V5KHUpO2lmKG51bGw9PWMpdGhyb3cgbmV3IEVycm9yKGBTZXJpYWxpemVyIEVycm9yOiBVbmtub3duIGFueU9mIHR5cGU6ICR7dX1gKTtyZXR1cm5cImJvb2xlYW5cIj09PWMuc3RyS2V5JiY2PT09Yy5rZXkmJiExPT09YS52YWx1ZSYmKGMua2V5PTcpLHM9dC5zZXJpYWxpemVyRnJvbVNjaGVtYShjLnNjaGVtYSxyKSxudWxsPT1lLnZhbHVlRmllbGQ/cyhhKToobz1zKGFbZS52YWx1ZUZpZWxkXSksaS5jb25jYXQoKGUudG9CeXRlc3x8bi5CWVRFKShjLmtleSksbykpfWlmKFwicHJpbWl0aXZlXCI9PT1lLnR5cGV8fHZvaWQgMD09PWUudHlwZSlyZXR1cm4gZS50b0J5dGVzKGEpO2lmKFwiZGF0YVR4RmllbGRcIj09PWUudHlwZSl7Y29uc3QgdT1uLkxFTihuLlNIT1JUKShuLlNUUklORykoYS5rZXkpLGM9YS50eXBlLGw9ZS5pdGVtcy5nZXQoYyk7aWYobnVsbD09bCl0aHJvdyBuZXcgRXJyb3IoYFNlcmlhbGl6ZXIgRXJyb3I6IFVua25vd24gZGF0YVR4RmllbGQgdHlwZTogJHtjfWApO2NvbnN0IGY9Wy4uLmUuaXRlbXMudmFsdWVzKCldLmZpbmRJbmRleChlPT5lPT09bCk7cmV0dXJuIHM9dC5zZXJpYWxpemVyRnJvbVNjaGVtYShsLHIpLG89cyhhLnZhbHVlKSxpLmNvbmNhdCh1LG4uQllURShmKSxvKX10aHJvdyBuZXcgRXJyb3IoYFNlcmlhbGl6ZXIgRXJyb3I6IFVua25vd24gc2NoZW1hIHR5cGU6ICR7ZS50eXBlfWApfSx0LnNlcmlhbGl6ZVR4PWZ1bmN0aW9uKGUscil7Y29uc3R7dHlwZTpuLHZlcnNpb246aX09ZSxzPWEuZ2V0VHJhbnNhY3Rpb25TY2hlbWEobixpKTtyZXR1cm4gdC5zZXJpYWxpemVyRnJvbVNjaGVtYShzLHIpKGUpfSx0LnNlcmlhbGl6ZU9yZGVyPWZ1bmN0aW9uKGUscil7Y29uc3Qgbj1lLnZlcnNpb258fDEsaT1hLm9yZGVyVmVyc2lvbk1hcFtuXTtpZihudWxsPT1pKXRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcmRlciB2ZXJzaW9uOiAke259YCk7cmV0dXJuIHQuc2VyaWFsaXplckZyb21TY2hlbWEoaSxyKShlKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNiksaT17b3JkZXJUeXBlOm4ub3JFcShbXCJzZWxsXCIsXCJidXlcIl0pLHNlbmRlclB1YmxpY0tleTpuLmlzUHVibGljS2V5LG1hdGNoZXJQdWJsaWNLZXk6bi5pc1B1YmxpY0tleSx2ZXJzaW9uOm4ub3JFcShbdm9pZCAwLDAsMSwyLDNdKSxhc3NldFBhaXI6bi52YWxpZGF0ZVBpcGUobi5pc1JlcXVpcmVkKCEwKSxuLnBpcGUobi5wcm9wKFwiYW1vdW50QXNzZXRcIiksbi5pc0Fzc2V0SWQpLG4ucGlwZShuLnByb3AoXCJwcmljZUFzc2V0XCIpLG4uaXNBc3NldElkKSkscHJpY2U6bi5pc051bWJlckxpa2UsYW1vdW50Om4uaXNOdW1iZXJMaWtlLG1hdGNoZXJGZWU6bi5pc051bWJlckxpa2UsZXhwaXJhdGlvbjpuLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6bi5pc051bWJlcixwcm9vZnM6bi5pZkVsc2Uobi5pc0FycmF5LG4uZGVmYXVsdFZhbHVlKCEwKSxuLm9yRXEoW3ZvaWQgMF0pKX0sYT17bWF0Y2hlckZlZUFzc2V0SWQ6bi5vckVxKFt2b2lkIDAsbnVsbCxcIldBVkVTXCJdKX0scz17bWF0Y2hlckZlZUFzc2V0SWQ6bi5pc0Fzc2V0SWR9LG89bi52YWxpZGF0ZUJ5U2hlbWEoaSxuLmdldEVycm9yKSx1PW4udmFsaWRhdGVCeVNoZW1hKGEsbi5nZXRFcnJvciksYz1uLnZhbGlkYXRlQnlTaGVtYShzLG4uZ2V0RXJyb3IpO3Qub3JkZXJWYWxpZGF0b3I9bi52YWxpZGF0ZVBpcGUobyxuLmlmRWxzZShuLnBpcGUobi5wcm9wKFwidmVyc2lvblwiKSxuLmlzRXEoMykpLGMsdSkpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDQpLGk9cigzKSxhPXIoMykscz1yKDUpO2Z1bmN0aW9uIG8oZSl7aWYoMT09PWUudmVyc2lvbilyZXR1cm4gbi5jb25jYXQoWzI1NSwyNTUsMjU1LDFdLGkuc2VyaWFsaXplUHJpbWl0aXZlcy5CQVNFNjRfU1RSSU5HKGUuYmluYXJ5KSk7aWYoMj09PWUudmVyc2lvbil7Y29uc3QgdD1hLmJpbmFyeS5zZXJpYWxpemVyRnJvbVNjaGVtYShpLnNjaGVtYXMudHhGaWVsZHMuZGF0YVsxXSk7cmV0dXJuIG4uY29uY2F0KFsyNTUsMjU1LDI1NSwyXSx0KGUuZGF0YSkpfXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDdXN0b21EYXRhIHZlcnNpb246ICR7ZS52ZXJzaW9ufWApfXQuY3VzdG9tRGF0YT1mdW5jdGlvbihlLHQpe3MudmFsaWRhdGUuY3VzdG9tRGF0YShlKTtsZXQgcj1vKGUpO2NvbnN0IGk9bi5iYXNlNThFbmNvZGUobi5ibGFrZTJiKHIpKSxhPWUucHVibGljS2V5P2UucHVibGljS2V5OnQmJm4ucHVibGljS2V5KHQpLHU9dCYmbi5zaWduQnl0ZXModCxyKTtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxlLHtoYXNoOmkscHVibGljS2V5OmEsc2lnbmF0dXJlOnV9KX0sdC5zZXJpYWxpemVDdXN0b21EYXRhPW99LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNCksaT1yKDMpLHtTVFJJTkc6YSxMRU46cyxTSE9SVDpvfT1pLnNlcmlhbGl6ZVByaW1pdGl2ZXMsdT1yKDcpLGM9cig1KTt0LnNlcmlhbGl6ZUF1dGhEYXRhPWU9Pm4uY29uY2F0KHMobykoYSkoXCJXYXZlc1dhbGxldEF1dGhlbnRpY2F0aW9uXCIpLHMobykoYSkoZS5ob3N0fHxcIlwiKSxzKG8pKGEpKGUuZGF0YXx8XCJcIikpLHQuYXV0aD1mdW5jdGlvbihlLHIsaSl7Y29uc3QgYT11LmNvbnZlcnRUb1BhaXJzKHIpLHM9ZS5wdWJsaWNLZXl8fHUuZ2V0U2VuZGVyUHVibGljS2V5KGEse3NlbmRlclB1YmxpY0tleTp2b2lkIDB9KTtjLnZhbGlkYXRlLmF1dGgoZSk7Y29uc3Qgbz17aGFzaDpcIlwiLHNpZ25hdHVyZTpcIlwiLGhvc3Q6ZS5ob3N0LGRhdGE6ZS5kYXRhLHB1YmxpY0tleTpzLGFkZHJlc3M6bi5hZGRyZXNzKHtwdWJsaWNLZXk6c30saSl9LGw9dC5zZXJpYWxpemVBdXRoRGF0YShvKTtyZXR1cm4gby5zaWduYXR1cmU9bnVsbCE9ciYmbi5zaWduQnl0ZXMocixsKXx8XCJcIixvLmhhc2g9bi5iYXNlNThFbmNvZGUobi5ibGFrZTJiKFVpbnQ4QXJyYXkuZnJvbShsKSkpLG99fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDQpLGk9cigzKSx7TE9ORzphLEJBU0U1OF9TVFJJTkc6c309aS5zZXJpYWxpemVQcmltaXRpdmVzLG89cig3KSx1PXIoNSk7dC5zZXJpYWxpemVXYXZlc0F1dGhEYXRhPWU9Pm4uY29uY2F0KHMoZS5wdWJsaWNLZXkpLGEoZS50aW1lc3RhbXApKSx0LndhdmVzQXV0aD1mdW5jdGlvbihlLHIsaSl7Y29uc3QgYT1vLmNvbnZlcnRUb1BhaXJzKHIpLHM9ZS5wdWJsaWNLZXl8fG8uZ2V0U2VuZGVyUHVibGljS2V5KGEse3NlbmRlclB1YmxpY0tleTp2b2lkIDB9KSxjPWUudGltZXN0YW1wfHxEYXRlLm5vdygpO3UudmFsaWRhdGUud2F2ZXNBdXRoKHtwdWJsaWNLZXk6cyx0aW1lc3RhbXA6Y30pO2NvbnN0IGw9e2hhc2g6XCJcIixzaWduYXR1cmU6XCJcIix0aW1lc3RhbXA6YyxwdWJsaWNLZXk6cyxhZGRyZXNzOm4uYWRkcmVzcyh7cHVibGljS2V5OnN9LGkpfSxmPXQuc2VyaWFsaXplV2F2ZXNBdXRoRGF0YShsKTtyZXR1cm4gbC5zaWduYXR1cmU9YS5tYXAoKFtlXSk9Pm4uc2lnbkJ5dGVzKGUsZikpWzBdfHxcIlwiLGwuaGFzaD1uLmJhc2U1OEVuY29kZShuLmJsYWtlMmIoVWludDhBcnJheS5mcm9tKGYpKSksbH19LGZ1bmN0aW9uKGUsdCxyKXtlLmV4cG9ydHM9cigxMzcpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciByPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKSxuPTA7bjxyLmxlbmd0aDtuKyspcltuXT1hcmd1bWVudHNbbl07cmV0dXJuIGUuYXBwbHkodCxyKX19fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KTtmdW5jdGlvbiBpKGUpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQoZSkucmVwbGFjZSgvJTQwL2dpLFwiQFwiKS5yZXBsYWNlKC8lM0EvZ2ksXCI6XCIpLnJlcGxhY2UoLyUyNC9nLFwiJFwiKS5yZXBsYWNlKC8lMkMvZ2ksXCIsXCIpLnJlcGxhY2UoLyUyMC9nLFwiK1wiKS5yZXBsYWNlKC8lNUIvZ2ksXCJbXCIpLnJlcGxhY2UoLyU1RC9naSxcIl1cIil9ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXtpZighdClyZXR1cm4gZTt2YXIgYTtpZihyKWE9cih0KTtlbHNlIGlmKG4uaXNVUkxTZWFyY2hQYXJhbXModCkpYT10LnRvU3RyaW5nKCk7ZWxzZXt2YXIgcz1bXTtuLmZvckVhY2godCwoZnVuY3Rpb24oZSx0KXtudWxsIT1lJiYobi5pc0FycmF5KGUpP3QrPVwiW11cIjplPVtlXSxuLmZvckVhY2goZSwoZnVuY3Rpb24oZSl7bi5pc0RhdGUoZSk/ZT1lLnRvSVNPU3RyaW5nKCk6bi5pc09iamVjdChlKSYmKGU9SlNPTi5zdHJpbmdpZnkoZSkpLHMucHVzaChpKHQpK1wiPVwiK2koZSkpfSkpKX0pKSxhPXMuam9pbihcIiZcIil9aWYoYSl7dmFyIG89ZS5pbmRleE9mKFwiI1wiKTstMSE9PW8mJihlPWUuc2xpY2UoMCxvKSksZSs9KC0xPT09ZS5pbmRleE9mKFwiP1wiKT9cIj9cIjpcIiZcIikrYX1yZXR1cm4gZX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuISghZXx8IWUuX19DQU5DRUxfXyl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKHQpe3ZhciBuPXIoOCksaT1yKDE0MyksYT17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifTtmdW5jdGlvbiBzKGUsdCl7IW4uaXNVbmRlZmluZWQoZSkmJm4uaXNVbmRlZmluZWQoZVtcIkNvbnRlbnQtVHlwZVwiXSkmJihlW1wiQ29udGVudC1UeXBlXCJdPXQpfXZhciBvLHU9e2FkYXB0ZXI6KHZvaWQgMCE9PXQmJlwiW29iamVjdCBwcm9jZXNzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpP289cig3Nyk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFhNTEh0dHBSZXF1ZXN0JiYobz1yKDc3KSksbyksdHJhbnNmb3JtUmVxdWVzdDpbZnVuY3Rpb24oZSx0KXtyZXR1cm4gaSh0LFwiQWNjZXB0XCIpLGkodCxcIkNvbnRlbnQtVHlwZVwiKSxuLmlzRm9ybURhdGEoZSl8fG4uaXNBcnJheUJ1ZmZlcihlKXx8bi5pc0J1ZmZlcihlKXx8bi5pc1N0cmVhbShlKXx8bi5pc0ZpbGUoZSl8fG4uaXNCbG9iKGUpP2U6bi5pc0FycmF5QnVmZmVyVmlldyhlKT9lLmJ1ZmZlcjpuLmlzVVJMU2VhcmNoUGFyYW1zKGUpPyhzKHQsXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiKSxlLnRvU3RyaW5nKCkpOm4uaXNPYmplY3QoZSk/KHModCxcImFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOFwiKSxKU09OLnN0cmluZ2lmeShlKSk6ZX1dLHRyYW5zZm9ybVJlc3BvbnNlOltmdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSl0cnl7ZT1KU09OLnBhcnNlKGUpfWNhdGNoKGUpe31yZXR1cm4gZX1dLHRpbWVvdXQ6MCx4c3JmQ29va2llTmFtZTpcIlhTUkYtVE9LRU5cIix4c3JmSGVhZGVyTmFtZTpcIlgtWFNSRi1UT0tFTlwiLG1heENvbnRlbnRMZW5ndGg6LTEsdmFsaWRhdGVTdGF0dXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGU+PTIwMCYmZTwzMDB9fTt1LmhlYWRlcnM9e2NvbW1vbjp7QWNjZXB0OlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qXCJ9fSxuLmZvckVhY2goW1wiZGVsZXRlXCIsXCJnZXRcIixcImhlYWRcIl0sKGZ1bmN0aW9uKGUpe3UuaGVhZGVyc1tlXT17fX0pKSxuLmZvckVhY2goW1wicG9zdFwiLFwicHV0XCIsXCJwYXRjaFwiXSwoZnVuY3Rpb24oZSl7dS5oZWFkZXJzW2VdPW4ubWVyZ2UoYSl9KSksZS5leHBvcnRzPXV9KS5jYWxsKHRoaXMscigxOCkpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KSxpPXIoMTQ0KSxhPXIoNzQpLHM9cigxNDYpLG89cigxNDcpLHU9cig3OCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCxjKXt2YXIgbD1lLmRhdGEsZj1lLmhlYWRlcnM7bi5pc0Zvcm1EYXRhKGwpJiZkZWxldGUgZltcIkNvbnRlbnQtVHlwZVwiXTt2YXIgaD1uZXcgWE1MSHR0cFJlcXVlc3Q7aWYoZS5hdXRoKXt2YXIgcD1lLmF1dGgudXNlcm5hbWV8fFwiXCIsZD1lLmF1dGgucGFzc3dvcmR8fFwiXCI7Zi5BdXRob3JpemF0aW9uPVwiQmFzaWMgXCIrYnRvYShwK1wiOlwiK2QpfWlmKGgub3BlbihlLm1ldGhvZC50b1VwcGVyQ2FzZSgpLGEoZS51cmwsZS5wYXJhbXMsZS5wYXJhbXNTZXJpYWxpemVyKSwhMCksaC50aW1lb3V0PWUudGltZW91dCxoLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGgmJjQ9PT1oLnJlYWR5U3RhdGUmJigwIT09aC5zdGF0dXN8fGgucmVzcG9uc2VVUkwmJjA9PT1oLnJlc3BvbnNlVVJMLmluZGV4T2YoXCJmaWxlOlwiKSkpe3ZhciByPVwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXCJpbiBoP3MoaC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk6bnVsbCxuPXtkYXRhOmUucmVzcG9uc2VUeXBlJiZcInRleHRcIiE9PWUucmVzcG9uc2VUeXBlP2gucmVzcG9uc2U6aC5yZXNwb25zZVRleHQsc3RhdHVzOmguc3RhdHVzLHN0YXR1c1RleHQ6aC5zdGF0dXNUZXh0LGhlYWRlcnM6cixjb25maWc6ZSxyZXF1ZXN0Omh9O2kodCxjLG4pLGg9bnVsbH19LGgub25hYm9ydD1mdW5jdGlvbigpe2gmJihjKHUoXCJSZXF1ZXN0IGFib3J0ZWRcIixlLFwiRUNPTk5BQk9SVEVEXCIsaCkpLGg9bnVsbCl9LGgub25lcnJvcj1mdW5jdGlvbigpe2ModShcIk5ldHdvcmsgRXJyb3JcIixlLG51bGwsaCkpLGg9bnVsbH0saC5vbnRpbWVvdXQ9ZnVuY3Rpb24oKXtjKHUoXCJ0aW1lb3V0IG9mIFwiK2UudGltZW91dCtcIm1zIGV4Y2VlZGVkXCIsZSxcIkVDT05OQUJPUlRFRFwiLGgpKSxoPW51bGx9LG4uaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSl7dmFyIHk9cigxNDgpLGc9KGUud2l0aENyZWRlbnRpYWxzfHxvKGUudXJsKSkmJmUueHNyZkNvb2tpZU5hbWU/eS5yZWFkKGUueHNyZkNvb2tpZU5hbWUpOnZvaWQgMDtnJiYoZltlLnhzcmZIZWFkZXJOYW1lXT1nKX1pZihcInNldFJlcXVlc3RIZWFkZXJcImluIGgmJm4uZm9yRWFjaChmLChmdW5jdGlvbihlLHQpe3ZvaWQgMD09PWwmJlwiY29udGVudC10eXBlXCI9PT10LnRvTG93ZXJDYXNlKCk/ZGVsZXRlIGZbdF06aC5zZXRSZXF1ZXN0SGVhZGVyKHQsZSl9KSksZS53aXRoQ3JlZGVudGlhbHMmJihoLndpdGhDcmVkZW50aWFscz0hMCksZS5yZXNwb25zZVR5cGUpdHJ5e2gucmVzcG9uc2VUeXBlPWUucmVzcG9uc2VUeXBlfWNhdGNoKHQpe2lmKFwianNvblwiIT09ZS5yZXNwb25zZVR5cGUpdGhyb3cgdH1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLm9uRG93bmxvYWRQcm9ncmVzcyYmaC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIixlLm9uRG93bmxvYWRQcm9ncmVzcyksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vblVwbG9hZFByb2dyZXNzJiZoLnVwbG9hZCYmaC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsZS5vblVwbG9hZFByb2dyZXNzKSxlLmNhbmNlbFRva2VuJiZlLmNhbmNlbFRva2VuLnByb21pc2UudGhlbigoZnVuY3Rpb24oZSl7aCYmKGguYWJvcnQoKSxjKGUpLGg9bnVsbCl9KSksdm9pZCAwPT09bCYmKGw9bnVsbCksaC5zZW5kKGwpfSkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTQ1KTtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsaSxhKXt2YXIgcz1uZXcgRXJyb3IoZSk7cmV0dXJuIG4ocyx0LHIsaSxhKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDgpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3Q9dHx8e307dmFyIHI9e307cmV0dXJuIG4uZm9yRWFjaChbXCJ1cmxcIixcIm1ldGhvZFwiLFwicGFyYW1zXCIsXCJkYXRhXCJdLChmdW5jdGlvbihlKXt2b2lkIDAhPT10W2VdJiYocltlXT10W2VdKX0pKSxuLmZvckVhY2goW1wiaGVhZGVyc1wiLFwiYXV0aFwiLFwicHJveHlcIl0sKGZ1bmN0aW9uKGkpe24uaXNPYmplY3QodFtpXSk/cltpXT1uLmRlZXBNZXJnZShlW2ldLHRbaV0pOnZvaWQgMCE9PXRbaV0/cltpXT10W2ldOm4uaXNPYmplY3QoZVtpXSk/cltpXT1uLmRlZXBNZXJnZShlW2ldKTp2b2lkIDAhPT1lW2ldJiYocltpXT1lW2ldKX0pKSxuLmZvckVhY2goW1wiYmFzZVVSTFwiLFwidHJhbnNmb3JtUmVxdWVzdFwiLFwidHJhbnNmb3JtUmVzcG9uc2VcIixcInBhcmFtc1NlcmlhbGl6ZXJcIixcInRpbWVvdXRcIixcIndpdGhDcmVkZW50aWFsc1wiLFwiYWRhcHRlclwiLFwicmVzcG9uc2VUeXBlXCIsXCJ4c3JmQ29va2llTmFtZVwiLFwieHNyZkhlYWRlck5hbWVcIixcIm9uVXBsb2FkUHJvZ3Jlc3NcIixcIm9uRG93bmxvYWRQcm9ncmVzc1wiLFwibWF4Q29udGVudExlbmd0aFwiLFwidmFsaWRhdGVTdGF0dXNcIixcIm1heFJlZGlyZWN0c1wiLFwiaHR0cEFnZW50XCIsXCJodHRwc0FnZW50XCIsXCJjYW5jZWxUb2tlblwiLFwic29ja2V0UGF0aFwiXSwoZnVuY3Rpb24obil7dm9pZCAwIT09dFtuXT9yW25dPXRbbl06dm9pZCAwIT09ZVtuXSYmKHJbbl09ZVtuXSl9KSkscn19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKGUpe3RoaXMubWVzc2FnZT1lfW4ucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJDYW5jZWxcIisodGhpcy5tZXNzYWdlP1wiOiBcIit0aGlzLm1lc3NhZ2U6XCJcIil9LG4ucHJvdG90eXBlLl9fQ0FOQ0VMX189ITAsZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoKGZ1bmN0aW9uKGksYSl7ZnVuY3Rpb24gcyhlKXt0cnl7dShuLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIG8oZSl7dHJ5e3Uobi50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gdShlKXtlLmRvbmU/aShlLnZhbHVlKTpuZXcgcigoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pKS50aGVuKHMsbyl9dSgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IGE9aShyKDcyKSkscz1yKDMpLG89ZT0+e2NvbnN0IHQ9e30scj1uZXcgUHJvbWlzZSgocixuKT0+e3QucmVzb2x2ZT1yLHQuaWQ9c2V0VGltZW91dCgoKT0+cigpLGUpfSk7cmV0dXJuIHIuY2FuY2VsPSgpPT57dC5yZXNvbHZlKCksY2xlYXJUaW1lb3V0KHQuaWQpfSxyfSx1PShlLHQscj0xZTMpPT5vKHIpLnRoZW4ocj0+dD9Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUeCB3YWl0IHN0b3BwZWQ6IHRpbWVvdXRcIikpOmUoKSksYz17dGltZW91dDoxMmU0LGFwaUJhc2U6XCJodHRwczovL25vZGVzLndhdmVzcGxhdGZvcm0uY29tXCJ9O2Z1bmN0aW9uIGwoZSxyKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0e3RpbWVvdXQ6bixhcGlCYXNlOml9PU9iamVjdC5hc3NpZ24oe30sYyxyKTtsZXQgYT0hMTtjb25zdCBzPW8obik7cy50aGVuKCgpPT5hPSEwKTtjb25zdCBsPSgpPT50LmN1cnJlbnRIZWlnaHQoaSkudGhlbih0PT50Pj1lPyhzLmNhbmNlbCgpLHQpOnUobCxhLDFlNCkpLmNhdGNoKGU9PnUobCxhKSk7cmV0dXJuIGwoKX0pKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdHt0aW1lb3V0OnIsYXBpQmFzZTpufT1PYmplY3QuYXNzaWduKHt9LGMsdCk7bGV0IGk9ITE7Y29uc3Qgcz1vKHIpO3MudGhlbigoKT0+aT0hMCk7Y29uc3QgdT0oKT0+YS5kZWZhdWx0LmdldChgdHJhbnNhY3Rpb25zL2luZm8vJHtlfWAse2Jhc2VVUkw6bn0pLnRoZW4oZT0+KHMuY2FuY2VsKCksZS5kYXRhKSkuY2F0Y2goZT0+bygxZTMpLnRoZW4oZT0+aT9Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUeCB3YWl0IHN0b3BwZWQ6IHRpbWVvdXRcIikpOnUoKSkpO3JldHVybiB1KCl9KSl9dC5jdXJyZW50SGVpZ2h0PWU9Pm4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4geWllbGQgYS5kZWZhdWx0LmdldChcIi9ibG9ja3MvaGVpZ2h0XCIse2Jhc2VVUkw6ZX0pLnRoZW4oZT0+ZS5kYXRhJiZlLmRhdGEuaGVpZ2h0KX0pKSx0LndhaXRGb3JIZWlnaHQ9bCx0LndhaXRGb3JUeD1mO2NvbnN0IGg9ZT0+NDAwPT09ZS5zdGF0dXM/UHJvbWlzZS5yZWplY3QoT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IsZS5kYXRhKSk6ZSxwPWU9PjQwMD09PWV8fGU+PTIwMCYmZTwzMDA7dC53YWl0Rm9yVHhXaXRoTkNvbmZpcm1hdGlvbnM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3R7dGltZW91dDpufT1PYmplY3QuYXNzaWduKHt9LGMscik7bGV0IGk9ITE7byhuKS50aGVuKCgpPT5pPSEwKTtsZXQgYT15aWVsZCBmKGUscikscz1hLmhlaWdodCx1PWEuaGVpZ2h0O2Zvcig7cyt0PnU7KXtpZihpKXRocm93IG5ldyBFcnJvcihcIlR4IHdhaXQgc3RvcHBlZDogdGltZW91dFwiKTt5aWVsZCBsKHMrdCxyKSxhPXlpZWxkIGYoZSxyKSxzPWEuaGVpZ2h0fXJldHVybiBhfSkpfSx0LndhaXROQmxvY2tzPWZ1bmN0aW9uKGUscj1jKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0e2FwaUJhc2U6bn09T2JqZWN0LmFzc2lnbih7fSxjLHIpLGk9KHlpZWxkIHQuY3VycmVudEhlaWdodChuKSkrZTtyZXR1cm4geWllbGQgbChpLHIpfSkpfSx0LnRyYW5zYWN0aW9uQnlJZD1mdW5jdGlvbihlLHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIGEuZGVmYXVsdC5nZXQoYHRyYW5zYWN0aW9ucy9pbmZvLyR7ZX1gLHtiYXNlVVJMOnQsdmFsaWRhdGVTdGF0dXM6ZT0+NDA0PT09ZXx8cChlKX0pLnRoZW4oZT0+MzExPT09ZS5kYXRhLmVycm9yP251bGw6ZS5kYXRhKX0pKX0sdC5iYWxhbmNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gYS5kZWZhdWx0LmdldChgYWRkcmVzc2VzL2JhbGFuY2UvJHtlfWAse2Jhc2VVUkw6dCx2YWxpZGF0ZVN0YXR1czpwfSkudGhlbihoKS50aGVuKGU9PmUuZGF0YS5iYWxhbmNlKX0pKX0sdC5iYWxhbmNlRGV0YWlscz1mdW5jdGlvbihlLHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIGEuZGVmYXVsdC5nZXQoYGFkZHJlc3Nlcy9iYWxhbmNlL2RldGFpbHMvJHtlfWAse2Jhc2VVUkw6dCx2YWxpZGF0ZVN0YXR1czpwfSkudGhlbihoKS50aGVuKGU9PmUuZGF0YSl9KSl9LHQuYXNzZXRCYWxhbmNlPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiBhLmRlZmF1bHQuZ2V0KGBhc3NldHMvYmFsYW5jZS8ke3R9LyR7ZX1gLHtiYXNlVVJMOnIsdmFsaWRhdGVTdGF0dXM6cH0pLnRoZW4oaCkudGhlbihlPT5lLmRhdGEuYmFsYW5jZSl9KSl9LHQuYWNjb3VudERhdGE9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2xldCByLG47XCJzdHJpbmdcIj09dHlwZW9mIGU/KHI9ZSxuPXZvaWQgMCk6KHI9ZS5hZGRyZXNzLG49ZS5tYXRjaCYmZW5jb2RlVVJJQ29tcG9uZW50KFwic3RyaW5nXCI9PXR5cGVvZiBlLm1hdGNoP2UubWF0Y2g6ZS5tYXRjaC5zb3VyY2UpKTtjb25zdCBpPWBhZGRyZXNzZXMvZGF0YS8ke3J9YCxzPXtiYXNlVVJMOnQscGFyYW1zOnttYXRjaGVzOm59LHZhbGlkYXRlU3RhdHVzOnB9O3JldHVybih5aWVsZCBhLmRlZmF1bHQuZ2V0KGkscykudGhlbihoKS50aGVuKGU9PmUuZGF0YSkpLnJlZHVjZSgoZSx0KT0+T2JqZWN0LmFzc2lnbih7fSxlLHtbdC5rZXldOnR9KSx7fSl9KSl9LHQuYWNjb3VudERhdGFCeUtleT1mdW5jdGlvbihlLHQscil7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gYS5kZWZhdWx0LmdldChgYWRkcmVzc2VzL2RhdGEvJHt0fS8ke2V9YCx7YmFzZVVSTDpyLHZhbGlkYXRlU3RhdHVzOmU9PjQwND09PWV8fHAoZSl9KS50aGVuKGgpLnRoZW4oZT0+NDA0PT09ZS5zdGF0dXM/bnVsbDplLmRhdGEpfSkpfSx0LnNjcmlwdEluZm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiBhLmRlZmF1bHQuZ2V0KGBhZGRyZXNzZXMvc2NyaXB0SW5mby8ke2V9YCx7YmFzZVVSTDp0LHZhbGlkYXRlU3RhdHVzOmU9PnAoZSl9KS50aGVuKGgpLnRoZW4oZT0+ZS5kYXRhKX0pKX0sdC5zY3JpcHRNZXRhPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gYS5kZWZhdWx0LmdldChgYWRkcmVzc2VzL3NjcmlwdEluZm8vJHtlfS9tZXRhYCx7YmFzZVVSTDp0LHZhbGlkYXRlU3RhdHVzOmU9PnAoZSl9KS50aGVuKGgpLnRoZW4oZT0+ZS5kYXRhKX0pKX0sdC5yZXdhcmRzPWZ1bmN0aW9uKC4uLmUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7bGV0IHQscj1cImJsb2NrY2hhaW4vcmV3YXJkcy9cIjtyZXR1cm4gdm9pZCAwIT09ZVsxXT8ocis9ZVswXS50b1N0cmluZygpLHQ9ZVsxXSk6dD1lWzBdLGEuZGVmYXVsdC5nZXQocix7YmFzZVVSTDp0LHZhbGlkYXRlU3RhdHVzOmU9PnAoZSl9KS50aGVuKGgpLnRoZW4oZT0+ZS5kYXRhKX0pKX0sdC5zdGF0ZUNoYW5nZXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiBhLmRlZmF1bHQuZ2V0KGBkZWJ1Zy9zdGF0ZUNoYW5nZXMvaW5mby8ke2V9YCx7YmFzZVVSTDp0LHZhbGlkYXRlU3RhdHVzOmU9PnAoZSl9KS50aGVuKGgpLnRoZW4oZT0+ZS5kYXRhJiZlLmRhdGEuc3RhdGVDaGFuZ2VzKX0pKX0sdC5icm9hZGNhc3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gYS5kZWZhdWx0LnBvc3QoXCJ0cmFuc2FjdGlvbnMvYnJvYWRjYXN0XCIscy5qc29uLnN0cmluZ2lmeVR4KGUpLHtiYXNlVVJMOnQsaGVhZGVyczp7XCJjb250ZW50LXR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIn0sdmFsaWRhdGVTdGF0dXM6cH0pLnRoZW4oaCkudGhlbihlPT5lLmRhdGEpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPXIoODMpO3QuUHJvdmlkZXJTZWVkPW4uUHJvdmlkZXJTZWVkLHQuZGVmYXVsdD1uLlByb3ZpZGVyU2VlZH0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19hc3NpZ258fGZ1bmN0aW9uKCl7cmV0dXJuKG49T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHI9MSxuPWFyZ3VtZW50cy5sZW5ndGg7cjxuO3IrKylmb3IodmFyIGkgaW4gdD1hcmd1bWVudHNbcl0pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsaSkmJihlW2ldPXRbaV0pO3JldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1yKDg0KSxhPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLl9vcHRpb25zPXtORVRXT1JLX0JZVEU6XCJXXCIuY2hhckNvZGVBdCgwKSxOT0RFX1VSTDpcImh0dHBzOi8vbm9kZXMud2F2ZXNwbGF0Zm9ybS5jb21cIn0sdGhpcy5fc2VlZD1lfHxpLmxpYnMuY3J5cHRvLnJhbmRvbVNlZWQoKX1yZXR1cm4gZS5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fb3B0aW9ucz1lLFByb21pc2UucmVzb2x2ZSgpfSxlLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIFByb21pc2UucmVzb2x2ZShlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGkuc2lnblR4KG4oe2NoYWluSWQ6dC5fb3B0aW9ucy5ORVRXT1JLX0JZVEV9LGUpLHQuX3NlZWQpfSkpKX0sZS5wcm90b3R5cGUubG9naW49ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHthZGRyZXNzOmkubGlicy5jcnlwdG8uYWRkcmVzcyh0aGlzLl9zZWVkLHRoaXMuX29wdGlvbnMuTkVUV09SS19CWVRFKSxwdWJsaWNLZXk6aS5saWJzLmNyeXB0by5wdWJsaWNLZXkodGhpcy5fc2VlZCl9KX0sZS5wcm90b3R5cGUubG9nb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfSxlLnByb3RvdHlwZS5zaWduVHlwZWREYXRhPWZ1bmN0aW9uKGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoXCIvLyBUT0RPXCIpfSxlLnByb3RvdHlwZS5zaWduTWVzc2FnZT1mdW5jdGlvbihlKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFwiLy8gVE9ET1wiKX0sZX0oKTt0LlByb3ZpZGVyU2VlZD1hfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgaT1yKDI3KTt0Lm1hc3NUcmFuc2Zlcj1pLm1hc3NUcmFuc2Zlcjt2YXIgYT1yKDM4KTt0LnJlaXNzdWU9YS5yZWlzc3VlO3ZhciBzPXIoMzkpO3QuYnVybj1zLmJ1cm47dmFyIG89cig0MCk7dC5leGNoYW5nZT1vLmV4Y2hhbmdlO3ZhciB1PXIoNDEpO3QubGVhc2U9dS5sZWFzZTt2YXIgYz1yKDQyKTt0LmNhbmNlbExlYXNlPWMuY2FuY2VsTGVhc2U7dmFyIGw9cig0Myk7dC5kYXRhPWwuZGF0YTt2YXIgZj1yKDQ0KTt0Lmlzc3VlPWYuaXNzdWU7dmFyIGg9cig0NSk7dC50cmFuc2Zlcj1oLnRyYW5zZmVyO3ZhciBwPXIoNDYpO3QuYWxpYXM9cC5hbGlhczt2YXIgZD1yKDQ3KTt0LnNldFNjcmlwdD1kLnNldFNjcmlwdDt2YXIgeT1yKDQ4KTt0LnNldEFzc2V0U2NyaXB0PXkuc2V0QXNzZXRTY3JpcHQ7dmFyIGc9cig0OSk7dC5zcG9uc29yc2hpcD1nLnNwb25zb3JzaGlwO3ZhciBtPXIoMTM0KTt0Lm9yZGVyPW0ub3JkZXI7dmFyIHY9cigxMzUpO3QuY2FuY2VsT3JkZXI9di5jYW5jZWxPcmRlcjt2YXIgYj1yKDY5KTt0LmN1c3RvbURhdGE9Yi5jdXN0b21EYXRhLHQuc2VyaWFsaXplQ3VzdG9tRGF0YT1iLnNlcmlhbGl6ZUN1c3RvbURhdGE7dmFyIEU9cig3MCk7dC5hdXRoPUUuYXV0aDt2YXIgUz1yKDcxKTt0LndhdmVzQXV0aD1TLndhdmVzQXV0aDt2YXIgVD1yKDUwKTt0Lmludm9rZVNjcmlwdD1ULmludm9rZVNjcmlwdDt2YXIgQz1yKDEzNik7dC5zaWduVHg9Qy5zaWduVHgsdC52ZXJpZnk9Qy52ZXJpZnksdC5zZXJpYWxpemU9Qy5zZXJpYWxpemUsdC5zdWJtaXRPcmRlcj1DLnN1Ym1pdE9yZGVyLHQuY2FuY2VsU3VibWl0dGVkT3JkZXI9Qy5jYW5jZWxTdWJtaXR0ZWRPcmRlcix0LnZlcmlmeUF1dGhEYXRhPUMudmVyaWZ5QXV0aERhdGEsdC52ZXJpZnlDdXN0b21EYXRhPUMudmVyaWZ5Q3VzdG9tRGF0YSx0LnZlcmlmeVdhdmVzQXV0aERhdGE9Qy52ZXJpZnlXYXZlc0F1dGhEYXRhO3ZhciBBPXIoODEpO3Qud2FpdEZvclR4PUEud2FpdEZvclR4LHQuYnJvYWRjYXN0PUEuYnJvYWRjYXN0O3ZhciBJPXIoMTUzKTt0Lm1ha2VUeD1JLm1ha2VUeDtjb25zdCB3PXtjcnlwdG86bihyKDQpKSxtYXJzaGFsbDpuKHIoMykpfTt0LmxpYnM9dztjb25zdCBCPW4ocigxNTQpKTt0LnNlZWRVdGlscz1CO2NvbnN0IE49bihyKDgxKSk7dC5ub2RlSW50ZXJhY3Rpb249Tjtjb25zdCBSPW4ocig1KSk7dC52YWxpZGF0b3JzPVJ9LGZ1bmN0aW9uKGUsdCl7dC5yZWFkPWZ1bmN0aW9uKGUsdCxyLG4saSl7dmFyIGEscyxvPTgqaS1uLTEsdT0oMTw8byktMSxjPXU+PjEsbD0tNyxmPXI/aS0xOjAsaD1yPy0xOjEscD1lW3QrZl07Zm9yKGYrPWgsYT1wJigxPDwtbCktMSxwPj49LWwsbCs9bztsPjA7YT0yNTYqYStlW3QrZl0sZis9aCxsLT04KTtmb3Iocz1hJigxPDwtbCktMSxhPj49LWwsbCs9bjtsPjA7cz0yNTYqcytlW3QrZl0sZis9aCxsLT04KTtpZigwPT09YSlhPTEtYztlbHNle2lmKGE9PT11KXJldHVybiBzP05hTjoxLzAqKHA/LTE6MSk7cys9TWF0aC5wb3coMixuKSxhLT1jfXJldHVybihwPy0xOjEpKnMqTWF0aC5wb3coMixhLW4pfSx0LndyaXRlPWZ1bmN0aW9uKGUsdCxyLG4saSxhKXt2YXIgcyxvLHUsYz04KmEtaS0xLGw9KDE8PGMpLTEsZj1sPj4xLGg9MjM9PT1pP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MCxwPW4/MDphLTEsZD1uPzE6LTEseT10PDB8fDA9PT10JiYxL3Q8MD8xOjA7Zm9yKHQ9TWF0aC5hYnModCksaXNOYU4odCl8fHQ9PT0xLzA/KG89aXNOYU4odCk/MTowLHM9bCk6KHM9TWF0aC5mbG9vcihNYXRoLmxvZyh0KS9NYXRoLkxOMiksdCoodT1NYXRoLnBvdygyLC1zKSk8MSYmKHMtLSx1Kj0yKSwodCs9cytmPj0xP2gvdTpoKk1hdGgucG93KDIsMS1mKSkqdT49MiYmKHMrKyx1Lz0yKSxzK2Y+PWw/KG89MCxzPWwpOnMrZj49MT8obz0odCp1LTEpKk1hdGgucG93KDIsaSkscys9Zik6KG89dCpNYXRoLnBvdygyLGYtMSkqTWF0aC5wb3coMixpKSxzPTApKTtpPj04O2VbcitwXT0yNTUmbyxwKz1kLG8vPTI1NixpLT04KTtmb3Iocz1zPDxpfG8sYys9aTtjPjA7ZVtyK3BdPTI1NSZzLHArPWQscy89MjU2LGMtPTgpO2VbcitwLWRdfD0xMjgqeX19LGZ1bmN0aW9uKGUsdCl7dmFyIHI9e30udG9TdHJpbmc7ZS5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09ci5jYWxsKGUpfX0sZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbihlKXt2YXIgbj12b2lkIDAhPT1lJiZlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZnx8d2luZG93LGk9RnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O2Z1bmN0aW9uIGEoZSx0KXt0aGlzLl9pZD1lLHRoaXMuX2NsZWFyRm49dH10LnNldFRpbWVvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoaS5jYWxsKHNldFRpbWVvdXQsbixhcmd1bWVudHMpLGNsZWFyVGltZW91dCl9LHQuc2V0SW50ZXJ2YWw9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGEoaS5jYWxsKHNldEludGVydmFsLG4sYXJndW1lbnRzKSxjbGVhckludGVydmFsKX0sdC5jbGVhclRpbWVvdXQ9dC5jbGVhckludGVydmFsPWZ1bmN0aW9uKGUpe2UmJmUuY2xvc2UoKX0sYS5wcm90b3R5cGUudW5yZWY9YS5wcm90b3R5cGUucmVmPWZ1bmN0aW9uKCl7fSxhLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe3RoaXMuX2NsZWFyRm4uY2FsbChuLHRoaXMuX2lkKX0sdC5lbnJvbGw9ZnVuY3Rpb24oZSx0KXtjbGVhclRpbWVvdXQoZS5faWRsZVRpbWVvdXRJZCksZS5faWRsZVRpbWVvdXQ9dH0sdC51bmVucm9sbD1mdW5jdGlvbihlKXtjbGVhclRpbWVvdXQoZS5faWRsZVRpbWVvdXRJZCksZS5faWRsZVRpbWVvdXQ9LTF9LHQuX3VucmVmQWN0aXZlPXQuYWN0aXZlPWZ1bmN0aW9uKGUpe2NsZWFyVGltZW91dChlLl9pZGxlVGltZW91dElkKTt2YXIgdD1lLl9pZGxlVGltZW91dDt0Pj0wJiYoZS5faWRsZVRpbWVvdXRJZD1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UuX29uVGltZW91dCYmZS5fb25UaW1lb3V0KCl9KSx0KSl9LHIoODgpLHQuc2V0SW1tZWRpYXRlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLnNldEltbWVkaWF0ZXx8dm9pZCAwIT09ZSYmZS5zZXRJbW1lZGlhdGV8fHRoaXMmJnRoaXMuc2V0SW1tZWRpYXRlLHQuY2xlYXJJbW1lZGlhdGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuY2xlYXJJbW1lZGlhdGV8fHZvaWQgMCE9PWUmJmUuY2xlYXJJbW1lZGlhdGV8fHRoaXMmJnRoaXMuY2xlYXJJbW1lZGlhdGV9KS5jYWxsKHRoaXMscigxNykpfSxmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKGUsdCl7IWZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7aWYoIWUuc2V0SW1tZWRpYXRlKXt2YXIgbixpLGEscyxvLHU9MSxjPXt9LGw9ITEsZj1lLmRvY3VtZW50LGg9T2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk7aD1oJiZoLnNldFRpbWVvdXQ/aDplLFwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbChlLnByb2Nlc3MpP249ZnVuY3Rpb24oZSl7dC5uZXh0VGljaygoZnVuY3Rpb24oKXtkKGUpfSkpfTohZnVuY3Rpb24oKXtpZihlLnBvc3RNZXNzYWdlJiYhZS5pbXBvcnRTY3JpcHRzKXt2YXIgdD0hMCxyPWUub25tZXNzYWdlO3JldHVybiBlLm9ubWVzc2FnZT1mdW5jdGlvbigpe3Q9ITF9LGUucG9zdE1lc3NhZ2UoXCJcIixcIipcIiksZS5vbm1lc3NhZ2U9cix0fX0oKT9lLk1lc3NhZ2VDaGFubmVsPygoYT1uZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbihlKXtkKGUuZGF0YSl9LG49ZnVuY3Rpb24oZSl7YS5wb3J0Mi5wb3N0TWVzc2FnZShlKX0pOmYmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBmLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/KGk9Zi5kb2N1bWVudEVsZW1lbnQsbj1mdW5jdGlvbihlKXt2YXIgdD1mLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7dC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtkKGUpLHQub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsaS5yZW1vdmVDaGlsZCh0KSx0PW51bGx9LGkuYXBwZW5kQ2hpbGQodCl9KTpuPWZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZCwwLGUpfToocz1cInNldEltbWVkaWF0ZSRcIitNYXRoLnJhbmRvbSgpK1wiJFwiLG89ZnVuY3Rpb24odCl7dC5zb3VyY2U9PT1lJiZcInN0cmluZ1wiPT10eXBlb2YgdC5kYXRhJiYwPT09dC5kYXRhLmluZGV4T2YocykmJmQoK3QuZGF0YS5zbGljZShzLmxlbmd0aCkpfSxlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLG8sITEpOmUuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixvKSxuPWZ1bmN0aW9uKHQpe2UucG9zdE1lc3NhZ2Uocyt0LFwiKlwiKX0pLGguc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKGUpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJihlPW5ldyBGdW5jdGlvbihcIlwiK2UpKTtmb3IodmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09YXJndW1lbnRzW3IrMV07dmFyIGk9e2NhbGxiYWNrOmUsYXJnczp0fTtyZXR1cm4gY1t1XT1pLG4odSksdSsrfSxoLmNsZWFySW1tZWRpYXRlPXB9ZnVuY3Rpb24gcChlKXtkZWxldGUgY1tlXX1mdW5jdGlvbiBkKGUpe2lmKGwpc2V0VGltZW91dChkLDAsZSk7ZWxzZXt2YXIgdD1jW2VdO2lmKHQpe2w9ITA7dHJ5eyFmdW5jdGlvbihlKXt2YXIgdD1lLmNhbGxiYWNrLG49ZS5hcmdzO3N3aXRjaChuLmxlbmd0aCl7Y2FzZSAwOnQoKTticmVhaztjYXNlIDE6dChuWzBdKTticmVhaztjYXNlIDI6dChuWzBdLG5bMV0pO2JyZWFrO2Nhc2UgMzp0KG5bMF0sblsxXSxuWzJdKTticmVhaztkZWZhdWx0OnQuYXBwbHkocixuKX19KHQpfWZpbmFsbHl7cChlKSxsPSExfX19fX0oXCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/dm9pZCAwPT09ZT90aGlzOmU6c2VsZil9KS5jYWxsKHRoaXMscigxNykscigxOCkpfSxmdW5jdGlvbihlLHQscil7KGZ1bmN0aW9uKHQpe3ZhciByPXt9O2UuZXhwb3J0cz1yO3ZhciBuPXt9O3IuZW5jb2RlPWZ1bmN0aW9uKGUsdCxyKXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtpZih2b2lkIDAhPT1yJiZcIm51bWJlclwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm1heGxpbmVcIiBtdXN0IGJlIGEgbnVtYmVyLicpO3ZhciBuPVwiXCI7aWYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe3ZhciBpPTAsYT10Lmxlbmd0aCxzPXQuY2hhckF0KDApLG89WzBdO2ZvcihpPTA7aTxlLmxlbmd0aDsrK2kpe2Zvcih2YXIgdT0wLGM9ZVtpXTt1PG8ubGVuZ3RoOysrdSljKz1vW3VdPDw4LG9bdV09YyVhLGM9Yy9hfDA7Zm9yKDtjPjA7KW8ucHVzaChjJWEpLGM9Yy9hfDB9Zm9yKGk9MDswPT09ZVtpXSYmaTxlLmxlbmd0aC0xOysraSluKz1zO2ZvcihpPW8ubGVuZ3RoLTE7aT49MDstLWkpbis9dFtvW2ldXX1lbHNlIG49ZnVuY3Rpb24oZSx0KXt2YXIgcj0wLG49dC5sZW5ndGgsaT10LmNoYXJBdCgwKSxhPVswXTtmb3Iocj0wO3I8ZS5sZW5ndGgoKTsrK3Ipe2Zvcih2YXIgcz0wLG89ZS5hdChyKTtzPGEubGVuZ3RoOysrcylvKz1hW3NdPDw4LGFbc109byVuLG89by9ufDA7Zm9yKDtvPjA7KWEucHVzaChvJW4pLG89by9ufDB9dmFyIHU9XCJcIjtmb3Iocj0wOzA9PT1lLmF0KHIpJiZyPGUubGVuZ3RoKCktMTsrK3IpdSs9aTtmb3Iocj1hLmxlbmd0aC0xO3I+PTA7LS1yKXUrPXRbYVtyXV07cmV0dXJuIHV9KGUsdCk7aWYocil7dmFyIGw9bmV3IFJlZ0V4cChcIi57MSxcIityK1wifVwiLFwiZ1wiKTtuPW4ubWF0Y2gobCkuam9pbihcIlxcclxcblwiKX1yZXR1cm4gbn0sci5kZWNvZGU9ZnVuY3Rpb24oZSxyKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImlucHV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTtpZihcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImFscGhhYmV0XCIgbXVzdCBiZSBhIHN0cmluZy4nKTt2YXIgaT1uW3JdO2lmKCFpKXtpPW5bcl09W107Zm9yKHZhciBhPTA7YTxyLmxlbmd0aDsrK2EpaVtyLmNoYXJDb2RlQXQoYSldPWF9ZT1lLnJlcGxhY2UoL1xccy9nLFwiXCIpO3ZhciBzPXIubGVuZ3RoLG89ci5jaGFyQXQoMCksdT1bMF07Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyl7dmFyIGM9aVtlLmNoYXJDb2RlQXQoYSldO2lmKHZvaWQgMD09PWMpcmV0dXJuO2Zvcih2YXIgbD0wLGY9YztsPHUubGVuZ3RoOysrbClmKz11W2xdKnMsdVtsXT0yNTUmZixmPj49ODtmb3IoO2Y+MDspdS5wdXNoKDI1NSZmKSxmPj49OH1mb3IodmFyIGg9MDtlW2hdPT09byYmaDxlLmxlbmd0aC0xOysraCl1LnB1c2goMCk7cmV0dXJuIHZvaWQgMCE9PXQ/dC5mcm9tKHUucmV2ZXJzZSgpKTpuZXcgVWludDhBcnJheSh1LnJldmVyc2UoKSl9fSkuY2FsbCh0aGlzLHIoMTMpLkJ1ZmZlcil9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoOSkscigyKTt2YXIgaT1lLmV4cG9ydHM9bi5zaGEyNTY9bi5zaGEyNTZ8fHt9O24ubWQuc2hhMjU2PW4ubWQuYWxnb3JpdGhtcy5zaGEyNTY9aSxpLmNyZWF0ZT1mdW5jdGlvbigpe3N8fChhPVN0cmluZy5mcm9tQ2hhckNvZGUoMTI4KSxhKz1uLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDApLDY0KSxvPVsxMTE2MzUyNDA4LDE4OTk0NDc0NDEsMzA0OTMyMzQ3MSwzOTIxMDA5NTczLDk2MTk4NzE2MywxNTA4OTcwOTkzLDI0NTM2MzU3NDgsMjg3MDc2MzIyMSwzNjI0MzgxMDgwLDMxMDU5ODQwMSw2MDcyMjUyNzgsMTQyNjg4MTk4NywxOTI1MDc4Mzg4LDIxNjIwNzgyMDYsMjYxNDg4ODEwMywzMjQ4MjIyNTgwLDM4MzUzOTA0MDEsNDAyMjIyNDc3NCwyNjQzNDcwNzgsNjA0ODA3NjI4LDc3MDI1NTk4MywxMjQ5MTUwMTIyLDE1NTUwODE2OTIsMTk5NjA2NDk4NiwyNTU0MjIwODgyLDI4MjE4MzQzNDksMjk1Mjk5NjgwOCwzMjEwMzEzNjcxLDMzMzY1NzE4OTEsMzU4NDUyODcxMSwxMTM5MjY5OTMsMzM4MjQxODk1LDY2NjMwNzIwNSw3NzM1Mjk5MTIsMTI5NDc1NzM3MiwxMzk2MTgyMjkxLDE2OTUxODM3MDAsMTk4NjY2MTA1MSwyMTc3MDI2MzUwLDI0NTY5NTYwMzcsMjczMDQ4NTkyMSwyODIwMzAyNDExLDMyNTk3MzA4MDAsMzM0NTc2NDc3MSwzNTE2MDY1ODE3LDM2MDAzNTI4MDQsNDA5NDU3MTkwOSwyNzU0MjMzNDQsNDMwMjI3NzM0LDUwNjk0ODYxNiw2NTkwNjA1NTYsODgzOTk3ODc3LDk1ODEzOTU3MSwxMzIyODIyMjE4LDE1MzcwMDIwNjMsMTc0Nzg3Mzc3OSwxOTU1NTYyMjIyLDIwMjQxMDQ4MTUsMjIyNzczMDQ1MiwyMzYxODUyNDI0LDI0Mjg0MzY0NzQsMjc1NjczNDE4NywzMjA0MDMxNDc5LDMzMjkzMjUyOThdLHM9ITApO3ZhciBlPW51bGwsdD1uLnV0aWwuY3JlYXRlQnVmZmVyKCkscj1uZXcgQXJyYXkoNjQpLGk9e2FsZ29yaXRobTpcInNoYTI1NlwiLGJsb2NrTGVuZ3RoOjY0LGRpZ2VzdExlbmd0aDozMixtZXNzYWdlTGVuZ3RoOjAsZnVsbE1lc3NhZ2VMZW5ndGg6bnVsbCxtZXNzYWdlTGVuZ3RoU2l6ZTo4LHN0YXJ0OmZ1bmN0aW9uKCl7aS5tZXNzYWdlTGVuZ3RoPTAsaS5mdWxsTWVzc2FnZUxlbmd0aD1pLm1lc3NhZ2VMZW5ndGg2ND1bXTtmb3IodmFyIHI9aS5tZXNzYWdlTGVuZ3RoU2l6ZS80LGE9MDthPHI7KythKWkuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtyZXR1cm4gdD1uLnV0aWwuY3JlYXRlQnVmZmVyKCksZT17aDA6MTc3OTAzMzcwMyxoMTozMTQ0MTM0Mjc3LGgyOjEwMTM5MDQyNDIsaDM6Mjc3MzQ4MDc2MixoNDoxMzU5ODkzMTE5LGg1OjI2MDA4MjI5MjQsaDY6NTI4NzM0NjM1LGg3OjE1NDE0NTkyMjV9LGl9fTtyZXR1cm4gaS5zdGFydCgpLGkudXBkYXRlPWZ1bmN0aW9uKGEscyl7XCJ1dGY4XCI9PT1zJiYoYT1uLnV0aWwuZW5jb2RlVXRmOChhKSk7dmFyIG89YS5sZW5ndGg7aS5tZXNzYWdlTGVuZ3RoKz1vLG89W28vNDI5NDk2NzI5Nj4+PjAsbz4+PjBdO2Zvcih2YXIgYz1pLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aC0xO2M+PTA7LS1jKWkuZnVsbE1lc3NhZ2VMZW5ndGhbY10rPW9bMV0sb1sxXT1vWzBdKyhpLmZ1bGxNZXNzYWdlTGVuZ3RoW2NdLzQyOTQ5NjcyOTY+Pj4wKSxpLmZ1bGxNZXNzYWdlTGVuZ3RoW2NdPWkuZnVsbE1lc3NhZ2VMZW5ndGhbY10+Pj4wLG9bMF09b1sxXS80Mjk0OTY3Mjk2Pj4+MDtyZXR1cm4gdC5wdXRCeXRlcyhhKSx1KGUscix0KSwodC5yZWFkPjIwNDh8fDA9PT10Lmxlbmd0aCgpKSYmdC5jb21wYWN0KCksaX0saS5kaWdlc3Q9ZnVuY3Rpb24oKXt2YXIgcz1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7cy5wdXRCeXRlcyh0LmJ5dGVzKCkpO3ZhciBvLGM9aS5mdWxsTWVzc2FnZUxlbmd0aFtpLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aC0xXStpLm1lc3NhZ2VMZW5ndGhTaXplJmkuYmxvY2tMZW5ndGgtMTtzLnB1dEJ5dGVzKGEuc3Vic3RyKDAsaS5ibG9ja0xlbmd0aC1jKSk7Zm9yKHZhciBsPTgqaS5mdWxsTWVzc2FnZUxlbmd0aFswXSxmPTA7ZjxpLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aC0xOysrZilsKz0obz04KmkuZnVsbE1lc3NhZ2VMZW5ndGhbZisxXSkvNDI5NDk2NzI5Nj4+PjAscy5wdXRJbnQzMihsPj4+MCksbD1vPj4+MDtzLnB1dEludDMyKGwpO3ZhciBoPXtoMDplLmgwLGgxOmUuaDEsaDI6ZS5oMixoMzplLmgzLGg0OmUuaDQsaDU6ZS5oNSxoNjplLmg2LGg3OmUuaDd9O3UoaCxyLHMpO3ZhciBwPW4udXRpbC5jcmVhdGVCdWZmZXIoKTtyZXR1cm4gcC5wdXRJbnQzMihoLmgwKSxwLnB1dEludDMyKGguaDEpLHAucHV0SW50MzIoaC5oMikscC5wdXRJbnQzMihoLmgzKSxwLnB1dEludDMyKGguaDQpLHAucHV0SW50MzIoaC5oNSkscC5wdXRJbnQzMihoLmg2KSxwLnB1dEludDMyKGguaDcpLHB9LGl9O3ZhciBhPW51bGwscz0hMSxvPW51bGw7ZnVuY3Rpb24gdShlLHQscil7Zm9yKHZhciBuLGksYSxzLHUsYyxsLGYsaCxwLGQseSxnLG09ci5sZW5ndGgoKTttPj02NDspe2Zvcih1PTA7dTwxNjsrK3UpdFt1XT1yLmdldEludDMyKCk7Zm9yKDt1PDY0OysrdSluPSgobj10W3UtMl0pPj4+MTd8bjw8MTUpXihuPj4+MTl8bjw8MTMpXm4+Pj4xMCxpPSgoaT10W3UtMTVdKT4+Pjd8aTw8MjUpXihpPj4+MTh8aTw8MTQpXmk+Pj4zLHRbdV09bit0W3UtN10raSt0W3UtMTZdfDA7Zm9yKGM9ZS5oMCxsPWUuaDEsZj1lLmgyLGg9ZS5oMyxwPWUuaDQsZD1lLmg1LHk9ZS5oNixnPWUuaDcsdT0wO3U8NjQ7Kyt1KWE9KGM+Pj4yfGM8PDMwKV4oYz4+PjEzfGM8PDE5KV4oYz4+PjIyfGM8PDEwKSxzPWMmbHxmJihjXmwpLG49ZysoKHA+Pj42fHA8PDI2KV4ocD4+PjExfHA8PDIxKV4ocD4+PjI1fHA8PDcpKSsoeV5wJihkXnkpKStvW3VdK3RbdV0sZz15LHk9ZCxkPXAscD1oK24+Pj4wLGg9ZixmPWwsbD1jLGM9bisoaT1hK3MpPj4+MDtlLmgwPWUuaDArY3wwLGUuaDE9ZS5oMStsfDAsZS5oMj1lLmgyK2Z8MCxlLmgzPWUuaDMraHwwLGUuaDQ9ZS5oNCtwfDAsZS5oNT1lLmg1K2R8MCxlLmg2PWUuaDYreXwwLGUuaDc9ZS5oNytnfDAsbS09NjR9fX0sZnVuY3Rpb24oZSx0LHIpeyhmdW5jdGlvbih0KXt2YXIgbj1yKDEpO3IoMik7dmFyIGk9bnVsbDshbi51dGlsLmlzTm9kZWpzfHxuLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHR8fHQudmVyc2lvbnNbXCJub2RlLXdlYmtpdFwiXXx8KGk9cigzMSkpLChlLmV4cG9ydHM9bi5wcm5nPW4ucHJuZ3x8e30pLmNyZWF0ZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e3BsdWdpbjplLGtleTpudWxsLHNlZWQ6bnVsbCx0aW1lOm51bGwscmVzZWVkczowLGdlbmVyYXRlZDowLGtleUJ5dGVzOlwiXCJ9LHI9ZS5tZCxhPW5ldyBBcnJheSgzMikscz0wO3M8MzI7KytzKWFbc109ci5jcmVhdGUoKTtmdW5jdGlvbiBvKCl7aWYodC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoPj0zMilyZXR1cm4gdSgpO3ZhciBlPTMyLXQucG9vbHNbMF0ubWVzc2FnZUxlbmd0aDw8NTt0LmNvbGxlY3QodC5zZWVkRmlsZVN5bmMoZSkpLHUoKX1mdW5jdGlvbiB1KCl7dC5yZXNlZWRzPTQyOTQ5NjcyOTU9PT10LnJlc2VlZHM/MDp0LnJlc2VlZHMrMTt2YXIgZT10LnBsdWdpbi5tZC5jcmVhdGUoKTtlLnVwZGF0ZSh0LmtleUJ5dGVzKTtmb3IodmFyIHI9MSxuPTA7bjwzMjsrK24pdC5yZXNlZWRzJXI9PTAmJihlLnVwZGF0ZSh0LnBvb2xzW25dLmRpZ2VzdCgpLmdldEJ5dGVzKCkpLHQucG9vbHNbbl0uc3RhcnQoKSkscjw8PTE7dC5rZXlCeXRlcz1lLmRpZ2VzdCgpLmdldEJ5dGVzKCksZS5zdGFydCgpLGUudXBkYXRlKHQua2V5Qnl0ZXMpO3ZhciBpPWUuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTt0LmtleT10LnBsdWdpbi5mb3JtYXRLZXkodC5rZXlCeXRlcyksdC5zZWVkPXQucGx1Z2luLmZvcm1hdFNlZWQoaSksdC5nZW5lcmF0ZWQ9MH1mdW5jdGlvbiBjKGUpe3ZhciB0PW51bGwscj1uLnV0aWwuZ2xvYmFsU2NvcGUsaT1yLmNyeXB0b3x8ci5tc0NyeXB0bztpJiZpLmdldFJhbmRvbVZhbHVlcyYmKHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGkuZ2V0UmFuZG9tVmFsdWVzKGUpfSk7dmFyIGE9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO2lmKHQpZm9yKDthLmxlbmd0aCgpPGU7KXt2YXIgcz1NYXRoLm1heCgxLE1hdGgubWluKGUtYS5sZW5ndGgoKSw2NTUzNikvNCksbz1uZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihzKSk7dHJ5e3Qobyk7Zm9yKHZhciB1PTA7dTxvLmxlbmd0aDsrK3UpYS5wdXRJbnQzMihvW3VdKX1jYXRjaChlKXtpZighKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBRdW90YUV4Y2VlZGVkRXJyb3ImJmUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKXRocm93IGV9fWlmKGEubGVuZ3RoKCk8ZSlmb3IodmFyIGMsbCxmLGg9TWF0aC5mbG9vcig2NTUzNipNYXRoLnJhbmRvbSgpKTthLmxlbmd0aCgpPGU7KXtsPTE2ODA3Kig2NTUzNSZoKSxsKz0oMzI3NjcmKGM9MTY4MDcqKGg+PjE2KSkpPDwxNixoPTQyOTQ5NjcyOTUmKGw9KDIxNDc0ODM2NDcmKGwrPWM+PjE1KSkrKGw+PjMxKSk7Zm9yKHU9MDt1PDM7Kyt1KWY9aD4+Pih1PDwzKSxmXj1NYXRoLmZsb29yKDI1NipNYXRoLnJhbmRvbSgpKSxhLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmZikpfXJldHVybiBhLmdldEJ5dGVzKGUpfXJldHVybiB0LnBvb2xzPWEsdC5wb29sPTAsdC5nZW5lcmF0ZT1mdW5jdGlvbihlLHIpe2lmKCFyKXJldHVybiB0LmdlbmVyYXRlU3luYyhlKTt2YXIgaT10LnBsdWdpbi5jaXBoZXIsYT10LnBsdWdpbi5pbmNyZW1lbnQscz10LnBsdWdpbi5mb3JtYXRLZXksbz10LnBsdWdpbi5mb3JtYXRTZWVkLGM9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpO3Qua2V5PW51bGwsZnVuY3Rpb24gbChmKXtpZihmKXJldHVybiByKGYpO2lmKGMubGVuZ3RoKCk+PWUpcmV0dXJuIHIobnVsbCxjLmdldEJ5dGVzKGUpKTt0LmdlbmVyYXRlZD4xMDQ4NTc1JiYodC5rZXk9bnVsbCk7aWYobnVsbD09PXQua2V5KXJldHVybiBuLnV0aWwubmV4dFRpY2soKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKGUpe2lmKHQucG9vbHNbMF0ubWVzc2FnZUxlbmd0aD49MzIpcmV0dXJuIHUoKSxlKCk7dmFyIHI9MzItdC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoPDw1O3Quc2VlZEZpbGUociwoZnVuY3Rpb24ocixuKXtpZihyKXJldHVybiBlKHIpO3QuY29sbGVjdChuKSx1KCksZSgpfSkpfShsKX0pKTt2YXIgaD1pKHQua2V5LHQuc2VlZCk7dC5nZW5lcmF0ZWQrPWgubGVuZ3RoLGMucHV0Qnl0ZXMoaCksdC5rZXk9cyhpKHQua2V5LGEodC5zZWVkKSkpLHQuc2VlZD1vKGkodC5rZXksdC5zZWVkKSksbi51dGlsLnNldEltbWVkaWF0ZShsKX0oKX0sdC5nZW5lcmF0ZVN5bmM9ZnVuY3Rpb24oZSl7dmFyIHI9dC5wbHVnaW4uY2lwaGVyLGk9dC5wbHVnaW4uaW5jcmVtZW50LGE9dC5wbHVnaW4uZm9ybWF0S2V5LHM9dC5wbHVnaW4uZm9ybWF0U2VlZDt0LmtleT1udWxsO2Zvcih2YXIgdT1uLnV0aWwuY3JlYXRlQnVmZmVyKCk7dS5sZW5ndGgoKTxlOyl7dC5nZW5lcmF0ZWQ+MTA0ODU3NSYmKHQua2V5PW51bGwpLG51bGw9PT10LmtleSYmbygpO3ZhciBjPXIodC5rZXksdC5zZWVkKTt0LmdlbmVyYXRlZCs9Yy5sZW5ndGgsdS5wdXRCeXRlcyhjKSx0LmtleT1hKHIodC5rZXksaSh0LnNlZWQpKSksdC5zZWVkPXMocih0LmtleSx0LnNlZWQpKX1yZXR1cm4gdS5nZXRCeXRlcyhlKX0saT8odC5zZWVkRmlsZT1mdW5jdGlvbihlLHQpe2kucmFuZG9tQnl0ZXMoZSwoZnVuY3Rpb24oZSxyKXtpZihlKXJldHVybiB0KGUpO3QobnVsbCxyLnRvU3RyaW5nKCkpfSkpfSx0LnNlZWRGaWxlU3luYz1mdW5jdGlvbihlKXtyZXR1cm4gaS5yYW5kb21CeXRlcyhlKS50b1N0cmluZygpfSk6KHQuc2VlZEZpbGU9ZnVuY3Rpb24oZSx0KXt0cnl7dChudWxsLGMoZSkpfWNhdGNoKGUpe3QoZSl9fSx0LnNlZWRGaWxlU3luYz1jKSx0LmNvbGxlY3Q9ZnVuY3Rpb24oZSl7Zm9yKHZhciByPWUubGVuZ3RoLG49MDtuPHI7KytuKXQucG9vbHNbdC5wb29sXS51cGRhdGUoZS5zdWJzdHIobiwxKSksdC5wb29sPTMxPT09dC5wb29sPzA6dC5wb29sKzF9LHQuY29sbGVjdEludD1mdW5jdGlvbihlLHIpe2Zvcih2YXIgbj1cIlwiLGk9MDtpPHI7aSs9OCluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGU+PmkmMjU1KTt0LmNvbGxlY3Qobil9LHQucmVnaXN0ZXJXb3JrZXI9ZnVuY3Rpb24oZSl7aWYoZT09PXNlbGYpdC5zZWVkRmlsZT1mdW5jdGlvbihlLHQpe3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24gZShyKXt2YXIgbj1yLmRhdGE7bi5mb3JnZSYmbi5mb3JnZS5wcm5nJiYoc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGUpLHQobi5mb3JnZS5wcm5nLmVycixuLmZvcmdlLnBybmcuYnl0ZXMpKX0pKSxzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZTp7cHJuZzp7bmVlZGVkOmV9fX0pfTtlbHNle2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24ocil7dmFyIG49ci5kYXRhO24uZm9yZ2UmJm4uZm9yZ2UucHJuZyYmdC5zZWVkRmlsZShuLmZvcmdlLnBybmcubmVlZGVkLChmdW5jdGlvbih0LHIpe2UucG9zdE1lc3NhZ2Uoe2ZvcmdlOntwcm5nOntlcnI6dCxieXRlczpyfX19KX0pKX0pKX19LHR9fSkuY2FsbCh0aGlzLHIoMTgpKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuPVwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiLGk9bi5zcGxpdChcIlwiKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZVt0XT1yLGV9KSx7fSk7dC5kZWZhdWx0PXtlbmNvZGU6ZnVuY3Rpb24oZSl7aWYoIWUubGVuZ3RoKXJldHVyblwiXCI7Zm9yKHZhciB0PVswXSxyPTA7cjxlLmxlbmd0aDtyKyspe2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKXRbaV08PD04O3RbMF0rPWVbcl07Zm9yKHZhciBhPTAscz0wO3M8dC5sZW5ndGg7cysrKXRbc10rPWEsYT10W3NdLzU4fDAsdFtzXSU9NTg7Zm9yKDthOyl0LnB1c2goYSU1OCksYT1hLzU4fDB9Zm9yKHI9MDswPT09ZVtyXSYmcjxlLmxlbmd0aC0xO3IrKyl0LnB1c2goMCk7cmV0dXJuIHQucmV2ZXJzZSgpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIG5bZV19KSkuam9pbihcIlwiKX0sZGVjb2RlOmZ1bmN0aW9uKGUpe2lmKCFlLmxlbmd0aClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7Zm9yKHZhciB0PVswXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07aWYoIShuIGluIGkpKXRocm93J1RoZXJlIGlzIG5vIGNoYXJhY3RlciBcIicrbisnXCIgaW4gdGhlIEJhc2U1OCBzZXF1ZW5jZSEnO2Zvcih2YXIgYT0wO2E8dC5sZW5ndGg7YSsrKXRbYV0qPTU4O3RbMF0rPWlbbl07dmFyIHM9MDtmb3IoYT0wO2E8dC5sZW5ndGg7YSsrKXRbYV0rPXMscz10W2FdPj44LHRbYV0mPTI1NTtmb3IoO3M7KXQucHVzaCgyNTUmcykscz4+PTh9Zm9yKHI9MDtcIjFcIj09PWVbcl0mJnI8ZS5sZW5ndGgtMTtyKyspdC5wdXNoKDApO3JldHVybiBuZXcgVWludDhBcnJheSh0LnJldmVyc2UoKSl9fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLGksYTt0LnV0ZjhBcnJheVRvU3RyPShuPW5ldyBBcnJheSgxMjgpLGk9U3RyaW5nLmZyb21Db2RlUG9pbnR8fFN0cmluZy5mcm9tQ2hhckNvZGUsYT1bXSxmdW5jdGlvbihlKXt2YXIgdCxyLHM9ZS5sZW5ndGg7YS5sZW5ndGg9MDtmb3IodmFyIG89MDtvPHM7KShyPWVbbysrXSk8PTEyNz90PXI6cjw9MjIzP3Q9KDMxJnIpPDw2fDYzJmVbbysrXTpyPD0yMzk/dD0oMTUmcik8PDEyfCg2MyZlW28rK10pPDw2fDYzJmVbbysrXTpTdHJpbmcuZnJvbUNvZGVQb2ludD90PSg3JnIpPDwxOHwoNjMmZVtvKytdKTw8MTJ8KDYzJmVbbysrXSk8PDZ8NjMmZVtvKytdOih0PTYzLG8rPTMpLGEucHVzaChuW3RdfHwoblt0XT1pKHQpKSk7cmV0dXJuIGEuam9pbihcIlwiKX0pLHQuc3RyVG9VdGY4QXJyYXk9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG49ZS5jaGFyQ29kZUF0KHIpO248MTI4P3QucHVzaChuKTpuPDIwNDg/dC5wdXNoKDE5MnxuPj42LDEyOHw2MyZuKTpuPDU1Mjk2fHxuPj01NzM0ND90LnB1c2goMjI0fG4+PjEyLDEyOHxuPj42JjYzLDEyOHw2MyZuKToocisrLG49NjU1MzYrKCgxMDIzJm4pPDwxMHwxMDIzJmUuY2hhckNvZGVBdChyKSksdC5wdXNoKDI0MHxuPj4xOCwxMjh8bj4+MTImNjMsMTI4fG4+PjYmNjMsMTI4fDYzJm4pKX1yZXR1cm4gVWludDhBcnJheS5mcm9tKHQpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO1xuLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuNS43XG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMTZcbiAqIEBsaWNlbnNlIE1JVFxuICovdC5fX2VzTW9kdWxlPSEwO2Zvcih2YXIgbj1cIjAxMjM0NTY3ODlhYmNkZWZcIi5zcGxpdChcIlwiKSxpPVswLDgsMTYsMjRdLGE9WzEsMCwzMjg5OCwwLDMyOTA2LDIxNDc0ODM2NDgsMjE0NzUxNjQxNiwyMTQ3NDgzNjQ4LDMyOTA3LDAsMjE0NzQ4MzY0OSwwLDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjc3NywyMTQ3NDgzNjQ4LDEzOCwwLDEzNiwwLDIxNDc1MTY0MjUsMCwyMTQ3NDgzNjU4LDAsMjE0NzUxNjU1NSwwLDEzOSwyMTQ3NDgzNjQ4LDMyOTA1LDIxNDc0ODM2NDgsMzI3NzEsMjE0NzQ4MzY0OCwzMjc3MCwyMTQ3NDgzNjQ4LDEyOCwyMTQ3NDgzNjQ4LDMyNzc4LDAsMjE0NzQ4MzY1OCwyMTQ3NDgzNjQ4LDIxNDc1MTY1NDUsMjE0NzQ4MzY0OCwzMjg5NiwyMTQ3NDgzNjQ4LDIxNDc0ODM2NDksMCwyMTQ3NTE2NDI0LDIxNDc0ODM2NDhdLHM9WzIyNCwyNTYsMzg0LDUxMl0sbz1bXCJoZXhcIixcImJ1ZmZlclwiLFwiYXJyYXlCdWZmZXJcIixcImFycmF5XCJdLHU9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gbmV3IGIoZSx0LGUpLnVwZGF0ZShuKVtyXSgpfX0sYz1mdW5jdGlvbihlLHQscil7cmV0dXJuIGZ1bmN0aW9uKG4saSl7cmV0dXJuIG5ldyBiKGUsdCxpKS51cGRhdGUobilbcl0oKX19LGw9ZnVuY3Rpb24oZSx0KXt2YXIgcj11KGUsdCxcImhleFwiKTtyLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgYihlLHQsZSl9LHIudXBkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiByLmNyZWF0ZSgpLnVwZGF0ZShlKX07Zm9yKHZhciBuPTA7bjxvLmxlbmd0aDsrK24pe3ZhciBpPW9bbl07cltpXT11KGUsdCxpKX1yZXR1cm4gcn0sZj1be25hbWU6XCJrZWNjYWtcIixwYWRkaW5nOlsxLDI1Niw2NTUzNiwxNjc3NzIxNl0sYml0czpzLGNyZWF0ZU1ldGhvZDpsfSx7bmFtZTpcInNoYTNcIixwYWRkaW5nOls2LDE1MzYsMzkzMjE2LDEwMDY2MzI5Nl0sYml0czpzLGNyZWF0ZU1ldGhvZDpsfSx7bmFtZTpcInNoYWtlXCIscGFkZGluZzpbMzEsNzkzNiwyMDMxNjE2LDUyMDA5MzY5Nl0sYml0czpbMTI4LDI1Nl0sY3JlYXRlTWV0aG9kOmZ1bmN0aW9uKGUsdCl7dmFyIHI9YyhlLHQsXCJoZXhcIik7ci5jcmVhdGU9ZnVuY3Rpb24ocil7cmV0dXJuIG5ldyBiKGUsdCxyKX0sci51cGRhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gci5jcmVhdGUodCkudXBkYXRlKGUpfTtmb3IodmFyIG49MDtuPG8ubGVuZ3RoOysrbil7dmFyIGk9b1tuXTtyW2ldPWMoZSx0LGkpfXJldHVybiByfX1dLGg9e30scD1bXSxkPTA7ZDxmLmxlbmd0aDsrK2QpZm9yKHZhciB5PWZbZF0sZz15LmJpdHMsbT0wO208Zy5sZW5ndGg7KyttKXt2YXIgdj15Lm5hbWUrXCJfXCIrZ1ttXTtwLnB1c2godiksaFt2XT15LmNyZWF0ZU1ldGhvZChnW21dLHkucGFkZGluZyl9ZnVuY3Rpb24gYihlLHQscil7dGhpcy5ibG9ja3M9W10sdGhpcy5zPVtdLHRoaXMucGFkZGluZz10LHRoaXMub3V0cHV0Qml0cz1yLHRoaXMucmVzZXQ9ITAsdGhpcy5ibG9jaz0wLHRoaXMuc3RhcnQ9MCx0aGlzLmJsb2NrQ291bnQ9MTYwMC0oZTw8MSk+PjUsdGhpcy5ieXRlQ291bnQ9dGhpcy5ibG9ja0NvdW50PDwyLHRoaXMub3V0cHV0QmxvY2tzPXI+PjUsdGhpcy5leHRyYUJ5dGVzPSgzMSZyKT4+Mztmb3IodmFyIG49MDtuPDUwOysrbil0aGlzLnNbbl09MH1iLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSl7dmFyIHQ9XCJzdHJpbmdcIiE9dHlwZW9mIGU7dCYmZS5jb25zdHJ1Y3Rvcj09PUFycmF5QnVmZmVyJiYoZT1uZXcgVWludDhBcnJheShlKSk7Zm9yKHZhciByLG4sYT1lLmxlbmd0aCxzPXRoaXMuYmxvY2tzLG89dGhpcy5ieXRlQ291bnQsdT10aGlzLmJsb2NrQ291bnQsYz0wLGw9dGhpcy5zO2M8YTspe2lmKHRoaXMucmVzZXQpZm9yKHRoaXMucmVzZXQ9ITEsc1swXT10aGlzLmJsb2NrLHI9MTtyPHUrMTsrK3Ipc1tyXT0wO2lmKHQpZm9yKHI9dGhpcy5zdGFydDtjPGEmJnI8bzsrK2Mpc1tyPj4yXXw9ZVtjXTw8aVszJnIrK107ZWxzZSBmb3Iocj10aGlzLnN0YXJ0O2M8YSYmcjxvOysrYykobj1lLmNoYXJDb2RlQXQoYykpPDEyOD9zW3I+PjJdfD1uPDxpWzMmcisrXTpuPDIwNDg/KHNbcj4+Ml18PSgxOTJ8bj4+Nik8PGlbMyZyKytdLHNbcj4+Ml18PSgxMjh8NjMmbik8PGlbMyZyKytdKTpuPDU1Mjk2fHxuPj01NzM0ND8oc1tyPj4yXXw9KDIyNHxuPj4xMik8PGlbMyZyKytdLHNbcj4+Ml18PSgxMjh8bj4+NiY2Myk8PGlbMyZyKytdLHNbcj4+Ml18PSgxMjh8NjMmbik8PGlbMyZyKytdKToobj02NTUzNisoKDEwMjMmbik8PDEwfDEwMjMmZS5jaGFyQ29kZUF0KCsrYykpLHNbcj4+Ml18PSgyNDB8bj4+MTgpPDxpWzMmcisrXSxzW3I+PjJdfD0oMTI4fG4+PjEyJjYzKTw8aVszJnIrK10sc1tyPj4yXXw9KDEyOHxuPj42JjYzKTw8aVszJnIrK10sc1tyPj4yXXw9KDEyOHw2MyZuKTw8aVszJnIrK10pO2lmKHRoaXMubGFzdEJ5dGVJbmRleD1yLHI+PW8pe2Zvcih0aGlzLnN0YXJ0PXItbyx0aGlzLmJsb2NrPXNbdV0scj0wO3I8dTsrK3IpbFtyXV49c1tyXTtFKGwpLHRoaXMucmVzZXQ9ITB9ZWxzZSB0aGlzLnN0YXJ0PXJ9cmV0dXJuIHRoaXN9LGIucHJvdG90eXBlLmZpbmFsaXplPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ibG9ja3MsdD10aGlzLmxhc3RCeXRlSW5kZXgscj10aGlzLmJsb2NrQ291bnQsbj10aGlzLnM7aWYoZVt0Pj4yXXw9dGhpcy5wYWRkaW5nWzMmdF0sdGhpcy5sYXN0Qnl0ZUluZGV4PT09dGhpcy5ieXRlQ291bnQpZm9yKGVbMF09ZVtyXSx0PTE7dDxyKzE7Kyt0KWVbdF09MDtmb3IoZVtyLTFdfD0yMTQ3NDgzNjQ4LHQ9MDt0PHI7Kyt0KW5bdF1ePWVbdF07RShuKX0sYi5wcm90b3R5cGUudG9TdHJpbmc9Yi5wcm90b3R5cGUuaGV4PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0PXRoaXMuYmxvY2tDb3VudCxyPXRoaXMucyxpPXRoaXMub3V0cHV0QmxvY2tzLGE9dGhpcy5leHRyYUJ5dGVzLHM9MCxvPTAsdT1cIlwiO288aTspe2ZvcihzPTA7czx0JiZvPGk7KytzLCsrbyllPXJbc10sdSs9bltlPj40JjE1XStuWzE1JmVdK25bZT4+MTImMTVdK25bZT4+OCYxNV0rbltlPj4yMCYxNV0rbltlPj4xNiYxNV0rbltlPj4yOCYxNV0rbltlPj4yNCYxNV07byV0PT0wJiYoRShyKSxzPTApfXJldHVybiBhJiYoZT1yW3NdLGE+MCYmKHUrPW5bZT4+NCYxNV0rblsxNSZlXSksYT4xJiYodSs9bltlPj4xMiYxNV0rbltlPj44JjE1XSksYT4yJiYodSs9bltlPj4yMCYxNV0rbltlPj4xNiYxNV0pKSx1fSxiLnByb3RvdHlwZS5hcnJheUJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuZmluYWxpemUoKTt2YXIgZSx0PXRoaXMuYmxvY2tDb3VudCxyPXRoaXMucyxuPXRoaXMub3V0cHV0QmxvY2tzLGk9dGhpcy5leHRyYUJ5dGVzLGE9MCxzPTAsbz10aGlzLm91dHB1dEJpdHM+PjM7ZT1pP25ldyBBcnJheUJ1ZmZlcihuKzE8PDIpOm5ldyBBcnJheUJ1ZmZlcihvKTtmb3IodmFyIHU9bmV3IFVpbnQzMkFycmF5KGUpO3M8bjspe2ZvcihhPTA7YTx0JiZzPG47KythLCsrcyl1W3NdPXJbYV07cyV0PT0wJiZFKHIpfXJldHVybiBpJiYodVthXT1yW2FdLGU9ZS5zbGljZSgwLG8pKSxlfSxiLnByb3RvdHlwZS5idWZmZXI9Yi5wcm90b3R5cGUuYXJyYXlCdWZmZXIsYi5wcm90b3R5cGUuZGlnZXN0PWIucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0LHI9dGhpcy5ibG9ja0NvdW50LG49dGhpcy5zLGk9dGhpcy5vdXRwdXRCbG9ja3MsYT10aGlzLmV4dHJhQnl0ZXMscz0wLG89MCx1PVtdO288aTspe2ZvcihzPTA7czxyJiZvPGk7KytzLCsrbyllPW88PDIsdD1uW3NdLHVbZV09MjU1JnQsdVtlKzFdPXQ+PjgmMjU1LHVbZSsyXT10Pj4xNiYyNTUsdVtlKzNdPXQ+PjI0JjI1NTtvJXI9PTAmJkUobil9cmV0dXJuIGEmJihlPW88PDIsdD1uW3NdLGE+MCYmKHVbZV09MjU1JnQpLGE+MSYmKHVbZSsxXT10Pj44JjI1NSksYT4yJiYodVtlKzJdPXQ+PjE2JjI1NSkpLHV9O3ZhciBFPWZ1bmN0aW9uKGUpe3ZhciB0LHIsbixpLHMsbyx1LGMsbCxmLGgscCxkLHksZyxtLHYsYixFLFMsVCxDLEEsSSx3LEIsTixSLF8sUCxPLGssVSxMLEQsVix4LEssTSxqLEYscSx6LEcsSCxZLFEsVyxYLCQsSixaLGVlLHRlLHJlLG5lLGllLGFlLHNlLG9lLHVlLGNlLGxlO2ZvcihuPTA7bjw0ODtuKz0yKWk9ZVswXV5lWzEwXV5lWzIwXV5lWzMwXV5lWzQwXSxzPWVbMV1eZVsxMV1eZVsyMV1eZVszMV1eZVs0MV0sbz1lWzJdXmVbMTJdXmVbMjJdXmVbMzJdXmVbNDJdLHU9ZVszXV5lWzEzXV5lWzIzXV5lWzMzXV5lWzQzXSxjPWVbNF1eZVsxNF1eZVsyNF1eZVszNF1eZVs0NF0sbD1lWzVdXmVbMTVdXmVbMjVdXmVbMzVdXmVbNDVdLGY9ZVs2XV5lWzE2XV5lWzI2XV5lWzM2XV5lWzQ2XSxoPWVbN11eZVsxN11eZVsyN11eZVszN11eZVs0N10sdD0ocD1lWzhdXmVbMThdXmVbMjhdXmVbMzhdXmVbNDhdKV4obzw8MXx1Pj4+MzEpLHI9KGQ9ZVs5XV5lWzE5XV5lWzI5XV5lWzM5XV5lWzQ5XSleKHU8PDF8bz4+PjMxKSxlWzBdXj10LGVbMV1ePXIsZVsxMF1ePXQsZVsxMV1ePXIsZVsyMF1ePXQsZVsyMV1ePXIsZVszMF1ePXQsZVszMV1ePXIsZVs0MF1ePXQsZVs0MV1ePXIsdD1pXihjPDwxfGw+Pj4zMSkscj1zXihsPDwxfGM+Pj4zMSksZVsyXV49dCxlWzNdXj1yLGVbMTJdXj10LGVbMTNdXj1yLGVbMjJdXj10LGVbMjNdXj1yLGVbMzJdXj10LGVbMzNdXj1yLGVbNDJdXj10LGVbNDNdXj1yLHQ9b14oZjw8MXxoPj4+MzEpLHI9dV4oaDw8MXxmPj4+MzEpLGVbNF1ePXQsZVs1XV49cixlWzE0XV49dCxlWzE1XV49cixlWzI0XV49dCxlWzI1XV49cixlWzM0XV49dCxlWzM1XV49cixlWzQ0XV49dCxlWzQ1XV49cix0PWNeKHA8PDF8ZD4+PjMxKSxyPWxeKGQ8PDF8cD4+PjMxKSxlWzZdXj10LGVbN11ePXIsZVsxNl1ePXQsZVsxN11ePXIsZVsyNl1ePXQsZVsyN11ePXIsZVszNl1ePXQsZVszN11ePXIsZVs0Nl1ePXQsZVs0N11ePXIsdD1mXihpPDwxfHM+Pj4zMSkscj1oXihzPDwxfGk+Pj4zMSksZVs4XV49dCxlWzldXj1yLGVbMThdXj10LGVbMTldXj1yLGVbMjhdXj10LGVbMjldXj1yLGVbMzhdXj10LGVbMzldXj1yLGVbNDhdXj10LGVbNDldXj1yLHk9ZVswXSxnPWVbMV0sWT1lWzExXTw8NHxlWzEwXT4+PjI4LFE9ZVsxMF08PDR8ZVsxMV0+Pj4yOCxSPWVbMjBdPDwzfGVbMjFdPj4+MjksXz1lWzIxXTw8M3xlWzIwXT4+PjI5LG9lPWVbMzFdPDw5fGVbMzBdPj4+MjMsdWU9ZVszMF08PDl8ZVszMV0+Pj4yMyxxPWVbNDBdPDwxOHxlWzQxXT4+PjE0LHo9ZVs0MV08PDE4fGVbNDBdPj4+MTQsTD1lWzJdPDwxfGVbM10+Pj4zMSxEPWVbM108PDF8ZVsyXT4+PjMxLG09ZVsxM108PDEyfGVbMTJdPj4+MjAsdj1lWzEyXTw8MTJ8ZVsxM10+Pj4yMCxXPWVbMjJdPDwxMHxlWzIzXT4+PjIyLFg9ZVsyM108PDEwfGVbMjJdPj4+MjIsUD1lWzMzXTw8MTN8ZVszMl0+Pj4xOSxPPWVbMzJdPDwxM3xlWzMzXT4+PjE5LGNlPWVbNDJdPDwyfGVbNDNdPj4+MzAsbGU9ZVs0M108PDJ8ZVs0Ml0+Pj4zMCx0ZT1lWzVdPDwzMHxlWzRdPj4+MixyZT1lWzRdPDwzMHxlWzVdPj4+MixWPWVbMTRdPDw2fGVbMTVdPj4+MjYseD1lWzE1XTw8NnxlWzE0XT4+PjI2LGI9ZVsyNV08PDExfGVbMjRdPj4+MjEsRT1lWzI0XTw8MTF8ZVsyNV0+Pj4yMSwkPWVbMzRdPDwxNXxlWzM1XT4+PjE3LEo9ZVszNV08PDE1fGVbMzRdPj4+MTcsaz1lWzQ1XTw8Mjl8ZVs0NF0+Pj4zLFU9ZVs0NF08PDI5fGVbNDVdPj4+MyxJPWVbNl08PDI4fGVbN10+Pj40LHc9ZVs3XTw8Mjh8ZVs2XT4+PjQsbmU9ZVsxN108PDIzfGVbMTZdPj4+OSxpZT1lWzE2XTw8MjN8ZVsxN10+Pj45LEs9ZVsyNl08PDI1fGVbMjddPj4+NyxNPWVbMjddPDwyNXxlWzI2XT4+PjcsUz1lWzM2XTw8MjF8ZVszN10+Pj4xMSxUPWVbMzddPDwyMXxlWzM2XT4+PjExLFo9ZVs0N108PDI0fGVbNDZdPj4+OCxlZT1lWzQ2XTw8MjR8ZVs0N10+Pj44LEc9ZVs4XTw8Mjd8ZVs5XT4+PjUsSD1lWzldPDwyN3xlWzhdPj4+NSxCPWVbMThdPDwyMHxlWzE5XT4+PjEyLE49ZVsxOV08PDIwfGVbMThdPj4+MTIsYWU9ZVsyOV08PDd8ZVsyOF0+Pj4yNSxzZT1lWzI4XTw8N3xlWzI5XT4+PjI1LGo9ZVszOF08PDh8ZVszOV0+Pj4yNCxGPWVbMzldPDw4fGVbMzhdPj4+MjQsQz1lWzQ4XTw8MTR8ZVs0OV0+Pj4xOCxBPWVbNDldPDwxNHxlWzQ4XT4+PjE4LGVbMF09eV5+bSZiLGVbMV09Z15+diZFLGVbMTBdPUlefkImUixlWzExXT13Xn5OJl8sZVsyMF09TF5+ViZLLGVbMjFdPURefngmTSxlWzMwXT1HXn5ZJlcsZVszMV09SF5+USZYLGVbNDBdPXRlXn5uZSZhZSxlWzQxXT1yZV5+aWUmc2UsZVsyXT1tXn5iJlMsZVszXT12Xn5FJlQsZVsxMl09Ql5+UiZQLGVbMTNdPU5efl8mTyxlWzIyXT1WXn5LJmosZVsyM109eF5+TSZGLGVbMzJdPVleflcmJCxlWzMzXT1RXn5YJkosZVs0Ml09bmVefmFlJm9lLGVbNDNdPWllXn5zZSZ1ZSxlWzRdPWJeflMmQyxlWzVdPUVeflQmQSxlWzE0XT1SXn5QJmssZVsxNV09X15+TyZVLGVbMjRdPUtefmomcSxlWzI1XT1NXn5GJnosZVszNF09V15+JCZaLGVbMzVdPVhefkomZWUsZVs0NF09YWVefm9lJmNlLGVbNDVdPXNlXn51ZSZsZSxlWzZdPVNefkMmeSxlWzddPVRefkEmZyxlWzE2XT1QXn5rJkksZVsxN109T15+VSZ3LGVbMjZdPWpefnEmTCxlWzI3XT1GXn56JkQsZVszNl09JF5+WiZHLGVbMzddPUpefmVlJkgsZVs0Nl09b2VefmNlJnRlLGVbNDddPXVlXn5sZSZyZSxlWzhdPUNefnkmbSxlWzldPUFefmcmdixlWzE4XT1rXn5JJkIsZVsxOV09VV5+dyZOLGVbMjhdPXFefkwmVixlWzI5XT16Xn5EJngsZVszOF09Wl5+RyZZLGVbMzldPWVlXn5IJlEsZVs0OF09Y2VefnRlJm5lLGVbNDldPWxlXn5yZSZpZSxlWzBdXj1hW25dLGVbMV1ePWFbbisxXX07dC5rZWNjYWsyNTY9aC5rZWNjYWtfMjU2fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKGUpe3QuX19lc01vZHVsZT0hMDt2YXIgcj1cIklucHV0IG11c3QgYmUgYW4gc3RyaW5nLCBCdWZmZXIgb3IgVWludDhBcnJheVwiO2Z1bmN0aW9uIG4oZSx0LHIpe3ZhciBuPWVbdF0rZVtyXSxpPWVbdCsxXStlW3IrMV07bj49NDI5NDk2NzI5NiYmaSsrLGVbdF09bixlW3QrMV09aX1mdW5jdGlvbiBpKGUsdCxyLG4pe3ZhciBpPWVbdF0rcjtyPDAmJihpKz00Mjk0OTY3Mjk2KTt2YXIgYT1lW3QrMV0rbjtpPj00Mjk0OTY3Mjk2JiZhKyssZVt0XT1pLGVbdCsxXT1hfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gZVt0XV5lW3QrMV08PDheZVt0KzJdPDwxNl5lW3QrM108PDI0fWZ1bmN0aW9uIHMoZSx0LHIsYSxzLG8pe3ZhciB1PWxbc10sZj1sW3MrMV0saD1sW29dLHA9bFtvKzFdO24oYyxlLHQpLGkoYyxlLHUsZik7dmFyIGQ9Y1thXV5jW2VdLHk9Y1thKzFdXmNbZSsxXTtjW2FdPXksY1thKzFdPWQsbihjLHIsYSksZD1jW3RdXmNbcl0seT1jW3QrMV1eY1tyKzFdLGNbdF09ZD4+PjI0Xnk8PDgsY1t0KzFdPXk+Pj4yNF5kPDw4LG4oYyxlLHQpLGkoYyxlLGgscCksZD1jW2FdXmNbZV0seT1jW2ErMV1eY1tlKzFdLGNbYV09ZD4+PjE2Xnk8PDE2LGNbYSsxXT15Pj4+MTZeZDw8MTYsbihjLHIsYSksZD1jW3RdXmNbcl0seT1jW3QrMV1eY1tyKzFdLGNbdF09eT4+PjMxXmQ8PDEsY1t0KzFdPWQ+Pj4zMV55PDwxfXZhciBvPW5ldyBVaW50MzJBcnJheShbNDA4OTIzNTcyMCwxNzc5MDMzNzAzLDIyMjc4NzM1OTUsMzE0NDEzNDI3Nyw0MjcxMTc1NzIzLDEwMTM5MDQyNDIsMTU5NTc1MDEyOSwyNzczNDgwNzYyLDI5MTc1NjUxMzcsMTM1OTg5MzExOSw3MjU1MTExOTksMjYwMDgyMjkyNCw0MjE1Mzg5NTQ3LDUyODczNDYzNSwzMjcwMzMyMDksMTU0MTQ1OTIyNV0pLHU9bmV3IFVpbnQ4QXJyYXkoWzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTQsMTAsNCw4LDksMTUsMTMsNiwxLDEyLDAsMiwxMSw3LDUsMywxMSw4LDEyLDAsNSwyLDE1LDEzLDEwLDE0LDMsNiw3LDEsOSw0LDcsOSwzLDEsMTMsMTIsMTEsMTQsMiw2LDUsMTAsNCwwLDE1LDgsOSwwLDUsNywyLDQsMTAsMTUsMTQsMSwxMSwxMiw2LDgsMywxMywyLDEyLDYsMTAsMCwxMSw4LDMsNCwxMyw3LDUsMTUsMTQsMSw5LDEyLDUsMSwxNSwxNCwxMyw0LDEwLDAsNyw2LDMsOSwyLDgsMTEsMTMsMTEsNywxNCwxMiwxLDMsOSw1LDAsMTUsNCw4LDYsMiwxMCw2LDE1LDE0LDksMTEsMywwLDgsMTIsMiwxMyw3LDEsNCwxMCw1LDEwLDIsOCw0LDcsNiwxLDUsMTUsMTEsOSwxNCwzLDEyLDEzLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNCwxMCw0LDgsOSwxNSwxMyw2LDEsMTIsMCwyLDExLDcsNSwzXS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiAyKmV9KSkpLGM9bmV3IFVpbnQzMkFycmF5KDMyKSxsPW5ldyBVaW50MzJBcnJheSgzMik7ZnVuY3Rpb24gZihlLHQpe3ZhciByPTA7Zm9yKHI9MDtyPDE2O3IrKyljW3JdPWUuaFtyXSxjW3IrMTZdPW9bcl07Zm9yKGNbMjRdPWNbMjRdXmUudCxjWzI1XT1jWzI1XV5lLnQvNDI5NDk2NzI5Nix0JiYoY1syOF09fmNbMjhdLGNbMjldPX5jWzI5XSkscj0wO3I8MzI7cisrKWxbcl09YShlLmIsNCpyKTtmb3Iocj0wO3I8MTI7cisrKXMoMCw4LDE2LDI0LHVbMTYqciswXSx1WzE2KnIrMV0pLHMoMiwxMCwxOCwyNix1WzE2KnIrMl0sdVsxNipyKzNdKSxzKDQsMTIsMjAsMjgsdVsxNipyKzRdLHVbMTYqcis1XSkscyg2LDE0LDIyLDMwLHVbMTYqcis2XSx1WzE2KnIrN10pLHMoMCwxMCwyMCwzMCx1WzE2KnIrOF0sdVsxNipyKzldKSxzKDIsMTIsMjIsMjQsdVsxNipyKzEwXSx1WzE2KnIrMTFdKSxzKDQsMTQsMTYsMjYsdVsxNipyKzEyXSx1WzE2KnIrMTNdKSxzKDYsOCwxOCwyOCx1WzE2KnIrMTRdLHVbMTYqcisxNV0pO2ZvcihyPTA7cjwxNjtyKyspZS5oW3JdPWUuaFtyXV5jW3JdXmNbcisxNl19ZnVuY3Rpb24gaChlLHQpe2lmKDA9PT1lfHxlPjY0KXRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgb3V0cHV0IGxlbmd0aCwgZXhwZWN0ZWQgMCA8IGxlbmd0aCA8PSA2NFwiKTtpZih0JiZ0Lmxlbmd0aD42NCl0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGtleSwgZXhwZWN0ZWQgVWludDhBcnJheSB3aXRoIDAgPCBsZW5ndGggPD0gNjRcIik7Zm9yKHZhciByPXtiOm5ldyBVaW50OEFycmF5KDEyOCksaDpuZXcgVWludDMyQXJyYXkoMTYpLHQ6MCxjOjAsb3V0bGVuOmV9LG49MDtuPDE2O24rKylyLmhbbl09b1tuXTt2YXIgaT10P3QubGVuZ3RoOjA7cmV0dXJuIHIuaFswXV49MTY4NDI3NTJeaTw8OF5lLHQmJihwKHIsdCksci5jPTEyOCkscn1mdW5jdGlvbiBwKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspMTI4PT09ZS5jJiYoZS50Kz1lLmMsZihlLCExKSxlLmM9MCksZS5iW2UuYysrXT10W3JdfWZ1bmN0aW9uIGQoZSl7Zm9yKGUudCs9ZS5jO2UuYzwxMjg7KWUuYltlLmMrK109MDtmKGUsITApO2Zvcih2YXIgdD1uZXcgVWludDhBcnJheShlLm91dGxlbikscj0wO3I8ZS5vdXRsZW47cisrKXRbcl09ZS5oW3I+PjJdPj44KigzJnIpO3JldHVybiB0fWZ1bmN0aW9uIHkodCxuLGkpe2k9aXx8NjQsdD1mdW5jdGlvbih0KXt2YXIgbjtpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSluPXQ7ZWxzZSBpZih0IGluc3RhbmNlb2YgZSluPW5ldyBVaW50OEFycmF5KHQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKHIpO249bmV3IFVpbnQ4QXJyYXkoZS5mcm9tKHQsXCJ1dGY4XCIpKX1yZXR1cm4gbn0odCk7dmFyIGE9aChpLG4pO3JldHVybiBwKGEsdCksZChhKX10LmJsYWtlMmJJbml0PWgsdC5ibGFrZTJiVXBkYXRlPXAsdC5ibGFrZTJiRmluYWw9ZCx0LmJsYWtlMmI9eSx0LmJsYWtlMmJIZXg9ZnVuY3Rpb24oZSx0LHIpe3ZhciBuLGk9eShlLHQscik7cmV0dXJuIG49aSxBcnJheS5wcm90b3R5cGUubWFwLmNhbGwobiwoZnVuY3Rpb24oZSl7cmV0dXJuKGU8MTY/XCIwXCI6XCJcIikrZS50b1N0cmluZygxNil9KSkuam9pbihcIlwiKX19KS5jYWxsKHRoaXMscigxMykuQnVmZmVyKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPW4ocigyNCkpLGE9cigxMSkscz1yKDM0KSxvPXIoMzMpLHU9cigyMik7dC5zaWduQnl0ZXM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBpLmRlZmF1bHQuc2lnbihhLl9mcm9tSW4ocy5pc1ByaXZhdGVLZXkoZSk/ZS5wcml2YXRlS2V5Om8ucHJpdmF0ZUtleShlKSksYS5fZnJvbUluKHQpLGEuX2Zyb21JbihyfHx1LnJhbmRvbUJ5dGVzKDY0KSkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPXIoMjApLGE9cig1Nikscz1yKDExKSxvPXIoMTQpLHU9cigzMyksYz1uKHIoMjQpKTt0LnZlcmlmeUFkZHJlc3M9ZnVuY3Rpb24oZSx0KXt2YXIgcj10P3QuY2hhaW5JZDp2b2lkIDA7dHJ5e3ZhciBuPXMuX2Zyb21JbihlKTtpZigxIT1uWzBdfHxyJiZuWzFdIT1hLkNoYWlkSWQudG9OdW1iZXIocikpcmV0dXJuITE7Zm9yKHZhciBpPW4uc2xpY2UoMCwyMiksYz1uLnNsaWNlKDIyLDI2KSxsPW8uX2hhc2hDaGFpbihpKS5zbGljZSgwLDQpLGY9MDtmPDQ7ZisrKWlmKGNbZl0hPWxbZl0pcmV0dXJuITE7aWYodCYmdC5wdWJsaWNLZXkpe3ZhciBoPXUuYWRkcmVzcyh7cHVibGljS2V5OnQucHVibGljS2V5fSxyKTtpZihuLmxlbmd0aCE9PWgubGVuZ3RoKXJldHVybiExO2ZvcihmPTA7ZjxoLmxlbmd0aDtmKyspaWYoaFtmXSE9PW5bZl0pcmV0dXJuITF9fWNhdGNoKGUpe3JldHVybiExfXJldHVybiEwfSx0LnZlcmlmeVNpZ25hdHVyZT1mdW5jdGlvbihlLHQscil7dHJ5e3JldHVybiBjLmRlZmF1bHQudmVyaWZ5KHMuX2Zyb21JbihlKSxzLl9mcm9tSW4odCkscy5fZnJvbUluKHIpKX1jYXRjaChlKXtyZXR1cm4hMX19LHQudmVyaWZ5UHVibGljS2V5PWZ1bmN0aW9uKGUpe3JldHVybiBzLl9mcm9tSW4oZSkubGVuZ3RoPT09aS5QVUJMSUNfS0VZX0xFTkdUSH19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oZSx0LHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoKGZ1bmN0aW9uKGksYSl7ZnVuY3Rpb24gcyhlKXt0cnl7dShuLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIG8oZSl7dHJ5e3Uobi50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gdShlKXtlLmRvbmU/aShlLnZhbHVlKTpuZXcgcigoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pKS50aGVuKHMsbyl9dSgobj1uLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19nZW5lcmF0b3J8fGZ1bmN0aW9uKGUsdCl7dmFyIHIsbixpLGEscz17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYoMSZpWzBdKXRocm93IGlbMV07cmV0dXJuIGlbMV19LHRyeXM6W10sb3BzOltdfTtyZXR1cm4gYT17bmV4dDpvKDApLHRocm93Om8oMSkscmV0dXJuOm8oMil9LFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmKGFbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksYTtmdW5jdGlvbiBvKGEpe3JldHVybiBmdW5jdGlvbihvKXtyZXR1cm4gZnVuY3Rpb24oYSl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtmb3IoO3M7KXRyeXtpZihyPTEsbiYmKGk9MiZhWzBdP24ucmV0dXJuOmFbMF0/bi50aHJvd3x8KChpPW4ucmV0dXJuKSYmaS5jYWxsKG4pLDApOm4ubmV4dCkmJiEoaT1pLmNhbGwobixhWzFdKSkuZG9uZSlyZXR1cm4gaTtzd2l0Y2gobj0wLGkmJihhPVsyJmFbMF0saS52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6aT1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEoaT0oaT1zLnRyeXMpLmxlbmd0aD4wJiZpW2kubGVuZ3RoLTFdKSYmKDY9PT1hWzBdfHwyPT09YVswXSkpe3M9MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFpfHxhWzFdPmlbMF0mJmFbMV08aVszXSkpe3MubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmcy5sYWJlbDxpWzFdKXtzLmxhYmVsPWlbMV0saT1hO2JyZWFrfWlmKGkmJnMubGFiZWw8aVsyXSl7cy5sYWJlbD1pWzJdLHMub3BzLnB1c2goYSk7YnJlYWt9aVsyXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfWE9dC5jYWxsKGUscyl9Y2F0Y2goZSl7YT1bNixlXSxuPTB9ZmluYWxseXtyPWk9MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2Esb10pfX19LGE9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgciBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pO3JldHVybiB0LmRlZmF1bHQ9ZSx0fSxzPXRoaXM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIG89YShyKDk5KSksdT1hKHIoOSkpLGM9YShyKDY0KSksbD1hKHIoMikpLGY9cigyMyksaD1yKDEwKSxwPWEocigxMDcpKTtvLm9pZHMuc2hhMjI0PVwiMi4xNi44NDAuMS4xMDEuMy40LjIuNFwiLG8ub2lkc1tcIjIuMTYuODQwLjEuMTAxLjMuNC4yLjRcIl09XCJzaGEyMjRcIixvLm9pZHNbXCJzaGEzLTIyNFwiXT1cIjIuMTYuODQwLjEuMTAxLjMuNC4yLjdcIixvLm9pZHNbXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMi43XCJdPVwic2hhMy0yMjRcIixvLm9pZHNbXCJzaGEzLTI1NlwiXT1cIjIuMTYuODQwLjEuMTAxLjMuNC4yLjhcIixvLm9pZHNbXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMi44XCJdPVwic2hhMy0yNTZcIixvLm9pZHNbXCJzaGEzLTM4NFwiXT1cIjIuMTYuODQwLjEuMTAxLjMuNC4yLjlcIixvLm9pZHNbXCIyLjE2Ljg0MC4xLjEwMS4zLjQuMi45XCJdPVwic2hhMy0zODRcIixvLm9pZHNbXCJzaGEzLTUxMlwiXT1cIjIuMTYuODQwLjEuMTAxLjMuNC4yLjEwXCIsby5vaWRzW1wiMi4xNi44NDAuMS4xMDEuMy40LjIuMTBcIl09XCJzaGEzLTUxMlwiLHQucGVtVG9CeXRlcz1mdW5jdGlvbihlKXtyZXR1cm4gZi5iYXNlNjREZWNvZGUoZS50cmltKCkuc3BsaXQoL1xcclxcbnxcXG4vKS5zbGljZSgxLC0xKS5qb2luKFwiXCIpLnRyaW0oKSl9O3ZhciBkPXtyc2FQcml2YXRlTm9uRW5jcnlwdGVkOlwiUlNBIFBSSVZBVEUgS0VZXCIscnNhUHVibGljOlwiUFVCTElDIEtFWVwifTt0LmJ5dGVzVG9QZW09ZnVuY3Rpb24oZSx0KXt2YXIgcj1cIi0tLS0tQkVHSU4gXCIrZFt0XStcIi0tLS0tXFxuXCIsbj1cIi0tLS0tRU5EIFwiK2RbdF0rXCItLS0tLVxcblwiLGk9Zi5iYXNlNjRFbmNvZGUoZSk7aS5sZW5ndGglNjQhPTAmJihpKz1cIiBcIi5yZXBlYXQoNjQtaS5sZW5ndGglNjQpKTtmb3IodmFyIGE9cixzPTA7czxpLmxlbmd0aC82NDtzKyspYSs9aS5zbGljZSg2NCpzLDY0KihzKzEpKStcIlxcblwiO3JldHVybiBhKz1ufSx0LnJzYUtleVBhaXJTeW5jPWZ1bmN0aW9uKGUscil7dmFyIG49by5yc2EuZ2VuZXJhdGVLZXlQYWlyKGUscik7cmV0dXJue3JzYVByaXZhdGU6dC5wZW1Ub0J5dGVzKG8ucHJpdmF0ZUtleVRvUGVtKG4ucHJpdmF0ZUtleSkpLHJzYVB1YmxpYzp0LnBlbVRvQnl0ZXMoby5wdWJsaWNLZXlUb1BlbShuLnB1YmxpY0tleSkpfX0sdC5yc2FLZXlQYWlyPWZ1bmN0aW9uKGUscil7cmV0dXJuIG4ocyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiBpKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVyblsyLG5ldyBQcm9taXNlKChmdW5jdGlvbihuLGkpe28ucnNhLmdlbmVyYXRlS2V5UGFpcihlLHIsKGZ1bmN0aW9uKGUscil7ZSYmaShlKSxuKHtyc2FQcml2YXRlOnQucGVtVG9CeXRlcyhvLnByaXZhdGVLZXlUb1BlbShyLnByaXZhdGVLZXkpKSxyc2FQdWJsaWM6dC5wZW1Ub0J5dGVzKG8ucHVibGljS2V5VG9QZW0oci5wdWJsaWNLZXkpKX0pfSkpfSkpXX0pKX0pKX07dmFyIHksZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLnNoYTNEaWdlc3Q9ZSx0aGlzLmFsZ29yaXRobT10fXJldHVybiBlLm1ha2VDcmVhdG9yPWZ1bmN0aW9uKHQscil7cmV0dXJue2NyZWF0ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgZSh0LmNyZWF0ZSgpLHIpfX19LGUucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLnNoYTNEaWdlc3QudXBkYXRlKGguc3RyaW5nVG9CeXRlcyhlLG51bGw9PXQ/XCJyYXdcIjp0KSksdGhpc30sZS5wcm90b3R5cGUuZGlnZXN0PWZ1bmN0aW9uKCl7dmFyIGU9VWludDhBcnJheS5mcm9tKHRoaXMuc2hhM0RpZ2VzdC5kaWdlc3QoKSk7cmV0dXJuIGwuY3JlYXRlQnVmZmVyKGguYnl0ZXNUb1N0cmluZyhlLFwicmF3XCIpKX0sZX0oKSxtPXtNRDU6YyxTSEExOnUuYWxnb3JpdGhtcy5zaGExLFNIQTIyNDooeT1cIlNIQTIyNFwiLGZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiRGlnZXN0IFwiK3krXCIgaXMgdW5zdXBwb3J0ZWRcIil9KSxTSEEyNTY6dS5hbGdvcml0aG1zLnNoYTI1NixTSEEzODQ6dS5hbGdvcml0aG1zLnNoYTM4NCxTSEE1MTI6dS5hbGdvcml0aG1zLnNoYTUxMixcIlNIQTMtMjI0XCI6Zy5tYWtlQ3JlYXRvcihwLnNoYTNfMjI0LFwic2hhMy0yMjRcIiksXCJTSEEzLTI1NlwiOmcubWFrZUNyZWF0b3IocC5zaGEzXzI1NixcInNoYTMtMjU2XCIpLFwiU0hBMy0zODRcIjpnLm1ha2VDcmVhdG9yKHAuc2hhM18zODQsXCJzaGEzLTM4NFwiKSxcIlNIQTMtNTEyXCI6Zy5tYWtlQ3JlYXRvcihwLnNoYTNfNTEyLFwic2hhMy01MTJcIil9O3QucnNhU2lnbj1mdW5jdGlvbihlLHIsbil7dm9pZCAwPT09biYmKG49XCJTSEEyNTZcIik7dmFyIGk9dC5ieXRlc1RvUGVtKGUsXCJyc2FQcml2YXRlTm9uRW5jcnlwdGVkXCIpLGE9by5wcml2YXRlS2V5RnJvbVBlbShpKSxzPW1bbl0uY3JlYXRlKCk7cmV0dXJuIHMudXBkYXRlKGguYnl0ZXNUb1N0cmluZyhyLFwicmF3XCIpKSxoLnN0cmluZ1RvQnl0ZXMoYS5zaWduKHMpLFwicmF3XCIpfSx0LnJzYVZlcmlmeT1mdW5jdGlvbihlLHIsbixpKXt2b2lkIDA9PT1pJiYoaT1cIlNIQTI1NlwiKTt2YXIgYT1vLnB1YmxpY0tleUZyb21QZW0odC5ieXRlc1RvUGVtKGUsXCJyc2FQdWJsaWNcIikpLHM9bVtpXS5jcmVhdGUoKTtyZXR1cm4gcy51cGRhdGUoaC5ieXRlc1RvU3RyaW5nKHIpLFwicmF3XCIpLGEudmVyaWZ5KHMuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSxoLmJ5dGVzVG9TdHJpbmcobixcInJhd1wiKSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDE1KSxyKDE2KSxyKDU3KSxyKDM1KSxyKDU5KSxyKDEwMykscig2MykscigyNSkscigyKSxyKDYyKTt2YXIgaT1uLmFzbjEsYT1lLmV4cG9ydHM9bi5wa2k9bi5wa2l8fHt9O2EucGVtVG9EZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9bi5wZW0uZGVjb2RlKGUpWzBdO2lmKHQucHJvY1R5cGUmJlwiRU5DUllQVEVEXCI9PT10LnByb2NUeXBlLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbnZlcnQgUEVNIHRvIERFUjsgUEVNIGlzIGVuY3J5cHRlZC5cIik7cmV0dXJuIG4udXRpbC5jcmVhdGVCdWZmZXIodC5ib2R5KX0sYS5wcml2YXRlS2V5RnJvbVBlbT1mdW5jdGlvbihlKXt2YXIgdD1uLnBlbS5kZWNvZGUoZSlbMF07aWYoXCJQUklWQVRFIEtFWVwiIT09dC50eXBlJiZcIlJTQSBQUklWQVRFIEtFWVwiIT09dC50eXBlKXt2YXIgcj1uZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgaXMgbm90IFwiUFJJVkFURSBLRVlcIiBvciBcIlJTQSBQUklWQVRFIEtFWVwiLicpO3Rocm93IHIuaGVhZGVyVHlwZT10LnR5cGUscn1pZih0LnByb2NUeXBlJiZcIkVOQ1JZUFRFRFwiPT09dC5wcm9jVHlwZS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IHByaXZhdGUga2V5IGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLlwiKTt2YXIgcz1pLmZyb21EZXIodC5ib2R5KTtyZXR1cm4gYS5wcml2YXRlS2V5RnJvbUFzbjEocyl9LGEucHJpdmF0ZUtleVRvUGVtPWZ1bmN0aW9uKGUsdCl7dmFyIHI9e3R5cGU6XCJSU0EgUFJJVkFURSBLRVlcIixib2R5OmkudG9EZXIoYS5wcml2YXRlS2V5VG9Bc24xKGUpKS5nZXRCeXRlcygpfTtyZXR1cm4gbi5wZW0uZW5jb2RlKHIse21heGxpbmU6dH0pfSxhLnByaXZhdGVLZXlJbmZvVG9QZW09ZnVuY3Rpb24oZSx0KXt2YXIgcj17dHlwZTpcIlBSSVZBVEUgS0VZXCIsYm9keTppLnRvRGVyKGUpLmdldEJ5dGVzKCl9O3JldHVybiBuLnBlbS5lbmNvZGUocix7bWF4bGluZTp0fSl9fSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDIpO3ZhciBpPVsyMTcsMTIwLDI0OSwxOTYsMjUsMjIxLDE4MSwyMzcsNDAsMjMzLDI1MywxMjEsNzQsMTYwLDIxNiwxNTcsMTk4LDEyNiw1NSwxMzEsNDMsMTE4LDgzLDE0Miw5OCw3NiwxMDAsMTM2LDY4LDEzOSwyNTEsMTYyLDIzLDE1NCw4OSwyNDUsMTM1LDE3OSw3OSwxOSw5Nyw2OSwxMDksMTQxLDksMTI5LDEyNSw1MCwxODksMTQzLDY0LDIzNSwxMzQsMTgzLDEyMywxMSwyNDAsMTQ5LDMzLDM0LDkyLDEwNyw3OCwxMzAsODQsMjE0LDEwMSwxNDcsMjA2LDk2LDE3OCwyOCwxMTUsODYsMTkyLDIwLDE2NywxNDAsMjQxLDIyMCwxOCwxMTcsMjAyLDMxLDU5LDE5MCwyMjgsMjA5LDY2LDYxLDIxMiw0OCwxNjMsNjAsMTgyLDM4LDExMSwxOTEsMTQsMjE4LDcwLDEwNSw3LDg3LDM5LDI0MiwyOSwxNTUsMTg4LDE0OCw2NywzLDI0OCwxNywxOTksMjQ2LDE0NCwyMzksNjIsMjMxLDYsMTk1LDIxMyw0NywyMDAsMTAyLDMwLDIxNSw4LDIzMiwyMzQsMjIyLDEyOCw4MiwyMzgsMjQ3LDEzMiwxNzAsMTE0LDE3Miw1Myw3NywxMDYsNDIsMTUwLDI2LDIxMCwxMTMsOTAsMjEsNzMsMTE2LDc1LDE1OSwyMDgsOTQsNCwyNCwxNjQsMjM2LDE5NCwyMjQsNjUsMTEwLDE1LDgxLDIwMywyMDQsMzYsMTQ1LDE3NSw4MCwxNjEsMjQ0LDExMiw1NywxNTMsMTI0LDU4LDEzMywzNSwxODQsMTgwLDEyMiwyNTIsMiw1NCw5MSwzNyw4NSwxNTEsNDksNDUsOTMsMjUwLDE1MiwyMjcsMTM4LDE0NiwxNzQsNSwyMjMsNDEsMTYsMTAzLDEwOCwxODYsMjAxLDIxMSwwLDIzMCwyMDcsMjI1LDE1OCwxNjgsNDQsOTksMjIsMSw2Myw4OCwyMjYsMTM3LDE2OSwxMyw1Niw1MiwyNywxNzEsNTEsMjU1LDE3NiwxODcsNzIsMTIsOTUsMTg1LDE3NywyMDUsNDYsMTk3LDI0MywyMTksNzEsMjI5LDE2NSwxNTYsMTE5LDEwLDE2NiwzMiwxMDQsMjU0LDEyNywxOTMsMTczXSxhPVsxLDIsMyw1XSxzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PHQmNjU1MzV8KDY1NTM1JmUpPj4xNi10fSxvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKDY1NTM1JmUpPj50fGU8PDE2LXQmNjU1MzV9O2UuZXhwb3J0cz1uLnJjMj1uLnJjMnx8e30sbi5yYzIuZXhwYW5kS2V5PWZ1bmN0aW9uKGUsdCl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPW4udXRpbC5jcmVhdGVCdWZmZXIoZSkpLHQ9dHx8MTI4O3ZhciByLGE9ZSxzPWUubGVuZ3RoKCksbz10LHU9TWF0aC5jZWlsKG8vOCksYz0yNTU+Pig3Jm8pO2ZvcihyPXM7cjwxMjg7cisrKWEucHV0Qnl0ZShpW2EuYXQoci0xKSthLmF0KHItcykmMjU1XSk7Zm9yKGEuc2V0QXQoMTI4LXUsaVthLmF0KDEyOC11KSZjXSkscj0xMjctdTtyPj0wO3ItLSlhLnNldEF0KHIsaVthLmF0KHIrMSleYS5hdChyK3UpXSk7cmV0dXJuIGF9O3ZhciB1PWZ1bmN0aW9uKGUsdCxyKXt2YXIgaSx1LGMsbCxmPSExLGg9bnVsbCxwPW51bGwsZD1udWxsLHk9W107Zm9yKGU9bi5yYzIuZXhwYW5kS2V5KGUsdCksYz0wO2M8NjQ7YysrKXkucHVzaChlLmdldEludDE2TGUoKSk7cj8oaT1mdW5jdGlvbihlKXtmb3IoYz0wO2M8NDtjKyspZVtjXSs9eVtsXSsoZVsoYyszKSU0XSZlWyhjKzIpJTRdKSsofmVbKGMrMyklNF0mZVsoYysxKSU0XSksZVtjXT1zKGVbY10sYVtjXSksbCsrfSx1PWZ1bmN0aW9uKGUpe2ZvcihjPTA7Yzw0O2MrKyllW2NdKz15WzYzJmVbKGMrMyklNF1dfSk6KGk9ZnVuY3Rpb24oZSl7Zm9yKGM9MztjPj0wO2MtLSllW2NdPW8oZVtjXSxhW2NdKSxlW2NdLT15W2xdKyhlWyhjKzMpJTRdJmVbKGMrMiklNF0pKyh+ZVsoYyszKSU0XSZlWyhjKzEpJTRdKSxsLS19LHU9ZnVuY3Rpb24oZSl7Zm9yKGM9MztjPj0wO2MtLSllW2NdLT15WzYzJmVbKGMrMyklNF1dfSk7dmFyIGc9ZnVuY3Rpb24oZSl7dmFyIHQ9W107Zm9yKGM9MDtjPDQ7YysrKXt2YXIgbj1oLmdldEludDE2TGUoKTtudWxsIT09ZCYmKHI/bl49ZC5nZXRJbnQxNkxlKCk6ZC5wdXRJbnQxNkxlKG4pKSx0LnB1c2goNjU1MzUmbil9bD1yPzA6NjM7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspZm9yKHZhciBhPTA7YTxlW2ldWzBdO2ErKyllW2ldWzFdKHQpO2ZvcihjPTA7Yzw0O2MrKyludWxsIT09ZCYmKHI/ZC5wdXRJbnQxNkxlKHRbY10pOnRbY11ePWQuZ2V0SW50MTZMZSgpKSxwLnB1dEludDE2TGUodFtjXSl9LG09bnVsbDtyZXR1cm4gbT17c3RhcnQ6ZnVuY3Rpb24oZSx0KXtlJiZcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9bi51dGlsLmNyZWF0ZUJ1ZmZlcihlKSksZj0hMSxoPW4udXRpbC5jcmVhdGVCdWZmZXIoKSxwPXR8fG5ldyBuLnV0aWwuY3JlYXRlQnVmZmVyLGQ9ZSxtLm91dHB1dD1wfSx1cGRhdGU6ZnVuY3Rpb24oZSl7Zm9yKGZ8fGgucHV0QnVmZmVyKGUpO2gubGVuZ3RoKCk+PTg7KWcoW1s1LGldLFsxLHVdLFs2LGldLFsxLHVdLFs1LGldXSl9LGZpbmlzaDpmdW5jdGlvbihlKXt2YXIgdD0hMDtpZihyKWlmKGUpdD1lKDgsaCwhcik7ZWxzZXt2YXIgbj04PT09aC5sZW5ndGgoKT84OjgtaC5sZW5ndGgoKTtoLmZpbGxXaXRoQnl0ZShuLG4pfWlmKHQmJihmPSEwLG0udXBkYXRlKCkpLCFyJiYodD0wPT09aC5sZW5ndGgoKSkpaWYoZSl0PWUoOCxwLCFyKTtlbHNle3ZhciBpPXAubGVuZ3RoKCksYT1wLmF0KGktMSk7YT5pP3Q9ITE6cC50cnVuY2F0ZShhKX1yZXR1cm4gdH19fTtuLnJjMi5zdGFydEVuY3J5cHRpbmc9ZnVuY3Rpb24oZSx0LHIpe3ZhciBpPW4ucmMyLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIoZSwxMjgpO3JldHVybiBpLnN0YXJ0KHQsciksaX0sbi5yYzIuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcj1mdW5jdGlvbihlLHQpe3JldHVybiB1KGUsdCwhMCl9LG4ucmMyLnN0YXJ0RGVjcnlwdGluZz1mdW5jdGlvbihlLHQscil7dmFyIGk9bi5yYzIuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcihlLDEyOCk7cmV0dXJuIGkuc3RhcnQodCxyKSxpfSxuLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHUoZSx0LCExKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMikscigxMikscig2MSk7dmFyIGk9ZS5leHBvcnRzPW4ucGtjczE9bi5wa2NzMXx8e307ZnVuY3Rpb24gYShlLHQscil7cnx8KHI9bi5tZC5zaGExLmNyZWF0ZSgpKTtmb3IodmFyIGk9XCJcIixhPU1hdGguY2VpbCh0L3IuZGlnZXN0TGVuZ3RoKSxzPTA7czxhOysrcyl7dmFyIG89U3RyaW5nLmZyb21DaGFyQ29kZShzPj4yNCYyNTUscz4+MTYmMjU1LHM+PjgmMjU1LDI1NSZzKTtyLnN0YXJ0KCksci51cGRhdGUoZStvKSxpKz1yLmRpZ2VzdCgpLmdldEJ5dGVzKCl9cmV0dXJuIGkuc3Vic3RyaW5nKDAsdCl9aS5lbmNvZGVfcnNhX29hZXA9ZnVuY3Rpb24oZSx0LHIpe3ZhciBpLHMsbyx1O1wic3RyaW5nXCI9PXR5cGVvZiByPyhpPXIscz1hcmd1bWVudHNbM118fHZvaWQgMCxvPWFyZ3VtZW50c1s0XXx8dm9pZCAwKTpyJiYoaT1yLmxhYmVsfHx2b2lkIDAscz1yLnNlZWR8fHZvaWQgMCxvPXIubWR8fHZvaWQgMCxyLm1nZjEmJnIubWdmMS5tZCYmKHU9ci5tZ2YxLm1kKSksbz9vLnN0YXJ0KCk6bz1uLm1kLnNoYTEuY3JlYXRlKCksdXx8KHU9byk7dmFyIGM9TWF0aC5jZWlsKGUubi5iaXRMZW5ndGgoKS84KSxsPWMtMipvLmRpZ2VzdExlbmd0aC0yO2lmKHQubGVuZ3RoPmwpdGhyb3coZz1uZXcgRXJyb3IoXCJSU0FFUy1PQUVQIGlucHV0IG1lc3NhZ2UgbGVuZ3RoIGlzIHRvbyBsb25nLlwiKSkubGVuZ3RoPXQubGVuZ3RoLGcubWF4TGVuZ3RoPWwsZztpfHwoaT1cIlwiKSxvLnVwZGF0ZShpLFwicmF3XCIpO2Zvcih2YXIgZj1vLmRpZ2VzdCgpLGg9XCJcIixwPWwtdC5sZW5ndGgsZD0wO2Q8cDtkKyspaCs9XCJcXDBcIjt2YXIgeT1mLmdldEJ5dGVzKCkraCtcIlx1MDAwMVwiK3Q7aWYocyl7aWYocy5sZW5ndGghPT1vLmRpZ2VzdExlbmd0aCl7dmFyIGc7dGhyb3coZz1uZXcgRXJyb3IoXCJJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguXCIpKS5zZWVkTGVuZ3RoPXMubGVuZ3RoLGcuZGlnZXN0TGVuZ3RoPW8uZGlnZXN0TGVuZ3RoLGd9fWVsc2Ugcz1uLnJhbmRvbS5nZXRCeXRlcyhvLmRpZ2VzdExlbmd0aCk7dmFyIG09YShzLGMtby5kaWdlc3RMZW5ndGgtMSx1KSx2PW4udXRpbC54b3JCeXRlcyh5LG0seS5sZW5ndGgpLGI9YSh2LG8uZGlnZXN0TGVuZ3RoLHUpLEU9bi51dGlsLnhvckJ5dGVzKHMsYixzLmxlbmd0aCk7cmV0dXJuXCJcXDBcIitFK3Z9LGkuZGVjb2RlX3JzYV9vYWVwPWZ1bmN0aW9uKGUsdCxyKXt2YXIgaSxzLG87XCJzdHJpbmdcIj09dHlwZW9mIHI/KGk9cixzPWFyZ3VtZW50c1szXXx8dm9pZCAwKTpyJiYoaT1yLmxhYmVsfHx2b2lkIDAscz1yLm1kfHx2b2lkIDAsci5tZ2YxJiZyLm1nZjEubWQmJihvPXIubWdmMS5tZCkpO3ZhciB1PU1hdGguY2VpbChlLm4uYml0TGVuZ3RoKCkvOCk7aWYodC5sZW5ndGghPT11KXRocm93KHY9bmV3IEVycm9yKFwiUlNBRVMtT0FFUCBlbmNvZGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuXCIpKS5sZW5ndGg9dC5sZW5ndGgsdi5leHBlY3RlZExlbmd0aD11LHY7aWYodm9pZCAwPT09cz9zPW4ubWQuc2hhMS5jcmVhdGUoKTpzLnN0YXJ0KCksb3x8KG89cyksdTwyKnMuZGlnZXN0TGVuZ3RoKzIpdGhyb3cgbmV3IEVycm9yKFwiUlNBRVMtT0FFUCBrZXkgaXMgdG9vIHNob3J0IGZvciB0aGUgaGFzaCBmdW5jdGlvbi5cIik7aXx8KGk9XCJcIikscy51cGRhdGUoaSxcInJhd1wiKTtmb3IodmFyIGM9cy5kaWdlc3QoKS5nZXRCeXRlcygpLGw9dC5jaGFyQXQoMCksZj10LnN1YnN0cmluZygxLHMuZGlnZXN0TGVuZ3RoKzEpLGg9dC5zdWJzdHJpbmcoMStzLmRpZ2VzdExlbmd0aCkscD1hKGgscy5kaWdlc3RMZW5ndGgsbyksZD1uLnV0aWwueG9yQnl0ZXMoZixwLGYubGVuZ3RoKSx5PWEoZCx1LXMuZGlnZXN0TGVuZ3RoLTEsbyksZz1uLnV0aWwueG9yQnl0ZXMoaCx5LGgubGVuZ3RoKSxtPWcuc3Vic3RyaW5nKDAscy5kaWdlc3RMZW5ndGgpLHY9XCJcXDBcIiE9PWwsYj0wO2I8cy5kaWdlc3RMZW5ndGg7KytiKXZ8PWMuY2hhckF0KGIpIT09bS5jaGFyQXQoYik7Zm9yKHZhciBFPTEsUz1zLmRpZ2VzdExlbmd0aCxUPXMuZGlnZXN0TGVuZ3RoO1Q8Zy5sZW5ndGg7VCsrKXt2YXIgQz1nLmNoYXJDb2RlQXQoVCksQT0xJkNeMSxJPUU/NjU1MzQ6MDt2fD1DJkksUys9RSY9QX1pZih2fHwxIT09Zy5jaGFyQ29kZUF0KFMpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUlNBRVMtT0FFUCBwYWRkaW5nLlwiKTtyZXR1cm4gZy5zdWJzdHJpbmcoUysxKX19LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMikscig2MCkscigxMiksZnVuY3Rpb24oKXtpZihuLnByaW1lKWUuZXhwb3J0cz1uLnByaW1lO2Vsc2V7dmFyIHQ9ZS5leHBvcnRzPW4ucHJpbWU9bi5wcmltZXx8e30scj1uLmpzYm4uQmlnSW50ZWdlcixpPVs2LDQsMiw0LDIsNCw2LDJdLGE9bmV3IHIobnVsbCk7YS5mcm9tSW50KDMwKTt2YXIgcz1mdW5jdGlvbihlLHQpe3JldHVybiBlfHR9O3QuZ2VuZXJhdGVQcm9iYWJsZVByaW1lPWZ1bmN0aW9uKGUsdCxpKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYoaT10LHQ9e30pO3ZhciBhPSh0PXR8fHt9KS5hbGdvcml0aG18fFwiUFJJTUVJTkNcIjtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9e25hbWU6YX0pLGEub3B0aW9ucz1hLm9wdGlvbnN8fHt9O3ZhciBzPXQucHJuZ3x8bi5yYW5kb20sYz17bmV4dEJ5dGVzOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1zLmdldEJ5dGVzU3luYyhlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKWVbcl09dC5jaGFyQ29kZUF0KHIpfX07aWYoXCJQUklNRUlOQ1wiPT09YS5uYW1lKXJldHVybiBmdW5jdGlvbihlLHQsaSxhKXtpZihcIndvcmtlcnNcImluIGkpcmV0dXJuIGZ1bmN0aW9uKGUsdCxpLGEpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBXb3JrZXIpcmV0dXJuIG8oZSx0LGksYSk7dmFyIHM9dShlLHQpLGM9aS53b3JrZXJzLGw9aS53b3JrTG9hZHx8MTAwLGY9MzAqbC84LGg9aS53b3JrZXJTY3JpcHR8fFwiZm9yZ2UvcHJpbWUud29ya2VyLmpzXCI7aWYoLTE9PT1jKXJldHVybiBuLnV0aWwuZXN0aW1hdGVDb3JlcygoZnVuY3Rpb24oZSx0KXtlJiYodD0yKSxjPXQtMSxwKCl9KSk7ZnVuY3Rpb24gcCgpe2M9TWF0aC5tYXgoMSxjKTtmb3IodmFyIG49W10saT0wO2k8YzsrK2kpbltpXT1uZXcgV29ya2VyKGgpO2ZvcihpPTA7aTxjOysraSluW2ldLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIscCk7dmFyIG89ITE7ZnVuY3Rpb24gcChpKXtpZighbyl7MDt2YXIgYz1pLmRhdGE7aWYoYy5mb3VuZCl7Zm9yKHZhciBoPTA7aDxuLmxlbmd0aDsrK2gpbltoXS50ZXJtaW5hdGUoKTtyZXR1cm4gbz0hMCxhKG51bGwsbmV3IHIoYy5wcmltZSwxNikpfXMuYml0TGVuZ3RoKCk+ZSYmKHM9dShlLHQpKTt2YXIgcD1zLnRvU3RyaW5nKDE2KTtpLnRhcmdldC5wb3N0TWVzc2FnZSh7aGV4OnAsd29ya0xvYWQ6bH0pLHMuZEFkZE9mZnNldChmLDApfX19cCgpfShlLHQsaSxhKTtyZXR1cm4gbyhlLHQsaSxhKX0oZSxjLGEub3B0aW9ucyxpKTt0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaW1lIGdlbmVyYXRpb24gYWxnb3JpdGhtOiBcIithLm5hbWUpfX1mdW5jdGlvbiBvKGUsdCxyLGEpe3ZhciBzPXUoZSx0KSxvPWZ1bmN0aW9uKGUpe3JldHVybiBlPD0xMDA/Mjc6ZTw9MTUwPzE4OmU8PTIwMD8xNTplPD0yNTA/MTI6ZTw9MzAwPzk6ZTw9MzUwPzg6ZTw9NDAwPzc6ZTw9NTAwPzY6ZTw9NjAwPzU6ZTw9ODAwPzQ6ZTw9MTI1MD8zOjJ9KHMuYml0TGVuZ3RoKCkpO1wibWlsbGVyUmFiaW5UZXN0c1wiaW4gciYmKG89ci5taWxsZXJSYWJpblRlc3RzKTt2YXIgYz0xMDtcIm1heEJsb2NrVGltZVwiaW4gciYmKGM9ci5tYXhCbG9ja1RpbWUpLGZ1bmN0aW9uIGUodCxyLGEscyxvLGMsbCl7dmFyIGY9K25ldyBEYXRlO2Rve2lmKHQuYml0TGVuZ3RoKCk+ciYmKHQ9dShyLGEpKSx0LmlzUHJvYmFibGVQcmltZShvKSlyZXR1cm4gbChudWxsLHQpO3QuZEFkZE9mZnNldChpW3MrKyU4XSwwKX13aGlsZShjPDB8fCtuZXcgRGF0ZS1mPGMpO24udXRpbC5zZXRJbW1lZGlhdGUoKGZ1bmN0aW9uKCl7ZSh0LHIsYSxzLG8sYyxsKX0pKX0ocyxlLHQsMCxvLGMsYSl9ZnVuY3Rpb24gdShlLHQpe3ZhciBuPW5ldyByKGUsdCksaT1lLTE7cmV0dXJuIG4udGVzdEJpdChpKXx8bi5iaXR3aXNlVG8oci5PTkUuc2hpZnRMZWZ0KGkpLHMsbiksbi5kQWRkT2Zmc2V0KDMxLW4ubW9kKGEpLmJ5dGVWYWx1ZSgpLDApLG59fSgpfSxmdW5jdGlvbihlLHQscil7dmFyIG49cigxKTtyKDE1KSxyKDMyKSxyKDE2KSxyKDEwNCkscig1NykscigxMikscigyNSkscig2MSkscigyKSxyKDYyKTt2YXIgaT1uLmFzbjEsYT1uLnBraSxzPWUuZXhwb3J0cz1uLnBrY3MxMj1uLnBrY3MxMnx8e30sbz17bmFtZTpcIkNvbnRlbnRJbmZvXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiQ29udGVudEluZm8uY29udGVudFR5cGVcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNvbnRlbnRUeXBlXCJ9LHtuYW1lOlwiQ29udGVudEluZm8uY29udGVudFwiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImNvbnRlbnRcIn1dfSx1PXtuYW1lOlwiUEZYXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUEZYLnZlcnNpb25cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJ2ZXJzaW9uXCJ9LG8se25hbWU6XCJQRlgubWFjRGF0YVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLG9wdGlvbmFsOiEwLGNhcHR1cmVBc24xOlwibWFjXCIsdmFsdWU6W3tuYW1lOlwiUEZYLm1hY0RhdGEubWFjXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIlBGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJtYWNBbGdvcml0aG1cIn0se25hbWU6XCJQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLnBhcmFtZXRlcnNcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCxjYXB0dXJlQXNuMTpcIm1hY0FsZ29yaXRobVBhcmFtZXRlcnNcIn1dfSx7bmFtZTpcIlBGWC5tYWNEYXRhLm1hYy5kaWdlc3RcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PQ1RFVFNUUklORyxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwibWFjRGlnZXN0XCJ9XX0se25hbWU6XCJQRlgubWFjRGF0YS5tYWNTYWx0XCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0NURVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcIm1hY1NhbHRcIn0se25hbWU6XCJQRlgubWFjRGF0YS5pdGVyYXRpb25zXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxvcHRpb25hbDohMCxjYXB0dXJlOlwibWFjSXRlcmF0aW9uc1wifV19XX0sYz17bmFtZTpcIlNhZmVCYWdcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJTYWZlQmFnLmJhZ0lkXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJiYWdJZFwifSx7bmFtZTpcIlNhZmVCYWcuYmFnVmFsdWVcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsY29uc3RydWN0ZWQ6ITAsY2FwdHVyZUFzbjE6XCJiYWdWYWx1ZVwifSx7bmFtZTpcIlNhZmVCYWcuYmFnQXR0cmlidXRlc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFVCxjb25zdHJ1Y3RlZDohMCxvcHRpb25hbDohMCxjYXB0dXJlOlwiYmFnQXR0cmlidXRlc1wifV19LGw9e25hbWU6XCJBdHRyaWJ1dGVcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJBdHRyaWJ1dGUuYXR0cklkXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJvaWRcIn0se25hbWU6XCJBdHRyaWJ1dGUuYXR0clZhbHVlc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFVCxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlOlwidmFsdWVzXCJ9XX0sZj17bmFtZTpcIkNlcnRCYWdcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJDZXJ0QmFnLmNlcnRJZFwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiY2VydElkXCJ9LHtuYW1lOlwiQ2VydEJhZy5jZXJ0VmFsdWVcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiQ2VydEJhZy5jZXJ0VmFsdWVbMF1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuQ2xhc3MuT0NURVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNlcnRcIn1dfV19O2Z1bmN0aW9uIGgoZSx0LHIsbil7Zm9yKHZhciBpPVtdLGE9MDthPGUubGVuZ3RoO2ErKylmb3IodmFyIHM9MDtzPGVbYV0uc2FmZUJhZ3MubGVuZ3RoO3MrKyl7dmFyIG89ZVthXS5zYWZlQmFnc1tzXTt2b2lkIDAhPT1uJiZvLnR5cGUhPT1ufHwobnVsbCE9PXQ/dm9pZCAwIT09by5hdHRyaWJ1dGVzW3RdJiZvLmF0dHJpYnV0ZXNbdF0uaW5kZXhPZihyKT49MCYmaS5wdXNoKG8pOmkucHVzaChvKSl9cmV0dXJuIGl9ZnVuY3Rpb24gcChlKXtpZihlLmNvbXBvc2VkfHxlLmNvbnN0cnVjdGVkKXtmb3IodmFyIHQ9bi51dGlsLmNyZWF0ZUJ1ZmZlcigpLHI9MDtyPGUudmFsdWUubGVuZ3RoOysrcil0LnB1dEJ5dGVzKGUudmFsdWVbcl0udmFsdWUpO2UuY29tcG9zZWQ9ZS5jb25zdHJ1Y3RlZD0hMSxlLnZhbHVlPXQuZ2V0Qnl0ZXMoKX1yZXR1cm4gZX1mdW5jdGlvbiBkKGUsdCl7dmFyIHI9e30scz1bXTtpZighaS52YWxpZGF0ZShlLG4ucGtjczcuYXNuMS5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yLHIscykpdGhyb3cobz1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBFbmNyeXB0ZWRDb250ZW50SW5mby5cIikpLmVycm9ycz1zLG87dmFyIG8sdT1pLmRlclRvT2lkKHIuY29udGVudFR5cGUpO2lmKHUhPT1hLm9pZHMuZGF0YSl0aHJvdyhvPW5ldyBFcnJvcihcIlBLQ1MjMTIgRW5jcnlwdGVkQ29udGVudEluZm8gQ29udGVudFR5cGUgaXMgbm90IERhdGEuXCIpKS5vaWQ9dSxvO3U9aS5kZXJUb09pZChyLmVuY0FsZ29yaXRobSk7dmFyIGM9YS5wYmUuZ2V0Q2lwaGVyKHUsci5lbmNQYXJhbWV0ZXIsdCksbD1wKHIuZW5jcnlwdGVkQ29udGVudEFzbjEpLGY9bi51dGlsLmNyZWF0ZUJ1ZmZlcihsLnZhbHVlKTtpZihjLnVwZGF0ZShmKSwhYy5maW5pc2goKSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCBQS0NTIzEyIFNhZmVDb250ZW50cy5cIik7cmV0dXJuIGMub3V0cHV0LmdldEJ5dGVzKCl9ZnVuY3Rpb24geShlLHQscil7aWYoIXQmJjA9PT1lLmxlbmd0aClyZXR1cm5bXTtpZigoZT1pLmZyb21EZXIoZSx0KSkudGFnQ2xhc3MhPT1pLkNsYXNzLlVOSVZFUlNBTHx8ZS50eXBlIT09aS5UeXBlLlNFUVVFTkNFfHwhMCE9PWUuY29uc3RydWN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiUEtDUyMxMiBTYWZlQ29udGVudHMgZXhwZWN0ZWQgdG8gYmUgYSBTRVFVRU5DRSBPRiBTYWZlQmFnLlwiKTtmb3IodmFyIG49W10scz0wO3M8ZS52YWx1ZS5sZW5ndGg7cysrKXt2YXIgbz1lLnZhbHVlW3NdLHU9e30sbD1bXTtpZighaS52YWxpZGF0ZShvLGMsdSxsKSl0aHJvdyhtPW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFNhZmVCYWcuXCIpKS5lcnJvcnM9bCxtO3ZhciBoLHAsZD17dHlwZTppLmRlclRvT2lkKHUuYmFnSWQpLGF0dHJpYnV0ZXM6Zyh1LmJhZ0F0dHJpYnV0ZXMpfTtuLnB1c2goZCk7dmFyIHk9dS5iYWdWYWx1ZS52YWx1ZVswXTtzd2l0Y2goZC50eXBlKXtjYXNlIGEub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnOmlmKG51bGw9PT0oeT1hLmRlY3J5cHRQcml2YXRlS2V5SW5mbyh5LHIpKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjcnlwdCBQS0NTIzggU2hyb3VkZWRLZXlCYWcsIHdyb25nIHBhc3N3b3JkP1wiKTtjYXNlIGEub2lkcy5rZXlCYWc6dHJ5e2Qua2V5PWEucHJpdmF0ZUtleUZyb21Bc24xKHkpfWNhdGNoKGUpe2Qua2V5PW51bGwsZC5hc24xPXl9Y29udGludWU7Y2FzZSBhLm9pZHMuY2VydEJhZzpoPWYscD1mdW5jdGlvbigpe2lmKGkuZGVyVG9PaWQodS5jZXJ0SWQpIT09YS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSl7dmFyIGU9bmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY2VydGlmaWNhdGUgdHlwZSwgb25seSBYLjUwOSBzdXBwb3J0ZWQuXCIpO3Rocm93IGUub2lkPWkuZGVyVG9PaWQodS5jZXJ0SWQpLGV9dmFyIHI9aS5mcm9tRGVyKHUuY2VydCx0KTt0cnl7ZC5jZXJ0PWEuY2VydGlmaWNhdGVGcm9tQXNuMShyLCEwKX1jYXRjaChlKXtkLmNlcnQ9bnVsbCxkLmFzbjE9cn19O2JyZWFrO2RlZmF1bHQ6dmFyIG07dGhyb3cobT1uZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBQS0NTIzEyIFNhZmVCYWcgdHlwZS5cIikpLm9pZD1kLnR5cGUsbX1pZih2b2lkIDAhPT1oJiYhaS52YWxpZGF0ZSh5LGgsdSxsKSl0aHJvdyhtPW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MjMTIgXCIraC5uYW1lKSkuZXJyb3JzPWwsbTtwKCl9cmV0dXJuIG59ZnVuY3Rpb24gZyhlKXt2YXIgdD17fTtpZih2b2lkIDAhPT1lKWZvcih2YXIgcj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbj17fSxzPVtdO2lmKCFpLnZhbGlkYXRlKGVbcl0sbCxuLHMpKXt2YXIgbz1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS5cIik7dGhyb3cgby5lcnJvcnM9cyxvfXZhciB1PWkuZGVyVG9PaWQobi5vaWQpO2lmKHZvaWQgMCE9PWEub2lkc1t1XSl7dFthLm9pZHNbdV1dPVtdO2Zvcih2YXIgYz0wO2M8bi52YWx1ZXMubGVuZ3RoOysrYyl0W2Eub2lkc1t1XV0ucHVzaChuLnZhbHVlc1tjXS52YWx1ZSl9fXJldHVybiB0fXMucGtjczEyRnJvbUFzbjE9ZnVuY3Rpb24oZSx0LHIpe1wic3RyaW5nXCI9PXR5cGVvZiB0PyhyPXQsdD0hMCk6dm9pZCAwPT09dCYmKHQ9ITApO3ZhciBjPXt9O2lmKCFpLnZhbGlkYXRlKGUsdSxjLFtdKSl0aHJvdyhsPW5ldyBFcnJvcihcIkNhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiBBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLlwiKSkuZXJyb3JzPWwsbDt2YXIgbCxmPXt2ZXJzaW9uOmMudmVyc2lvbi5jaGFyQ29kZUF0KDApLHNhZmVDb250ZW50czpbXSxnZXRCYWdzOmZ1bmN0aW9uKGUpe3ZhciB0LHI9e307cmV0dXJuXCJsb2NhbEtleUlkXCJpbiBlP3Q9ZS5sb2NhbEtleUlkOlwibG9jYWxLZXlJZEhleFwiaW4gZSYmKHQ9bi51dGlsLmhleFRvQnl0ZXMoZS5sb2NhbEtleUlkSGV4KSksdm9pZCAwPT09dCYmIShcImZyaWVuZGx5TmFtZVwiaW4gZSkmJlwiYmFnVHlwZVwiaW4gZSYmKHJbZS5iYWdUeXBlXT1oKGYuc2FmZUNvbnRlbnRzLG51bGwsbnVsbCxlLmJhZ1R5cGUpKSx2b2lkIDAhPT10JiYoci5sb2NhbEtleUlkPWgoZi5zYWZlQ29udGVudHMsXCJsb2NhbEtleUlkXCIsdCxlLmJhZ1R5cGUpKSxcImZyaWVuZGx5TmFtZVwiaW4gZSYmKHIuZnJpZW5kbHlOYW1lPWgoZi5zYWZlQ29udGVudHMsXCJmcmllbmRseU5hbWVcIixlLmZyaWVuZGx5TmFtZSxlLmJhZ1R5cGUpKSxyfSxnZXRCYWdzQnlGcmllbmRseU5hbWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaChmLnNhZmVDb250ZW50cyxcImZyaWVuZGx5TmFtZVwiLGUsdCl9LGdldEJhZ3NCeUxvY2FsS2V5SWQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaChmLnNhZmVDb250ZW50cyxcImxvY2FsS2V5SWRcIixlLHQpfX07aWYoMyE9PWMudmVyc2lvbi5jaGFyQ29kZUF0KDApKXRocm93KGw9bmV3IEVycm9yKFwiUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC5cIikpLnZlcnNpb249Yy52ZXJzaW9uLmNoYXJDb2RlQXQoMCksbDtpZihpLmRlclRvT2lkKGMuY29udGVudFR5cGUpIT09YS5vaWRzLmRhdGEpdGhyb3cobD1uZXcgRXJyb3IoXCJPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC5cIikpLm9pZD1pLmRlclRvT2lkKGMuY29udGVudFR5cGUpLGw7dmFyIGc9Yy5jb250ZW50LnZhbHVlWzBdO2lmKGcudGFnQ2xhc3MhPT1pLkNsYXNzLlVOSVZFUlNBTHx8Zy50eXBlIT09aS5UeXBlLk9DVEVUU1RSSU5HKXRocm93IG5ldyBFcnJvcihcIlBLQ1MjMTIgYXV0aFNhZmUgY29udGVudCBkYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuXCIpO2lmKGc9cChnKSxjLm1hYyl7dmFyIG09bnVsbCx2PTAsYj1pLmRlclRvT2lkKGMubWFjQWxnb3JpdGhtKTtzd2l0Y2goYil7Y2FzZSBhLm9pZHMuc2hhMTptPW4ubWQuc2hhMS5jcmVhdGUoKSx2PTIwO2JyZWFrO2Nhc2UgYS5vaWRzLnNoYTI1NjptPW4ubWQuc2hhMjU2LmNyZWF0ZSgpLHY9MzI7YnJlYWs7Y2FzZSBhLm9pZHMuc2hhMzg0Om09bi5tZC5zaGEzODQuY3JlYXRlKCksdj00ODticmVhaztjYXNlIGEub2lkcy5zaGE1MTI6bT1uLm1kLnNoYTUxMi5jcmVhdGUoKSx2PTY0O2JyZWFrO2Nhc2UgYS5vaWRzLm1kNTptPW4ubWQubWQ1LmNyZWF0ZSgpLHY9MTZ9aWYobnVsbD09PW0pdGhyb3cgbmV3IEVycm9yKFwiUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06IFwiK2IpO3ZhciBFPW5ldyBuLnV0aWwuQnl0ZUJ1ZmZlcihjLm1hY1NhbHQpLFM9XCJtYWNJdGVyYXRpb25zXCJpbiBjP3BhcnNlSW50KG4udXRpbC5ieXRlc1RvSGV4KGMubWFjSXRlcmF0aW9ucyksMTYpOjEsVD1zLmdlbmVyYXRlS2V5KHIsRSwzLFMsdixtKSxDPW4uaG1hYy5jcmVhdGUoKTtpZihDLnN0YXJ0KG0sVCksQy51cGRhdGUoZy52YWx1ZSksQy5nZXRNYWMoKS5nZXRCeXRlcygpIT09Yy5tYWNEaWdlc3QpdGhyb3cgbmV3IEVycm9yKFwiUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkP1wiKX1yZXR1cm4gZnVuY3Rpb24oZSx0LHIsbil7aWYoKHQ9aS5mcm9tRGVyKHQscikpLnRhZ0NsYXNzIT09aS5DbGFzcy5VTklWRVJTQUx8fHQudHlwZSE9PWkuVHlwZS5TRVFVRU5DRXx8ITAhPT10LmNvbnN0cnVjdGVkKXRocm93IG5ldyBFcnJvcihcIlBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgZXhwZWN0ZWQgdG8gYmUgYSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1wiKTtmb3IodmFyIHM9MDtzPHQudmFsdWUubGVuZ3RoO3MrKyl7dmFyIHU9dC52YWx1ZVtzXSxjPXt9LGw9W107aWYoIWkudmFsaWRhdGUodSxvLGMsbCkpdGhyb3cobT1uZXcgRXJyb3IoXCJDYW5ub3QgcmVhZCBDb250ZW50SW5mby5cIikpLmVycm9ycz1sLG07dmFyIGY9e2VuY3J5cHRlZDohMX0saD1udWxsLGc9Yy5jb250ZW50LnZhbHVlWzBdO3N3aXRjaChpLmRlclRvT2lkKGMuY29udGVudFR5cGUpKXtjYXNlIGEub2lkcy5kYXRhOmlmKGcudGFnQ2xhc3MhPT1pLkNsYXNzLlVOSVZFUlNBTHx8Zy50eXBlIT09aS5UeXBlLk9DVEVUU1RSSU5HKXRocm93IG5ldyBFcnJvcihcIlBLQ1MjMTIgU2FmZUNvbnRlbnRzIERhdGEgaXMgbm90IGFuIE9DVEVUIFNUUklORy5cIik7aD1wKGcpLnZhbHVlO2JyZWFrO2Nhc2UgYS5vaWRzLmVuY3J5cHRlZERhdGE6aD1kKGcsbiksZi5lbmNyeXB0ZWQ9ITA7YnJlYWs7ZGVmYXVsdDp2YXIgbTt0aHJvdyhtPW5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFBLQ1MjMTIgY29udGVudFR5cGUuXCIpKS5jb250ZW50VHlwZT1pLmRlclRvT2lkKGMuY29udGVudFR5cGUpLG19Zi5zYWZlQmFncz15KGgscixuKSxlLnNhZmVDb250ZW50cy5wdXNoKGYpfX0oZixnLnZhbHVlLHQsciksZn0scy50b1BrY3MxMkFzbjE9ZnVuY3Rpb24oZSx0LHIsbyl7KG89b3x8e30pLnNhbHRTaXplPW8uc2FsdFNpemV8fDgsby5jb3VudD1vLmNvdW50fHwyMDQ4LG8uYWxnb3JpdGhtPW8uYWxnb3JpdGhtfHxvLmVuY0FsZ29yaXRobXx8XCJhZXMxMjhcIixcInVzZU1hY1wiaW4gb3x8KG8udXNlTWFjPSEwKSxcImxvY2FsS2V5SWRcImluIG98fChvLmxvY2FsS2V5SWQ9bnVsbCksXCJnZW5lcmF0ZUxvY2FsS2V5SWRcImluIG98fChvLmdlbmVyYXRlTG9jYWxLZXlJZD0hMCk7dmFyIHUsYz1vLmxvY2FsS2V5SWQ7aWYobnVsbCE9PWMpYz1uLnV0aWwuaGV4VG9CeXRlcyhjKTtlbHNlIGlmKG8uZ2VuZXJhdGVMb2NhbEtleUlkKWlmKHQpe3ZhciBsPW4udXRpbC5pc0FycmF5KHQpP3RbMF06dDtcInN0cmluZ1wiPT10eXBlb2YgbCYmKGw9YS5jZXJ0aWZpY2F0ZUZyb21QZW0obCkpLChCPW4ubWQuc2hhMS5jcmVhdGUoKSkudXBkYXRlKGkudG9EZXIoYS5jZXJ0aWZpY2F0ZVRvQXNuMShsKSkuZ2V0Qnl0ZXMoKSksYz1CLmRpZ2VzdCgpLmdldEJ5dGVzKCl9ZWxzZSBjPW4ucmFuZG9tLmdldEJ5dGVzKDIwKTt2YXIgZj1bXTtudWxsIT09YyYmZi5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKGEub2lkcy5sb2NhbEtleUlkKS5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VULCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0NURVRTVFJJTkcsITEsYyldKV0pKSxcImZyaWVuZGx5TmFtZVwiaW4gbyYmZi5wdXNoKGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKGEub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVQsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5CTVBTVFJJTkcsITEsby5mcmllbmRseU5hbWUpXSldKSksZi5sZW5ndGg+MCYmKHU9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFVCwhMCxmKSk7dmFyIGg9W10scD1bXTtudWxsIT09dCYmKHA9bi51dGlsLmlzQXJyYXkodCk/dDpbdF0pO2Zvcih2YXIgZD1bXSx5PTA7eTxwLmxlbmd0aDsrK3kpe1wic3RyaW5nXCI9PXR5cGVvZih0PXBbeV0pJiYodD1hLmNlcnRpZmljYXRlRnJvbVBlbSh0KSk7dmFyIGc9MD09PXk/dTp2b2lkIDAsbT1hLmNlcnRpZmljYXRlVG9Bc24xKHQpLHY9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoYS5vaWRzLmNlcnRCYWcpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywwLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihhLm9pZHMueDUwOUNlcnRpZmljYXRlKS5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMCwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9DVEVUU1RSSU5HLCExLGkudG9EZXIobSkuZ2V0Qnl0ZXMoKSldKV0pXSksZ10pO2QucHVzaCh2KX1pZihkLmxlbmd0aD4wKXt2YXIgYj1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsZCksRT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihhLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PQ1RFVFNUUklORywhMSxpLnRvRGVyKGIpLmdldEJ5dGVzKCkpXSldKTtoLnB1c2goRSl9dmFyIFM9bnVsbDtpZihudWxsIT09ZSl7dmFyIFQ9YS53cmFwUnNhUHJpdmF0ZUtleShhLnByaXZhdGVLZXlUb0FzbjEoZSkpO1M9bnVsbD09PXI/aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoYS5vaWRzLmtleUJhZykuZ2V0Qnl0ZXMoKSksaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW1RdKSx1XSk6aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoYS5vaWRzLnBrY3M4U2hyb3VkZWRLZXlCYWcpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywwLCEwLFthLmVuY3J5cHRQcml2YXRlS2V5SW5mbyhULHIsbyldKSx1XSk7dmFyIEM9aS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtTXSksQT1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PSUQsITEsaS5vaWRUb0RlcihhLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksaS5jcmVhdGUoaS5DbGFzcy5DT05URVhUX1NQRUNJRklDLDAsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5PQ1RFVFNUUklORywhMSxpLnRvRGVyKEMpLmdldEJ5dGVzKCkpXSldKTtoLnB1c2goQSl9dmFyIEksdz1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsaCk7aWYoby51c2VNYWMpe3ZhciBCPW4ubWQuc2hhMS5jcmVhdGUoKSxOPW5ldyBuLnV0aWwuQnl0ZUJ1ZmZlcihuLnJhbmRvbS5nZXRCeXRlcyhvLnNhbHRTaXplKSksUj1vLmNvdW50LF89KGU9cy5nZW5lcmF0ZUtleShyLE4sMyxSLDIwKSxuLmhtYWMuY3JlYXRlKCkpO18uc3RhcnQoQixlKSxfLnVwZGF0ZShpLnRvRGVyKHcpLmdldEJ5dGVzKCkpO3ZhciBQPV8uZ2V0TWFjKCk7ST1pLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLlNFUVVFTkNFLCEwLFtpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0lELCExLGkub2lkVG9EZXIoYS5vaWRzLnNoYTEpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5OVUxMLCExLFwiXCIpXSksaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9DVEVUU1RSSU5HLCExLFAuZ2V0Qnl0ZXMoKSldKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuT0NURVRTVFJJTkcsITEsTi5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuSU5URUdFUiwhMSxpLmludGVnZXJUb0RlcihSKS5nZXRCeXRlcygpKV0pfXJldHVybiBpLmNyZWF0ZShpLkNsYXNzLlVOSVZFUlNBTCxpLlR5cGUuU0VRVUVOQ0UsITAsW2kuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5JTlRFR0VSLCExLGkuaW50ZWdlclRvRGVyKDMpLmdldEJ5dGVzKCkpLGkuY3JlYXRlKGkuQ2xhc3MuVU5JVkVSU0FMLGkuVHlwZS5TRVFVRU5DRSwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9JRCwhMSxpLm9pZFRvRGVyKGEub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxpLmNyZWF0ZShpLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsMCwhMCxbaS5jcmVhdGUoaS5DbGFzcy5VTklWRVJTQUwsaS5UeXBlLk9DVEVUU1RSSU5HLCExLGkudG9EZXIodykuZ2V0Qnl0ZXMoKSldKV0pLEldKX0scy5nZW5lcmF0ZUtleT1uLnBiZS5nZW5lcmF0ZVBrY3MxMktleX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7cigxNSkscigyKTt2YXIgaT1uLmFzbjEsYT1lLmV4cG9ydHM9bi5wa2NzN2FzbjE9bi5wa2NzN2FzbjF8fHt9O24ucGtjczc9bi5wa2NzN3x8e30sbi5wa2NzNy5hc24xPWE7dmFyIHM9e25hbWU6XCJDb250ZW50SW5mb1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFUVVFTkNFLGNvbnN0cnVjdGVkOiEwLHZhbHVlOlt7bmFtZTpcIkNvbnRlbnRJbmZvLkNvbnRlbnRUeXBlXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJjb250ZW50VHlwZVwifSx7bmFtZTpcIkNvbnRlbnRJbmZvLmNvbnRlbnRcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsdHlwZTowLGNvbnN0cnVjdGVkOiEwLG9wdGlvbmFsOiEwLGNhcHR1cmVBc24xOlwiY29udGVudFwifV19O2EuY29udGVudEluZm9WYWxpZGF0b3I9czt2YXIgbz17bmFtZTpcIkVuY3J5cHRlZENvbnRlbnRJbmZvXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudFR5cGVcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImNvbnRlbnRUeXBlXCJ9LHtuYW1lOlwiRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5hbGdvcml0aG1cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5PSUQsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcImVuY0FsZ29yaXRobVwifSx7bmFtZTpcIkVuY3J5cHRlZENvbnRlbnRJbmZvLmNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlclwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLGNhcHR1cmVBc24xOlwiZW5jUGFyYW1ldGVyXCJ9XX0se25hbWU6XCJFbmNyeXB0ZWRDb250ZW50SW5mby5lbmNyeXB0ZWRDb250ZW50XCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MCxjYXB0dXJlOlwiZW5jcnlwdGVkQ29udGVudFwiLGNhcHR1cmVBc24xOlwiZW5jcnlwdGVkQ29udGVudEFzbjFcIn1dfTthLmVudmVsb3BlZERhdGFWYWxpZGF0b3I9e25hbWU6XCJFbnZlbG9wZWREYXRhXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiRW52ZWxvcGVkRGF0YS5WZXJzaW9uXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwidmVyc2lvblwifSx7bmFtZTpcIkVudmVsb3BlZERhdGEuUmVjaXBpZW50SW5mb3NcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVQsY29uc3RydWN0ZWQ6ITAsY2FwdHVyZUFzbjE6XCJyZWNpcGllbnRJbmZvc1wifV0uY29uY2F0KG8pfSxhLmVuY3J5cHRlZERhdGFWYWxpZGF0b3I9e25hbWU6XCJFbmNyeXB0ZWREYXRhXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiRW5jcnlwdGVkRGF0YS5WZXJzaW9uXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwidmVyc2lvblwifV0uY29uY2F0KG8pfTt2YXIgdT17bmFtZTpcIlNpZ25lckluZm9cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJTaWduZXJJbmZvLnZlcnNpb25cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExfSx7bmFtZTpcIlNpZ25lckluZm8uaXNzdWVyQW5kU2VyaWFsTnVtYmVyXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuaXNzdWVyXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsY2FwdHVyZUFzbjE6XCJpc3N1ZXJcIn0se25hbWU6XCJTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5zZXJpYWxOdW1iZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJzZXJpYWxcIn1dfSx7bmFtZTpcIlNpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0uYWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0lELGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJkaWdlc3RBbGdvcml0aG1cIn0se25hbWU6XCJTaWduZXJJbmZvLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlQXNuMTpcImRpZ2VzdFBhcmFtZXRlclwiLG9wdGlvbmFsOiEwfV19LHtuYW1lOlwiU2lnbmVySW5mby5hdXRoZW50aWNhdGVkQXR0cmlidXRlc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx0eXBlOjAsY29uc3RydWN0ZWQ6ITAsb3B0aW9uYWw6ITAsY2FwdHVyZTpcImF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzXCJ9LHtuYW1lOlwiU2lnbmVySW5mby5kaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsY2FwdHVyZTpcInNpZ25hdHVyZUFsZ29yaXRobVwifSx7bmFtZTpcIlNpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0XCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuT0NURVRTVFJJTkcsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInNpZ25hdHVyZVwifSx7bmFtZTpcIlNpZ25lckluZm8udW5hdXRoZW50aWNhdGVkQXR0cmlidXRlc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyx0eXBlOjEsY29uc3RydWN0ZWQ6ITAsb3B0aW9uYWw6ITAsY2FwdHVyZTpcInVuYXV0aGVudGljYXRlZEF0dHJpYnV0ZXNcIn1dfTthLnNpZ25lZERhdGFWYWxpZGF0b3I9e25hbWU6XCJTaWduZWREYXRhXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiU2lnbmVkRGF0YS5WZXJzaW9uXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuSU5URUdFUixjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwidmVyc2lvblwifSx7bmFtZTpcIlNpZ25lZERhdGEuRGlnZXN0QWxnb3JpdGhtc1wiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLlNFVCxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImRpZ2VzdEFsZ29yaXRobXNcIn0scyx7bmFtZTpcIlNpZ25lZERhdGEuQ2VydGlmaWNhdGVzXCIsdGFnQ2xhc3M6aS5DbGFzcy5DT05URVhUX1NQRUNJRklDLHR5cGU6MCxvcHRpb25hbDohMCxjYXB0dXJlQXNuMTpcImNlcnRpZmljYXRlc1wifSx7bmFtZTpcIlNpZ25lZERhdGEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHNcIix0YWdDbGFzczppLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsdHlwZToxLG9wdGlvbmFsOiEwLGNhcHR1cmVBc24xOlwiY3Jsc1wifSx7bmFtZTpcIlNpZ25lZERhdGEuU2lnbmVySW5mb3NcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVQsY2FwdHVyZTpcInNpZ25lckluZm9zXCIsb3B0aW9uYWw6ITAsdmFsdWU6W3VdfV19LGEucmVjaXBpZW50SW5mb1ZhbGlkYXRvcj17bmFtZTpcIlJlY2lwaWVudEluZm9cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJSZWNpcGllbnRJbmZvLnZlcnNpb25cIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5JTlRFR0VSLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJ2ZXJzaW9uXCJ9LHtuYW1lOlwiUmVjaXBpZW50SW5mby5pc3N1ZXJBbmRTZXJpYWxcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCx2YWx1ZTpbe25hbWU6XCJSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXJcIix0YWdDbGFzczppLkNsYXNzLlVOSVZFUlNBTCx0eXBlOmkuVHlwZS5TRVFVRU5DRSxjb25zdHJ1Y3RlZDohMCxjYXB0dXJlQXNuMTpcImlzc3VlclwifSx7bmFtZTpcIlJlY2lwaWVudEluZm8uaXNzdWVyQW5kU2VyaWFsLnNlcmlhbE51bWJlclwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLklOVEVHRVIsY29uc3RydWN0ZWQ6ITEsY2FwdHVyZTpcInNlcmlhbFwifV19LHtuYW1lOlwiUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtXCIsdGFnQ2xhc3M6aS5DbGFzcy5VTklWRVJTQUwsdHlwZTppLlR5cGUuU0VRVUVOQ0UsY29uc3RydWN0ZWQ6ITAsdmFsdWU6W3tuYW1lOlwiUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtLmFsZ29yaXRobVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9JRCxjb25zdHJ1Y3RlZDohMSxjYXB0dXJlOlwiZW5jQWxnb3JpdGhtXCJ9LHtuYW1lOlwiUmVjaXBpZW50SW5mby5rZXlFbmNyeXB0aW9uQWxnb3JpdGhtLnBhcmFtZXRlclwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLGNvbnN0cnVjdGVkOiExLGNhcHR1cmVBc24xOlwiZW5jUGFyYW1ldGVyXCJ9XX0se25hbWU6XCJSZWNpcGllbnRJbmZvLmVuY3J5cHRlZEtleVwiLHRhZ0NsYXNzOmkuQ2xhc3MuVU5JVkVSU0FMLHR5cGU6aS5UeXBlLk9DVEVUU1RSSU5HLGNvbnN0cnVjdGVkOiExLGNhcHR1cmU6XCJlbmNLZXlcIn1dfX0sZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXIoMSk7cigxMDYpLGUuZXhwb3J0cz1uLm1nZj1uLm1nZnx8e30sbi5tZ2YubWdmMT1uLm1nZjF9LGZ1bmN0aW9uKGUsdCxyKXt2YXIgbj1yKDEpO3IoMiksbi5tZ2Y9bi5tZ2Z8fHt9LChlLmV4cG9ydHM9bi5tZ2YubWdmMT1uLm1nZjE9bi5tZ2YxfHx7fSkuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybntnZW5lcmF0ZTpmdW5jdGlvbih0LHIpe2Zvcih2YXIgaT1uZXcgbi51dGlsLkJ5dGVCdWZmZXIsYT1NYXRoLmNlaWwoci9lLmRpZ2VzdExlbmd0aCkscz0wO3M8YTtzKyspe3ZhciBvPW5ldyBuLnV0aWwuQnl0ZUJ1ZmZlcjtvLnB1dEludDMyKHMpLGUuc3RhcnQoKSxlLnVwZGF0ZSh0K28uZ2V0Qnl0ZXMoKSksaS5wdXRCdWZmZXIoZS5kaWdlc3QoKSl9cmV0dXJuIGkudHJ1bmNhdGUoaS5sZW5ndGgoKS1yKSxpLmdldEJ5dGVzKCl9fX19LGZ1bmN0aW9uKGUsdCxyKXsoZnVuY3Rpb24obixpKXt2YXIgYTtcbi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqLyFmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBzPVwiaW5wdXQgaXMgaW52YWxpZCB0eXBlXCIsbz1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LHU9bz93aW5kb3c6e307dS5KU19TSEEzX05PX1dJTkRPVyYmKG89ITEpO3ZhciBjPSFvJiZcIm9iamVjdFwiPT10eXBlb2Ygc2VsZjshdS5KU19TSEEzX05PX05PREVfSlMmJlwib2JqZWN0XCI9PXR5cGVvZiBuJiZuLnZlcnNpb25zJiZuLnZlcnNpb25zLm5vZGU/dT1pOmMmJih1PXNlbGYpO3ZhciBsPSF1LkpTX1NIQTNfTk9fQ09NTU9OX0pTJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZS5leHBvcnRzLGY9cigxMDgpLGg9IXUuSlNfU0hBM19OT19BUlJBWV9CVUZGRVImJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlcixwPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLnNwbGl0KFwiXCIpLGQ9WzQsMTAyNCwyNjIxNDQsNjcxMDg4NjRdLHk9WzAsOCwxNiwyNF0sZz1bMSwwLDMyODk4LDAsMzI5MDYsMjE0NzQ4MzY0OCwyMTQ3NTE2NDE2LDIxNDc0ODM2NDgsMzI5MDcsMCwyMTQ3NDgzNjQ5LDAsMjE0NzUxNjU0NSwyMTQ3NDgzNjQ4LDMyNzc3LDIxNDc0ODM2NDgsMTM4LDAsMTM2LDAsMjE0NzUxNjQyNSwwLDIxNDc0ODM2NTgsMCwyMTQ3NTE2NTU1LDAsMTM5LDIxNDc0ODM2NDgsMzI5MDUsMjE0NzQ4MzY0OCwzMjc3MSwyMTQ3NDgzNjQ4LDMyNzcwLDIxNDc0ODM2NDgsMTI4LDIxNDc0ODM2NDgsMzI3NzgsMCwyMTQ3NDgzNjU4LDIxNDc0ODM2NDgsMjE0NzUxNjU0NSwyMTQ3NDgzNjQ4LDMyODk2LDIxNDc0ODM2NDgsMjE0NzQ4MzY0OSwwLDIxNDc1MTY0MjQsMjE0NzQ4MzY0OF0sbT1bMjI0LDI1NiwzODQsNTEyXSx2PVsxMjgsMjU2XSxiPVtcImhleFwiLFwiYnVmZmVyXCIsXCJhcnJheUJ1ZmZlclwiLFwiYXJyYXlcIixcImRpZ2VzdFwiXSxFPXsxMjg6MTY4LDI1NjoxMzZ9OyF1LkpTX1NIQTNfTk9fTk9ERV9KUyYmQXJyYXkuaXNBcnJheXx8KEFycmF5LmlzQXJyYXk9ZnVuY3Rpb24oZSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfSksIWh8fCF1LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcmJkFycmF5QnVmZmVyLmlzVmlld3x8KEFycmF5QnVmZmVyLmlzVmlldz1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZSYmZS5idWZmZXImJmUuYnVmZmVyLmNvbnN0cnVjdG9yPT09QXJyYXlCdWZmZXJ9KTtmb3IodmFyIFM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gbmV3IEQoZSx0LGUpLnVwZGF0ZShuKVtyXSgpfX0sVD1mdW5jdGlvbihlLHQscil7cmV0dXJuIGZ1bmN0aW9uKG4saSl7cmV0dXJuIG5ldyBEKGUsdCxpKS51cGRhdGUobilbcl0oKX19LEM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBmdW5jdGlvbih0LG4saSxhKXtyZXR1cm4gTltcImNzaGFrZVwiK2VdLnVwZGF0ZSh0LG4saSxhKVtyXSgpfX0sQT1mdW5jdGlvbihlLHQscil7cmV0dXJuIGZ1bmN0aW9uKHQsbixpLGEpe3JldHVybiBOW1wia21hY1wiK2VdLnVwZGF0ZSh0LG4saSxhKVtyXSgpfX0sST1mdW5jdGlvbihlLHQscixuKXtmb3IodmFyIGk9MDtpPGIubGVuZ3RoOysraSl7dmFyIGE9YltpXTtlW2FdPXQocixuLGEpfXJldHVybiBlfSx3PWZ1bmN0aW9uKGUsdCl7dmFyIHI9UyhlLHQsXCJoZXhcIik7cmV0dXJuIHIuY3JlYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBEKGUsdCxlKX0sci51cGRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHIuY3JlYXRlKCkudXBkYXRlKGUpfSxJKHIsUyxlLHQpfSxCPVt7bmFtZTpcImtlY2Nha1wiLHBhZGRpbmc6WzEsMjU2LDY1NTM2LDE2Nzc3MjE2XSxiaXRzOm0sY3JlYXRlTWV0aG9kOnd9LHtuYW1lOlwic2hhM1wiLHBhZGRpbmc6WzYsMTUzNiwzOTMyMTYsMTAwNjYzMjk2XSxiaXRzOm0sY3JlYXRlTWV0aG9kOnd9LHtuYW1lOlwic2hha2VcIixwYWRkaW5nOlszMSw3OTM2LDIwMzE2MTYsNTIwMDkzNjk2XSxiaXRzOnYsY3JlYXRlTWV0aG9kOmZ1bmN0aW9uKGUsdCl7dmFyIHI9VChlLHQsXCJoZXhcIik7cmV0dXJuIHIuY3JlYXRlPWZ1bmN0aW9uKHIpe3JldHVybiBuZXcgRChlLHQscil9LHIudXBkYXRlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIuY3JlYXRlKHQpLnVwZGF0ZShlKX0sSShyLFQsZSx0KX19LHtuYW1lOlwiY3NoYWtlXCIscGFkZGluZzpkLGJpdHM6dixjcmVhdGVNZXRob2Q6ZnVuY3Rpb24oZSx0KXt2YXIgcj1FW2VdLG49QyhlLDAsXCJoZXhcIik7cmV0dXJuIG4uY3JlYXRlPWZ1bmN0aW9uKG4saSxhKXtyZXR1cm4gaXx8YT9uZXcgRChlLHQsbikuYnl0ZXBhZChbaSxhXSxyKTpOW1wic2hha2VcIitlXS5jcmVhdGUobil9LG4udXBkYXRlPWZ1bmN0aW9uKGUsdCxyLGkpe3JldHVybiBuLmNyZWF0ZSh0LHIsaSkudXBkYXRlKGUpfSxJKG4sQyxlLHQpfX0se25hbWU6XCJrbWFjXCIscGFkZGluZzpkLGJpdHM6dixjcmVhdGVNZXRob2Q6ZnVuY3Rpb24oZSx0KXt2YXIgcj1FW2VdLG49QShlLDAsXCJoZXhcIik7cmV0dXJuIG4uY3JlYXRlPWZ1bmN0aW9uKG4saSxhKXtyZXR1cm4gbmV3IFYoZSx0LGkpLmJ5dGVwYWQoW1wiS01BQ1wiLGFdLHIpLmJ5dGVwYWQoW25dLHIpfSxuLnVwZGF0ZT1mdW5jdGlvbihlLHQscixpKXtyZXR1cm4gbi5jcmVhdGUoZSxyLGkpLnVwZGF0ZSh0KX0sSShuLEEsZSx0KX19XSxOPXt9LFI9W10sXz0wO188Qi5sZW5ndGg7KytfKWZvcih2YXIgUD1CW19dLE89UC5iaXRzLGs9MDtrPE8ubGVuZ3RoOysrayl7dmFyIFU9UC5uYW1lK1wiX1wiK09ba107aWYoUi5wdXNoKFUpLE5bVV09UC5jcmVhdGVNZXRob2QoT1trXSxQLnBhZGRpbmcpLFwic2hhM1wiIT09UC5uYW1lKXt2YXIgTD1QLm5hbWUrT1trXTtSLnB1c2goTCksTltMXT1OW1VdfX1mdW5jdGlvbiBEKGUsdCxyKXt0aGlzLmJsb2Nrcz1bXSx0aGlzLnM9W10sdGhpcy5wYWRkaW5nPXQsdGhpcy5vdXRwdXRCaXRzPXIsdGhpcy5yZXNldD0hMCx0aGlzLmZpbmFsaXplZD0hMSx0aGlzLmJsb2NrPTAsdGhpcy5zdGFydD0wLHRoaXMuYmxvY2tDb3VudD0xNjAwLShlPDwxKT4+NSx0aGlzLmJ5dGVDb3VudD10aGlzLmJsb2NrQ291bnQ8PDIsdGhpcy5vdXRwdXRCbG9ja3M9cj4+NSx0aGlzLmV4dHJhQnl0ZXM9KDMxJnIpPj4zO2Zvcih2YXIgbj0wO248NTA7KytuKXRoaXMuc1tuXT0wfWZ1bmN0aW9uIFYoZSx0LHIpe0QuY2FsbCh0aGlzLGUsdCxyKX1ELnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oZSl7aWYodGhpcy5maW5hbGl6ZWQpdGhyb3cgbmV3IEVycm9yKFwiZmluYWxpemUgYWxyZWFkeSBjYWxsZWRcIik7dmFyIHQscj10eXBlb2YgZTtpZihcInN0cmluZ1wiIT09cil7aWYoXCJvYmplY3RcIiE9PXIpdGhyb3cgbmV3IEVycm9yKHMpO2lmKG51bGw9PT1lKXRocm93IG5ldyBFcnJvcihzKTtpZihoJiZlLmNvbnN0cnVjdG9yPT09QXJyYXlCdWZmZXIpZT1uZXcgVWludDhBcnJheShlKTtlbHNlIGlmKCEoQXJyYXkuaXNBcnJheShlKXx8aCYmQXJyYXlCdWZmZXIuaXNWaWV3KGUpKSl0aHJvdyBuZXcgRXJyb3Iocyk7dD0hMH1mb3IodmFyIG4saSxhPXRoaXMuYmxvY2tzLG89dGhpcy5ieXRlQ291bnQsdT1lLmxlbmd0aCxjPXRoaXMuYmxvY2tDb3VudCxsPTAsZj10aGlzLnM7bDx1Oyl7aWYodGhpcy5yZXNldClmb3IodGhpcy5yZXNldD0hMSxhWzBdPXRoaXMuYmxvY2ssbj0xO248YysxOysrbilhW25dPTA7aWYodClmb3Iobj10aGlzLnN0YXJ0O2w8dSYmbjxvOysrbClhW24+PjJdfD1lW2xdPDx5WzMmbisrXTtlbHNlIGZvcihuPXRoaXMuc3RhcnQ7bDx1JiZuPG87KytsKShpPWUuY2hhckNvZGVBdChsKSk8MTI4P2Fbbj4+Ml18PWk8PHlbMyZuKytdOmk8MjA0OD8oYVtuPj4yXXw9KDE5MnxpPj42KTw8eVszJm4rK10sYVtuPj4yXXw9KDEyOHw2MyZpKTw8eVszJm4rK10pOmk8NTUyOTZ8fGk+PTU3MzQ0PyhhW24+PjJdfD0oMjI0fGk+PjEyKTw8eVszJm4rK10sYVtuPj4yXXw9KDEyOHxpPj42JjYzKTw8eVszJm4rK10sYVtuPj4yXXw9KDEyOHw2MyZpKTw8eVszJm4rK10pOihpPTY1NTM2KygoMTAyMyZpKTw8MTB8MTAyMyZlLmNoYXJDb2RlQXQoKytsKSksYVtuPj4yXXw9KDI0MHxpPj4xOCk8PHlbMyZuKytdLGFbbj4+Ml18PSgxMjh8aT4+MTImNjMpPDx5WzMmbisrXSxhW24+PjJdfD0oMTI4fGk+PjYmNjMpPDx5WzMmbisrXSxhW24+PjJdfD0oMTI4fDYzJmkpPDx5WzMmbisrXSk7aWYodGhpcy5sYXN0Qnl0ZUluZGV4PW4sbj49byl7Zm9yKHRoaXMuc3RhcnQ9bi1vLHRoaXMuYmxvY2s9YVtjXSxuPTA7bjxjOysrbilmW25dXj1hW25dO3goZiksdGhpcy5yZXNldD0hMH1lbHNlIHRoaXMuc3RhcnQ9bn1yZXR1cm4gdGhpc30sRC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7dmFyIHI9MjU1JmUsbj0xLGk9W3JdO2ZvcihyPTI1NSYoZT4+PTgpO3I+MDspaS51bnNoaWZ0KHIpLHI9MjU1JihlPj49OCksKytuO3JldHVybiB0P2kucHVzaChuKTppLnVuc2hpZnQobiksdGhpcy51cGRhdGUoaSksaS5sZW5ndGh9LEQucHJvdG90eXBlLmVuY29kZVN0cmluZz1mdW5jdGlvbihlKXt2YXIgdCxyPXR5cGVvZiBlO2lmKFwic3RyaW5nXCIhPT1yKXtpZihcIm9iamVjdFwiIT09cil0aHJvdyBuZXcgRXJyb3Iocyk7aWYobnVsbD09PWUpdGhyb3cgbmV3IEVycm9yKHMpO2lmKGgmJmUuY29uc3RydWN0b3I9PT1BcnJheUJ1ZmZlcillPW5ldyBVaW50OEFycmF5KGUpO2Vsc2UgaWYoIShBcnJheS5pc0FycmF5KGUpfHxoJiZBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpKXRocm93IG5ldyBFcnJvcihzKTt0PSEwfXZhciBuPTAsaT1lLmxlbmd0aDtpZih0KW49aTtlbHNlIGZvcih2YXIgYT0wO2E8ZS5sZW5ndGg7KythKXt2YXIgbz1lLmNoYXJDb2RlQXQoYSk7bzwxMjg/bis9MTpvPDIwNDg/bis9MjpvPDU1Mjk2fHxvPj01NzM0ND9uKz0zOihvPTY1NTM2KygoMTAyMyZvKTw8MTB8MTAyMyZlLmNoYXJDb2RlQXQoKythKSksbis9NCl9cmV0dXJuIG4rPXRoaXMuZW5jb2RlKDgqbiksdGhpcy51cGRhdGUoZSksbn0sRC5wcm90b3R5cGUuYnl0ZXBhZD1mdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLmVuY29kZSh0KSxuPTA7bjxlLmxlbmd0aDsrK24pcis9dGhpcy5lbmNvZGVTdHJpbmcoZVtuXSk7dmFyIGk9dC1yJXQsYT1bXTtyZXR1cm4gYS5sZW5ndGg9aSx0aGlzLnVwZGF0ZShhKSx0aGlzfSxELnByb3RvdHlwZS5maW5hbGl6ZT1mdW5jdGlvbigpe2lmKCF0aGlzLmZpbmFsaXplZCl7dGhpcy5maW5hbGl6ZWQ9ITA7dmFyIGU9dGhpcy5ibG9ja3MsdD10aGlzLmxhc3RCeXRlSW5kZXgscj10aGlzLmJsb2NrQ291bnQsbj10aGlzLnM7aWYoZVt0Pj4yXXw9dGhpcy5wYWRkaW5nWzMmdF0sdGhpcy5sYXN0Qnl0ZUluZGV4PT09dGhpcy5ieXRlQ291bnQpZm9yKGVbMF09ZVtyXSx0PTE7dDxyKzE7Kyt0KWVbdF09MDtmb3IoZVtyLTFdfD0yMTQ3NDgzNjQ4LHQ9MDt0PHI7Kyt0KW5bdF1ePWVbdF07eChuKX19LEQucHJvdG90eXBlLnRvU3RyaW5nPUQucHJvdG90eXBlLmhleD1mdW5jdGlvbigpe3RoaXMuZmluYWxpemUoKTtmb3IodmFyIGUsdD10aGlzLmJsb2NrQ291bnQscj10aGlzLnMsbj10aGlzLm91dHB1dEJsb2NrcyxpPXRoaXMuZXh0cmFCeXRlcyxhPTAscz0wLG89XCJcIjtzPG47KXtmb3IoYT0wO2E8dCYmczxuOysrYSwrK3MpZT1yW2FdLG8rPXBbZT4+NCYxNV0rcFsxNSZlXStwW2U+PjEyJjE1XStwW2U+PjgmMTVdK3BbZT4+MjAmMTVdK3BbZT4+MTYmMTVdK3BbZT4+MjgmMTVdK3BbZT4+MjQmMTVdO3MldD09MCYmKHgociksYT0wKX1yZXR1cm4gaSYmKGU9clthXSxvKz1wW2U+PjQmMTVdK3BbMTUmZV0saT4xJiYobys9cFtlPj4xMiYxNV0rcFtlPj44JjE1XSksaT4yJiYobys9cFtlPj4yMCYxNV0rcFtlPj4xNiYxNV0pKSxvfSxELnByb3RvdHlwZS5hcnJheUJ1ZmZlcj1mdW5jdGlvbigpe3RoaXMuZmluYWxpemUoKTt2YXIgZSx0PXRoaXMuYmxvY2tDb3VudCxyPXRoaXMucyxuPXRoaXMub3V0cHV0QmxvY2tzLGk9dGhpcy5leHRyYUJ5dGVzLGE9MCxzPTAsbz10aGlzLm91dHB1dEJpdHM+PjM7ZT1pP25ldyBBcnJheUJ1ZmZlcihuKzE8PDIpOm5ldyBBcnJheUJ1ZmZlcihvKTtmb3IodmFyIHU9bmV3IFVpbnQzMkFycmF5KGUpO3M8bjspe2ZvcihhPTA7YTx0JiZzPG47KythLCsrcyl1W3NdPXJbYV07cyV0PT0wJiZ4KHIpfXJldHVybiBpJiYodVthXT1yW2FdLGU9ZS5zbGljZSgwLG8pKSxlfSxELnByb3RvdHlwZS5idWZmZXI9RC5wcm90b3R5cGUuYXJyYXlCdWZmZXIsRC5wcm90b3R5cGUuZGlnZXN0PUQucHJvdG90eXBlLmFycmF5PWZ1bmN0aW9uKCl7dGhpcy5maW5hbGl6ZSgpO2Zvcih2YXIgZSx0LHI9dGhpcy5ibG9ja0NvdW50LG49dGhpcy5zLGk9dGhpcy5vdXRwdXRCbG9ja3MsYT10aGlzLmV4dHJhQnl0ZXMscz0wLG89MCx1PVtdO288aTspe2ZvcihzPTA7czxyJiZvPGk7KytzLCsrbyllPW88PDIsdD1uW3NdLHVbZV09MjU1JnQsdVtlKzFdPXQ+PjgmMjU1LHVbZSsyXT10Pj4xNiYyNTUsdVtlKzNdPXQ+PjI0JjI1NTtvJXI9PTAmJngobil9cmV0dXJuIGEmJihlPW88PDIsdD1uW3NdLHVbZV09MjU1JnQsYT4xJiYodVtlKzFdPXQ+PjgmMjU1KSxhPjImJih1W2UrMl09dD4+MTYmMjU1KSksdX0sVi5wcm90b3R5cGU9bmV3IEQsVi5wcm90b3R5cGUuZmluYWxpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCEwKSxELnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpfTt2YXIgeD1mdW5jdGlvbihlKXt2YXIgdCxyLG4saSxhLHMsbyx1LGMsbCxmLGgscCxkLHksbSx2LGIsRSxTLFQsQyxBLEksdyxCLE4sUixfLFAsTyxrLFUsTCxELFYseCxLLE0saixGLHEseixHLEgsWSxRLFcsWCwkLEosWixlZSx0ZSxyZSxuZSxpZSxhZSxzZSxvZSx1ZSxjZSxsZTtmb3Iobj0wO248NDg7bis9MilpPWVbMF1eZVsxMF1eZVsyMF1eZVszMF1eZVs0MF0sYT1lWzFdXmVbMTFdXmVbMjFdXmVbMzFdXmVbNDFdLHM9ZVsyXV5lWzEyXV5lWzIyXV5lWzMyXV5lWzQyXSxvPWVbM11eZVsxM11eZVsyM11eZVszM11eZVs0M10sdT1lWzRdXmVbMTRdXmVbMjRdXmVbMzRdXmVbNDRdLGM9ZVs1XV5lWzE1XV5lWzI1XV5lWzM1XV5lWzQ1XSxsPWVbNl1eZVsxNl1eZVsyNl1eZVszNl1eZVs0Nl0sZj1lWzddXmVbMTddXmVbMjddXmVbMzddXmVbNDddLHQ9KGg9ZVs4XV5lWzE4XV5lWzI4XV5lWzM4XV5lWzQ4XSleKHM8PDF8bz4+PjMxKSxyPShwPWVbOV1eZVsxOV1eZVsyOV1eZVszOV1eZVs0OV0pXihvPDwxfHM+Pj4zMSksZVswXV49dCxlWzFdXj1yLGVbMTBdXj10LGVbMTFdXj1yLGVbMjBdXj10LGVbMjFdXj1yLGVbMzBdXj10LGVbMzFdXj1yLGVbNDBdXj10LGVbNDFdXj1yLHQ9aV4odTw8MXxjPj4+MzEpLHI9YV4oYzw8MXx1Pj4+MzEpLGVbMl1ePXQsZVszXV49cixlWzEyXV49dCxlWzEzXV49cixlWzIyXV49dCxlWzIzXV49cixlWzMyXV49dCxlWzMzXV49cixlWzQyXV49dCxlWzQzXV49cix0PXNeKGw8PDF8Zj4+PjMxKSxyPW9eKGY8PDF8bD4+PjMxKSxlWzRdXj10LGVbNV1ePXIsZVsxNF1ePXQsZVsxNV1ePXIsZVsyNF1ePXQsZVsyNV1ePXIsZVszNF1ePXQsZVszNV1ePXIsZVs0NF1ePXQsZVs0NV1ePXIsdD11XihoPDwxfHA+Pj4zMSkscj1jXihwPDwxfGg+Pj4zMSksZVs2XV49dCxlWzddXj1yLGVbMTZdXj10LGVbMTddXj1yLGVbMjZdXj10LGVbMjddXj1yLGVbMzZdXj10LGVbMzddXj1yLGVbNDZdXj10LGVbNDddXj1yLHQ9bF4oaTw8MXxhPj4+MzEpLHI9Zl4oYTw8MXxpPj4+MzEpLGVbOF1ePXQsZVs5XV49cixlWzE4XV49dCxlWzE5XV49cixlWzI4XV49dCxlWzI5XV49cixlWzM4XV49dCxlWzM5XV49cixlWzQ4XV49dCxlWzQ5XV49cixkPWVbMF0seT1lWzFdLFk9ZVsxMV08PDR8ZVsxMF0+Pj4yOCxRPWVbMTBdPDw0fGVbMTFdPj4+MjgsUj1lWzIwXTw8M3xlWzIxXT4+PjI5LF89ZVsyMV08PDN8ZVsyMF0+Pj4yOSxvZT1lWzMxXTw8OXxlWzMwXT4+PjIzLHVlPWVbMzBdPDw5fGVbMzFdPj4+MjMscT1lWzQwXTw8MTh8ZVs0MV0+Pj4xNCx6PWVbNDFdPDwxOHxlWzQwXT4+PjE0LEw9ZVsyXTw8MXxlWzNdPj4+MzEsRD1lWzNdPDwxfGVbMl0+Pj4zMSxtPWVbMTNdPDwxMnxlWzEyXT4+PjIwLHY9ZVsxMl08PDEyfGVbMTNdPj4+MjAsVz1lWzIyXTw8MTB8ZVsyM10+Pj4yMixYPWVbMjNdPDwxMHxlWzIyXT4+PjIyLFA9ZVszM108PDEzfGVbMzJdPj4+MTksTz1lWzMyXTw8MTN8ZVszM10+Pj4xOSxjZT1lWzQyXTw8MnxlWzQzXT4+PjMwLGxlPWVbNDNdPDwyfGVbNDJdPj4+MzAsdGU9ZVs1XTw8MzB8ZVs0XT4+PjIscmU9ZVs0XTw8MzB8ZVs1XT4+PjIsVj1lWzE0XTw8NnxlWzE1XT4+PjI2LHg9ZVsxNV08PDZ8ZVsxNF0+Pj4yNixiPWVbMjVdPDwxMXxlWzI0XT4+PjIxLEU9ZVsyNF08PDExfGVbMjVdPj4+MjEsJD1lWzM0XTw8MTV8ZVszNV0+Pj4xNyxKPWVbMzVdPDwxNXxlWzM0XT4+PjE3LGs9ZVs0NV08PDI5fGVbNDRdPj4+MyxVPWVbNDRdPDwyOXxlWzQ1XT4+PjMsST1lWzZdPDwyOHxlWzddPj4+NCx3PWVbN108PDI4fGVbNl0+Pj40LG5lPWVbMTddPDwyM3xlWzE2XT4+PjksaWU9ZVsxNl08PDIzfGVbMTddPj4+OSxLPWVbMjZdPDwyNXxlWzI3XT4+PjcsTT1lWzI3XTw8MjV8ZVsyNl0+Pj43LFM9ZVszNl08PDIxfGVbMzddPj4+MTEsVD1lWzM3XTw8MjF8ZVszNl0+Pj4xMSxaPWVbNDddPDwyNHxlWzQ2XT4+PjgsZWU9ZVs0Nl08PDI0fGVbNDddPj4+OCxHPWVbOF08PDI3fGVbOV0+Pj41LEg9ZVs5XTw8Mjd8ZVs4XT4+PjUsQj1lWzE4XTw8MjB8ZVsxOV0+Pj4xMixOPWVbMTldPDwyMHxlWzE4XT4+PjEyLGFlPWVbMjldPDw3fGVbMjhdPj4+MjUsc2U9ZVsyOF08PDd8ZVsyOV0+Pj4yNSxqPWVbMzhdPDw4fGVbMzldPj4+MjQsRj1lWzM5XTw8OHxlWzM4XT4+PjI0LEM9ZVs0OF08PDE0fGVbNDldPj4+MTgsQT1lWzQ5XTw8MTR8ZVs0OF0+Pj4xOCxlWzBdPWRefm0mYixlWzFdPXlefnYmRSxlWzEwXT1JXn5CJlIsZVsxMV09d15+TiZfLGVbMjBdPUxeflYmSyxlWzIxXT1EXn54Jk0sZVszMF09R15+WSZXLGVbMzFdPUheflEmWCxlWzQwXT10ZV5+bmUmYWUsZVs0MV09cmVefmllJnNlLGVbMl09bV5+YiZTLGVbM109dl5+RSZULGVbMTJdPUJeflImUCxlWzEzXT1OXn5fJk8sZVsyMl09Vl5+SyZqLGVbMjNdPXhefk0mRixlWzMyXT1ZXn5XJiQsZVszM109UV5+WCZKLGVbNDJdPW5lXn5hZSZvZSxlWzQzXT1pZV5+c2UmdWUsZVs0XT1iXn5TJkMsZVs1XT1FXn5UJkEsZVsxNF09Ul5+UCZrLGVbMTVdPV9efk8mVSxlWzI0XT1LXn5qJnEsZVsyNV09TV5+RiZ6LGVbMzRdPVdefiQmWixlWzM1XT1YXn5KJmVlLGVbNDRdPWFlXn5vZSZjZSxlWzQ1XT1zZV5+dWUmbGUsZVs2XT1TXn5DJmQsZVs3XT1UXn5BJnksZVsxNl09UF5+ayZJLGVbMTddPU9eflUmdyxlWzI2XT1qXn5xJkwsZVsyN109Rl5+eiZELGVbMzZdPSReflomRyxlWzM3XT1KXn5lZSZILGVbNDZdPW9lXn5jZSZ0ZSxlWzQ3XT11ZV5+bGUmcmUsZVs4XT1DXn5kJm0sZVs5XT1BXn55JnYsZVsxOF09a15+SSZCLGVbMTldPVVefncmTixlWzI4XT1xXn5MJlYsZVsyOV09el5+RCZ4LGVbMzhdPVpefkcmWSxlWzM5XT1lZV5+SCZRLGVbNDhdPWNlXn50ZSZuZSxlWzQ5XT1sZV5+cmUmaWUsZVswXV49Z1tuXSxlWzFdXj1nW24rMV19O2lmKGwpZS5leHBvcnRzPU47ZWxzZXtmb3IoXz0wO188Ui5sZW5ndGg7KytfKXVbUltfXV09TltSW19dXTtmJiYodm9pZCAwPT09KGE9ZnVuY3Rpb24oKXtyZXR1cm4gTn0uY2FsbCh0LHIsdCxlKSl8fChlLmV4cG9ydHM9YSkpfX0oKX0pLmNhbGwodGhpcyxyKDE4KSxyKDE3KSl9LGZ1bmN0aW9uKGUsdCl7KGZ1bmN0aW9uKHQpe2UuZXhwb3J0cz10fSkuY2FsbCh0aGlzLHt9KX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtyZXR1cm4gdC5kZWZhdWx0PWUsdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGk9cigxMCksYT1uKHIoNjQpKSxzPXIoMTkpLG89cig1NCksdT1yKDIzKSxjPXIoMTQpLGw9cigyMik7ZnVuY3Rpb24gZihlLHQpe2Zvcih2b2lkIDA9PT10JiYodD01ZTMpO3QtLTspe3ZhciByPWkuc3RyaW5nVG9CeXRlcyhlKTtlPXUuYmFzZTE2RW5jb2RlKGMuc2hhMjU2KHIpKX1yZXR1cm4gZX1mdW5jdGlvbiBoKGUsdCxyKXt2b2lkIDA9PT1yJiYocj00OCk7Zm9yKHZhciBuPWkuYnl0ZXNUb1N0cmluZyhzLmNvbmNhdChlLHQpLFwicmF3XCIpLG89XCJcIix1PW87dS5sZW5ndGg8cjspdSs9bz1hLmNyZWF0ZSgpLnVwZGF0ZShvK24pLmRpZ2VzdCgpLmdldEJ5dGVzKCk7cmV0dXJuIHV9dC5lbmNyeXB0U2VlZD1mdW5jdGlvbihlLHQscil7dmFyIG49Zih0LHIpLGE9bC5yYW5kb21CeXRlcyg4KSxjPWgoaS5zdHJpbmdUb0J5dGVzKG4sXCJyYXdcIiksYSkscD1pLnN0cmluZ1RvQnl0ZXMoYy5zbGljZSgwLDMyKSxcInJhd1wiKSxkPWkuc3RyaW5nVG9CeXRlcyhjLnNsaWNlKDMyKSxcInJhd1wiKSx5PW8uYWVzRW5jcnlwdChpLnN0cmluZ1RvQnl0ZXMoZSkscCxcIkNCQ1wiLGQpO3JldHVybiB1LmJhc2U2NEVuY29kZShzLmNvbmNhdChpLnN0cmluZ1RvQnl0ZXMoXCJTYWx0ZWRfX1wiKSxhLHkpKX0sdC5kZWNyeXB0U2VlZD1mdW5jdGlvbihlLHQscil7dmFyIG49Zih0LHIpLGE9dS5iYXNlNjREZWNvZGUoZSkscz1hLnNsaWNlKDgsMTYpLGM9aChpLnN0cmluZ1RvQnl0ZXMobixcInJhd1wiKSxzKSxsPWkuc3RyaW5nVG9CeXRlcyhjLnNsaWNlKDAsMzIpLFwicmF3XCIpLHA9aS5zdHJpbmdUb0J5dGVzKGMuc2xpY2UoMzIpLFwicmF3XCIpO3JldHVybiBpLmJ5dGVzVG9TdHJpbmcoby5hZXNEZWNyeXB0KGEuc2xpY2UoMTYpLGwsXCJDQkNcIixwKSl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49dGhpcyYmdGhpcy5fX3JlYWR8fGZ1bmN0aW9uKGUsdCl7dmFyIHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXIpcmV0dXJuIGU7dmFyIG4saSxhPXIuY2FsbChlKSxzPVtdO3RyeXtmb3IoOyh2b2lkIDA9PT10fHx0LS0gPjApJiYhKG49YS5uZXh0KCkpLmRvbmU7KXMucHVzaChuLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtuJiYhbi5kb25lJiYocj1hLnJldHVybikmJnIuY2FsbChhKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIHN9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBpPXIoMTQpLGE9cigxOSk7dC5tZXJrbGVWZXJpZnk9ZnVuY3Rpb24oZSx0LHIpe3ZhciBzPVVpbnQ4QXJyYXkuZnJvbShbMF0pLG89VWludDhBcnJheS5mcm9tKFsxXSk7aWYoMzIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgbWVya2xlUHJvb2Y6IEludmFsaWQgcm9vdEhhc2ggbGVuZ3RoXCIpO2Zvcih2YXIgdT1pLmJsYWtlMmIoYS5jb25jYXQocyxyKSksYz1bXSxsPXQubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZX0pKTtsLmxlbmd0aD4wOyl7dmFyIGY9MD09PWxbMF0/XCJMXCI6XCJSXCIsaD1sWzFdO2lmKGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgbWVya2xlUHJvb2Y6IFdyb25nIGhhc2ggc2l6ZVwiKTt2YXIgcD1sLnNsaWNlKDIsMitoKTtjLnB1c2goW2YscF0pLGw9bC5zbGljZSgyK2gpfXJldHVybiBjLnJlZHVjZSgoZnVuY3Rpb24oZSx0KXt2YXIgcj1uKHQsMikscz1yWzBdLHU9clsxXTtyZXR1cm4gaS5ibGFrZTJiKGEuY29uY2F0KG8sXCJSXCI9PT1zP2EuY29uY2F0KHUsZSk6YS5jb25jYXQoZSx1KSkpfSksdSkuZXZlcnkoKGZ1bmN0aW9uKHQscil7cmV0dXJuIHQ9PT1lW3JdfSkpfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBuLGksYTt0LlV0ZjhBcnJheVRvU3RyPShuPW5ldyBBcnJheSgxMjgpLGk9U3RyaW5nLmZyb21Db2RlUG9pbnR8fFN0cmluZy5mcm9tQ2hhckNvZGUsYT1bXSxmdW5jdGlvbihlKXt2YXIgdCxyLHM9ZS5sZW5ndGg7YS5sZW5ndGg9MDtmb3IodmFyIG89MDtvPHM7KShyPWVbbysrXSk8PTEyNz90PXI6cjw9MjIzP3Q9KDMxJnIpPDw2fDYzJmVbbysrXTpyPD0yMzk/dD0oMTUmcik8PDEyfCg2MyZlW28rK10pPDw2fDYzJmVbbysrXTpTdHJpbmcuZnJvbUNvZGVQb2ludD90PSg3JnIpPDwxOHwoNjMmZVtvKytdKTw8MTJ8KDYzJmVbbysrXSk8PDZ8NjMmZVtvKytdOih0PTYzLG8rPTMpLGEucHVzaChuW3RdfHwoblt0XT1pKHQpKSk7cmV0dXJuIGEuam9pbihcIlwiKX0pfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZnVuY3Rpb24oZSl7ZS5JTlRFR0VSPVwiaW50ZWdlclwiLGUuQk9PTEVBTj1cImJvb2xlYW5cIixlLlNUUklORz1cInN0cmluZ1wiLGUuQklOQVJZPVwiYmluYXJ5XCJ9KHQuREFUQV9GSUVMRF9UWVBFfHwodC5EQVRBX0ZJRUxEX1RZUEU9e30pKSx0LmFueU9mPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBuKGUsdCl9O2NsYXNzIG57Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9pdGVtcz1lLHRoaXMudHlwZT1cImFueU9mXCIsdGhpcy5kaXNjcmltaW5hdG9yRmllbGQ9XCJ0eXBlXCIsdGhpcy5kaXNjcmltaW5hdG9yQnl0ZVBvcz0wLE9iamVjdC5hc3NpZ24odGhpcyx0KX1pdGVtQnlLZXkoZSl7Y29uc3QgdD10aGlzLl9pdGVtcy5maW5kKChbdCxyLG5dKT0+bj09PWV8fHQ9PWUpO3JldHVybiB0JiZ7c2NoZW1hOnRbMV0sa2V5OnRbMF0sc3RyS2V5OnRbMl19fWl0ZW1CeUJ5dGVLZXkoZSl7Y29uc3QgdD10aGlzLl9pdGVtcy5maW5kKChbdCxyXSk9PnQ9PT1lKTtyZXR1cm4gdCYme3NjaGVtYTp0WzFdLGtleTp0WzBdLHN0cktleTp0WzJdfHx0WzBdLnRvU3RyaW5nKDEwKX19fX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigzNyksaT1yKDM2KSxhPXIoMjEpO3QucGFyc2VyRnJvbVNjaGVtYT0oZSxyKT0+KGEscz0wKT0+e2xldCBvPXM7aWYoXCJhcnJheVwiPT09ZS50eXBlKXtjb25zdCB1PVtdLHt2YWx1ZTpjLHNoaWZ0Omx9PShlLmZyb21CeXRlc3x8bi5QX1NIT1JUKShhLHMpO3JldHVybiBvKz1sLGkucmFuZ2UoMCxjKS5mb3JFYWNoKG49Pntjb25zdCBpPXQucGFyc2VyRnJvbVNjaGVtYShlLml0ZW1zLHIpLHt2YWx1ZTpzLHNoaWZ0OmN9PWkoYSxvKTt1LnB1c2gocyksbys9Y30pLHt2YWx1ZTp1LHNoaWZ0Om8tc319aWYoXCJvYmplY3RcIj09PWUudHlwZSl7aWYoZS5vcHRpb25hbCl7Y29uc3QgZT0xPT09YVtvXTtpZihvKz0xLCFlKXJldHVybnt2YWx1ZTp2b2lkIDAsc2hpZnQ6MX19aWYoZS53aXRoTGVuZ3RoKXtjb25zdCB0PWUud2l0aExlbmd0aC5mcm9tQnl0ZXMoYSxvKTtvKz10LnNoaWZ0fWNvbnN0IG49e307cmV0dXJuIGUuc2NoZW1hLmZvckVhY2goZT0+e2NvbnN0W2ksc109ZSx1PXQucGFyc2VyRnJvbVNjaGVtYShzLHIpLHt2YWx1ZTpjLHNoaWZ0Omx9PXUoYSxvKTtvKz1sLHZvaWQgMCE9PWMmJihBcnJheS5pc0FycmF5KGkpP09iamVjdC5hc3NpZ24obixjKTpuW2ldPWMpfSkse3ZhbHVlOm4sc2hpZnQ6by1zfX1pZihcImFueU9mXCI9PT1lLnR5cGUpe2NvbnN0IGk9KGUuZnJvbUJ5dGVzfHxuLlBfQllURSkoYSxvK2UuZGlzY3JpbWluYXRvckJ5dGVQb3MpO2UudmFsdWVGaWVsZCYmMD09PWUuZGlzY3JpbWluYXRvckJ5dGVQb3MmJihvKz1pLnNoaWZ0KTtjb25zdCB1PWUuaXRlbUJ5Qnl0ZUtleShpLnZhbHVlKTtpZihudWxsPT11KXRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBzY2hlbWEgZm9yIGl0ZW0gd2l0aCBieXRlY29kZTogJHtpLnZhbHVlfWApO2NvbnN0IGM9dC5wYXJzZXJGcm9tU2NoZW1hKHUuc2NoZW1hLHIpLHt2YWx1ZTpsLHNoaWZ0OmZ9PWMoYSxvKTtyZXR1cm4gbys9Zix7dmFsdWU6ZS52YWx1ZUZpZWxkP3tbZS5kaXNjcmltaW5hdG9yRmllbGRdOnUuc3RyS2V5LFtlLnZhbHVlRmllbGRdOmx9Omwsc2hpZnQ6by1zfX1pZihcImRhdGFUeEZpZWxkXCI9PT1lLnR5cGUpe2NvbnN0IGk9bi5ieXRlVG9TdHJpbmdXaXRoTGVuZ3RoKGEsbyk7bys9aS5zaGlmdDtsZXQgcz1uLlBfQllURShhLG8pO28rPXMuc2hpZnQ7Y29uc3QgdT1bLi4uZS5pdGVtc10uZmluZCgoZSx0KT0+dD09PXMudmFsdWUpO2lmKCF1KXRocm93IG5ldyBFcnJvcihgUGFyc2VyIEVycm9yOiBVbmtub3duIGRhdGFUeEZpZWxkIHR5cGU6ICR7cy52YWx1ZX1gKTtjb25zdCBjPXQucGFyc2VyRnJvbVNjaGVtYSh1WzFdLHIpKGEsbyk7cmV0dXJue3ZhbHVlOnt2YWx1ZTpjLnZhbHVlLGtleTppLnZhbHVlLHR5cGU6dVswXX0sc2hpZnQ6Yy5zaGlmdCtpLnNoaWZ0K3Muc2hpZnR9fWlmKFwicHJpbWl0aXZlXCI9PT1lLnR5cGV8fHZvaWQgMD09PWUudHlwZSl7Y29uc3QgdD1lLmZyb21CeXRlcztsZXR7dmFsdWU6aSxzaGlmdDpvfT10KGEscyk7cmV0dXJuIHQ9PT1uLlBfTE9ORyYmciYmKGk9cihpKSkse3ZhbHVlOmksc2hpZnQ6b319dGhyb3cgbmV3IEVycm9yKGBQYXJzZXIgRXJyb3I6IFVua25vd24gc2NoZW1hIHR5cGU6ICR7ZS50eXBlfWApfSx0LnBhcnNlSGVhZGVyPWU9PntsZXQgdD0wLHI9bi5QX0JZVEUoZSx0KTt0Kz1yLnNoaWZ0LDA9PT1yLnZhbHVlJiYocj1uLlBfQllURShlLHQpLHQrPXIuc2hpZnQpO2xldCBpPW4uUF9CWVRFKGUsdCk7cmV0dXJue3R5cGU6ci52YWx1ZSx2ZXJzaW9uOmkudmFsdWV9fSx0LnBhcnNlVHg9ZnVuY3Rpb24oZSxyKXtjb25zdHt0eXBlOm4sdmVyc2lvbjppfT10LnBhcnNlSGVhZGVyKGUpLHM9YS5nZXRUcmFuc2FjdGlvblNjaGVtYShuLGkpO3JldHVybiB0LnBhcnNlckZyb21TY2hlbWEocyxyKShlKS52YWx1ZX0sdC5wYXJzZU9yZGVyPWZ1bmN0aW9uKGUscil7cmV0dXJuIHQucGFyc2VyRnJvbVNjaGVtYShhLm9yZGVyU2NoZW1hVjIscikoZSkudmFsdWV9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDExNSkse3BhcnNlOmksc3RyaW5naWZ5OmF9PW4oKSxzPXIoMjEpLG89cigyNiksdT1yKDMpO2Z1bmN0aW9uIGMoZSx0KXtyZXR1cm4gMD09PWUubGVuZ3RoP3Q6XCJvYmplY3RcIj09dHlwZW9mIHQ/YyhlLnNsaWNlKDEpLHRbZVswXV0pOnZvaWQgMH1jb25zdCBsPShlLHQscik9PntyZXR1cm4gZnVuY3Rpb24gdChuLGkpe2lmKG51bGw9PWkpcmV0dXJuITE7aWYoMD09PW4ubGVuZ3RoJiYoXCJwcmltaXRpdmVcIj09PWkudHlwZXx8dm9pZCAwPT09aS50eXBlKSlyZXR1cm4gaS50b0J5dGVzPT09by5MT05HO2lmKFwib2JqZWN0XCI9PT1pLnR5cGUpe2NvbnN0IGU9aS5zY2hlbWEuZmluZCgoW2UsdF0pPT5lPT09blswXSk7cmV0dXJuIHQobi5zbGljZSgxKSxlJiZlWzFdKX1pZihcImFycmF5XCI9PT1pLnR5cGUpcmV0dXJuIHQobi5zbGljZSgxKSxpLml0ZW1zKTtpZihcImRhdGFUeEZpZWxkXCI9PT1pLnR5cGUpe2lmKFwidmFsdWVcIiE9PW5bMF0pcmV0dXJuITE7Y29uc3QgYT1jKGUuc2xpY2UoMCxlLmxlbmd0aC0xKSxyKSxzPWkuaXRlbXMuZ2V0KGEudHlwZSk7cmV0dXJuIHQobi5zbGljZSgxKSxzKX1pZihcImFueU9mXCI9PT1pLnR5cGUpe2NvbnN0IGE9YyhlLnNsaWNlKDAsZS5sZW5ndGgtMSkscilbaS5kaXNjcmltaW5hdG9yRmllbGRdLHM9aS5pdGVtQnlLZXkoYSk7cmV0dXJuISFzJiYobnVsbCE9aS52YWx1ZUZpZWxkJiZlW2UubGVuZ3RoLTFdPT09aS52YWx1ZUZpZWxkP3Qobi5zbGljZSgxKSxzLnNjaGVtYSk6dChuLHMuc2NoZW1hKSl9cmV0dXJuITF9KGUsdCl9O2Z1bmN0aW9uIGYoZSx0KXtjb25zdCByPVtdLG49W107ZnVuY3Rpb24gaShzKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgcyYmbChyLHQsZSk/czpcImJvb2xlYW5cIj09dHlwZW9mIHN8fHMgaW5zdGFuY2VvZiBCb29sZWFufHxudWxsPT09c3x8XCJudW1iZXJcIj09dHlwZW9mIHN8fHMgaW5zdGFuY2VvZiBOdW1iZXJ8fFwic3RyaW5nXCI9PXR5cGVvZiBzfHxzIGluc3RhbmNlb2YgU3RyaW5nfHxzIGluc3RhbmNlb2YgRGF0ZT9KU09OLnN0cmluZ2lmeShzKTpBcnJheS5pc0FycmF5KHMpP2Z1bmN0aW9uKGUpe2xldCB0PVwiW1wiO2NvbnN0IGE9bi5sZW5ndGg7blthXT1lO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgcz1uK1wiXCIsbz1lW25dO3ZvaWQgMCE9PW8mJlwiZnVuY3Rpb25cIiE9dHlwZW9mIG8/KHJbYV09cyx0Kz1pKG8pKTp0Kz1cIm51bGxcIixuPGUubGVuZ3RoLTEmJih0Kz1cIixcIil9cmV0dXJuIG4ubGVuZ3RoPWEsci5sZW5ndGg9YSx0Kz1cIl1cIix0fShzKTpzJiZcIm9iamVjdFwiPT10eXBlb2Ygcz9mdW5jdGlvbihlKXtsZXQgdD0hMCxzPVwie1wiO2NvbnN0IG89bi5sZW5ndGg7bltvXT1lO2ZvcihsZXQgbiBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkobikpe2xldCB1PWVbbl07YSh1KSYmKHQ/dD0hMTpzKz1cIixcIixzKz0nXCInK24rJ1wiOicscltvXT1uLHMrPWkodSkpfXJldHVybiBuLmxlbmd0aD1vLHIubGVuZ3RoPW8scys9XCJ9XCIsc30ocyk6dm9pZCAwfWZ1bmN0aW9uIGEoZSl7cmV0dXJuIHZvaWQgMCE9PWUmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGV9cmV0dXJuIGkoZSl8fFwiXCJ9dC5zdHJpbmdpZnlXaXRoU2NoZW1hPWYsdC5wYXJzZVR4PWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1pKGUpO3JldHVybiB0P3UuY29udmVydFR4TG9uZ0ZpZWxkcyhyLHQpOnJ9LHQuc3RyaW5naWZ5VHg9ZnVuY3Rpb24oZSx0KXtjb25zdHt0eXBlOnIsdmVyc2lvbjpufT1lLGk9cy5nZXRUcmFuc2FjdGlvblNjaGVtYShyLG4pO3JldHVybiBmKHUuY29udmVydExvbmdGaWVsZHMoZSxpLHZvaWQgMCx0KSxpKX0sdC5wYXJzZU9yZGVyPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1pKGUpLG49Mj09PXIudmVyc2lvbj9zLm9yZGVyU2NoZW1hVjI6cy5vcmRlclNjaGVtYVYxO3JldHVybiB0P3UuY29udmVydExvbmdGaWVsZHMocixuLHQpOnJ9LHQuc3RyaW5naWZ5T3JkZXI9ZnVuY3Rpb24oZSx0KXtjb25zdCByPTI9PT1lLnZlcnNpb24/cy5vcmRlclNjaGVtYVYyOnMub3JkZXJTY2hlbWFWMTtyZXR1cm4gZih1LmNvbnZlcnRMb25nRmllbGRzKGUscix2b2lkIDAsdCkscil9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciB0PXtzdHJpY3Q6ITF9O251bGwhPWUmJiEwPT09ZS5zdHJpY3QmJih0LnN0cmljdD0hMCk7dmFyIHIsbixpLGEscz17J1wiJzonXCInLFwiXFxcXFwiOlwiXFxcXFwiLFwiL1wiOlwiL1wiLGI6XCJcXGJcIixmOlwiXFxmXCIsbjpcIlxcblwiLHI6XCJcXHJcIix0OlwiXFx0XCJ9LG89ZnVuY3Rpb24oZSl7dGhyb3d7bmFtZTpcIlN5bnRheEVycm9yXCIsbWVzc2FnZTplLGF0OnIsdGV4dDppfX0sdT1mdW5jdGlvbihlKXtyZXR1cm4gZSYmZSE9PW4mJm8oXCJFeHBlY3RlZCAnXCIrZStcIicgaW5zdGVhZCBvZiAnXCIrbitcIidcIiksbj1pLmNoYXJBdChyKSxyKz0xLG59LGM9ZnVuY3Rpb24oKXt2YXIgdCxyPVwiXCI7Zm9yKFwiLVwiPT09biYmKHI9XCItXCIsdShcIi1cIikpO24+PVwiMFwiJiZuPD1cIjlcIjspcis9bix1KCk7aWYoXCIuXCI9PT1uKWZvcihyKz1cIi5cIjt1KCkmJm4+PVwiMFwiJiZuPD1cIjlcIjspcis9bjtpZihcImVcIj09PW58fFwiRVwiPT09bilmb3Iocis9bix1KCksXCItXCIhPT1uJiZcIitcIiE9PW58fChyKz1uLHUoKSk7bj49XCIwXCImJm48PVwiOVwiOylyKz1uLHUoKTtyZXR1cm4gdD0rcixlJiZlLnBhcnNlP2UucGFyc2Uocik6aXNGaW5pdGUodCk/ci5sZW5ndGg+MTU/cjp0OnZvaWQgbyhcIkJhZCBudW1iZXJcIil9LGw9ZnVuY3Rpb24oKXt2YXIgZSx0LHIsaT1cIlwiO2lmKCdcIic9PT1uKWZvcig7dSgpOyl7aWYoJ1wiJz09PW4pcmV0dXJuIHUoKSxpO2lmKFwiXFxcXFwiPT09bilpZih1KCksXCJ1XCI9PT1uKXtmb3Iocj0wLHQ9MDt0PDQmJihlPXBhcnNlSW50KHUoKSwxNiksaXNGaW5pdGUoZSkpO3QrPTEpcj0xNipyK2U7aSs9U3RyaW5nLmZyb21DaGFyQ29kZShyKX1lbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiBzW25dKWJyZWFrO2krPXNbbl19ZWxzZSBpKz1ufW8oXCJCYWQgc3RyaW5nXCIpfSxmPWZ1bmN0aW9uKCl7Zm9yKDtuJiZuPD1cIiBcIjspdSgpfTthPWZ1bmN0aW9uKCl7c3dpdGNoKGYoKSxuKXtjYXNlXCJ7XCI6cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGUscj17fTtpZihcIntcIj09PW4pe2lmKHUoXCJ7XCIpLGYoKSxcIn1cIj09PW4pcmV0dXJuIHUoXCJ9XCIpLHI7Zm9yKDtuOyl7aWYoZT1sKCksZigpLHUoXCI6XCIpLCEwPT09dC5zdHJpY3QmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSkmJm8oJ0R1cGxpY2F0ZSBrZXkgXCInK2UrJ1wiJykscltlXT1hKCksZigpLFwifVwiPT09bilyZXR1cm4gdShcIn1cIikscjt1KFwiLFwiKSxmKCl9fW8oXCJCYWQgb2JqZWN0XCIpfSgpO2Nhc2VcIltcIjpyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT1bXTtpZihcIltcIj09PW4pe2lmKHUoXCJbXCIpLGYoKSxcIl1cIj09PW4pcmV0dXJuIHUoXCJdXCIpLGU7Zm9yKDtuOyl7aWYoZS5wdXNoKGEoKSksZigpLFwiXVwiPT09bilyZXR1cm4gdShcIl1cIiksZTt1KFwiLFwiKSxmKCl9fW8oXCJCYWQgYXJyYXlcIil9KCk7Y2FzZSdcIic6cmV0dXJuIGwoKTtjYXNlXCItXCI6cmV0dXJuIGMoKTtkZWZhdWx0OnJldHVybiBuPj1cIjBcIiYmbjw9XCI5XCI/YygpOmZ1bmN0aW9uKCl7c3dpdGNoKG4pe2Nhc2VcInRcIjpyZXR1cm4gdShcInRcIiksdShcInJcIiksdShcInVcIiksdShcImVcIiksITA7Y2FzZVwiZlwiOnJldHVybiB1KFwiZlwiKSx1KFwiYVwiKSx1KFwibFwiKSx1KFwic1wiKSx1KFwiZVwiKSwhMTtjYXNlXCJuXCI6cmV0dXJuIHUoXCJuXCIpLHUoXCJ1XCIpLHUoXCJsXCIpLHUoXCJsXCIpLG51bGx9byhcIlVuZXhwZWN0ZWQgJ1wiK24rXCInXCIpfSgpfX07dmFyIGgscCxkLHk9L1tcXFxcXCJcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxnPXtcIlxcYlwiOlwiXFxcXGJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcclwiOlwiXFxcXHJcIiwnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIn07ZnVuY3Rpb24gbShlKXtyZXR1cm4geS5sYXN0SW5kZXg9MCx5LnRlc3QoZSk/J1wiJytlLnJlcGxhY2UoeSwoZnVuY3Rpb24oZSl7dmFyIHQ9Z1tlXTtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXFxcXHVcIisoXCIwMDAwXCIrZS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpfSkpKydcIic6J1wiJytlKydcIid9cmV0dXJue3BhcnNlOmZ1bmN0aW9uKGUsdCl7dmFyIHM7cmV0dXJuIGk9ZStcIlwiLHI9MCxuPVwiIFwiLHM9YSgpLGYoKSxuJiZvKFwiU3ludGF4IGVycm9yXCIpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/ZnVuY3Rpb24gZShyLG4pe3ZhciBpLGE9cltuXTtyZXR1cm4gYSYmXCJvYmplY3RcIj09dHlwZW9mIGEmJk9iamVjdC5rZXlzKGEpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZvaWQgMCE9PShpPWUoYSx0KSk/YVt0XT1pOmRlbGV0ZSBhW3RdfSkpLHQuY2FsbChyLG4sYSl9KHtcIlwiOnN9LFwiXCIpOnN9LHN0cmluZ2lmeTpmdW5jdGlvbih0LHIsbil7dmFyIGk7aWYoaD1cIlwiLHA9XCJcIixcIm51bWJlclwiPT10eXBlb2Ygbilmb3IoaT0wO2k8bjtpKz0xKXArPVwiIFwiO2Vsc2VcInN0cmluZ1wiPT10eXBlb2YgbiYmKHA9bik7aWYoZD1yLHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHImJihcIm9iamVjdFwiIT10eXBlb2Ygcnx8XCJudW1iZXJcIiE9dHlwZW9mIHIubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJKU09OLnN0cmluZ2lmeVwiKTtyZXR1cm4gZnVuY3Rpb24gdChyLG4pe3ZhciBpLGEscyxvLHUsYz1oLGw9bltyXSxmPWUmJmUuaXNJbnN0YW5jZSYmZS5pc0luc3RhbmNlKGwpO3N3aXRjaChmJiYhbC5pc0Zpbml0ZSgpJiYobD1udWxsKSxmP2w9ZS5zdHJpbmdpZnkobCk6bCYmXCJvYmplY3RcIj09dHlwZW9mIGwmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGwudG9KU09OJiYobD1sLnRvSlNPTihyKSksXCJmdW5jdGlvblwiPT10eXBlb2YgZCYmKGw9ZC5jYWxsKG4scixsKSksdHlwZW9mIGwpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBmP2w6bShsKTtjYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUobCk/U3RyaW5nKGwpOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpyZXR1cm4gU3RyaW5nKGwpO2Nhc2VcIm9iamVjdFwiOmlmKCFsKXJldHVyblwibnVsbFwiO2lmKGgrPXAsdT1bXSxcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGwpKXtmb3Iobz1sLmxlbmd0aCxpPTA7aTxvO2krPTEpdVtpXT10KGksbCl8fFwibnVsbFwiO3JldHVybiBzPTA9PT11Lmxlbmd0aD9cIltdXCI6aD9cIltcXG5cIitoK3Uuam9pbihcIixcXG5cIitoKStcIlxcblwiK2MrXCJdXCI6XCJbXCIrdS5qb2luKFwiLFwiKStcIl1cIixoPWMsc31pZihkJiZcIm9iamVjdFwiPT10eXBlb2YgZClmb3Iobz1kLmxlbmd0aCxpPTA7aTxvO2krPTEpXCJzdHJpbmdcIj09dHlwZW9mIGRbaV0mJihzPXQoYT1kW2ldLGwpKSYmdS5wdXNoKG0oYSkrKGg/XCI6IFwiOlwiOlwiKStzKTtlbHNlIGZvcihhIGluIGwpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGwsYSkmJihzPXQoYSxsKSkmJnUucHVzaChtKGEpKyhoP1wiOiBcIjpcIjpcIikrcyk7cmV0dXJuIHM9MD09PXUubGVuZ3RoP1wie31cIjpoP1wie1xcblwiK2grdS5qb2luKFwiLFxcblwiK2gpK1wiXFxuXCIrYytcIn1cIjpcIntcIit1LmpvaW4oXCIsXCIpK1wifVwiLGg9YyxzfX0oXCJcIix7XCJcIjp0fSl9fX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5UUkFOU0ZFUiksc2VuZGVyUHVibGljS2V5OmkuaXNQdWJsaWNLZXksdmVyc2lvbjppLm9yRXEoW3ZvaWQgMCwyXSksYXNzZXRJZDppLmlzQXNzZXRJZCxmZWVBc3NldElkOmkuaXNBc3NldElkLHJlY2lwaWVudDppLmlzUmVjaXBpZW50LGFtb3VudDppLmlzTnVtYmVyTGlrZSxhdHRhY2htZW50OmkuaXNBdHRhY2htZW50LGZlZTppLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6aS5pc051bWJlcixwcm9vZnM6aS5pZkVsc2UoaS5pc0FycmF5LGkuZGVmYXVsdFZhbHVlKCEwKSxpLm9yRXEoW3ZvaWQgMF0pKX07dC50cmFuc2ZlclZhbGlkYXRvcj1pLnZhbGlkYXRlQnlTaGVtYShhLGkuZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cig2KSxhPXt0eXBlOmkuaXNFcShuLlRSQU5TQUNUSU9OX1RZUEUuTUFTU19UUkFOU0ZFUiksc2VuZGVyUHVibGljS2V5OmkuaXNQdWJsaWNLZXksdmVyc2lvbjppLm9yRXEoW3ZvaWQgMCwwLDFdKSx0cmFuc2ZlcnM6aS52YWxpZGF0ZVBpcGUoaS5pc0FycmF5LGkucGlwZShpLnByb3AoXCJsZW5ndGhcIiksaS5ndGUoMCkpLGU9PmUuZXZlcnkoaS52YWxpZGF0ZVBpcGUoaS5pc1JlcXVpcmVkKCEwKSxpLnBpcGUoaS5wcm9wKFwicmVjaXBpZW50XCIpLGkuaXNSZWNpcGllbnQpLGkucGlwZShpLnByb3AoXCJhbW91bnRcIiksaS5pc051bWJlckxpa2UpKSkpLGFzc2V0SWQ6aS5pc0Fzc2V0SWQsYXR0YWNobWVudDppLmlzQXR0YWNobWVudCxmZWU6aS5pc051bWJlckxpa2UsdGltZXN0YW1wOmkuaXNOdW1iZXIscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3QubWFzc1RyYW5zZmVyVmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5BTElBUyksdmVyc2lvbjppLm9yRXEoW3ZvaWQgMCwyXSksc2VuZGVyUHVibGljS2V5OmkuaXNQdWJsaWNLZXksYWxpYXM6aS5pc1ZhbGlkQWxpYXNOYW1lLGZlZTppLmlzTnVtYmVyTGlrZSxjaGFpbklkOmkuaXNOdW1iZXIsdGltZXN0YW1wOmkuaXNOdW1iZXIscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3QuYWxpYXNWYWxpZGF0b3I9aS52YWxpZGF0ZUJ5U2hlbWEoYSxpLmdldEVycm9yKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNiksYT17dHlwZTppLmlzRXEobi5UUkFOU0FDVElPTl9UWVBFLkJVUk4pLHNlbmRlclB1YmxpY0tleTppLmlzUHVibGljS2V5LHZlcnNpb246aS5vckVxKFt2b2lkIDAsMl0pLGFzc2V0SWQ6aS5pc0Fzc2V0SWQscXVhbnRpdHk6aS5pc051bWJlckxpa2UsY2hhaW5JZDppLmlzTnVtYmVyLGZlZTppLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6aS5pc051bWJlcixwcm9vZnM6aS5pZkVsc2UoaS5pc0FycmF5LGkuZGVmYXVsdFZhbHVlKCEwKSxpLm9yRXEoW3ZvaWQgMF0pKX07dC5idXJuVmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5DQU5DRUxfTEVBU0UpLHNlbmRlclB1YmxpY0tleTppLmlzUHVibGljS2V5LHZlcnNpb246aS5vckVxKFt2b2lkIDAsMl0pLGxlYXNlSWQ6aS5pc0Fzc2V0SWQsY2hhaW5JZDppLmlzTnVtYmVyLGZlZTppLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6aS5pc051bWJlcixwcm9vZnM6aS5pZkVsc2UoaS5pc0FycmF5LGkuZGVmYXVsdFZhbHVlKCEwKSxpLm9yRXEoW3ZvaWQgMF0pKX07dC5jYW5jZWxMZWFzZVZhbGlkYXRvcj1pLnZhbGlkYXRlQnlTaGVtYShhLGkuZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cig2KSxhPXt0eXBlOmkuaXNFcShuLlRSQU5TQUNUSU9OX1RZUEUuREFUQSksc2VuZGVyUHVibGljS2V5OmkuaXNQdWJsaWNLZXksdmVyc2lvbjppLm9yRXEoW3ZvaWQgMCwwLDFdKSxkYXRhOmU9PmkuaXNBcnJheShlKSYmZS5ldmVyeShlPT5pLmlzVmFsaWREYXRhKGUpKSxmZWU6aS5pc051bWJlckxpa2UsdGltZXN0YW1wOmkuaXNOdW1iZXIscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3QuZGF0YVZhbGlkYXRvcj1pLnZhbGlkYXRlQnlTaGVtYShhLGkuZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cig2KSxhPXt0eXBlOmkuaXNFcShuLlRSQU5TQUNUSU9OX1RZUEUuU1BPTlNPUlNISVApLHNlbmRlclB1YmxpY0tleTppLmlzUHVibGljS2V5LHZlcnNpb246aS5vckVxKFt2b2lkIDAsMCwxXSksYXNzZXRJZDppLmlzQXNzZXRJZCxtaW5TcG9uc29yZWRBc3NldEZlZTppLmlzTnVtYmVyTGlrZSxmZWU6aS5pc051bWJlckxpa2UsdGltZXN0YW1wOmkuaXNOdW1iZXIscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3Quc3BvbnNvcnNoaXBWYWxpZGF0b3I9aS52YWxpZGF0ZUJ5U2hlbWEoYSxpLmdldEVycm9yKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNiksYT17dHlwZTppLmlzRXEobi5UUkFOU0FDVElPTl9UWVBFLlNFVF9BU1NFVF9TQ1JJUFQpLHNlbmRlclB1YmxpY0tleTppLmlzUHVibGljS2V5LHZlcnNpb246aS5vckVxKFt2b2lkIDAsMCwxXSksYXNzZXRJZDppLmlzQXNzZXRJZCxjaGFpbklkOmkuaXNOdW1iZXIsZmVlOmkuaXNOdW1iZXJMaWtlLHRpbWVzdGFtcDppLmlzTnVtYmVyLHNjcmlwdDppLmlzQmFzZTY0LHByb29mczppLmlmRWxzZShpLmlzQXJyYXksaS5kZWZhdWx0VmFsdWUoITApLGkub3JFcShbdm9pZCAwXSkpfTt0LnNldEFzc2V0U2NyaXB0VmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5TRVRfU0NSSVBUKSxzZW5kZXJQdWJsaWNLZXk6aS5pc1B1YmxpY0tleSx2ZXJzaW9uOmkub3JFcShbdm9pZCAwLDAsMV0pLGNoYWluSWQ6aS5pc051bWJlcixmZWU6aS5pc051bWJlckxpa2UsdGltZXN0YW1wOmkuaXNOdW1iZXIsc2NyaXB0OmkuaWZFbHNlKGkuaXNFcShudWxsKSxpLmRlZmF1bHRWYWx1ZSghMCksaS5pc0Jhc2U2NCkscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3Quc2V0U2NyaXB0VmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5SRUlTU1VFKSxzZW5kZXJQdWJsaWNLZXk6aS5pc1B1YmxpY0tleSx2ZXJzaW9uOmkub3JFcShbdm9pZCAwLDJdKSxhc3NldElkOmkuaXNBc3NldElkLHF1YW50aXR5OmkuaXNOdW1iZXJMaWtlLHJlaXNzdWFibGU6aS5pc0Jvb2xlYW4sY2hhaW5JZDppLmlzTnVtYmVyLGZlZTppLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6aS5pc051bWJlcixwcm9vZnM6aS5pZkVsc2UoaS5pc0FycmF5LGkuZGVmYXVsdFZhbHVlKCEwKSxpLm9yRXEoW3ZvaWQgMF0pKX07dC5yZWlzc3VlVmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5JU1NVRSksdmVyc2lvbjppLm9yRXEoW3ZvaWQgMCwyXSksc2VuZGVyUHVibGljS2V5OmkuaXNQdWJsaWNLZXksbmFtZTppLmlzVmFsaWRBc3NldE5hbWUsZGVzY3JpcHRpb246aS5pc1ZhbGlkQXNzZXREZXNjcmlwdGlvbixxdWFudGl0eTppLmlzTnVtYmVyTGlrZSxkZWNpbWFsczppLmlzTnVtYmVyLHJlaXNzdWFibGU6aS5pc0Jvb2xlYW4sc2NyaXB0OmkuaWZFbHNlKGkuaXNSZXF1aXJlZCghMCksaS5pc0Jhc2U2NCxpLmRlZmF1bHRWYWx1ZSghMCkpLGNoYWluSWQ6aS5pc051bWJlcixmZWU6aS5pc051bWJlckxpa2UsdGltZXN0YW1wOmkuaXNOdW1iZXIscHJvb2ZzOmkuaWZFbHNlKGkuaXNBcnJheSxpLmRlZmF1bHRWYWx1ZSghMCksaS5vckVxKFt2b2lkIDBdKSl9O3QuaXNzdWVWYWxpZGF0b3I9aS52YWxpZGF0ZUJ5U2hlbWEoYSxpLmdldEVycm9yKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cigwKSxpPXIoNiksYT17dHlwZTppLmlzRXEobi5UUkFOU0FDVElPTl9UWVBFLkxFQVNFKSx2ZXJzaW9uOmkub3JFcShbdm9pZCAwLDJdKSxzZW5kZXJQdWJsaWNLZXk6aS5pc1B1YmxpY0tleSxyZWNpcGllbnQ6aS5pc1JlY2lwaWVudCxhbW91bnQ6aS5pc051bWJlckxpa2UsZmVlOmkuaXNOdW1iZXJMaWtlLHRpbWVzdGFtcDppLmlzTnVtYmVyLHByb29mczppLmlmRWxzZShpLmlzQXJyYXksaS5kZWZhdWx0VmFsdWUoITApLGkub3JFcShbdm9pZCAwXSkpfTt0LmxlYXNlVmFsaWRhdG9yPWkudmFsaWRhdGVCeVNoZW1hKGEsaS5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDYpLGE9e3R5cGU6aS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5JTlZPS0VfU0NSSVBUKSxzZW5kZXJQdWJsaWNLZXk6aS5pc1B1YmxpY0tleSx2ZXJzaW9uOmkub3JFcShbdm9pZCAwLDAsMV0pLGRBcHA6aS5pc1JlY2lwaWVudCxjYWxsOmkuaWZFbHNlKGkuaXNSZXF1aXJlZCghMSksaS5kZWZhdWx0VmFsdWUoITApLGkudmFsaWRhdGVQaXBlKGkucGlwZShpLnByb3AoXCJmdW5jdGlvblwiKSxpLmlzU3RyaW5nKSxpLnBpcGUoaS5wcm9wKFwiZnVuY3Rpb25cIiksaS5wcm9wKFwibGVuZ3RoXCIpLGkuZ3RlKDApKSxpLnBpcGUoaS5wcm9wKFwiYXJnc1wiKSxpLmlzQXJyYXkpLGU9PmUuZXZlcnkoaS52YWxpZGF0ZVBpcGUoaS5pc1JlcXVpcmVkKCEwKSxpLmlzVmFsaWREYXRhUGFpcikpKSkscGF5bWVudDppLnZhbGlkYXRlUGlwZShpLmlzQXJyYXksZT0+ZS5ldmVyeShpLnZhbGlkYXRlUGlwZShpLnBpcGUoaS5wcm9wKFwiYW1vdW50XCIpLGkuaXNOdW1iZXJMaWtlKSxpLnBpcGUoaS5wcm9wKFwiYXNzZXRJZFwiKSxpLmlzQXNzZXRJZCkpKSksZmVlOmkuaXNOdW1iZXJMaWtlLGZlZUFzc2V0SWQ6aS5pc0Fzc2V0SWQsY2hhaW5JZDppLmlzTnVtYmVyLHRpbWVzdGFtcDppLmlzTnVtYmVyLHByb29mczppLmlmRWxzZShpLmlzQXJyYXksaS5kZWZhdWx0VmFsdWUoITApLGkub3JFcShbdm9pZCAwXSkpfTt0Lmludm9rZVZhbGlkYXRvcj1pLnZhbGlkYXRlQnlTaGVtYShhLGkuZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDApLGk9cig2OCksYT1yKDYpLHM9e3R5cGU6YS5pc0VxKG4uVFJBTlNBQ1RJT05fVFlQRS5FWENIQU5HRSksc2VuZGVyUHVibGljS2V5OmEuaXNQdWJsaWNLZXksdmVyc2lvbjphLm9yRXEoW3ZvaWQgMCwwLDEsMl0pLG9yZGVyMTphLnZhbGlkYXRlUGlwZShhLmlzUmVxdWlyZWQoITApLGkub3JkZXJWYWxpZGF0b3IpLG9yZGVyMjphLnZhbGlkYXRlUGlwZShhLmlzUmVxdWlyZWQoITApLGkub3JkZXJWYWxpZGF0b3IpLGFtb3VudDphLmlzTnVtYmVyTGlrZSxwcmljZTphLmlzTnVtYmVyTGlrZSxidXlNYXRjaGVyRmVlOmEuaXNOdW1iZXJMaWtlLHNlbGxNYXRjaGVyRmVlOmEuaXNOdW1iZXJMaWtlLGZlZTphLmlzTnVtYmVyTGlrZSx0aW1lc3RhbXA6YS5pc051bWJlcixwcm9vZnM6YS5pZkVsc2UoYS5pc0FycmF5LGEuZGVmYXVsdFZhbHVlKCEwKSxhLm9yRXEoW3ZvaWQgMF0pKX07dC5leGNoYW5nZVZhbGlkYXRvcj1hLnZhbGlkYXRlQnlTaGVtYShzLGEuZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDYpLGk9e3NlbmRlcjpuLmlzUHVibGljS2V5LG9yZGVySWQ6bi5pc0hhc2gsc2lnbmF0dXJlOm4uaXNCYXNlNTgsaGFzaDpuLmlzQmFzZTU4fTt0LmNhbmNlbE9yZGVyVmFsaWRhdG9yPW4udmFsaWRhdGVCeVNoZW1hKGksbi5nZXRFcnJvcil9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNiksaT17dmVyc2lvbjpuLmlzRXEoMSksYmluYXJ5Om4uaXNCYXNlNjR9LGE9e3ZlcnNpb246bi5pc0VxKDIpLGRhdGE6bi52YWxpZGF0ZVBpcGUobi5pc0FycmF5LGU9PmUuZXZlcnkobi52YWxpZGF0ZVBpcGUobi5pc1JlcXVpcmVkKCEwKSxuLmlzVmFsaWREYXRhUGFpcikpKX0scz1uLnZhbGlkYXRlQnlTaGVtYShpLG4uZ2V0RXJyb3IpLG89bi52YWxpZGF0ZUJ5U2hlbWEoYSxuLmdldEVycm9yKTt0LmN1c3RvbURhdGFWYWxpZGF0b3I9bi5pZkVsc2Uobi5waXBlKG4ucHJvcChcInZlcnNpb25cIiksbi5pc0VxKDEpKSxzLG8pfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDYpLGk9e2RhdGE6bi5pc1N0cmluZyxob3N0Om4uaXNTdHJpbmd9O3QuYXV0aFZhbGlkYXRvcj1uLnZhbGlkYXRlQnlTaGVtYShpLG4uZ2V0RXJyb3IpfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3Qgbj1yKDYpLGk9e3B1YmxpY0tleTpuLmlzUHVibGljS2V5LHRpbWVzdGFtcDpuLmlzTnVtYmVyfTt0LmF1dGhWYWxpZGF0b3I9bi52YWxpZGF0ZUJ5U2hlbWEoaSxuLmdldEVycm9yKX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cig0KSxpPXIoNyksYT1yKDMpLHM9cig1KTt0Lm9yZGVyPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1pLmlzT3JkZXIoZSk/ZS5hc3NldFBhaXIuYW1vdW50QXNzZXQ6ZS5hbW91bnRBc3NldCxvPWkuaXNPcmRlcihlKT9lLmFzc2V0UGFpci5wcmljZUFzc2V0OmUucHJpY2VBc3NldCx1PWkuaXNPcmRlcihlKT9lLnByb29mczpbXSx7bWF0Y2hlckZlZTpjLG1hdGNoZXJQdWJsaWNLZXk6bCxwcmljZTpmLGFtb3VudDpoLG9yZGVyVHlwZTpwLGV4cGlyYXRpb246ZCx0aW1lc3RhbXA6eX09ZSxnPXl8fERhdGUubm93KCksbT1pLmNvbnZlcnRUb1BhaXJzKHQpLHY9ZS5zZW5kZXJQdWJsaWNLZXl8fGkuZ2V0U2VuZGVyUHVibGljS2V5KG0sZSksYj17b3JkZXJUeXBlOnAsdmVyc2lvbjpudWxsPT09ZS52ZXJzaW9uP3ZvaWQgMDplLnZlcnNpb258fDIsYXNzZXRQYWlyOnthbW91bnRBc3NldDpyLHByaWNlQXNzZXQ6b30scHJpY2U6ZixhbW91bnQ6aCx0aW1lc3RhbXA6ZyxleHBpcmF0aW9uOmR8fGcrMjUwNTZlNSxtYXRjaGVyRmVlOmN8fDNlNSxtYXRjaGVyUHVibGljS2V5Omwsc2VuZGVyUHVibGljS2V5OnYscHJvb2ZzOnUsaWQ6XCJcIn07Mz09PWIudmVyc2lvbiYmKGIubWF0Y2hlckZlZUFzc2V0SWQ9XCJXQVZFU1wiPT09ZS5tYXRjaGVyRmVlQXNzZXRJZD9udWxsOmUubWF0Y2hlckZlZUFzc2V0SWQpO2NvbnN0IEU9YS5iaW5hcnkuc2VyaWFsaXplT3JkZXIoYik7cmV0dXJuIG0uZm9yRWFjaCgoW2UsdF0pPT5pLmFkZFByb29mKGIsbi5zaWduQnl0ZXMoZSxFKSx0KSkscy52YWxpZGF0ZS5vcmRlcihiKSxiLmlkPW4uYmFzZTU4RW5jb2RlKG4uYmxha2UyYihFKSksdm9pZCAwIT09Yi52ZXJzaW9uJiYxIT09Yi52ZXJzaW9ufHwoYi5zaWduYXR1cmU9Yi5wcm9vZnMmJmIucHJvb2ZzWzBdKSxifX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IG49cig0KSxpPXIoMykse0JBU0U1OF9TVFJJTkc6YX09aS5zZXJpYWxpemVQcmltaXRpdmVzLHM9cig3KSxvPXIoNSk7dC5jYW5jZWxPcmRlclBhcmFtc1RvQnl0ZXM9ZT0+bi5jb25jYXQoYShlLnNlbmRlciksYShlLm9yZGVySWQpKSx0LmNhbmNlbE9yZGVyPWZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1zLmNvbnZlcnRUb1BhaXJzKHQpLGk9ZS5zZW5kZXJQdWJsaWNLZXl8fHMuZ2V0U2VuZGVyUHVibGljS2V5KHIse3NlbmRlclB1YmxpY0tleTp2b2lkIDB9KSx1PW4uY29uY2F0KGEoaSksYShlLm9yZGVySWQpKSxjPWUuc2lnbmF0dXJlfHxudWxsIT10JiZuLnNpZ25CeXRlcyh0LHUpfHxcIlwiLGw9bi5iYXNlNThFbmNvZGUobi5ibGFrZTJiKFVpbnQ4QXJyYXkuZnJvbSh1KSkpLGY9e3NlbmRlcjppLG9yZGVySWQ6ZS5vcmRlcklkLHNpZ25hdHVyZTpjLGhhc2g6bH07cmV0dXJuIG8udmFsaWRhdGUuY2FuY2VsT3JkZXIoZiksZn19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBpPW4ocig3MikpLGE9cigzKSxzPXIoNCksbz1yKDApLHU9cig0NCksYz1yKDQ1KSxsPXIoMzgpLGY9cigzOSksaD1yKDQxKSxwPXIoNDIpLGQ9cig0MykseT1yKDI3KSxnPXIoNDYpLG09cig0Nyksdj1yKDcpLGI9cig0OCksRT1yKDQwKSxTPXIoNDkpLFQ9cig1MCksQz1yKDY5KSxBPXIoNzApLEk9cig3MSk7ZnVuY3Rpb24gdyhlKXtyZXR1cm4gdi5pc09yZGVyKGUpP2EuYmluYXJ5LnNlcmlhbGl6ZU9yZGVyKGUpOmEuYmluYXJ5LnNlcmlhbGl6ZVR4KGUpfXQudHhUeXBlTWFwPXtbby5UUkFOU0FDVElPTl9UWVBFLklTU1VFXTp7c2lnbjooZSx0KT0+dS5pc3N1ZShlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLlRSQU5TRkVSXTp7c2lnbjooZSx0KT0+Yy50cmFuc2ZlcihlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLlJFSVNTVUVdOntzaWduOihlLHQpPT5sLnJlaXNzdWUoZSx0KX0sW28uVFJBTlNBQ1RJT05fVFlQRS5CVVJOXTp7c2lnbjooZSx0KT0+Zi5idXJuKGUsdCl9LFtvLlRSQU5TQUNUSU9OX1RZUEUuTEVBU0VdOntzaWduOihlLHQpPT5oLmxlYXNlKGUsdCl9LFtvLlRSQU5TQUNUSU9OX1RZUEUuQ0FOQ0VMX0xFQVNFXTp7c2lnbjooZSx0KT0+cC5jYW5jZWxMZWFzZShlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLkFMSUFTXTp7c2lnbjooZSx0KT0+Zy5hbGlhcyhlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLk1BU1NfVFJBTlNGRVJdOntzaWduOihlLHQpPT55Lm1hc3NUcmFuc2ZlcihlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLkRBVEFdOntzaWduOihlLHQpPT5kLmRhdGEoZSx0KX0sW28uVFJBTlNBQ1RJT05fVFlQRS5TRVRfU0NSSVBUXTp7c2lnbjooZSx0KT0+bS5zZXRTY3JpcHQoZSx0KX0sW28uVFJBTlNBQ1RJT05fVFlQRS5TRVRfQVNTRVRfU0NSSVBUXTp7c2lnbjooZSx0KT0+Yi5zZXRBc3NldFNjcmlwdChlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLlNQT05TT1JTSElQXTp7c2lnbjooZSx0KT0+Uy5zcG9uc29yc2hpcChlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLkVYQ0hBTkdFXTp7c2lnbjooZSx0KT0+RS5leGNoYW5nZShlLHQpfSxbby5UUkFOU0FDVElPTl9UWVBFLklOVk9LRV9TQ1JJUFRdOntzaWduOihlLHQpPT5ULmludm9rZVNjcmlwdChlLHQpfX0sdC5zaWduVHg9ZnVuY3Rpb24oZSxyKXtpZighdC50eFR5cGVNYXBbZS50eXBlXSl0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdHggdHlwZTogJHtlLnR5cGV9YCk7cmV0dXJuIHQudHhUeXBlTWFwW2UudHlwZV0uc2lnbihlLHIpfSx0LnNlcmlhbGl6ZT13LHQudmVyaWZ5PWZ1bmN0aW9uKGUsdD0wLHIpe3I9cnx8ZS5zZW5kZXJQdWJsaWNLZXk7Y29uc3Qgbj13KGUpLGk9bnVsbD09ZS52ZXJzaW9uP2Uuc2lnbmF0dXJlOmUucHJvb2ZzW3RdO3JldHVybiBzLnZlcmlmeVNpZ25hdHVyZShyLG4saSl9LHQudmVyaWZ5Q3VzdG9tRGF0YT1mdW5jdGlvbihlKXtjb25zdCB0PUMuc2VyaWFsaXplQ3VzdG9tRGF0YShlKTtyZXR1cm4gcy52ZXJpZnlTaWduYXR1cmUoZS5wdWJsaWNLZXksdCxlLnNpZ25hdHVyZSl9LHQudmVyaWZ5QXV0aERhdGE9ZnVuY3Rpb24oZSx0LHIpe3I9cnx8XCJXXCI7Y29uc3Qgbj1BLnNlcmlhbGl6ZUF1dGhEYXRhKHQpO3JldHVybiBzLmFkZHJlc3Moe3B1YmxpY0tleTplLnB1YmxpY0tleX0scik9PT1lLmFkZHJlc3MmJnMudmVyaWZ5U2lnbmF0dXJlKGUucHVibGljS2V5LG4sZS5zaWduYXR1cmUpfSx0LnZlcmlmeVdhdmVzQXV0aERhdGE9ZnVuY3Rpb24oZSx0LHIpe3I9cnx8XCJXXCI7Y29uc3Qgbj1JLnNlcmlhbGl6ZVdhdmVzQXV0aERhdGEodCk7cmV0dXJuIHMuYWRkcmVzcyh7cHVibGljS2V5OmUucHVibGljS2V5fSxyKT09PWUuYWRkcmVzcyYmcy52ZXJpZnlTaWduYXR1cmUoZS5wdWJsaWNLZXksbixlLnNpZ25hdHVyZSl9LHQuc3VibWl0T3JkZXI9ZnVuY3Rpb24oZSx0KXtsZXQgcixuO3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0PyhuPXQscj1cIm1hdGNoZXIvb3JkZXJib29rXCIpOihuPXQubWF0Y2hlclVybCxyPXQubWFya2V0P1wibWF0Y2hlci9vcmRlcmJvb2svbWFya2V0XCI6XCJtYXRjaGVyL29yZGVyYm9va1wiKSxpLmRlZmF1bHQucG9zdChyLGEuanNvbi5zdHJpbmdpZnlPcmRlcihlKSx7YmFzZVVSTDpuLGhlYWRlcnM6e1wiY29udGVudC10eXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSkudGhlbihlPT5lLmRhdGEpLmNhdGNoKGU9PlByb21pc2UucmVqZWN0KGUucmVzcG9uc2UmJjQwMD09PWUucmVzcG9uc2Uuc3RhdHVzP25ldyBFcnJvcihlLnJlc3BvbnNlLmRhdGEubWVzc2FnZSk6ZSkpfSx0LmNhbmNlbFN1Ym1pdHRlZE9yZGVyPWZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBpLmRlZmF1bHQucG9zdChgbWF0Y2hlci9vcmRlcmJvb2svJHt0fHxcIldBVkVTXCJ9LyR7cnx8XCJXQVZFU1wifS9jYW5jZWxgLEpTT04uc3RyaW5naWZ5KGUpLHtiYXNlVVJMOm4saGVhZGVyczp7XCJjb250ZW50LXR5cGVcIjpcImFwcGxpY2F0aW9uL2pzb25cIn19KS50aGVuKGU9PmUuZGF0YSkuY2F0Y2goZT0+UHJvbWlzZS5yZWplY3QoZS5yZXNwb25zZSYmNDAwPT09ZS5yZXNwb25zZS5zdGF0dXM/bmV3IEVycm9yKGUucmVzcG9uc2UuZGF0YS5tZXNzYWdlKTplKSl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KSxpPXIoNzMpLGE9cigxMzkpLHM9cig3OSk7ZnVuY3Rpb24gbyhlKXt2YXIgdD1uZXcgYShlKSxyPWkoYS5wcm90b3R5cGUucmVxdWVzdCx0KTtyZXR1cm4gbi5leHRlbmQocixhLnByb3RvdHlwZSx0KSxuLmV4dGVuZChyLHQpLHJ9dmFyIHU9byhyKDc2KSk7dS5BeGlvcz1hLHUuY3JlYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBvKHModS5kZWZhdWx0cyxlKSl9LHUuQ2FuY2VsPXIoODApLHUuQ2FuY2VsVG9rZW49cigxNTEpLHUuaXNDYW5jZWw9cig3NSksdS5hbGw9ZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKGUpfSx1LnNwcmVhZD1yKDE1MiksZS5leHBvcnRzPXUsZS5leHBvcnRzLmRlZmF1bHQ9dX0sZnVuY3Rpb24oZSx0KXtcbi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmbnVsbCE9ZS5jb25zdHJ1Y3RvciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciYmZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihlKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDgpLGk9cig3NCksYT1yKDE0MCkscz1yKDE0MSksbz1yKDc5KTtmdW5jdGlvbiB1KGUpe3RoaXMuZGVmYXVsdHM9ZSx0aGlzLmludGVyY2VwdG9ycz17cmVxdWVzdDpuZXcgYSxyZXNwb25zZTpuZXcgYX19dS5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbihlKXtcInN0cmluZ1wiPT10eXBlb2YgZT8oZT1hcmd1bWVudHNbMV18fHt9KS51cmw9YXJndW1lbnRzWzBdOmU9ZXx8e30sKGU9byh0aGlzLmRlZmF1bHRzLGUpKS5tZXRob2Q9ZS5tZXRob2Q/ZS5tZXRob2QudG9Mb3dlckNhc2UoKTpcImdldFwiO3ZhciB0PVtzLHZvaWQgMF0scj1Qcm9taXNlLnJlc29sdmUoZSk7Zm9yKHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC51bnNoaWZ0KGUuZnVsZmlsbGVkLGUucmVqZWN0ZWQpfSkpLHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QucHVzaChlLmZ1bGZpbGxlZCxlLnJlamVjdGVkKX0pKTt0Lmxlbmd0aDspcj1yLnRoZW4odC5zaGlmdCgpLHQuc2hpZnQoKSk7cmV0dXJuIHJ9LHUucHJvdG90eXBlLmdldFVyaT1mdW5jdGlvbihlKXtyZXR1cm4gZT1vKHRoaXMuZGVmYXVsdHMsZSksaShlLnVybCxlLnBhcmFtcyxlLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLFwiXCIpfSxuLmZvckVhY2goW1wiZGVsZXRlXCIsXCJnZXRcIixcImhlYWRcIixcIm9wdGlvbnNcIl0sKGZ1bmN0aW9uKGUpe3UucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMucmVxdWVzdChuLm1lcmdlKHJ8fHt9LHttZXRob2Q6ZSx1cmw6dH0pKX19KSksbi5mb3JFYWNoKFtcInBvc3RcIixcInB1dFwiLFwicGF0Y2hcIl0sKGZ1bmN0aW9uKGUpe3UucHJvdG90eXBlW2VdPWZ1bmN0aW9uKHQscixpKXtyZXR1cm4gdGhpcy5yZXF1ZXN0KG4ubWVyZ2UoaXx8e30se21ldGhvZDplLHVybDp0LGRhdGE6cn0pKX19KSksZS5leHBvcnRzPXV9LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDgpO2Z1bmN0aW9uIGkoKXt0aGlzLmhhbmRsZXJzPVtdfWkucHJvdG90eXBlLnVzZT1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmhhbmRsZXJzLnB1c2goe2Z1bGZpbGxlZDplLHJlamVjdGVkOnR9KSx0aGlzLmhhbmRsZXJzLmxlbmd0aC0xfSxpLnByb3RvdHlwZS5lamVjdD1mdW5jdGlvbihlKXt0aGlzLmhhbmRsZXJzW2VdJiYodGhpcy5oYW5kbGVyc1tlXT1udWxsKX0saS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihlKXtuLmZvckVhY2godGhpcy5oYW5kbGVycywoZnVuY3Rpb24odCl7bnVsbCE9PXQmJmUodCl9KSl9LGUuZXhwb3J0cz1pfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KSxpPXIoMTQyKSxhPXIoNzUpLHM9cig3Niksbz1yKDE0OSksdT1yKDE1MCk7ZnVuY3Rpb24gYyhlKXtlLmNhbmNlbFRva2VuJiZlLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGMoZSksZS5iYXNlVVJMJiYhbyhlLnVybCkmJihlLnVybD11KGUuYmFzZVVSTCxlLnVybCkpLGUuaGVhZGVycz1lLmhlYWRlcnN8fHt9LGUuZGF0YT1pKGUuZGF0YSxlLmhlYWRlcnMsZS50cmFuc2Zvcm1SZXF1ZXN0KSxlLmhlYWRlcnM9bi5tZXJnZShlLmhlYWRlcnMuY29tbW9ufHx7fSxlLmhlYWRlcnNbZS5tZXRob2RdfHx7fSxlLmhlYWRlcnN8fHt9KSxuLmZvckVhY2goW1wiZGVsZXRlXCIsXCJnZXRcIixcImhlYWRcIixcInBvc3RcIixcInB1dFwiLFwicGF0Y2hcIixcImNvbW1vblwiXSwoZnVuY3Rpb24odCl7ZGVsZXRlIGUuaGVhZGVyc1t0XX0pKSwoZS5hZGFwdGVyfHxzLmFkYXB0ZXIpKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiBjKGUpLHQuZGF0YT1pKHQuZGF0YSx0LmhlYWRlcnMsZS50cmFuc2Zvcm1SZXNwb25zZSksdH0pLChmdW5jdGlvbih0KXtyZXR1cm4gYSh0KXx8KGMoZSksdCYmdC5yZXNwb25zZSYmKHQucmVzcG9uc2UuZGF0YT1pKHQucmVzcG9uc2UuZGF0YSx0LnJlc3BvbnNlLmhlYWRlcnMsZS50cmFuc2Zvcm1SZXNwb25zZSkpKSxQcm9taXNlLnJlamVjdCh0KX0pKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDgpO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQscil7cmV0dXJuIG4uZm9yRWFjaChyLChmdW5jdGlvbihyKXtlPXIoZSx0KX0pKSxlfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoOCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7bi5mb3JFYWNoKGUsKGZ1bmN0aW9uKHIsbil7biE9PXQmJm4udG9VcHBlckNhc2UoKT09PXQudG9VcHBlckNhc2UoKSYmKGVbdF09cixkZWxldGUgZVtuXSl9KSl9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig3OCk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyKXt2YXIgaT1yLmNvbmZpZy52YWxpZGF0ZVN0YXR1czshaXx8aShyLnN0YXR1cyk/ZShyKTp0KG4oXCJSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIFwiK3Iuc3RhdHVzLHIuY29uZmlnLG51bGwsci5yZXF1ZXN0LHIpKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIsbixpKXtyZXR1cm4gZS5jb25maWc9dCxyJiYoZS5jb2RlPXIpLGUucmVxdWVzdD1uLGUucmVzcG9uc2U9aSxlLmlzQXhpb3NFcnJvcj0hMCxlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnttZXNzYWdlOnRoaXMubWVzc2FnZSxuYW1lOnRoaXMubmFtZSxkZXNjcmlwdGlvbjp0aGlzLmRlc2NyaXB0aW9uLG51bWJlcjp0aGlzLm51bWJlcixmaWxlTmFtZTp0aGlzLmZpbGVOYW1lLGxpbmVOdW1iZXI6dGhpcy5saW5lTnVtYmVyLGNvbHVtbk51bWJlcjp0aGlzLmNvbHVtbk51bWJlcixzdGFjazp0aGlzLnN0YWNrLGNvbmZpZzp0aGlzLmNvbmZpZyxjb2RlOnRoaXMuY29kZX19LGV9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KSxpPVtcImFnZVwiLFwiYXV0aG9yaXphdGlvblwiLFwiY29udGVudC1sZW5ndGhcIixcImNvbnRlbnQtdHlwZVwiLFwiZXRhZ1wiLFwiZXhwaXJlc1wiLFwiZnJvbVwiLFwiaG9zdFwiLFwiaWYtbW9kaWZpZWQtc2luY2VcIixcImlmLXVubW9kaWZpZWQtc2luY2VcIixcImxhc3QtbW9kaWZpZWRcIixcImxvY2F0aW9uXCIsXCJtYXgtZm9yd2FyZHNcIixcInByb3h5LWF1dGhvcml6YXRpb25cIixcInJlZmVyZXJcIixcInJldHJ5LWFmdGVyXCIsXCJ1c2VyLWFnZW50XCJdO2UuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgdCxyLGEscz17fTtyZXR1cm4gZT8obi5mb3JFYWNoKGUuc3BsaXQoXCJcXG5cIiksKGZ1bmN0aW9uKGUpe2lmKGE9ZS5pbmRleE9mKFwiOlwiKSx0PW4udHJpbShlLnN1YnN0cigwLGEpKS50b0xvd2VyQ2FzZSgpLHI9bi50cmltKGUuc3Vic3RyKGErMSkpLHQpe2lmKHNbdF0mJmkuaW5kZXhPZih0KT49MClyZXR1cm47c1t0XT1cInNldC1jb29raWVcIj09PXQ/KHNbdF0/c1t0XTpbXSkuY29uY2F0KFtyXSk6c1t0XT9zW3RdK1wiLCBcIityOnJ9fSkpLHMpOnN9fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig4KTtlLmV4cG9ydHM9bi5pc1N0YW5kYXJkQnJvd3NlckVudigpP2Z1bmN0aW9uKCl7dmFyIGUsdD0vKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpLHI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7ZnVuY3Rpb24gaShlKXt2YXIgbj1lO3JldHVybiB0JiYoci5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsbiksbj1yLmhyZWYpLHIuc2V0QXR0cmlidXRlKFwiaHJlZlwiLG4pLHtocmVmOnIuaHJlZixwcm90b2NvbDpyLnByb3RvY29sP3IucHJvdG9jb2wucmVwbGFjZSgvOiQvLFwiXCIpOlwiXCIsaG9zdDpyLmhvc3Qsc2VhcmNoOnIuc2VhcmNoP3Iuc2VhcmNoLnJlcGxhY2UoL15cXD8vLFwiXCIpOlwiXCIsaGFzaDpyLmhhc2g/ci5oYXNoLnJlcGxhY2UoL14jLyxcIlwiKTpcIlwiLGhvc3RuYW1lOnIuaG9zdG5hbWUscG9ydDpyLnBvcnQscGF0aG5hbWU6XCIvXCI9PT1yLnBhdGhuYW1lLmNoYXJBdCgwKT9yLnBhdGhuYW1lOlwiL1wiK3IucGF0aG5hbWV9fXJldHVybiBlPWkod2luZG93LmxvY2F0aW9uLmhyZWYpLGZ1bmN0aW9uKHQpe3ZhciByPW4uaXNTdHJpbmcodCk/aSh0KTp0O3JldHVybiByLnByb3RvY29sPT09ZS5wcm90b2NvbCYmci5ob3N0PT09ZS5ob3N0fX0oKTpmdW5jdGlvbigpe3JldHVybiEwfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoOCk7ZS5leHBvcnRzPW4uaXNTdGFuZGFyZEJyb3dzZXJFbnYoKT97d3JpdGU6ZnVuY3Rpb24oZSx0LHIsaSxhLHMpe3ZhciBvPVtdO28ucHVzaChlK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudCh0KSksbi5pc051bWJlcihyKSYmby5wdXNoKFwiZXhwaXJlcz1cIituZXcgRGF0ZShyKS50b0dNVFN0cmluZygpKSxuLmlzU3RyaW5nKGkpJiZvLnB1c2goXCJwYXRoPVwiK2kpLG4uaXNTdHJpbmcoYSkmJm8ucHVzaChcImRvbWFpbj1cIithKSwhMD09PXMmJm8ucHVzaChcInNlY3VyZVwiKSxkb2N1bWVudC5jb29raWU9by5qb2luKFwiOyBcIil9LHJlYWQ6ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoXCIoXnw7XFxcXHMqKShcIitlK1wiKT0oW147XSopXCIpKTtyZXR1cm4gdD9kZWNvZGVVUklDb21wb25lbnQodFszXSk6bnVsbH0scmVtb3ZlOmZ1bmN0aW9uKGUpe3RoaXMud3JpdGUoZSxcIlwiLERhdGUubm93KCktODY0ZTUpfX06e3dyaXRlOmZ1bmN0aW9uKCl7fSxyZWFkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LHJlbW92ZTpmdW5jdGlvbigpe319fSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybi9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdChlKX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdD9lLnJlcGxhY2UoL1xcLyskLyxcIlwiKStcIi9cIit0LnJlcGxhY2UoL15cXC8rLyxcIlwiKTplfX0sZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoODApO2Z1bmN0aW9uIGkoZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTt2YXIgdDt0aGlzLnByb21pc2U9bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUpe3Q9ZX0pKTt2YXIgcj10aGlzO2UoKGZ1bmN0aW9uKGUpe3IucmVhc29ufHwoci5yZWFzb249bmV3IG4oZSksdChyLnJlYXNvbikpfSkpfWkucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLnJlYXNvbil0aHJvdyB0aGlzLnJlYXNvbn0saS5zb3VyY2U9ZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm57dG9rZW46bmV3IGkoKGZ1bmN0aW9uKHQpe2U9dH0pKSxjYW5jZWw6ZX19LGUuZXhwb3J0cz1pfSxmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZS5hcHBseShudWxsLHQpfX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoMCksaT1yKDQ0KSxhPXIoNDUpLHM9cigzOCksbz1yKDM5KSx1PXIoNDEpLGM9cig0MiksbD1yKDQ2KSxmPXIoMjcpLGg9cig0MykscD1yKDQ3KSxkPXIoNDgpLHk9cig0OSksZz1yKDQwKSxtPXIoNTApO3QubWFrZVR4PWZ1bmN0aW9uKGUpe3N3aXRjaChlLnR5cGUpe2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLklTU1VFOnJldHVybiBpLmlzc3VlKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLlRSQU5TRkVSOnJldHVybiBhLnRyYW5zZmVyKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLlJFSVNTVUU6cmV0dXJuIHMucmVpc3N1ZShlKTtjYXNlIG4uVFJBTlNBQ1RJT05fVFlQRS5CVVJOOnJldHVybiBvLmJ1cm4oZSk7Y2FzZSBuLlRSQU5TQUNUSU9OX1RZUEUuTEVBU0U6cmV0dXJuIHUubGVhc2UoZSk7Y2FzZSBuLlRSQU5TQUNUSU9OX1RZUEUuQ0FOQ0VMX0xFQVNFOnJldHVybiBjLmNhbmNlbExlYXNlKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLkFMSUFTOnJldHVybiBsLmFsaWFzKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLk1BU1NfVFJBTlNGRVI6cmV0dXJuIGYubWFzc1RyYW5zZmVyKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLkRBVEE6cmV0dXJuIGguZGF0YShlKTtjYXNlIG4uVFJBTlNBQ1RJT05fVFlQRS5TRVRfU0NSSVBUOnJldHVybiBwLnNldFNjcmlwdChlKTtjYXNlIG4uVFJBTlNBQ1RJT05fVFlQRS5TRVRfQVNTRVRfU0NSSVBUOnJldHVybiBkLnNldEFzc2V0U2NyaXB0KGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLlNQT05TT1JTSElQOnJldHVybiB5LnNwb25zb3JzaGlwKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLkVYQ0hBTkdFOnJldHVybiBnLmV4Y2hhbmdlKGUpO2Nhc2Ugbi5UUkFOU0FDVElPTl9UWVBFLklOVk9LRV9TQ1JJUFQ6cmV0dXJuIG0uaW52b2tlU2NyaXB0KGUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR4IHR5cGU6ICR7ZS50eXBlfWApfX19LGZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBuPXIoNCk7dC5lbmNyeXB0U2VlZD1uLmVuY3J5cHRTZWVkLHQuZGVjcnlwdFNlZWQ9bi5kZWNyeXB0U2VlZDtjb25zdCBpPXIoMyk7Y2xhc3MgYXtjb25zdHJ1Y3RvcihlLHQpe2lmKGUubGVuZ3RoPDEyKXRocm93IG5ldyBFcnJvcihcIllvdXIgc2VlZCBsZW5ndGggaXMgbGVzcyB0aGFuIGFsbG93ZWQgaW4gY29uZmlnXCIpO3RoaXMucGhyYXNlPWUsdGhpcy5hZGRyZXNzPW4uYWRkcmVzcyhlLHQpLHRoaXMua2V5UGFpcj17cHJpdmF0ZUtleTpuLnByaXZhdGVLZXkoZSkscHVibGljS2V5Om4ucHVibGljS2V5KGUpfSxPYmplY3QuZnJlZXplKHRoaXMpLE9iamVjdC5mcmVlemUodGhpcy5rZXlQYWlyKX1lbmNyeXB0KGUsdCl7cmV0dXJuIGEuZW5jcnlwdFNlZWRQaHJhc2UodGhpcy5waHJhc2UsZSx0KX1zdGF0aWMgZW5jcnlwdFNlZWRQaHJhc2UoZSx0LHI9NWUzKXtpZih0JiZ0Lmxlbmd0aCxlLmxlbmd0aDwxMil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2VlZCBwaHJhc2UgeW91IGFyZSB0cnlpbmcgdG8gZW5jcnlwdCBpcyB0b28gc2hvcnRcIik7cmV0dXJuIG4uZW5jcnlwdFNlZWQoZSx0LHIpfXN0YXRpYyBkZWNyeXB0U2VlZFBocmFzZShlLHQscj01ZTMpe2xldCBpO3RyeXtpPW4uZGVjcnlwdFNlZWQoZSx0LHIpfWNhdGNoKGUpe3Rocm93IG5ldyBFcnJvcihcIlRoZSBwYXNzd29yZCBpcyB3cm9uZ1wiKX1pZihcIlwiPT09aXx8aS5sZW5ndGg8MTIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBhc3N3b3JkIGlzIHdyb25nXCIpO3JldHVybiBpfXN0YXRpYyBjcmVhdGUoZT0xNSl7Y29uc3QgdD1zKGUpO2lmKHQubGVuZ3RoPDEyKXRocm93IG5ldyBFcnJvcihcIlRoZSByZXN1bHRlZCBzZWVkIGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gbGVuZ3RoICgxMilcIik7cmV0dXJuIG5ldyBhKHQpfXN0YXRpYyBmcm9tRXhpc3RpbmdQaHJhc2UoZSl7aWYoZS5sZW5ndGg8MTIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3VsdGVkIHNlZWQgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBsZW5ndGggKDEyKVwiKTtyZXR1cm4gbmV3IGEoZSl9fWZ1bmN0aW9uIHMoZT0xNSl7cmV0dXJuIG4ucmFuZG9tU2VlZChlKX10LlNlZWQ9YSx0LmdlbmVyYXRlTmV3U2VlZD1zLHQuc3RyZW5ndGhlblBhc3N3b3JkPWZ1bmN0aW9uKGUsdD01ZTMpe2Zvcig7dC0tOyl7Y29uc3QgdD1pLnNlcmlhbGl6ZVByaW1pdGl2ZXMuU1RSSU5HKGUpO2U9bi5iYXNlMTZFbmNvZGUobi5zaGEyNTYodCkpfXJldHVybiBlfX1dKX0pKTsiLCJpbXBvcnQgeyBfX2Fzc2lnbiwgX19hd2FpdGVyLCBfX2RlY29yYXRlLCBfX2dlbmVyYXRvciwgX19zcHJlYWRBcnJheXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IERFRkFVTFRfT1BUSU9OUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IG1ha2VDb25zb2xlLCBtYWtlT3B0aW9ucyB9IGZyb20gJ0B3YXZlcy9jbGllbnQtbG9ncyc7XG5pbXBvcnQgeyBmZXRjaEJhbGFuY2VEZXRhaWxzIH0gZnJvbSAnQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy9hcGktbm9kZS9hZGRyZXNzZXMnO1xuaW1wb3J0IHsgZmV0Y2hBc3NldHNCYWxhbmNlIH0gZnJvbSAnQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy9hcGktbm9kZS9hc3NldHMnO1xuaW1wb3J0IHdhaXQgZnJvbSAnQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy90b29scy90cmFuc2FjdGlvbnMvd2FpdCc7XG5pbXBvcnQgYnJvYWRjYXN0IGZyb20gJ0B3YXZlcy9ub2RlLWFwaS1qcy9janMvdG9vbHMvdHJhbnNhY3Rpb25zL2Jyb2FkY2FzdCc7XG5pbXBvcnQgZ2V0TmV0d29ya0J5dGUgZnJvbSAnQHdhdmVzL25vZGUtYXBpLWpzL2Nqcy90b29scy9ibG9ja3MvZ2V0TmV0d29ya0J5dGUnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fVFlQRSwgfSBmcm9tICdAd2F2ZXMvdHMtdHlwZXMnO1xuaW1wb3J0IHsgYXJnc1ZhbGlkYXRvcnMsIHZhbGlkYXRlU2lnbmVyT3B0aW9ucywgdmFsaWRhdGVQcm92aWRlckludGVyZmFjZSwgfSBmcm9tICcuL3ZhbGlkYXRpb24nO1xuaW1wb3J0IHsgRVJST1JTIH0gZnJvbSAnLi9TaWduZXJFcnJvcic7XG5pbXBvcnQgeyBlcnJvckhhbmRsZXJGYWN0b3J5IH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGVuc3VyZVByb3ZpZGVyLCBjaGVja0F1dGgsIGNhdGNoUHJvdmlkZXJFcnJvciB9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbnZhciBTaWduZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbmVyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2lzc3VlID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpc18xLl9jcmVhdGVQaXBlbGluZUFQSSh0eExpc3QsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLklTU1VFIH0pKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdGhpcy5fdHJhbnNmZXIgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzEuX2NyZWF0ZVBpcGVsaW5lQVBJKHR4TGlzdCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuVFJBTlNGRVIgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9yZWlzc3VlID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpc18xLl9jcmVhdGVQaXBlbGluZUFQSSh0eExpc3QsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLlJFSVNTVUUgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9idXJuID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpc18xLl9jcmVhdGVQaXBlbGluZUFQSSh0eExpc3QsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLkJVUk4gfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9sZWFzZSA9IGZ1bmN0aW9uICh0eExpc3QpIHsgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5fY3JlYXRlUGlwZWxpbmVBUEkodHhMaXN0LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgdHlwZTogVFJBTlNBQ1RJT05fVFlQRS5MRUFTRSB9KSk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHRoaXMuX2V4Y2hhbmdlID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpc18xLl9jcmVhdGVQaXBlbGluZUFQSSh0eExpc3QsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLkVYQ0hBTkdFIH0pKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdGhpcy5fY2FuY2VsTGVhc2UgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzEuX2NyZWF0ZVBpcGVsaW5lQVBJKHR4TGlzdCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuQ0FOQ0VMX0xFQVNFIH0pKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdGhpcy5fYWxpYXMgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzEuX2NyZWF0ZVBpcGVsaW5lQVBJKHR4TGlzdCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuQUxJQVMgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9tYXNzVHJhbnNmZXIgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzEuX2NyZWF0ZVBpcGVsaW5lQVBJKHR4TGlzdCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuTUFTU19UUkFOU0ZFUiB9KSk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHRoaXMuX2RhdGEgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzXzEuX2NyZWF0ZVBpcGVsaW5lQVBJKHR4TGlzdCwgX19hc3NpZ24oX19hc3NpZ24oe30sIGRhdGEpLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuREFUQSB9KSk7XG4gICAgICAgIH07IH07XG4gICAgICAgIHRoaXMuX3Nwb25zb3JzaGlwID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKHNwb25zb3JzaGlwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5fY3JlYXRlUGlwZWxpbmVBUEkodHhMaXN0LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3BvbnNvcnNoaXApLCB7IHR5cGU6IFRSQU5TQUNUSU9OX1RZUEUuU1BPTlNPUlNISVAgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9zZXRTY3JpcHQgPSBmdW5jdGlvbiAodHhMaXN0KSB7IHJldHVybiBmdW5jdGlvbiAoc2V0U2NyaXB0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5fY3JlYXRlUGlwZWxpbmVBUEkodHhMaXN0LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2V0U2NyaXB0KSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLlNFVF9TQ1JJUFQgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9zZXRBc3NldFNjcmlwdCA9IGZ1bmN0aW9uICh0eExpc3QpIHsgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5fY3JlYXRlUGlwZWxpbmVBUEkodHhMaXN0LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgdHlwZTogVFJBTlNBQ1RJT05fVFlQRS5TRVRfQVNTRVRfU0NSSVBUIH0pKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKHR4TGlzdCkgeyByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpc18xLl9jcmVhdGVQaXBlbGluZUFQSSh0eExpc3QsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyB0eXBlOiBUUkFOU0FDVElPTl9UWVBFLklOVk9LRV9TQ1JJUFQgfSkpO1xuICAgICAgICB9OyB9O1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSBtYWtlQ29uc29sZShtYWtlT3B0aW9ucygoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuTE9HX0xFVkVMKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAncHJvZHVjdGlvbicsICdTaWduZXInKSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVycm9yID0gZXJyb3JIYW5kbGVyRmFjdG9yeSh0aGlzLl9sb2dnZXIpO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIChvcHRpb25zIHx8IHt9KSk7XG4gICAgICAgIHZhciBfYiA9IHZhbGlkYXRlU2lnbmVyT3B0aW9ucyh0aGlzLl9vcHRpb25zKSwgaXNWYWxpZCA9IF9iLmlzVmFsaWQsIGludmFsaWRPcHRpb25zID0gX2IuaW52YWxpZE9wdGlvbnM7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gdGhpcy5faGFuZGxlRXJyb3IoRVJST1JTLlNJR05FUl9PUFRJT05TLCBbXG4gICAgICAgICAgICAgICAgaW52YWxpZE9wdGlvbnMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYWtlTmV0d29ya0J5dGVFcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBfdGhpc18xLl9oYW5kbGVFcnJvcihFUlJPUlMuTkVUV09SS19CWVRFLCBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBfdGhpc18xLl9vcHRpb25zLk5PREVfVVJMLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIF90aGlzXzEuX2xvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrQnl0ZVByb21pc2UgPSBnZXROZXR3b3JrQnl0ZSh0aGlzLl9vcHRpb25zLk5PREVfVVJMKS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZU5ldHdvcmtCeXRlRXJyb3IoZSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbWFrZU5ldHdvcmtCeXRlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oJ1NpZ25lciBpbnN0YW5jZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY3JlYXRlZC4gT3B0aW9uczogJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaWduZXIucHJvdG90eXBlLCBcIl9jb25uZWN0UHJvbWlzZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jb25uZWN0UHJvbWlzZSB8fCBQcm9taXNlLnJlamVjdCgnSGFzIG5vIHByb3ZpZGVyIScpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9fY29ubmVjdFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2lnbmVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlci5vbihldmVudCwgaGFuZGxlcik7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiSGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIgaGFzIGJlZW4gYWRkZWQuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlci5vbmNlKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJPbmUtVGltZSBoYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIiBoYXMgYmVlbiBhZGRlZC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvdmlkZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJIYW5kbGVyIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIiBoYXMgYmVlbiByZW1vdmVkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uICh0b0Jyb2FkY2FzdCwgb3B0aW9ucykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBicm9hZGNhc3QodGhpcy5fb3B0aW9ucy5OT0RFX1VSTCwgdG9Ccm9hZGNhc3QsIG9wdGlvbnMpOyAvLyBUT0RPINC/0L7Qv9GA0LDQstC40YLRjCDRgtC40L8g0LIgYnJvYWRjYXN0XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDQl9Cw0L/RgNC+0YHQuNGC0Ywg0LHQsNC50YIg0YHQtdGC0LhcbiAgICAgKi9cbiAgICBTaWduZXIucHJvdG90eXBlLmdldE5ldHdvcmtCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29ya0J5dGVQcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0L/RgNC+0LLQsNC50LTQtdGAINC+0YLQstC10YfQsNGO0YnQuNC5INC30LAg0L/QvtC00L/QuNGB0YxcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IFNpZ25lciBmcm9tICdAd2F2ZXMvc2lnbmVyJztcbiAgICAgKiBpbXBvcnQgUHJvdmlkZXIgZnJvbSAnQHdhdmVzL3NlZWQtcHJvdmlkZXInO1xuICAgICAqXG4gICAgICogY29uc3Qgd2F2ZXMgPSBuZXcgU2lnbmVyKCk7XG4gICAgICogd2F2ZXMuc2V0UHJvdmlkZXIobmV3IFByb3ZpZGVyKCdTRUVEJykpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFNpZ25lci5wcm90b3R5cGUuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyVmFsaWRhdGlvbiwgZXJyb3I7XG4gICAgICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJWYWxpZGF0aW9uID0gdmFsaWRhdGVQcm92aWRlckludGVyZmFjZShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlclZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yKEVSUk9SUy5QUk9WSURFUl9JTlRFUkZBQ0UsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyVmFsaWRhdGlvbi5pbnZhbGlkUHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKCdQcm92aWRlciBoYXMgYmVlbiBzZXQuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdFByb21pc2UgPSB0aGlzLl9uZXR3b3JrQnl0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25uZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5FVFdPUktfQllURTogYnl0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE5PREVfVVJMOiBfdGhpc18xLl9vcHRpb25zLk5PREVfVVJMLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5fbG9nZ2VyLmluZm8oJ1Byb3ZpZGVyIGhhcyBjb25uZWNlZCB0byBub2RlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBfdGhpc18xLl9oYW5kbGVFcnJvcihFUlJPUlMuUFJPVklERVJfQ09OTkVDVCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogX3RoaXNfMS5fb3B0aW9ucy5OT0RFX1VSTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl9sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog0J/QvtC70YPRh9Cw0LXQvCDRgdC/0LjRgdC+0Log0LHQsNC70LDQvdGB0L7QsiDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y8gKNC90LXQvtCx0YXQvtC00LjQvNC+INCy0YvQv9C+0LvQvdC40YLRjCBsb2dpbiDQv9C10YDQtdC0INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC10LwpXG4gICAgICogQmFzaWMgdXNhZ2UgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgd2F2ZXMuZ2V0QmFsYW5jZSgpOyAvLyDQktC+0LfQstGA0LDRidCw0LXRgiDQsdCw0LvQsNC90YHRiyDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBTaWduZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGZldGNoQmFsYW5jZURldGFpbHModGhpcy5fb3B0aW9ucy5OT0RFX1VSTCwgdGhpcy5fdXNlckRhdGEuYWRkcmVzcykudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBhc3NldElkOiAnV0FWRVMnLFxuICAgICAgICAgICAgICAgIGFzc2V0TmFtZTogJ1dhdmVzJyxcbiAgICAgICAgICAgICAgICBkZWNpbWFsczogOCxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IFN0cmluZyhkYXRhLmF2YWlsYWJsZSksXG4gICAgICAgICAgICAgICAgaXNNeUFzc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IE51bWJlcihkYXRhLmF2YWlsYWJsZSkgKiBNYXRoLnBvdygxMCwgOCksXG4gICAgICAgICAgICAgICAgc3BvbnNvcnNoaXA6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNTbWFydDogZmFsc2UsXG4gICAgICAgICAgICB9KTsgfSksXG4gICAgICAgICAgICBmZXRjaEFzc2V0c0JhbGFuY2UodGhpcy5fb3B0aW9ucy5OT0RFX1VSTCwgdGhpcy5fdXNlckRhdGEuYWRkcmVzcykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmJhbGFuY2VzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXRJZDogaXRlbS5hc3NldElkLFxuICAgICAgICAgICAgICAgICAgICBhc3NldE5hbWU6IGl0ZW0uaXNzdWVUcmFuc2FjdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogaXRlbS5pc3N1ZVRyYW5zYWN0aW9uLmRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IFN0cmluZyhpdGVtLmJhbGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBpc015QXNzZXQ6IGl0ZW0uaXNzdWVUcmFuc2FjdGlvbi5zZW5kZXIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc18xLl91c2VyRGF0YS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IGl0ZW0uYmFsYW5jZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdygxMCwgaXRlbS5pc3N1ZVRyYW5zYWN0aW9uLmRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTbWFydDogISFpdGVtLmlzc3VlVHJhbnNhY3Rpb24uc2NyaXB0LFxuICAgICAgICAgICAgICAgICAgICBzcG9uc29yc2hpcDogaXRlbS5zcG9uc29yQmFsYW5jZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnNwb25zb3JCYWxhbmNlID4gTWF0aC5wb3coMTAsIDgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbS5taW5TcG9uc29yZWRBc3NldEZlZSB8fCAwKSA8IGl0ZW0uYmFsYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpdGVtLm1pblNwb25zb3JlZEFzc2V0RmVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgd2F2ZXMgPSBfYVswXSwgYXNzZXRzID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheXMoW3dhdmVzXSwgYXNzZXRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDQn9C+0LvRg9GH0LDQtdC8INC40L3RhNC+0YDQvNCw0YbQuNGOINC+INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvQtVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCB3YXZlcy5sb2dpbigpOyAvLyDQkNCy0YLQvtGA0LjQt9GD0LXQvNGB0Y8uINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINCw0LTRgNC10YEg0Lgg0L/Rg9Cx0LvQuNGH0L3Ri9C5INC60LvRjtGHXG4gICAgICogYGBgXG4gICAgICovXG4gICAgU2lnbmVyLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBlcnJfMSwgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2Nvbm5lY3RQcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzIsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jdXJyZW50UHJvdmlkZXIubG9naW4oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLl91c2VyRGF0YSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKCdMb2dnZWQgaW4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fdXNlckRhdGFdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJfMSA9PT0gJ0Vycm9yOiBVc2VyIHJlamVjdGlvbiEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yKEVSUk9SUy5QUk9WSURFUl9JTlRFUk5BTCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDQktGL0LvQvtCz0LjQvdC40LLQsNC10LzRgdGPINC40Lcg0Y7Qt9C10YDQsFxuICAgICAqL1xuICAgIFNpZ25lci5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIG1lc3NhZ2UsIGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9jb25uZWN0UHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuY3VycmVudFByb3ZpZGVyLmxvZ291dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbygnTG9nZ2VkIG91dC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSB0aGlzLl9oYW5kbGVFcnJvcihFUlJPUlMuUFJPVklERVJfSU5URVJOQUwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqINCf0L7QtNC/0LjRgdGL0LLQsNC10Lwg0YHQvtC+0LHRidC10L3QuNC1INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyAo0L/RgNC+0LLQsNC50LTQtdGAINC80L7QttC10YIg0YPRgdGC0LDQvdCw0LLQu9C40LLQsNGC0Ywg0L/RgNC10YTQuNC60YEpXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog0J/QvtC00L/QuNGB0YvQstCw0LXQvCDRgtC40L/QuNC30LjRgNC+0LLQsNC90L3Ri9C1INC00LDQvdC90YvQtVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgU2lnbmVyLnByb3RvdHlwZS5zaWduVHlwZWREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2lnblR5cGVkRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDQn9C+0LvRg9GH0LDQtdC8INGB0L/QuNGB0L7QuiDQsdCw0LvQsNC90YHQvtCyINCyINC60YLQvtGA0YvRhSDQvNC+0LbQvdC+INC/0LvQsNGC0LjRgtGMINC60L7QvNC40YHRgdC40Y5cbiAgICAgKi9cbiAgICBTaWduZXIucHJvdG90eXBlLmdldFNwb25zb3JlZEJhbGFuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCYWxhbmNlKCkudGhlbihmdW5jdGlvbiAoYmFsYW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2UuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhIWl0ZW0uc3BvbnNvcnNoaXA7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuYmF0Y2ggPSBmdW5jdGlvbiAodHN4KSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgdmFyIHNpZ24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5fc2lnbih0c3gpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0OyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ246IHNpZ24sXG4gICAgICAgICAgICBicm9hZGNhc3Q6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbigpLnRoZW4oZnVuY3Rpb24gKHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNfMS5icm9hZGNhc3QodHJhbnNhY3Rpb25zLCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuaXNzdWUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNzdWUoW10pKGRhdGEpO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS50cmFuc2ZlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2ZlcihbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLnJlaXNzdWUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVpc3N1ZShbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmJ1cm4gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVybihbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmxlYXNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYXNlKFtdKShkYXRhKTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuZXhjaGFuZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2UoW10pKGRhdGEpO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS5jYW5jZWxMZWFzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxMZWFzZShbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWFzKFtdKShkYXRhKTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUubWFzc1RyYW5zZmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc3NUcmFuc2ZlcihbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YShbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLnNwb25zb3JzaGlwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nwb25zb3JzaGlwKFtdKShkYXRhKTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuc2V0U2NyaXB0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLnNldEFzc2V0U2NyaXB0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldEFzc2V0U2NyaXB0KFtdKShkYXRhKTtcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShbXSkoZGF0YSk7XG4gICAgfTtcbiAgICBTaWduZXIucHJvdG90eXBlLndhaXRUeENvbmZpcm0gPSBmdW5jdGlvbiAodHgsIGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHdhaXQodGhpcy5fb3B0aW9ucy5OT0RFX1VSTCwgdHgsIHsgY29uZmlybWF0aW9uczogY29uZmlybWF0aW9ucyB9KTsgLy8gVE9ETyBGaXggdHlwZXNcbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuX2NyZWF0ZVBpcGVsaW5lQVBJID0gZnVuY3Rpb24gKHByZXZDYWxsVHhMaXN0LCBzaWduZXJUeCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0eHMgPSBwcmV2Q2FsbFR4TGlzdC5sZW5ndGhcbiAgICAgICAgICAgID8gX19zcHJlYWRBcnJheXMocHJldkNhbGxUeExpc3QsIFtzaWduZXJUeF0pIDogW3NpZ25lclR4XTtcbiAgICAgICAgdmFyIGNoYWluQXJncyA9IEFycmF5LmlzQXJyYXkodHhzKSA/IHR4cyA6IFt0eHNdO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIGlzc3VlOiB0aGlzLl9pc3N1ZShjaGFpbkFyZ3MpLFxuICAgICAgICAgICAgdHJhbnNmZXI6IHRoaXMuX3RyYW5zZmVyKGNoYWluQXJncyksXG4gICAgICAgICAgICByZWlzc3VlOiB0aGlzLl9yZWlzc3VlKGNoYWluQXJncyksXG4gICAgICAgICAgICBidXJuOiB0aGlzLl9idXJuKGNoYWluQXJncyksXG4gICAgICAgICAgICBsZWFzZTogdGhpcy5fbGVhc2UoY2hhaW5BcmdzKSxcbiAgICAgICAgICAgIGV4Y2hhbmdlOiB0aGlzLl9leGNoYW5nZShjaGFpbkFyZ3MpLFxuICAgICAgICAgICAgY2FuY2VsTGVhc2U6IHRoaXMuX2NhbmNlbExlYXNlKGNoYWluQXJncyksXG4gICAgICAgICAgICBhbGlhczogdGhpcy5fYWxpYXMoY2hhaW5BcmdzKSxcbiAgICAgICAgICAgIG1hc3NUcmFuc2ZlcjogdGhpcy5fbWFzc1RyYW5zZmVyKGNoYWluQXJncyksXG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9kYXRhKGNoYWluQXJncyksXG4gICAgICAgICAgICBzcG9uc29yc2hpcDogdGhpcy5fc3BvbnNvcnNoaXAoY2hhaW5BcmdzKSxcbiAgICAgICAgICAgIHNldFNjcmlwdDogdGhpcy5fc2V0U2NyaXB0KGNoYWluQXJncyksXG4gICAgICAgICAgICBzZXRBc3NldFNjcmlwdDogdGhpcy5fc2V0QXNzZXRTY3JpcHQoY2hhaW5BcmdzKSxcbiAgICAgICAgICAgIGludm9rZTogdGhpcy5faW52b2tlKGNoYWluQXJncyksXG4gICAgICAgIH0pLCB7IHNpZ246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzXzEuX3NpZ24odHhzKTsgfSwgYnJvYWRjYXN0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IF90aGlzLmN1cnJlbnRQcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzU2lnbkFuZEJyb2FkY2FzdEJ5UHJvdmlkZXIpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jdXJyZW50UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zaWduKHR4cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eHMpIHsgcmV0dXJuIF90aGlzLmJyb2FkY2FzdCh0eHMsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IH0pO1xuICAgIH07XG4gICAgU2lnbmVyLnByb3RvdHlwZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiAodG9TaWduKSB7XG4gICAgICAgIHZhciBzaWduZXJUeHMgPSBBcnJheS5pc0FycmF5KHRvU2lnbikgPyB0b1NpZ24gOiBbdG9TaWduXTtcbiAgICAgICAgdmFyIHZhbGlkYXRlVHggPSBmdW5jdGlvbiAodHgpIHsgcmV0dXJuIGFyZ3NWYWxpZGF0b3JzW3R4LnR5cGVdKHR4KTsgfTtcbiAgICAgICAgdmFyIGtub3duVHhQcmVkaWNhdGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFyZ3NWYWxpZGF0b3JzKS5pbmNsdWRlcyhTdHJpbmcodHlwZSkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5rbm93blR4cyA9IHNpZ25lclR4cy5maWx0ZXIoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGU7XG4gICAgICAgICAgICByZXR1cm4gIWtub3duVHhQcmVkaWNhdGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIga25vd25UeHMgPSBzaWduZXJUeHMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGtub3duVHhQcmVkaWNhdGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW52YWxpZFR4cyA9IGtub3duVHhzXG4gICAgICAgICAgICAubWFwKHZhbGlkYXRlVHgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBfYS5pc1ZhbGlkO1xuICAgICAgICAgICAgcmV0dXJuICFpc1ZhbGlkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRUeHMubGVuZ3RoID09PSAwICYmIHVua25vd25UeHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yczogX19zcHJlYWRBcnJheXMoaW52YWxpZFR4cy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IF9hLnRyYW5zYWN0aW9uLCBzY29wZSA9IF9hLm1ldGhvZCwgaW52YWxpZEZpZWxkcyA9IF9hLmludmFsaWRGaWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZhbGlkYXRpb24gZXJyb3IgZm9yIFwiICsgc2NvcGUgKyBcIiB0cmFuc2FjdGlvbjogXCIgKyBKU09OLnN0cmluZ2lmeSh0cmFuc2FjdGlvbikgKyBcIi4gSW52YWxpZCBhcmd1bWVudHM6IFwiICsgKGludmFsaWRGaWVsZHMgPT09IG51bGwgfHwgaW52YWxpZEZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW52YWxpZEZpZWxkcy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICB9KSwgdW5rbm93blR4cy5tYXAoZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlZhbGlkYXRpb24gZXJyb3IgZm9yIHRyYW5zYWN0aW9uIFwiICsgSlNPTi5zdHJpbmdpZnkodHgpICsgXCIuIFVua25vd24gdHJhbnNhY3Rpb24gdHlwZTogXCIgKyB0eC50eXBlO1xuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpZ25lci5wcm90b3R5cGUuX3NpZ24gPSBmdW5jdGlvbiAodG9TaWduKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0ZSh0b1NpZ24pO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuY3VycmVudFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNTaWduQW5kQnJvYWRjYXN0QnlQcm92aWRlcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yKEVSUk9SUy5QUk9WSURFUl9TSUdOX05PVF9TVVBQT1JURUQsIFt7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAnUFJPVklERVJfU0lHTl9OT1RfU1VQUE9SVEVEJyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGhpcy5fb3B0aW9ucy5OT0RFX1VSTCxcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdFByb21pc2UudGhlbihmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnNpZ24odG9TaWduKTsgfVxuICAgICAgICAgICAgLy8gYW55IGZpeGVzIFwiRXhwcmVzc2lvbiBwcm9kdWNlcyBhIHVuaW9uIHR5cGUgdGhhdCBpcyB0b28gY29tcGxleCB0b1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yKEVSUk9SUy5BUElfQVJHVU1FTlRTLCBbXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbi5lcnJvcnMsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZW5zdXJlUHJvdmlkZXJcbiAgICBdLCBTaWduZXIucHJvdG90eXBlLCBcIm9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBlbnN1cmVQcm92aWRlclxuICAgIF0sIFNpZ25lci5wcm90b3R5cGUsIFwib25jZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZW5zdXJlUHJvdmlkZXJcbiAgICBdLCBTaWduZXIucHJvdG90eXBlLCBcIm9mZlwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZW5zdXJlUHJvdmlkZXIsXG4gICAgICAgIGNoZWNrQXV0aFxuICAgIF0sIFNpZ25lci5wcm90b3R5cGUsIFwiZ2V0QmFsYW5jZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZW5zdXJlUHJvdmlkZXJcbiAgICBdLCBTaWduZXIucHJvdG90eXBlLCBcImxvZ2luXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBlbnN1cmVQcm92aWRlclxuICAgIF0sIFNpZ25lci5wcm90b3R5cGUsIFwibG9nb3V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBlbnN1cmVQcm92aWRlclxuICAgIF0sIFNpZ25lci5wcm90b3R5cGUsIFwic2lnbk1lc3NhZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGVuc3VyZVByb3ZpZGVyXG4gICAgXSwgU2lnbmVyLnByb3RvdHlwZSwgXCJzaWduVHlwZWREYXRhXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBjYXRjaFByb3ZpZGVyRXJyb3JcbiAgICBdLCBTaWduZXIucHJvdG90eXBlLCBcIl9zaWduXCIsIG51bGwpO1xuICAgIHJldHVybiBTaWduZXI7XG59KCkpO1xuZXhwb3J0IHsgU2lnbmVyIH07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWRlZmF1bHQtZXhwb3J0XG5leHBvcnQgZGVmYXVsdCBTaWduZXI7XG4iLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbnZhciBSRVBPU0lUT1JZX1VSTCA9ICdodHRwOi8vZ2l0aHViLmNvbS93YXZlc3BsYXRmb3JtL3NpZ25lcic7XG5leHBvcnQgdmFyIEVSUk9SUyA9IHtcbiAgICBTSUdORVJfT1BUSU9OUzogMTAwMCxcbiAgICBORVRXT1JLX0JZVEU6IDEwMDEsXG4gICAgTk9UX0FVVEhPUklaRUQ6IDEwMDIsXG4gICAgUFJPVklERVJfQ09OTkVDVDogMTAwMyxcbiAgICBFTlNVUkVfUFJPVklERVI6IDEwMDQsXG4gICAgUFJPVklERVJfSU5URVJGQUNFOiAxMDA1LFxuICAgIFBST1ZJREVSX0lOVEVSTkFMOiAxMDA2LFxuICAgIEFQSV9BUkdVTUVOVFM6IDEwMDcsXG4gICAgTkVUV09SS19FUlJPUjogMTAwOCxcbiAgICBQUk9WSURFUl9TSUdOX05PVF9TVVBQT1JURUQ6IDEwMDksXG59O1xudmFyIGVycm9yVGVtcGxhdGUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgZGV0YWlscyA9IGVycm9yLmRldGFpbHMgPyBcIiAgICBEZXRhaWxzOiBcIiArIGVycm9yLmRldGFpbHMgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9yQXJncyA9IGVycm9yLmVycm9yQXJnc1xuICAgICAgICA/IFwiICAgIEVycm9yQXJnczogXCIgKyBlcnJvci5lcnJvckFyZ3NcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgXCJTaWduZXIgZXJyb3I6XCIsXG4gICAgICAgIFwiICAgIFRpdGxlOiBcIiArIGVycm9yLnRpdGxlLFxuICAgICAgICBcIiAgICBUeXBlOiBcIiArIGVycm9yLnR5cGUsXG4gICAgICAgIFwiICAgIENvZGU6IFwiICsgZXJyb3IuY29kZSxcbiAgICAgICAgZXJyb3JBcmdzLFxuICAgICAgICBkZXRhaWxzLFxuICAgICAgICBcIiAgICBNb3JlIGluZm86IFwiICsgUkVQT1NJVE9SWV9VUkwgKyBcIi9SRUFETUUubWQjZXJyb3ItY29kZXNcIixcbiAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufTtcbnZhciBTaWduZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmVyRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmVyRXJyb3IoZGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvclRlbXBsYXRlKGRldGFpbHMpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb2RlID0gZGV0YWlscy5jb2RlO1xuICAgICAgICBfdGhpcy50eXBlID0gZGV0YWlscy50eXBlO1xuICAgICAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25lckVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25lckVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0IHsgU2lnbmVyRXJyb3IgfTtcbnZhciBTaWduZXJPcHRpb25zRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25lck9wdGlvbnNFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduZXJPcHRpb25zRXJyb3IoYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjb2RlOiBFUlJPUlMuU0lHTkVSX09QVElPTlMsXG4gICAgICAgICAgICB0aXRsZTogJ0ludmFsaWQgc2lnbmVyIG9wdGlvbnMnLFxuICAgICAgICAgICAgdHlwZTogJ3ZhbGlkYXRpb24nLFxuICAgICAgICAgICAgZGV0YWlsczogXCJcXG4gICAgICAgIEludmFsaWQgc2lnbmVyIG9wdGlvbnM6IFwiICsgYXJncy5qb2luKCcsICcpLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiBhcmdzLFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25lck9wdGlvbnNFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduZXJPcHRpb25zRXJyb3I7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJPcHRpb25zRXJyb3IgfTtcbnZhciBTaWduZXJBcGlBcmd1bWVudHNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmVyQXBpQXJndW1lbnRzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmVyQXBpQXJndW1lbnRzRXJyb3IoYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjb2RlOiBFUlJPUlMuQVBJX0FSR1VNRU5UUyxcbiAgICAgICAgICAgIHRpdGxlOiAnSW52YWxpZCBhcGkgbWV0aG9kIGFyZ3VtZW50cycsXG4gICAgICAgICAgICB0eXBlOiAndmFsaWRhdGlvbicsXG4gICAgICAgICAgICBkZXRhaWxzOiBcIlxcbiAgICAgICAgXCIgKyBhcmdzLmpvaW4oJ1xcbiAgICAgICAgJyksXG4gICAgICAgICAgICBlcnJvckFyZ3M6IGFyZ3MsXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmVyQXBpQXJndW1lbnRzRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmVyQXBpQXJndW1lbnRzRXJyb3I7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJBcGlBcmd1bWVudHNFcnJvciB9O1xudmFyIFNpZ25lck5ldHdvcmtCeXRlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25lck5ldHdvcmtCeXRlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2lnbmVyTmV0d29ya0J5dGVFcnJvcihfYSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBfYS5lcnJvciwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IEVSUk9SUy5ORVRXT1JLX0JZVEUsXG4gICAgICAgICAgICB0aXRsZTogJ05ldHdvcmsgYnl0ZSBmZXRjaGluZyBoYXMgZmFpbGVkJyxcbiAgICAgICAgICAgIHR5cGU6ICduZXR3b3JrJyxcbiAgICAgICAgICAgIGRldGFpbHM6IFwiXFxuICAgICAgICBDb3VsZCBub3QgZmV0Y2ggbmV0d29yayBmcm9tIFwiICsgbm9kZSArIFwiOiBcIiArIGVycm9yLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiB7IGVycm9yOiBlcnJvciwgbm9kZTogbm9kZSB9LFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25lck5ldHdvcmtCeXRlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmVyTmV0d29ya0J5dGVFcnJvcjtcbn0oU2lnbmVyRXJyb3IpKTtcbmV4cG9ydCB7IFNpZ25lck5ldHdvcmtCeXRlRXJyb3IgfTtcbnZhciBTaWduZXJQcm92aWRlckludGVyZmFjZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduZXJQcm92aWRlckludGVyZmFjZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25lclByb3ZpZGVySW50ZXJmYWNlRXJyb3IoaW52YWxpZFByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY29kZTogRVJST1JTLk5FVFdPUktfQllURSxcbiAgICAgICAgICAgIHRpdGxlOiAnSW52YWxpZCBQcm92aWRlciBpbnRlcmZhY2UnLFxuICAgICAgICAgICAgdHlwZTogJ3ZhbGlkYXRpb24nLFxuICAgICAgICAgICAgZGV0YWlsczogXCJcXG4gICAgICAgIEludmFsaWQgcHJvdmlkZXIgcHJvcGVydGllczogXCIgKyBpbnZhbGlkUHJvcGVydGllcy5qb2luKCcsICcpLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiBpbnZhbGlkUHJvcGVydGllcyxcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBTaWduZXJQcm92aWRlckludGVyZmFjZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25lclByb3ZpZGVySW50ZXJmYWNlRXJyb3I7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJQcm92aWRlckludGVyZmFjZUVycm9yIH07XG52YXIgU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25lclByb3ZpZGVyQ29ubmVjdEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25lclByb3ZpZGVyQ29ubmVjdEVycm9yKF9hKSB7XG4gICAgICAgIHZhciBlcnJvciA9IF9hLmVycm9yLCBub2RlID0gX2Eubm9kZTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY29kZTogRVJST1JTLlBST1ZJREVSX0NPTk5FQ1QsXG4gICAgICAgICAgICB0aXRsZTogJ0NvdWxkIG5vdCBjb25uZWN0IHRoZSBQcm92aWRlcicsXG4gICAgICAgICAgICB0eXBlOiAnbmV0d29yaycsXG4gICAgICAgICAgICBlcnJvckFyZ3M6IHsgZXJyb3I6IGVycm9yLCBub2RlOiBub2RlIH0sXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3I7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJQcm92aWRlckNvbm5lY3RFcnJvciB9O1xudmFyIFNpZ25lclByb3ZpZGVyU2lnbklzTm90U3VwcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmVyUHJvdmlkZXJTaWduSXNOb3RTdXBwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25lclByb3ZpZGVyU2lnbklzTm90U3VwcG9ydChfYSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBfYS5lcnJvciwgbm9kZSA9IF9hLm5vZGU7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IEVSUk9SUy5QUk9WSURFUl9TSUdOX05PVF9TVVBQT1JURUQsXG4gICAgICAgICAgICB0aXRsZTogJ01ldGhvZCBzaWduIGlzIG5vdCBzdXBwb3J0IGZvciB0aGlzIHByb3ZpZGVyLiBVc2UgYnJvYWRjYXRzIGluc3RlYWQnLFxuICAgICAgICAgICAgdHlwZTogJ3ZhbGlkYXRpb24nLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiB7IGVycm9yOiBlcnJvciwgbm9kZTogbm9kZSB9LFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25lclByb3ZpZGVyU2lnbklzTm90U3VwcG9ydC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduZXJQcm92aWRlclNpZ25Jc05vdFN1cHBvcnQ7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJQcm92aWRlclNpZ25Jc05vdFN1cHBvcnQgfTtcbnZhciBTaWduZXJFbnN1cmVQcm92aWRlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaWduZXJFbnN1cmVQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ25lckVuc3VyZVByb3ZpZGVyRXJyb3IobWV0aG9kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IEVSUk9SUy5FTlNVUkVfUFJPVklERVIsXG4gICAgICAgICAgICB0aXRsZTogJ1Byb3ZpZGVyIGluc3RhbmNlIGlzIG1pc3NpbmcnLFxuICAgICAgICAgICAgdHlwZTogJ3Byb3ZpZGVyJyxcbiAgICAgICAgICAgIGRldGFpbHM6IFwiQ2FuJ3QgdXNlIG1ldGhvZDogXCIgKyBtZXRob2QgKyBcIi4gUHJvdmlkZXIgaW5zdGFuY2UgaXMgbWlzc2luZ1wiLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiB7IGZhaWxlZE1ldGhvZDogbWV0aG9kIH0sXG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2lnbmVyRW5zdXJlUHJvdmlkZXJFcnJvcjtcbn0oU2lnbmVyRXJyb3IpKTtcbmV4cG9ydCB7IFNpZ25lckVuc3VyZVByb3ZpZGVyRXJyb3IgfTtcbnZhciBTaWduZXJQcm92aWRlckludGVybmFsRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25lclByb3ZpZGVySW50ZXJuYWxFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduZXJQcm92aWRlckludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjb2RlOiBFUlJPUlMuRU5TVVJFX1BST1ZJREVSLFxuICAgICAgICAgICAgdGl0bGU6ICdQcm92aWRlciBpbnRlcm5hbCBlcnJvcicsXG4gICAgICAgICAgICB0eXBlOiAncHJvdmlkZXInLFxuICAgICAgICAgICAgZGV0YWlsczogXCJQcm92aWRlciBpbnRlcm5hbCBlcnJvcjogXCIgKyBtZXNzYWdlICsgXCIuIFRoaXMgaXMgbm90IGVycm9yIG9mIHNpZ25lci5cIixcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBTaWduZXJQcm92aWRlckNvbm5lY3RFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWduZXJQcm92aWRlckludGVybmFsRXJyb3I7XG59KFNpZ25lckVycm9yKSk7XG5leHBvcnQgeyBTaWduZXJQcm92aWRlckludGVybmFsRXJyb3IgfTtcbnZhciBTaWduZXJBdXRoRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ25lckF1dGhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWduZXJBdXRoRXJyb3IobWV0aG9kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IEVSUk9SUy5OT1RfQVVUSE9SSVpFRCxcbiAgICAgICAgICAgIHRpdGxlOiAnQXV0aG9yaXphdGlvbiBlcnJvcicsXG4gICAgICAgICAgICB0eXBlOiAnYXV0aG9yaXphdGlvbicsXG4gICAgICAgICAgICBkZXRhaWxzOiBcIkNhbid0IHVzZSBtZXRob2Q6IFwiICsgbWV0aG9kICsgXCIuIFVzZXIgbXVzdCBiZSBsb2dnZWQgaW5cIixcbiAgICAgICAgICAgIGVycm9yQXJnczogeyBmYWlsZWRNZXRob2Q6IG1ldGhvZCB9LFxuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIFNpZ25lclByb3ZpZGVyQ29ubmVjdEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25lckF1dGhFcnJvcjtcbn0oU2lnbmVyRXJyb3IpKTtcbmV4cG9ydCB7IFNpZ25lckF1dGhFcnJvciB9O1xudmFyIFNpZ25lck5ldHdvcmtFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbmVyTmV0d29ya0Vycm9yLCBfc3VwZXIpO1xuICAgIC8vIFRPRE8gUkVNT1ZFIEFOWSwgQUREIE1PUkUgREVUQUlMU1xuICAgIGZ1bmN0aW9uIFNpZ25lck5ldHdvcmtFcnJvcihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IEVSUk9SUy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgdGl0bGU6ICdOZXR3b3JrIEVycm9yJyxcbiAgICAgICAgICAgIHR5cGU6ICduZXR3b3JrJyxcbiAgICAgICAgICAgIGRldGFpbHM6IFwiRXJyb3IgY29ubmVjdCB0byBcIiArICcnLFxuICAgICAgICAgICAgZXJyb3JBcmdzOiB7fSxcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNpZ25lck5ldHdvcmtFcnJvcjtcbn0oU2lnbmVyRXJyb3IpKTtcbmV4cG9ydCB7IFNpZ25lck5ldHdvcmtFcnJvciB9O1xuIiwiZXhwb3J0IHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgTk9ERV9VUkw6ICdodHRwczovL25vZGVzLndhdmVzcGxhdGZvcm0uY29tJyxcbiAgICBMT0dfTEVWRUw6ICdwcm9kdWN0aW9uJyxcbn07XG5leHBvcnQgdmFyIERFRkFVTFRfQlJPQURDQVNUX09QVElPTlMgPSB7XG4gICAgY2hhaW46IGZhbHNlLFxuICAgIGNvbmZpcm1hdGlvbnM6IC0xLFxufTtcbmV4cG9ydCB2YXIgTUFYX0FMSUFTX0xFTkdUSCA9IDMwO1xuZXhwb3J0IHZhciBTTUFSVF9BU1NFVF9FWFRSQV9GRUUgPSAwLjAwNCAqIE1hdGgucG93KDEwLCA4KTtcbiIsImltcG9ydCB7IFNpZ25lckVycm9yLCBFUlJPUlMgfSBmcm9tICcuL1NpZ25lckVycm9yJztcbnZhciBnZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoc2lnbmVyKSB7XG4gICAgcmV0dXJuIHNpZ25lci5faGFuZGxlRXJyb3I7XG59O1xuZXhwb3J0IHZhciBlbnN1cmVQcm92aWRlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIG9yaWdpbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLmN1cnJlbnRQcm92aWRlcjtcbiAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXIodGhpcyk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBoYW5kbGVyKEVSUk9SUy5FTlNVUkVfUFJPVklERVIsIFtwcm9wZXJ0eUtleV0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgY2F0Y2hQcm92aWRlckVycm9yID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICB2YXIgb3JpZ2luID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4uYXBwbHkodGhpcywgYXJncykuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlID09PSAnRXJyb3I6IFVzZXIgcmVqZWN0aW9uIScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNpZ25lckVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXIoX3RoaXMpO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gaGFuZGxlcihFUlJPUlMuUFJPVklERVJfSU5URVJOQUwsIFtlLm1lc3NhZ2VdKTtcbiAgICAgICAgICAgIF90aGlzLl9jb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5leHBvcnQgdmFyIGNoZWNrQXV0aCA9IGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIG9yaWdpbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvdmlkZXIudXNlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGdldEVycm9ySGFuZGxlcih0aGlzKTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGhhbmRsZXIoRVJST1JTLk5PVF9BVVRIT1JJWkVELCBbcHJvcGVydHlLZXldKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbn07XG5leHBvcnQgdmFyIGNhdGNoTmV0d29ya0Vycm9ycyA9IGZ1bmN0aW9uIChjaGVja0RhdGEpIHsgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIG9yaWdpbiA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tEYXRhLmlzTWF0Y2hlcikge1xuICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgLy8gaWYgKCF0aGlzLl9vcHRpb25zLk1BVENIRVJfVVJMKSB7XG4gICAgICAgICAgICAvLyAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2lnbmVyRXJyb3IoXG4gICAgICAgICAgICAvLyAgICAgICAgIEVSUk9SX0NPREVfTUFQLk5PX01BVENIRVJfVVJMX1BST1ZJREVELFxuICAgICAgICAgICAgLy8gICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgIC8vICAgICApO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICB0aGlzLl9jb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JpZ2luLmFwcGx5KHRoaXMsIGFyZ3MpLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNpZ25lckVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXIoX3RoaXMpO1xuICAgICAgICAgICAgLy8gVE9ETyBQcm92aWRlIG1vcmUgZGV0YWlscyBmb3IgcmVxdWVzdCBlcnJvciFcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGhhbmRsZXIoRVJST1JTLk5FVFdPUktfRVJST1IsIFt7fV0pO1xuICAgICAgICAgICAgX3RoaXMuX2NvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07IH07XG4iLCJ2YXIgX2E7XG5pbXBvcnQgeyBfX3NwcmVhZEFycmF5cyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgRVJST1JTLCBTaWduZXJBcGlBcmd1bWVudHNFcnJvciwgU2lnbmVyQXV0aEVycm9yLCBTaWduZXJFbnN1cmVQcm92aWRlckVycm9yLCBTaWduZXJOZXR3b3JrQnl0ZUVycm9yLCBTaWduZXJOZXR3b3JrRXJyb3IsIFNpZ25lck9wdGlvbnNFcnJvciwgU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3IsIFNpZ25lclByb3ZpZGVyU2lnbklzTm90U3VwcG9ydCwgU2lnbmVyUHJvdmlkZXJJbnRlcmZhY2VFcnJvciwgU2lnbmVyUHJvdmlkZXJJbnRlcm5hbEVycm9yLCB9IGZyb20gJy4vU2lnbmVyRXJyb3InO1xudmFyIEVSUk9SU19NQVAgPSAoX2EgPSB7fSxcbiAgICBfYVtFUlJPUlMuU0lHTkVSX09QVElPTlNdID0gU2lnbmVyT3B0aW9uc0Vycm9yLFxuICAgIF9hW0VSUk9SUy5ORVRXT1JLX0JZVEVdID0gU2lnbmVyTmV0d29ya0J5dGVFcnJvcixcbiAgICBfYVtFUlJPUlMuUFJPVklERVJfSU5URVJGQUNFXSA9IFNpZ25lclByb3ZpZGVySW50ZXJmYWNlRXJyb3IsXG4gICAgX2FbRVJST1JTLkFQSV9BUkdVTUVOVFNdID0gU2lnbmVyQXBpQXJndW1lbnRzRXJyb3IsXG4gICAgX2FbRVJST1JTLlBST1ZJREVSX0NPTk5FQ1RdID0gU2lnbmVyUHJvdmlkZXJDb25uZWN0RXJyb3IsXG4gICAgX2FbRVJST1JTLlBST1ZJREVSX1NJR05fTk9UX1NVUFBPUlRFRF0gPSBTaWduZXJQcm92aWRlclNpZ25Jc05vdFN1cHBvcnQsXG4gICAgX2FbRVJST1JTLkVOU1VSRV9QUk9WSURFUl0gPSBTaWduZXJFbnN1cmVQcm92aWRlckVycm9yLFxuICAgIF9hW0VSUk9SUy5QUk9WSURFUl9JTlRFUk5BTF0gPSBTaWduZXJQcm92aWRlckludGVybmFsRXJyb3IsXG4gICAgX2FbRVJST1JTLk5PVF9BVVRIT1JJWkVEXSA9IFNpZ25lckF1dGhFcnJvcixcbiAgICBfYVtFUlJPUlMuTkVUV09SS19FUlJPUl0gPSBTaWduZXJOZXR3b3JrRXJyb3IsXG4gICAgX2EpO1xuZXhwb3J0IHZhciBlcnJvckhhbmRsZXJGYWN0b3J5ID0gZnVuY3Rpb24gKGxvZ2dlcikgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGFyYW1ldGVycykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZXJyb3IgPSBuZXcgKChfYSA9IEVSUk9SU19NQVBbZXJyb3JDb2RlXSkuYmluZC5hcHBseShfYSwgX19zcHJlYWRBcnJheXMoW3ZvaWQgMF0sIChwYXJhbWV0ZXJzIHx8IFtdKSkpKSgpO1xuICAgIGxvZ2dlci5sb2coZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgdGhyb3cgZXJyb3I7XG59OyB9O1xuIiwiZXhwb3J0ICogZnJvbSAnLi90eXBlcy9hcGknO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL1NpZ25lcic7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzL2FwaSc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzL2luZGV4JztcbiIsInZhciBfYTtcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgZGVmYXVsdFRvIGZyb20gJ3JhbWRhL3NyYy9kZWZhdWx0VG8nO1xuaW1wb3J0IHByb3AgZnJvbSAncmFtZGEvc3JjL3Byb3AnO1xuaW1wb3J0IGlmRWxzZSBmcm9tICdyYW1kYS9zcmMvaWZFbHNlJztcbmltcG9ydCBwaXBlIGZyb20gJ3JhbWRhL3NyYy9waXBlJztcbmltcG9ydCBlcXVhbHMgZnJvbSAncmFtZGEvc3JjL2VxdWFscyc7XG5pbXBvcnQgbHRlIGZyb20gJ3JhbWRhL3NyYy9sdGUnO1xuaW1wb3J0IG5vdCBmcm9tICdyYW1kYS9zcmMvbm90JztcbmltcG9ydCB7IG5vb3AsIGlzTnVtYmVyTGlrZSwgaXNOdW1iZXIsIGlzQm9vbGVhbiwgdmFsaWRhdGVQaXBlLCBpc1JlcXVpcmVkLCBvckVxLCBpc0FycmF5LCBpc1N0cmluZywgdmFsaWRhdGVCeVNjaGVtYSBhcyB2YWxpZGF0ZUJ5U2hlbWUsIGlzQXR0YWNobWVudCwgaXNQdWJsaWNLZXksIGlzVmFsaWRBc3NldE5hbWUsIGlzVmFsaWRBc3NldERlc2NyaXB0aW9uLCBpc0Jhc2U2NCwgaXNSZWNpcGllbnQsIGlzQXNzZXRJZCwgaXNWYWxpZERhdGEsIG9yZGVyVmFsaWRhdG9yLCBpc1ZhbGlkQWxpYXNOYW1lLCB9IGZyb20gJy4vdmFsaWRhdG9ycyc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9UWVBFIH0gZnJvbSAnQHdhdmVzL3RzLXR5cGVzJztcbnZhciBzaG91bGRWYWxpZGF0ZSA9IHBpcGUoZXF1YWxzKHVuZGVmaW5lZCksIG5vdCk7XG52YXIgdmFsaWRhdGVPcHRpb25hbCA9IGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gaWZFbHNlKHNob3VsZFZhbGlkYXRlLCB2YWxpZGF0b3IsIGRlZmF1bHRUbyh0cnVlKSk7XG59O1xuLy8gd2F2ZXMtdHJhbnNhY3Rpb24gdmFsaWRhdG9yIGNhbid0IGNvbGxlY3QgZXJyb3JzIGZvciBlYWNoIGludmFsaWQgZmllbGQuXG4vLyBUaGlzIG1ldGhvZCBkb2VzLlxuZXhwb3J0IHZhciB2YWxpZGF0b3IgPSBmdW5jdGlvbiAoc2NoZW1lLCBtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgaW52YWxpZEZpZWxkcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSBPYmplY3QuZW50cmllcyhzY2hlbWUpOyBfaSA8IF9iLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2MgPSBfYltfaV0sIGZpZWxkTmFtZSA9IF9jWzBdLCB2YWxpZGF0aW9uU2NoZW1lID0gX2NbMV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJ5U2hlbWUoKF9hID0ge30sIF9hW2ZpZWxkTmFtZV0gPSB2YWxpZGF0aW9uU2NoZW1lLCBfYSksIFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgICAgICAgICAgbm9vcCkodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaW52YWxpZEZpZWxkcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogaW52YWxpZEZpZWxkcy5sZW5ndGggPT09IDAsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbixcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGludmFsaWRGaWVsZHM6IGludmFsaWRGaWVsZHMsXG4gICAgfTtcbn07IH07XG52YXIgZ2V0Q29tbW9uVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvblR5cGUpIHsgcmV0dXJuICh7XG4gICAgdHlwZTogZXF1YWxzKHRyYW5zYWN0aW9uVHlwZSksXG4gICAgdmVyc2lvbjogdmFsaWRhdGVPcHRpb25hbChvckVxKFt1bmRlZmluZWQsIDEsIDIsIDNdKSksXG4gICAgc2VuZGVyUHVibGljS2V5OiB2YWxpZGF0ZU9wdGlvbmFsKGlzUHVibGljS2V5KSxcbiAgICBmZWU6IHZhbGlkYXRlT3B0aW9uYWwoaXNOdW1iZXJMaWtlKSxcbiAgICBwcm9vZnM6IHZhbGlkYXRlT3B0aW9uYWwoaXNBcnJheSksXG59KTsgfTtcbmV4cG9ydCB2YXIgaXNzdWVBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5JU1NVRSkpLCB7IG5hbWU6IGlzVmFsaWRBc3NldE5hbWUsIGRlc2NyaXB0aW9uOiB2YWxpZGF0ZU9wdGlvbmFsKGlzVmFsaWRBc3NldERlc2NyaXB0aW9uKSwgcXVhbnRpdHk6IGlzTnVtYmVyTGlrZSwgZGVjaW1hbHM6IGlzTnVtYmVyLCByZWlzc3VhYmxlOiB2YWxpZGF0ZU9wdGlvbmFsKGlzQm9vbGVhbiksIHNjcmlwdDogdmFsaWRhdGVPcHRpb25hbChpc0Jhc2U2NCksIGNoYWluSWQ6IHZhbGlkYXRlT3B0aW9uYWwoaXNOdW1iZXIpIH0pO1xuZXhwb3J0IHZhciBpc3N1ZUFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoaXNzdWVBcmdzU2NoZW1lLCAnaXNzdWUnKTtcbmV4cG9ydCB2YXIgdHJhbnNmZXJBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5UUkFOU0ZFUikpLCB7IGFtb3VudDogaXNOdW1iZXJMaWtlLCByZWNpcGllbnQ6IGlzUmVjaXBpZW50LCBhc3NldElkOiB2YWxpZGF0ZU9wdGlvbmFsKGlzQXNzZXRJZCksIGZlZUFzc2V0SWQ6IHZhbGlkYXRlT3B0aW9uYWwoaXNBc3NldElkKSwgYXR0YWNobWVudDogdmFsaWRhdGVPcHRpb25hbChpc0F0dGFjaG1lbnQpIH0pO1xuZXhwb3J0IHZhciB0cmFuc2ZlckFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IodHJhbnNmZXJBcmdzU2NoZW1lLCAndHJhbnNmZXInKTtcbmV4cG9ydCB2YXIgcmVpc3N1ZUFyZ3NTY2hlbWUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZ2V0Q29tbW9uVmFsaWRhdG9ycyhUUkFOU0FDVElPTl9UWVBFLlJFSVNTVUUpKSwgeyBhc3NldElkOiBpc0Fzc2V0SWQsIHF1YW50aXR5OiBpc051bWJlckxpa2UsIHJlaXNzdWFibGU6IGlzQm9vbGVhbiwgY2hhaW5JZDogdmFsaWRhdGVPcHRpb25hbChpc051bWJlcikgfSk7XG5leHBvcnQgdmFyIHJlaXNzdWVBcmdzVmFsaWRhdG9yID0gdmFsaWRhdG9yKHJlaXNzdWVBcmdzU2NoZW1lLCAncmVpc3N1ZScpO1xuZXhwb3J0IHZhciBidXJuQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuQlVSTikpLCB7IFxuICAgIC8vIFRPRE8gaXNBc3NldElkIChub3QgV0FWRVMpXG4gICAgYXNzZXRJZDogaXNTdHJpbmcsIGFtb3VudDogaXNOdW1iZXJMaWtlLCBjaGFpbklkOiB2YWxpZGF0ZU9wdGlvbmFsKGlzTnVtYmVyKSB9KTtcbmV4cG9ydCB2YXIgYnVybkFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoYnVybkFyZ3NTY2hlbWUsICdidXJuJyk7XG5leHBvcnQgdmFyIGxlYXNlQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuTEVBU0UpKSwgeyBhbW91bnQ6IGlzTnVtYmVyTGlrZSwgcmVjaXBpZW50OiBpc1JlY2lwaWVudCB9KTtcbmV4cG9ydCB2YXIgbGVhc2VBcmdzVmFsaWRhdG9yID0gdmFsaWRhdG9yKGxlYXNlQXJnc1NjaGVtZSwgJ2xlYXNlJyk7XG5leHBvcnQgdmFyIGNhbmNlbExlYXNlQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuQ0FOQ0VMX0xFQVNFKSksIHsgbGVhc2VJZDogcGlwZShpc1N0cmluZyksIGNoYWluSWQ6IHZhbGlkYXRlT3B0aW9uYWwoaXNOdW1iZXIpIH0pO1xuZXhwb3J0IHZhciBjYW5jZWxMZWFzZUFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoY2FuY2VsTGVhc2VBcmdzU2NoZW1lLCAnY2FuY2VsIGxlYXNlJyk7XG5leHBvcnQgdmFyIGFsaWFzQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuQUxJQVMpKSwgeyBhbGlhczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gaXNWYWxpZEFsaWFzTmFtZSh2YWx1ZSkgOiBmYWxzZTtcbiAgICB9IH0pO1xuZXhwb3J0IHZhciBhbGlhc0FyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoYWxpYXNBcmdzU2NoZW1lLCAnYWxpYXMnKTtcbmV4cG9ydCB2YXIgbWFzc1RyYW5zZmVyQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuTUFTU19UUkFOU0ZFUikpLCB7IHRyYW5zZmVyczogdmFsaWRhdGVQaXBlKGlzQXJyYXksIHBpcGUocHJvcCgnbGVuZ3RoJyksIGx0ZSgwKSksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmV2ZXJ5KHZhbGlkYXRlUGlwZShpc1JlcXVpcmVkKHRydWUpLCBwaXBlKHByb3AoJ3JlY2lwaWVudCcpLCBpc1JlY2lwaWVudCksIHBpcGUocHJvcCgnYW1vdW50JyksIGlzTnVtYmVyTGlrZSkpKTtcbiAgICB9KSwgYXNzZXRJZDogdmFsaWRhdGVPcHRpb25hbChpc0Fzc2V0SWQpLCBhdHRhY2htZW50OiB2YWxpZGF0ZU9wdGlvbmFsKGlzQXR0YWNobWVudCkgfSk7XG5leHBvcnQgdmFyIG1hc3NUcmFuc2ZlckFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IobWFzc1RyYW5zZmVyQXJnc1NjaGVtZSwgJ21hc3MgdHJhbnNmZXInKTtcbmV4cG9ydCB2YXIgZGF0YUFyZ3NTY2hlbWUgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZ2V0Q29tbW9uVmFsaWRhdG9ycyhUUkFOU0FDVElPTl9UWVBFLkRBVEEpKSwgeyBkYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheShkYXRhKSAmJiBkYXRhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpc1ZhbGlkRGF0YShpdGVtKTsgfSk7XG4gICAgfSB9KTtcbmV4cG9ydCB2YXIgZGF0YUFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoZGF0YUFyZ3NTY2hlbWUsICdkYXRhJyk7IC8vIFRPRE8gZml4IGFueVxuZXhwb3J0IHZhciBzZXRTY3JpcHRBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5TRVRfU0NSSVBUKSksIHsgc2NyaXB0OiBpc0Jhc2U2NCwgY2hhaW5JZDogdmFsaWRhdGVPcHRpb25hbChpc051bWJlcikgfSk7XG5leHBvcnQgdmFyIHNldFNjcmlwdEFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3Ioc2V0U2NyaXB0QXJnc1NjaGVtZSwgJ3NldCBzY3JpcHQnKTtcbmV4cG9ydCB2YXIgc3BvbnNvcnNoaXBBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5TUE9OU09SU0hJUCkpLCB7IFxuICAgIC8vIFRPRE8gQWRkIG5vdCBXQVZFUyBBU1NFVCBJRFxuICAgIGFzc2V0SWQ6IGlzU3RyaW5nLCBtaW5TcG9uc29yZWRBc3NldEZlZTogaXNOdW1iZXJMaWtlIH0pO1xuZXhwb3J0IHZhciBzcG9uc29yc2hpcEFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3Ioc3BvbnNvcnNoaXBBcmdzU2NoZW1lLCAnc3BvbnNvcnNoaXAnKTtcbmV4cG9ydCB2YXIgZXhjaGFuZ2VBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5FWENIQU5HRSkpLCB7IG9yZGVyMTogdmFsaWRhdGVQaXBlKGlzUmVxdWlyZWQodHJ1ZSksIG9yZGVyVmFsaWRhdG9yKSwgb3JkZXIyOiB2YWxpZGF0ZVBpcGUoaXNSZXF1aXJlZCh0cnVlKSwgb3JkZXJWYWxpZGF0b3IpLCBhbW91bnQ6IGlzTnVtYmVyTGlrZSwgcHJpY2U6IGlzTnVtYmVyTGlrZSwgYnV5TWF0Y2hlckZlZTogaXNOdW1iZXJMaWtlLCBzZWxsTWF0Y2hlckZlZTogaXNOdW1iZXJMaWtlIH0pO1xuZXhwb3J0IHZhciBleGNoYW5nZUFyZ3NWYWxpZGF0b3IgPSB2YWxpZGF0b3IoZXhjaGFuZ2VBcmdzU2NoZW1lLCAnZXhjaGFuZ2UnKTtcbmV4cG9ydCB2YXIgc2V0QXNzZXRTY3JpcHRBcmdzU2NoZW1lID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGdldENvbW1vblZhbGlkYXRvcnMoVFJBTlNBQ1RJT05fVFlQRS5TRVRfQVNTRVRfU0NSSVBUKSksIHsgc2NyaXB0OiBpc0Jhc2U2NCwgYXNzZXRJZDogaXNBc3NldElkLCBjaGFpbklkOiB2YWxpZGF0ZU9wdGlvbmFsKGlzTnVtYmVyKSB9KTtcbmV4cG9ydCB2YXIgc2V0QXNzZXRTY3JpcHRBcmdzVmFsaWRhdG9yID0gdmFsaWRhdG9yKHNldEFzc2V0U2NyaXB0QXJnc1NjaGVtZSwgJ3NldCBhc3NldCBzY3JpcHQnKTtcbmV4cG9ydCB2YXIgaW52b2tlQXJnc1NjaGVtZSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRDb21tb25WYWxpZGF0b3JzKFRSQU5TQUNUSU9OX1RZUEUuSU5WT0tFX1NDUklQVCkpLCB7IGRBcHA6IGlzUmVjaXBpZW50LCBjYWxsOiB2YWxpZGF0ZU9wdGlvbmFsKHZhbGlkYXRlUGlwZShwaXBlKHByb3AoJ2Z1bmN0aW9uJyksIGlzU3RyaW5nKSwgcGlwZShwcm9wKCdmdW5jdGlvbicpLCBwcm9wKCdsZW5ndGgnKSwgbHRlKDApKSwgcGlwZShwcm9wKCdhcmdzJyksIGlzQXJyYXkpKSksIHBheW1lbnQ6IHZhbGlkYXRlT3B0aW9uYWwodmFsaWRhdGVQaXBlKGlzQXJyYXksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmV2ZXJ5KHZhbGlkYXRlUGlwZShwaXBlKHByb3AoJ2Ftb3VudCcpLCBpc051bWJlckxpa2UpLCBwaXBlKHByb3AoJ2Fzc2V0SWQnKSwgaXNBc3NldElkKSkpO1xuICAgIH0pKSwgZmVlQXNzZXRJZDogdmFsaWRhdGVPcHRpb25hbChpc0Fzc2V0SWQpLCBjaGFpbklkOiB2YWxpZGF0ZU9wdGlvbmFsKGlzTnVtYmVyKSB9KTtcbmV4cG9ydCB2YXIgaW52b2tlQXJnc1ZhbGlkYXRvciA9IHZhbGlkYXRvcihpbnZva2VBcmdzU2NoZW1lLCAnaW52b2tlJyk7XG5leHBvcnQgdmFyIGFyZ3NWYWxpZGF0b3JzID0gKF9hID0ge30sXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5JU1NVRV0gPSBpc3N1ZUFyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5UUkFOU0ZFUl0gPSB0cmFuc2ZlckFyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5SRUlTU1VFXSA9IHJlaXNzdWVBcmdzVmFsaWRhdG9yLFxuICAgIF9hW1RSQU5TQUNUSU9OX1RZUEUuQlVSTl0gPSBidXJuQXJnc1ZhbGlkYXRvcixcbiAgICBfYVtUUkFOU0FDVElPTl9UWVBFLkxFQVNFXSA9IGxlYXNlQXJnc1ZhbGlkYXRvcixcbiAgICBfYVtUUkFOU0FDVElPTl9UWVBFLkNBTkNFTF9MRUFTRV0gPSBjYW5jZWxMZWFzZUFyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5BTElBU10gPSBhbGlhc0FyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5NQVNTX1RSQU5TRkVSXSA9IG1hc3NUcmFuc2ZlckFyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5EQVRBXSA9IGRhdGFBcmdzVmFsaWRhdG9yLFxuICAgIF9hW1RSQU5TQUNUSU9OX1RZUEUuU0VUX1NDUklQVF0gPSBzZXRTY3JpcHRBcmdzVmFsaWRhdG9yLFxuICAgIF9hW1RSQU5TQUNUSU9OX1RZUEUuU1BPTlNPUlNISVBdID0gc3BvbnNvcnNoaXBBcmdzVmFsaWRhdG9yLFxuICAgIF9hW1RSQU5TQUNUSU9OX1RZUEUuRVhDSEFOR0VdID0gZXhjaGFuZ2VBcmdzVmFsaWRhdG9yLFxuICAgIF9hW1RSQU5TQUNUSU9OX1RZUEUuU0VUX0FTU0VUX1NDUklQVF0gPSBzZXRBc3NldFNjcmlwdEFyZ3NWYWxpZGF0b3IsXG4gICAgX2FbVFJBTlNBQ1RJT05fVFlQRS5JTlZPS0VfU0NSSVBUXSA9IGludm9rZUFyZ3NWYWxpZGF0b3IsXG4gICAgX2EpO1xuZXhwb3J0IHZhciB2YWxpZGF0ZVNpZ25lck9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgIGludmFsaWRPcHRpb25zOiBbXSxcbiAgICB9O1xuICAgIHZhciBpc1ZhbGlkTG9nTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIFsndmVyYm9zZScsICdwcm9kdWN0aW9uJywgJ2Vycm9yJ10uaW5jbHVkZXMoU3RyaW5nKGxldmVsKSk7XG4gICAgfTtcbiAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuTk9ERV9VUkwpKSB7XG4gICAgICAgIHJlcy5pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHJlcy5pbnZhbGlkT3B0aW9ucy5wdXNoKCdOT0RFX1VSTCcpO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlT3B0aW9uYWwoaXNWYWxpZExvZ0xldmVsKShvcHRpb25zLkxPR19MRVZFTCkpIHtcbiAgICAgICAgcmVzLmlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgcmVzLmludmFsaWRPcHRpb25zLnB1c2goJ2RlYnVnJyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0IHZhciB2YWxpZGF0ZVByb3ZpZGVySW50ZXJmYWNlID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJzsgfTtcbiAgICB2YXIgc2NoZW1lID0ge1xuICAgICAgICBjb25uZWN0OiBpc0Z1bmN0aW9uLFxuICAgICAgICBsb2dpbjogaXNGdW5jdGlvbixcbiAgICAgICAgbG9nb3V0OiBpc0Z1bmN0aW9uLFxuICAgICAgICBzaWduTWVzc2FnZTogaXNGdW5jdGlvbixcbiAgICAgICAgc2lnblR5cGVkRGF0YTogaXNGdW5jdGlvbixcbiAgICAgICAgc2lnbjogaXNGdW5jdGlvbixcbiAgICB9O1xuICAgIHZhciBpbnZhbGlkUHJvcGVydGllcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhzY2hlbWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGZpZWxkTmFtZSA9IF9iWzBdLCB2YWxpZGF0b3JfMSA9IF9iWzFdO1xuICAgICAgICBpZiAoIXZhbGlkYXRvcl8xKHByb3ZpZGVyW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICBpbnZhbGlkUHJvcGVydGllcy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNWYWxpZDogaW52YWxpZFByb3BlcnRpZXMubGVuZ3RoID09PSAwLFxuICAgICAgICBpbnZhbGlkUHJvcGVydGllczogaW52YWxpZFByb3BlcnRpZXMsXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgZGVmYXVsdFRvIGZyb20gJ3JhbWRhL3NyYy9kZWZhdWx0VG8nO1xuaW1wb3J0IHByb3AgZnJvbSAncmFtZGEvc3JjL3Byb3AnO1xuaW1wb3J0IGlmRWxzZSBmcm9tICdyYW1kYS9zcmMvaWZFbHNlJztcbmltcG9ydCBwaXBlIGZyb20gJ3JhbWRhL3NyYy9waXBlJztcbmltcG9ydCBlcXVhbHMgZnJvbSAncmFtZGEvc3JjL2VxdWFscyc7XG5pbXBvcnQgZ3RlIGZyb20gJ3JhbWRhL3NyYy9ndGUnO1xuaW1wb3J0IGx0ZSBmcm9tICdyYW1kYS9zcmMvbHRlJztcbmltcG9ydCBzdGFydHNXaXRoIGZyb20gJ3JhbWRhL3NyYy9zdGFydHNXaXRoJztcbmltcG9ydCBpc05pbCBmcm9tICdyYW1kYS9zcmMvaXNOaWwnO1xuaW1wb3J0IGluY2x1ZGVzIGZyb20gJ3JhbWRhL3NyYy9pbmNsdWRlcyc7XG5pbXBvcnQgZmxpcCBmcm9tICdyYW1kYS9zcmMvZmxpcCc7XG5pbXBvcnQgYWx3YXlzIGZyb20gJ3JhbWRhL3NyYy9hbHdheXMnO1xuaW1wb3J0IHRyeUNhdGNoIGZyb20gJ3JhbWRhL3NyYy90cnlDYXRjaCc7XG5pbXBvcnQgeyBiYXNlNThEZWNvZGUgfSBmcm9tICdAd2F2ZXMvdHMtbGliLWNyeXB0byc7XG52YXIgVFhfREVGQVVMVFMgPSB7XG4gICAgTUFYX0FUVEFDSE1FTlQ6IDE0MCxcbiAgICBBTElBUzoge1xuICAgICAgICBBVkFJTEFCTEVfQ0hBUlM6ICctLjAxMjM0NTY3ODlAX2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgICAgICAgTUFYX0FMSUFTX0xFTkdUSDogMzAsXG4gICAgICAgIE1JTl9BTElBU19MRU5HVEg6IDQsXG4gICAgfSxcbn07XG5leHBvcnQgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpOyB9O1xuZXhwb3J0IHZhciB2YWxpZGF0ZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFyZ3NfMSA9IGFyZ3M7IF9pIDwgYXJnc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNiID0gYXJnc18xW19pXTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSAhIWNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgaXNSZXF1aXJlZCA9IGZ1bmN0aW9uIChyZXF1aXJlZCkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICFyZXF1aXJlZCB8fCB2YWx1ZSAhPSBudWxsO1xufTsgfTtcbmV4cG9ydCB2YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5leHBvcnQgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJlxuICAgICAgICAhaXNOYU4oTnVtYmVyKHZhbHVlKSk7XG59O1xuZXhwb3J0IHZhciBpc051bWJlckxpa2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgISEodmFsdWUgfHwgdmFsdWUgPT09IDApO1xufTtcbmV4cG9ydCB2YXIgaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbik7XG59O1xuZXhwb3J0IHZhciBvckVxID0gZmxpcChpbmNsdWRlcyk7XG5leHBvcnQgdmFyIGV4Y2VwdGlvbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn07XG5leHBvcnQgdmFyIHZhbGlkYXRlQnlTY2hlbWEgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvclRwbCkgeyByZXR1cm4gZnVuY3Rpb24gKHR4KSB7XG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2FbMF0sIGNiID0gX2FbMV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3Aoa2V5LCB0eCB8fCB7fSk7XG4gICAgICAgIGlmICghY2IodmFsdWUpKSB7XG4gICAgICAgICAgICBleGNlcHRpb24oZXJyb3JUcGwoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59OyB9O1xuZXhwb3J0IHZhciBpc0F0dGFjaG1lbnQgPSBpZkVsc2Uob3JFcShbbnVsbCwgdW5kZWZpbmVkXSksIGRlZmF1bHRUbyh0cnVlKSwgaWZFbHNlKGlzU3RyaW5nLCBcbi8vIFRPRE8gRml4IGF0dGFjaG1lbnQgZ3RlKFRYX0RFRkFVTFRTLk1BWF9BVFRBQ0hNRU5UKVxucGlwZShwcm9wKCdsZW5ndGgnKSwgYWx3YXlzKHRydWUpKSwgZGVmYXVsdFRvKGZhbHNlKSkpO1xudmFyIHZhbGlkYXRlQ2hhcnMgPSBmdW5jdGlvbiAoY2hhcnMpIHsgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJykuZXZlcnkoZnVuY3Rpb24gKGNoYXIpIHsgcmV0dXJuIGNoYXJzLmluY2x1ZGVzKGNoYXIpOyB9KTtcbn07IH07XG5leHBvcnQgdmFyIGlzVmFsaWRBbGlhc05hbWUgPSBpZkVsc2UodmFsaWRhdGVDaGFycyhUWF9ERUZBVUxUUy5BTElBUy5BVkFJTEFCTEVfQ0hBUlMpLCBwaXBlKHByb3AoJ2xlbmd0aCcpLCB2YWxpZGF0ZVBpcGUoZ3RlKFRYX0RFRkFVTFRTLkFMSUFTLk1BWF9BTElBU19MRU5HVEgpLCBsdGUoVFhfREVGQVVMVFMuQUxJQVMuTUlOX0FMSUFTX0xFTkdUSCkpKSwgZGVmYXVsdFRvKGZhbHNlKSk7XG5leHBvcnQgdmFyIEFTU0VUUyA9IHtcbiAgICBOQU1FX01JTl9CWVRFUzogNCxcbiAgICBOQU1FX01BWF9CWVRFUzogMTYsXG4gICAgREVTQ1JJUFRJT05fTUFYX0JZVEVTOiAxMDAwLFxufTtcbmV4cG9ydCB2YXIgaXNCYXNlNjQgPSB2YWxpZGF0ZVBpcGUoaWZFbHNlKGlzU3RyaW5nLCBzdGFydHNXaXRoKCdiYXNlNjQ6JyksIHBpcGUoaXNOaWwpKSk7XG5leHBvcnQgdmFyIHZhbGlkYXRlVHlwZSA9IHtcbiAgICBpbnRlZ2VyOiBpc051bWJlckxpa2UsXG4gICAgYm9vbGVhbjogaXNCb29sZWFuLFxuICAgIHN0cmluZzogaXNTdHJpbmcsXG4gICAgYmluYXJ5OiBpc0Jhc2U2NCxcbn07XG5leHBvcnQgdmFyIGlzVmFsaWREYXRhUGFpciA9IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiAhISh2YWxpZGF0ZVR5cGVbZGF0YS50eXBlXSAmJiB2YWxpZGF0ZVR5cGVbZGF0YS50eXBlXShkYXRhLnZhbHVlKSk7IH07XG5leHBvcnQgdmFyIGlzVmFsaWREYXRhID0gdmFsaWRhdGVQaXBlKGlzUmVxdWlyZWQodHJ1ZSksIHBpcGUocHJvcCgna2V5JyksIHZhbGlkYXRlUGlwZShpc1N0cmluZywgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gISFrZXk7IH0pKSwgaXNWYWxpZERhdGFQYWlyKTtcbmV4cG9ydCB2YXIgaXNQdWJsaWNLZXkgPSB2YWxpZGF0ZVBpcGUoaXNTdHJpbmcsIHRyeUNhdGNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBiYXNlNThEZWNvZGUodikubGVuZ3RoID09PSAzMjsgfSwgYWx3YXlzKGZhbHNlKSkpO1xuZXhwb3J0IHZhciBpc1ZhbGlkQXNzZXROYW1lID0gdmFsaWRhdGVQaXBlKGlzU3RyaW5nLCBwaXBlKHByb3AoJ2xlbmd0aCcpLCBpZkVsc2UobHRlKEFTU0VUUy5OQU1FX01JTl9CWVRFUyksIGd0ZShBU1NFVFMuTkFNRV9NQVhfQllURVMpLCBkZWZhdWx0VG8oZmFsc2UpKSkpO1xuZXhwb3J0IHZhciBpc1ZhbGlkQXNzZXREZXNjcmlwdGlvbiA9IHZhbGlkYXRlUGlwZShpc1N0cmluZywgcGlwZShwcm9wKCdsZW5ndGgnKSwgZ3RlKEFTU0VUUy5ERVNDUklQVElPTl9NQVhfQllURVMpKSk7XG5leHBvcnQgdmFyIGlzQXNzZXRJZCA9IHZhbGlkYXRlUGlwZShpZkVsc2Uob3JFcShbJycsIG51bGwsIHVuZGVmaW5lZCwgJ1dBVkVTJ10pLCBkZWZhdWx0VG8odHJ1ZSksIGlzU3RyaW5nKSk7XG5leHBvcnQgdmFyIGlzQWxpYXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLnN0YXJ0c1dpdGgoJ2FsaWFzOicpOyB9O1xuLy8gVE9ETyBmaXggdmFsaWRhdG9yISEhXG5leHBvcnQgdmFyIGlzVmFsaWRBZGRyZXNzID0gaXNTdHJpbmc7XG5leHBvcnQgdmFyIGlzVmFsaWRBbGlhcyA9IHBpcGUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZS5zcGxpdCgnOicpWzJdOyB9LCBpc1ZhbGlkQWxpYXNOYW1lKTtcbmV4cG9ydCB2YXIgaXNSZWNpcGllbnQgPSB2YWxpZGF0ZVBpcGUoaXNTdHJpbmcsIGlmRWxzZShpc0FsaWFzLCBpc1ZhbGlkQWxpYXMsIGlzVmFsaWRBZGRyZXNzKSk7XG52YXIgb3JkZXJTY2hlbWUgPSB7XG4gICAgb3JkZXJUeXBlOiBvckVxKFsnc2VsbCcsICdidXknXSksXG4gICAgc2VuZGVyUHVibGljS2V5OiBpc1B1YmxpY0tleSxcbiAgICBtYXRjaGVyUHVibGljS2V5OiBpc1B1YmxpY0tleSxcbiAgICB2ZXJzaW9uOiBvckVxKFt1bmRlZmluZWQsIDAsIDEsIDIsIDNdKSxcbiAgICBhc3NldFBhaXI6IHZhbGlkYXRlUGlwZShpc1JlcXVpcmVkKHRydWUpLCBwaXBlKHByb3AoJ2Ftb3VudEFzc2V0JyksIGlzQXNzZXRJZCksIHBpcGUocHJvcCgncHJpY2VBc3NldCcpLCBpc0Fzc2V0SWQpKSxcbiAgICBwcmljZTogaXNOdW1iZXJMaWtlLFxuICAgIGFtb3VudDogaXNOdW1iZXJMaWtlLFxuICAgIG1hdGNoZXJGZWU6IGlzTnVtYmVyTGlrZSxcbiAgICBleHBpcmF0aW9uOiBpc051bWJlckxpa2UsXG4gICAgdGltZXN0YW1wOiBpc051bWJlcixcbiAgICBwcm9vZnM6IGlmRWxzZShpc0FycmF5LCBkZWZhdWx0VG8odHJ1ZSksIG9yRXEoW3VuZGVmaW5lZF0pKSxcbn07XG52YXIgdjEyT3JkZXJTY2hlbWUgPSB7XG4gICAgbWF0Y2hlckZlZUFzc2V0SWQ6IG9yRXEoW3VuZGVmaW5lZCwgbnVsbCwgJ1dBVkVTJ10pLFxufTtcbnZhciB2M09yZGVyU2NoZW1lID0ge1xuICAgIG1hdGNoZXJGZWVBc3NldElkOiBpc0Fzc2V0SWQsXG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuZXhwb3J0IHZhciBub29wID0gZnVuY3Rpb24gKCkge1xufTtcbi8vIFRPRE8hISFcbnZhciB2YWxpZGF0ZU9yZGVyID0gdmFsaWRhdGVCeVNjaGVtYShvcmRlclNjaGVtZSwgbm9vcCk7XG52YXIgdmFsaWRhdGVPcmRlclYyID0gdmFsaWRhdGVCeVNjaGVtYSh2MTJPcmRlclNjaGVtZSwgbm9vcCk7XG52YXIgdmFsaWRhdGVPcmRlclYzID0gdmFsaWRhdGVCeVNjaGVtYSh2M09yZGVyU2NoZW1lLCBub29wKTtcbmV4cG9ydCB2YXIgb3JkZXJWYWxpZGF0b3IgPSB2YWxpZGF0ZVBpcGUodmFsaWRhdGVPcmRlciwgaWZFbHNlKHBpcGUocHJvcCgndmVyc2lvbicpLCBlcXVhbHMoMykpLCB2YWxpZGF0ZU9yZGVyVjMsIHZhbGlkYXRlT3JkZXJWMikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vL0B0cy1pZ25vcmVcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvdXRpbFwiKTtcbnZhciBiYXNlNThfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbGlicy9iYXNlNThcIikpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi9wYXJhbVwiKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZy1ieXRlc1wiKTtcbmV4cG9ydHMuYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXModXRpbF8xLmRlY29kZTY0KGlucHV0KSwgJ3JhdycpO1xufTtcbmV4cG9ydHMuYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHV0aWxfMS5lbmNvZGU2NChzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKHBhcmFtXzEuX2Zyb21JbihpbnB1dCksICdyYXcnKSk7XG59O1xuZXhwb3J0cy5iYXNlNThEZWNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gYmFzZTU4XzEuZGVmYXVsdC5kZWNvZGUoaW5wdXQpO1xufTtcbmV4cG9ydHMuYmFzZTU4RW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGJhc2U1OF8xLmRlZmF1bHQuZW5jb2RlKHBhcmFtXzEuX2Zyb21JbihpbnB1dCkpO1xufTtcbmV4cG9ydHMuYmFzZTE2RGVjb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXModXRpbF8xLmhleFRvQnl0ZXMoaW5wdXQpLCAncmF3Jyk7XG59O1xuZXhwb3J0cy5iYXNlMTZFbmNvZGUgPSBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIHV0aWxfMS5ieXRlc1RvSGV4KHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcocGFyYW1fMS5fZnJvbUluKGlucHV0KSwgJ3JhdycpKTsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UteHguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmFzZV94eF8xID0gcmVxdWlyZShcIi4vYmFzZS14eFwiKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuL3N0cmluZy1ieXRlc1wiKTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZzsgfTtcbnZhciBpc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5OyB9O1xudmFyIGlzVFJhd1N0cmluZ0luRGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBmYWxzZTsgfTtcbmV4cG9ydHMuX2Zyb21JbiA9IGZ1bmN0aW9uIChpblZhbHVlKSB7XG4gICAgaWYgKGlzU3RyaW5nKGluVmFsdWUpKVxuICAgICAgICByZXR1cm4gYmFzZV94eF8xLmJhc2U1OERlY29kZShpblZhbHVlKTtcbiAgICBpZiAoaXNVaW50OEFycmF5KGluVmFsdWUpKVxuICAgICAgICByZXR1cm4gaW5WYWx1ZTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGluVmFsdWUpO1xufTtcbmV4cG9ydHMuX2Zyb21SYXdJbiA9IGZ1bmN0aW9uIChpblZhbHVlKSB7XG4gICAgaWYgKGlzVFJhd1N0cmluZ0luRGlzY3JpbWluYXRvcihpblZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnKTtcbiAgICBpZiAoaXNTdHJpbmcoaW5WYWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKGluVmFsdWUpO1xuICAgIGlmIChpc1VpbnQ4QXJyYXkoaW5WYWx1ZSkpXG4gICAgICAgIHJldHVybiBpblZhbHVlO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaW5WYWx1ZSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi9wYXJhbVwiKTtcbnZhciBVdGY4XzEgPSByZXF1aXJlKFwiLi4vbGlicy9VdGY4XCIpO1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9ICd1dGY4JzsgfVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAgIHJldHVybiBVdGY4XzEuc3RyVG9VdGY4QXJyYXkoc3RyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdyYXcnKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oX19zcHJlYWQoc3RyKS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTsgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcywgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9ICd1dGY4JzsgfVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICAgIHJldHVybiBVdGY4XzEudXRmOEFycmF5VG9TdHIoQXJyYXkuZnJvbShwYXJhbV8xLl9mcm9tSW4oYnl0ZXMpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuY29kaW5nID09PSAncmF3Jykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJhbV8xLl9mcm9tSW4oYnl0ZXMpKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYnl0ZSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nIFwiICsgZW5jb2RpbmcpO1xuICAgIH1cbn07XG4vKipcbiAqIENvbnZlcnRzIGVhY2ggY2hhcmFjdGVyIHRvIGJ5dGVcbiAqL1xuZXhwb3J0cy5iaW5hcnlTdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oX19zcHJlYWQoc3RyKS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTsgfSkpO1xufTtcbi8qKlxuICogUmVhZHMgZWFjaCBieXRlIGFzIGluZGl2aWR1YWwgY2hhcmFjdGVyXG4gKi9cbmV4cG9ydHMuYnl0ZXNUb0JpbmFyeVN0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmFtXzEuX2Zyb21JbihieXRlcykpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGJ5dGUpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSk7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmctYnl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7XG52YXIgc2VlZF8xID0gcmVxdWlyZShcIi4uL2V4dGVuc2lvbnMvc2VlZFwiKTtcbnZhciBoYXNoaW5nXzEgPSByZXF1aXJlKFwiLi9oYXNoaW5nXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vY29udmVyc2lvbnMvcGFyYW1cIik7XG52YXIgY29uY2F0X3NwbGl0XzEgPSByZXF1aXJlKFwiLi9jb25jYXQtc3BsaXRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBheGxzaWduXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xpYnMvYXhsc2lnblwiKSk7XG5leHBvcnRzLnNlZWRXaXRoTm9uY2UgPSBmdW5jdGlvbiAoc2VlZCwgbm9uY2UpIHsgcmV0dXJuICh7IHNlZWQ6IHNlZWRfMS5TZWVkLnRvQmluYXJ5KHNlZWQpLnNlZWQsIG5vbmNlOiBub25jZSB9KTsgfTtcbmV4cG9ydHMuYnVpbGRBZGRyZXNzID0gZnVuY3Rpb24gKHB1YmxpY0tleUJ5dGVzLCBjaGFpbklkKSB7XG4gICAgaWYgKGNoYWluSWQgPT09IHZvaWQgMCkgeyBjaGFpbklkID0gaW50ZXJmYWNlXzEuTUFJTl9ORVRfQ0hBSU5fSUQ7IH1cbiAgICB2YXIgcHJlZml4ID0gWzEsIHR5cGVvZiBjaGFpbklkID09PSAnc3RyaW5nJyA/IGNoYWluSWQuY2hhckNvZGVBdCgwKSA6IGNoYWluSWRdO1xuICAgIHZhciBwdWJsaWNLZXlIYXNoUGFydCA9IGhhc2hpbmdfMS5faGFzaENoYWluKHB1YmxpY0tleUJ5dGVzKS5zbGljZSgwLCAyMCk7XG4gICAgdmFyIHJhd0FkZHJlc3MgPSBjb25jYXRfc3BsaXRfMS5jb25jYXQocHJlZml4LCBwdWJsaWNLZXlIYXNoUGFydCk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gaGFzaGluZ18xLl9oYXNoQ2hhaW4ocmF3QWRkcmVzcykuc2xpY2UoMCwgNCk7XG4gICAgcmV0dXJuIGNvbmNhdF9zcGxpdF8xLmNvbmNhdChyYXdBZGRyZXNzLCBhZGRyZXNzSGFzaCk7XG59O1xudmFyIGJ1aWxkU2VlZEhhc2ggPSBmdW5jdGlvbiAoc2VlZEJ5dGVzLCBub25jZSkge1xuICAgIHZhciBub25jZUFycmF5ID0gWzAsIDAsIDAsIDBdO1xuICAgIGlmIChub25jZSAmJiBub25jZSA+IDApIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IG5vbmNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIG5vbmNlQXJyYXlbMyAtIGldID0gTWF0aC5mbG9vcihyZW1haW5kZXIgLyBNYXRoLnBvdygyLCAoaSAqIDgpKSk7XG4gICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIgJSBNYXRoLnBvdygyLCAoaSAqIDgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2VlZEJ5dGVzV2l0aE5vbmNlID0gY29uY2F0X3NwbGl0XzEuY29uY2F0KG5vbmNlQXJyYXksIHNlZWRCeXRlcyk7XG4gICAgdmFyIHNlZWRIYXNoID0gaGFzaGluZ18xLl9oYXNoQ2hhaW4oc2VlZEJ5dGVzV2l0aE5vbmNlKTtcbiAgICByZXR1cm4gaGFzaGluZ18xLnNoYTI1NihzZWVkSGFzaCk7XG59O1xuZXhwb3J0cy5rZXlQYWlyID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICB2YXIgX2EgPSBzZWVkXzEuU2VlZC50b0JpbmFyeShzZWVkKSwgc2VlZEJ5dGVzID0gX2Euc2VlZCwgbm9uY2UgPSBfYS5ub25jZTtcbiAgICB2YXIgc2VlZEhhc2ggPSBidWlsZFNlZWRIYXNoKHNlZWRCeXRlcywgbm9uY2UpO1xuICAgIHZhciBrZXlzID0gYXhsc2lnbl8xLmRlZmF1bHQuZ2VuZXJhdGVLZXlQYWlyKHNlZWRIYXNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcml2YXRlS2V5OiBrZXlzLnByaXZhdGUsXG4gICAgICAgIHB1YmxpY0tleToga2V5cy5wdWJsaWMsXG4gICAgfTtcbn07XG5leHBvcnRzLmFkZHJlc3MgPSBmdW5jdGlvbiAoc2VlZE9yUHVibGljS2V5LCBjaGFpbklkKSB7XG4gICAgaWYgKGNoYWluSWQgPT09IHZvaWQgMCkgeyBjaGFpbklkID0gaW50ZXJmYWNlXzEuTUFJTl9ORVRfQ0hBSU5fSUQ7IH1cbiAgICByZXR1cm4gdXRpbF8xLmlzUHVibGljS2V5KHNlZWRPclB1YmxpY0tleSkgP1xuICAgICAgICBleHBvcnRzLmJ1aWxkQWRkcmVzcyhwYXJhbV8xLl9mcm9tSW4oc2VlZE9yUHVibGljS2V5LnB1YmxpY0tleSksIGNoYWluSWQpIDpcbiAgICAgICAgZXhwb3J0cy5hZGRyZXNzKGV4cG9ydHMua2V5UGFpcihzZWVkT3JQdWJsaWNLZXkpLCBjaGFpbklkKTtcbn07XG5leHBvcnRzLnB1YmxpY0tleSA9IGZ1bmN0aW9uIChzZWVkT3JQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHV0aWxfMS5pc1ByaXZhdGVLZXkoc2VlZE9yUHJpdmF0ZUtleSkgP1xuICAgICAgICBheGxzaWduXzEuZGVmYXVsdC5nZW5lcmF0ZUtleVBhaXIocGFyYW1fMS5fZnJvbUluKHNlZWRPclByaXZhdGVLZXkucHJpdmF0ZUtleSkpLnB1YmxpYyA6XG4gICAgICAgIGV4cG9ydHMua2V5UGFpcihzZWVkT3JQcml2YXRlS2V5KS5wdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5wcml2YXRlS2V5ID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5rZXlQYWlyKHNlZWQpLnByaXZhdGVLZXk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy1rZXlzLXNlZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vY29udmVyc2lvbnMvcGFyYW1cIik7XG5leHBvcnRzLmNvbmNhdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXlzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJyYXlzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBVaW50OEFycmF5LmZyb20oX19zcHJlYWQoYSwgcGFyYW1fMS5fZnJvbUluKGIpKSk7IH0sIG5ldyBVaW50OEFycmF5KDApKTtcbn07XG5leHBvcnRzLnNwbGl0ID0gZnVuY3Rpb24gKGJpbmFyeSkge1xuICAgIHZhciBzaXplcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNpemVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgX2EgPSBzaXplcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIHMpIHsgcmV0dXJuICh7IGFycjogYS5hcnIuc2xpY2UocyksIHI6IF9fc3ByZWFkKGEuciwgW2EuYXJyLnNsaWNlKDAsIHMpXSkgfSk7IH0sIHsgYXJyOiBwYXJhbV8xLl9mcm9tSW4oYmluYXJ5KSwgcjogW10gfSksIHIgPSBfYS5yLCBhcnIgPSBfYS5hcnI7XG4gICAgcmV0dXJuIF9fc3ByZWFkKHIsIFthcnJdKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQtc3BsaXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZCkgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByYW5kb21fMSA9IHJlcXVpcmUoXCIuL3JhbmRvbVwiKTtcbnZhciBlbmNyeXB0aW9uXzEgPSByZXF1aXJlKFwiLi9lbmNyeXB0aW9uXCIpO1xudmFyIGJhc2VfeHhfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9iYXNlLXh4XCIpO1xudmFyIHN0cmluZ19ieXRlc18xID0gcmVxdWlyZShcIi4uL2NvbnZlcnNpb25zL3N0cmluZy1ieXRlc1wiKTtcbnZhciBjb25jYXRfc3BsaXRfMSA9IHJlcXVpcmUoXCIuL2NvbmNhdC1zcGxpdFwiKTtcbnZhciBoYXNoaW5nXzEgPSByZXF1aXJlKFwiLi9oYXNoaW5nXCIpO1xudmFyIGFkZHJlc3Nfa2V5c19zZWVkXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLWtleXMtc2VlZFwiKTtcbnZhciBzaWduXzEgPSByZXF1aXJlKFwiLi9zaWduXCIpO1xudmFyIHZlcmlmaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vdmVyaWZpY2F0aW9uXCIpO1xudmFyIHJzYV8xID0gcmVxdWlyZShcIi4vcnNhXCIpO1xudmFyIHNlZWRfZWNyeXB0aW9uXzEgPSByZXF1aXJlKFwiLi9zZWVkLWVjcnlwdGlvblwiKTtcbnZhciBtZXJrbGVfdmVyaWZ5XzEgPSByZXF1aXJlKFwiLi9tZXJrbGUtdmVyaWZ5XCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2VlZCA9PSAnJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBzZWVkIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgIHZhciBjID0gZnVuY3Rpb24gKGYsIGZpcnN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKFtmaXJzdF0sIGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciB0b091dCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBmLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpO1xuICAgICAgICByZXR1cm4gKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5vdXRwdXQgPT09ICdCYXNlNTgnKSA/IGJhc2VfeHhfMS5iYXNlNThFbmNvZGUocikgOiByO1xuICAgIH07IH07XG4gICAgdmFyIHRvT3V0S2V5ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IGYuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICAgIHJldHVybiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5vdXRwdXQgPT09ICdCYXNlNTgnKSA/XG4gICAgICAgICAgICAoeyBwcml2YXRlS2V5OiBiYXNlX3h4XzEuYmFzZTU4RW5jb2RlKHIucHJpdmF0ZUtleSksIHB1YmxpY0tleTogYmFzZV94eF8xLmJhc2U1OEVuY29kZShyLnB1YmxpY0tleSkgfSkgOlxuICAgICAgICAgICAgcik7XG4gICAgfTsgfTtcbiAgICB2YXIgcyA9IChvcHRpb25zICYmIG9wdGlvbnMuc2VlZCkgPyBvcHRpb25zLnNlZWQgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNlZWRQYXJ0ID0ge1xuICAgICAgICBzZWVkV2l0aE5vbmNlOiBzID8gYyhhZGRyZXNzX2tleXNfc2VlZF8xLnNlZWRXaXRoTm9uY2UsIHMpIDogYWRkcmVzc19rZXlzX3NlZWRfMS5zZWVkV2l0aE5vbmNlLFxuICAgICAgICBzaWduQnl0ZXM6IHRvT3V0KHMgPyBjKHNpZ25fMS5zaWduQnl0ZXMsIHMpIDogc2lnbl8xLnNpZ25CeXRlcyksXG4gICAgICAgIGtleVBhaXI6IHRvT3V0S2V5KHMgPyBjKGFkZHJlc3Nfa2V5c19zZWVkXzEua2V5UGFpciwgcykgOiBhZGRyZXNzX2tleXNfc2VlZF8xLmtleVBhaXIpLFxuICAgICAgICBwdWJsaWNLZXk6IHRvT3V0KHMgPyBjKGFkZHJlc3Nfa2V5c19zZWVkXzEucHVibGljS2V5LCBzKSA6IGFkZHJlc3Nfa2V5c19zZWVkXzEucHVibGljS2V5KSxcbiAgICAgICAgcHJpdmF0ZUtleTogdG9PdXQocyA/IGMoYWRkcmVzc19rZXlzX3NlZWRfMS5wcml2YXRlS2V5LCBzKSA6IGFkZHJlc3Nfa2V5c19zZWVkXzEucHJpdmF0ZUtleSksXG4gICAgICAgIGFkZHJlc3M6IHRvT3V0KHMgPyBjKGFkZHJlc3Nfa2V5c19zZWVkXzEuYWRkcmVzcywgcykgOiBhZGRyZXNzX2tleXNfc2VlZF8xLmFkZHJlc3MpLFxuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduKHt9LCBzZWVkUGFydCwgeyBzaGFyZWRLZXk6IHRvT3V0KGVuY3J5cHRpb25fMS5zaGFyZWRLZXkpLCBidWlsZEFkZHJlc3M6IGFkZHJlc3Nfa2V5c19zZWVkXzEuYnVpbGRBZGRyZXNzLFxuICAgICAgICBibGFrZTJiOiBoYXNoaW5nXzEuYmxha2UyYixcbiAgICAgICAga2VjY2FrOiBoYXNoaW5nXzEua2VjY2FrLFxuICAgICAgICBzaGEyNTY6IGhhc2hpbmdfMS5zaGEyNTYsXG4gICAgICAgIGJhc2U2NEVuY29kZTogYmFzZV94eF8xLmJhc2U2NEVuY29kZSxcbiAgICAgICAgYmFzZTY0RGVjb2RlOiBiYXNlX3h4XzEuYmFzZTY0RGVjb2RlLFxuICAgICAgICBiYXNlNThFbmNvZGU6IGJhc2VfeHhfMS5iYXNlNThFbmNvZGUsXG4gICAgICAgIGJhc2U1OERlY29kZTogYmFzZV94eF8xLmJhc2U1OERlY29kZSxcbiAgICAgICAgYmFzZTE2RW5jb2RlOiBiYXNlX3h4XzEuYmFzZTE2RW5jb2RlLFxuICAgICAgICBiYXNlMTZEZWNvZGU6IGJhc2VfeHhfMS5iYXNlMTZEZWNvZGUsXG4gICAgICAgIHN0cmluZ1RvQnl0ZXM6IHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXMsXG4gICAgICAgIGJ5dGVzVG9TdHJpbmc6IHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcsXG4gICAgICAgIHJhbmRvbTogcmFuZG9tXzEucmFuZG9tLFxuICAgICAgICByYW5kb21TZWVkOiByYW5kb21fMS5yYW5kb21TZWVkLFxuICAgICAgICByYW5kb21CeXRlczogcmFuZG9tXzEucmFuZG9tQnl0ZXMsXG4gICAgICAgIHZlcmlmeVNpZ25hdHVyZTogdmVyaWZpY2F0aW9uXzEudmVyaWZ5U2lnbmF0dXJlLFxuICAgICAgICB2ZXJpZnlQdWJsaWNLZXk6IHZlcmlmaWNhdGlvbl8xLnZlcmlmeVB1YmxpY0tleSxcbiAgICAgICAgdmVyaWZ5QWRkcmVzczogdmVyaWZpY2F0aW9uXzEudmVyaWZ5QWRkcmVzcyxcbiAgICAgICAgbWVzc2FnZURlY3J5cHQ6IGVuY3J5cHRpb25fMS5tZXNzYWdlRGVjcnlwdCxcbiAgICAgICAgbWVzc2FnZUVuY3J5cHQ6IGVuY3J5cHRpb25fMS5tZXNzYWdlRW5jcnlwdCxcbiAgICAgICAgYWVzRGVjcnlwdDogZW5jcnlwdGlvbl8xLmFlc0RlY3J5cHQsXG4gICAgICAgIGFlc0VuY3J5cHQ6IGVuY3J5cHRpb25fMS5hZXNFbmNyeXB0LFxuICAgICAgICBlbmNyeXB0U2VlZDogc2VlZF9lY3J5cHRpb25fMS5lbmNyeXB0U2VlZCxcbiAgICAgICAgZGVjcnlwdFNlZWQ6IHNlZWRfZWNyeXB0aW9uXzEuZGVjcnlwdFNlZWQsXG4gICAgICAgIHJzYUtleVBhaXI6IHJzYV8xLnJzYUtleVBhaXIsXG4gICAgICAgIHJzYUtleVBhaXJTeW5jOiByc2FfMS5yc2FLZXlQYWlyU3luYyxcbiAgICAgICAgcnNhU2lnbjogcnNhXzEucnNhU2lnbixcbiAgICAgICAgcnNhVmVyaWZ5OiByc2FfMS5yc2FWZXJpZnksXG4gICAgICAgIG1lcmtsZVZlcmlmeTogbWVya2xlX3ZlcmlmeV8xLm1lcmtsZVZlcmlmeSxcbiAgICAgICAgc3BsaXQ6IGNvbmNhdF9zcGxpdF8xLnNwbGl0LFxuICAgICAgICBjb25jYXQ6IGNvbmNhdF9zcGxpdF8xLmNvbmNhdCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBAdHMtaWdub3JlXG52YXIgZm9yZ2VDaXBoZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2NpcGhlclwiKSk7XG4vLyBAdHMtaWdub3JlXG52YXIgdXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvdXRpbFwiKSk7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb21cIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9wYXJhbVwiKTtcbnZhciBoYXNoaW5nXzEgPSByZXF1aXJlKFwiLi9oYXNoaW5nXCIpO1xudmFyIGNvbmNhdF9zcGxpdF8xID0gcmVxdWlyZShcIi4vY29uY2F0LXNwbGl0XCIpO1xudmFyIGF4bHNpZ25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbGlicy9heGxzaWduXCIpKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9zdHJpbmctYnl0ZXNcIik7XG5leHBvcnRzLmFlc0VuY3J5cHQgPSBmdW5jdGlvbiAoZGF0YSwga2V5LCBtb2RlLCBpdikge1xuICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9ICdDQkMnOyB9XG4gICAgdmFyIGNpcGhlciA9IGZvcmdlQ2lwaGVyLmNyZWF0ZUNpcGhlcihcIkFFUy1cIiArIG1vZGUsIHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcocGFyYW1fMS5fZnJvbUluKGtleSksICdyYXcnKSk7XG4gICAgY2lwaGVyLnN0YXJ0KHsgaXY6IGl2ICYmIHV0aWwuY3JlYXRlQnVmZmVyKHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcocGFyYW1fMS5fZnJvbUluKGl2KSwgJ3JhdycpKSB9KTtcbiAgICBjaXBoZXIudXBkYXRlKHV0aWwuY3JlYXRlQnVmZmVyKHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcoZGF0YSwgJ3JhdycpKSk7XG4gICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgIHJldHVybiBzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKSwgJ3JhdycpO1xufTtcbmV4cG9ydHMuYWVzRGVjcnlwdCA9IGZ1bmN0aW9uIChlbmNyeXB0ZWREYXRhLCBrZXksIG1vZGUsIGl2KSB7XG4gICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gJ0NCQyc7IH1cbiAgICB2YXIgZGVjaXBoZXIgPSBmb3JnZUNpcGhlci5jcmVhdGVEZWNpcGhlcihcIkFFUy1cIiArIG1vZGUsIHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcocGFyYW1fMS5fZnJvbUluKGtleSksICdyYXcnKSk7XG4gICAgZGVjaXBoZXIuc3RhcnQoeyBpdjogaXYgJiYgdXRpbC5jcmVhdGVCdWZmZXIoc3RyaW5nX2J5dGVzXzEuYnl0ZXNUb1N0cmluZyhwYXJhbV8xLl9mcm9tSW4oaXYpLCAncmF3JykpIH0pO1xuICAgIHZhciBlbmNidWYgPSB1dGlsLmNyZWF0ZUJ1ZmZlcihzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKHBhcmFtXzEuX2Zyb21JbihlbmNyeXB0ZWREYXRhKSwgJ3JhdycpKTtcbiAgICBkZWNpcGhlci51cGRhdGUoZW5jYnVmKTtcbiAgICBpZiAoIWRlY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgZGF0YSB3aXRoIHByb3ZpZGVkIGtleScpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhkZWNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKSwgJ3JhdycpO1xufTtcbmV4cG9ydHMubWVzc2FnZUVuY3J5cHQgPSBmdW5jdGlvbiAoc2hhcmVkS2V5LCBtZXNzYWdlKSB7XG4gICAgdmFyIHZlcnNpb24gPSBVaW50OEFycmF5LmZyb20oWzFdKTtcbiAgICB2YXIgQ0VLID0gcmFuZG9tXzEucmFuZG9tQnl0ZXMoMzIpO1xuICAgIHZhciBJViA9IHJhbmRvbV8xLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICB2YXIgbSA9IHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XG4gICAgdmFyIENjID0gZXhwb3J0cy5hZXNFbmNyeXB0KG0sIENFSywgJ0NUUicsIElWKTtcbiAgICB2YXIgQ2NlayA9IGV4cG9ydHMuYWVzRW5jcnlwdChDRUssIHNoYXJlZEtleSwgJ0VDQicpO1xuICAgIHZhciBNaG1hYyA9IGhhc2hpbmdfMS5obWFjU0hBMjU2KG0sIENFSyk7XG4gICAgdmFyIENFS2htYWMgPSBoYXNoaW5nXzEuaG1hY1NIQTI1Nihjb25jYXRfc3BsaXRfMS5jb25jYXQoQ0VLLCBJViksIHNoYXJlZEtleSk7XG4gICAgdmFyIHBhY2thZ2VCeXRlcyA9IGNvbmNhdF9zcGxpdF8xLmNvbmNhdCh2ZXJzaW9uLCBDY2VrLCBDRUtobWFjLCBNaG1hYywgSVYsIENjKTtcbiAgICByZXR1cm4gcGFja2FnZUJ5dGVzO1xufTtcbmV4cG9ydHMubWVzc2FnZURlY3J5cHQgPSBmdW5jdGlvbiAoc2hhcmVkS2V5LCBlbmNyeXB0ZWRNZXNzYWdlKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKGNvbmNhdF9zcGxpdF8xLnNwbGl0KGVuY3J5cHRlZE1lc3NhZ2UsIDEsIDQ4LCAzMiwgMzIsIDE2KSwgNiksIHZlcnNpb24gPSBfYVswXSwgQ2NlayA9IF9hWzFdLCBfQ0VLaG1hYyA9IF9hWzJdLCBfTWhtYWMgPSBfYVszXSwgaXYgPSBfYVs0XSwgQ2MgPSBfYVs1XTtcbiAgICB2YXIgQ0VLID0gZXhwb3J0cy5hZXNEZWNyeXB0KENjZWssIHNoYXJlZEtleSwgJ0VDQicpO1xuICAgIHZhciBDRUtobWFjID0gcGFyYW1fMS5fZnJvbUluKGhhc2hpbmdfMS5obWFjU0hBMjU2KGNvbmNhdF9zcGxpdF8xLmNvbmNhdChDRUssIGl2KSwgcGFyYW1fMS5fZnJvbUluKHNoYXJlZEtleSkpKTtcbiAgICB2YXIgaXNWYWxpZEtleSA9IENFS2htYWMuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYgPT09IF9DRUtobWFjW2ldOyB9KTtcbiAgICBpZiAoIWlzVmFsaWRLZXkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICB2YXIgTSA9IGV4cG9ydHMuYWVzRGVjcnlwdChDYywgQ0VLLCAnQ1RSJywgaXYpO1xuICAgIHZhciBNaG1hYyA9IHBhcmFtXzEuX2Zyb21JbihoYXNoaW5nXzEuaG1hY1NIQTI1NihNLCBDRUspKTtcbiAgICB2YXIgaXNWYWxpZE1lc3NhZ2UgPSBNaG1hYy5ldmVyeShmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gdiA9PT0gX01obWFjW2ldOyB9KTtcbiAgICBpZiAoIWlzVmFsaWRNZXNzYWdlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZScpO1xuICAgIHJldHVybiBzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKE0pO1xufTtcbmV4cG9ydHMuc2hhcmVkS2V5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXlGcm9tLCBwdWJsaWNLZXlUbywgcHJlZml4KSB7XG4gICAgdmFyIHNoYXJlZEtleSA9IGF4bHNpZ25fMS5kZWZhdWx0LnNoYXJlZEtleShwYXJhbV8xLl9mcm9tSW4ocHJpdmF0ZUtleUZyb20pLCBwYXJhbV8xLl9mcm9tSW4ocHVibGljS2V5VG8pKTtcbiAgICB2YXIgcHJlZml4SGFzaCA9IGhhc2hpbmdfMS5zaGEyNTYocGFyYW1fMS5fZnJvbVJhd0luKHByZWZpeCkpO1xuICAgIHJldHVybiBoYXNoaW5nXzEuaG1hY1NIQTI1NihzaGFyZWRLZXksIHByZWZpeEhhc2gpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuY3J5cHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9wYXJhbVwiKTtcbnZhciBzaGEzXzEgPSByZXF1aXJlKFwiLi4vbGlicy9zaGEzXCIpO1xuLy8gQHRzLWlnbm9yZVxudmFyIGZvcmdlSG1hYyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvaG1hY1wiKSk7XG4vLyBAdHMtaWdub3JlXG52YXIgZm9yZ2VNZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvbWRcIikpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3NoYTI1NlwiKTtcbnZhciBibGFrZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vbGlicy9ibGFrZTJiXCIpKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9zdHJpbmctYnl0ZXNcIik7XG5leHBvcnRzLl9oYXNoQ2hhaW4gPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gcGFyYW1fMS5fZnJvbUluKGV4cG9ydHMua2VjY2FrKGV4cG9ydHMuYmxha2UyYihwYXJhbV8xLl9mcm9tSW4oaW5wdXQpKSkpO1xufTtcbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIG1kID0gZm9yZ2VNZC5hbGdvcml0aG1zLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICBtZC51cGRhdGUoc3RyaW5nX2J5dGVzXzEuYnl0ZXNUb1N0cmluZyhpbnB1dCwgJ3JhdycpKTtcbiAgICByZXR1cm4gc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhtZC5kaWdlc3QoKS5nZXRCeXRlcygpLCAncmF3Jyk7XG59O1xuZXhwb3J0cy5ibGFrZTJiID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIGJsYWtlLmJsYWtlMmIocGFyYW1fMS5fZnJvbUluKGlucHV0KSwgbnVsbCwgMzIpO1xufTtcbmV4cG9ydHMua2VjY2FrID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHBhcmFtXzEuX2Zyb21JbihzaGEzXzEua2VjY2FrMjU2LmFycmF5KHBhcmFtXzEuX2Zyb21JbihpbnB1dCkpKTtcbn07XG5leHBvcnRzLmhtYWNTSEEyNTYgPSBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG4gICAgdmFyIGhtYWMgPSBmb3JnZUhtYWMuY3JlYXRlKCk7XG4gICAgaG1hYy5zdGFydCgnc2hhMjU2Jywgc3RyaW5nX2J5dGVzXzEuYnl0ZXNUb1N0cmluZyhwYXJhbV8xLl9mcm9tSW4oa2V5KSwgJ3JhdycpKTtcbiAgICBobWFjLnVwZGF0ZShzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKHBhcmFtXzEuX2Zyb21JbihtZXNzYWdlKSwgJ3JhdycpKTtcbiAgICByZXR1cm4gc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhobWFjLmRpZ2VzdCgpLmdldEJ5dGVzKCksICdyYXcnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuZXhwb3J0cy5QUklWQVRFX0tFWV9MRU5HVEggPSAzMjtcbmV4cG9ydHMuU0lHTkFUVVJFX0xFTkdUSCA9IDY0O1xuZXhwb3J0cy5BRERSRVNTX0xFTkdUSCA9IDI2O1xuZXhwb3J0cy5NQUlOX05FVF9DSEFJTl9JRCA9IDg3OyAvLyBXXG5leHBvcnRzLlRFU1RfTkVUX0NIQUlOX0lEID0gODQ7IC8vIFRcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYXNoaW5nXzEgPSByZXF1aXJlKFwiLi9oYXNoaW5nXCIpO1xudmFyIGNvbmNhdF9zcGxpdF8xID0gcmVxdWlyZShcIi4vY29uY2F0LXNwbGl0XCIpO1xuLyoqXG4gKlxuICogQHBhcmFtIHJvb3RIYXNoXG4gKiBAcGFyYW0gbWVya2xlUHJvb2ZcbiAqIEBwYXJhbSBsZWFmRGF0YVxuICovXG5mdW5jdGlvbiBtZXJrbGVWZXJpZnkocm9vdEhhc2gsIG1lcmtsZVByb29mLCBsZWFmRGF0YSkge1xuICAgIHZhciBMRUFGX1BSRUZJWCA9IFVpbnQ4QXJyYXkuZnJvbShbMF0pO1xuICAgIHZhciBJTlRFUk5BTF9OT0RFX1BSRUZJWCA9IFVpbnQ4QXJyYXkuZnJvbShbMV0pO1xuICAgIGlmIChyb290SGFzaC5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBtZXJrbGVQcm9vZjogSW52YWxpZCByb290SGFzaCBsZW5ndGgnKTtcbiAgICB2YXIgbGVhZkhhc2ggPSBoYXNoaW5nXzEuYmxha2UyYihjb25jYXRfc3BsaXRfMS5jb25jYXQoTEVBRl9QUkVGSVgsIGxlYWZEYXRhKSk7XG4gICAgdmFyIHByb29mc1dpdGhTaWRlID0gW107XG4gICAgdmFyIHByb29mQnl0ZXMgPSBtZXJrbGVQcm9vZi5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgIHdoaWxlIChwcm9vZkJ5dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHNpZGUgPSBwcm9vZkJ5dGVzWzBdID09PSAwID8gJ0wnIDogJ1InO1xuICAgICAgICB2YXIgc2l6ZSA9IHByb29mQnl0ZXNbMV07XG4gICAgICAgIGlmIChzaXplIDwgMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIG1lcmtsZVByb29mOiBXcm9uZyBoYXNoIHNpemUnKTtcbiAgICAgICAgdmFyIGhhc2ggPSBwcm9vZkJ5dGVzLnNsaWNlKDIsIDIgKyBzaXplKTtcbiAgICAgICAgcHJvb2ZzV2l0aFNpZGUucHVzaChbc2lkZSwgaGFzaF0pO1xuICAgICAgICBwcm9vZkJ5dGVzID0gcHJvb2ZCeXRlcy5zbGljZSgyICsgc2l6ZSk7XG4gICAgfVxuICAgIHZhciByb290SGFzaEZyb21Qcm9vZiA9IHByb29mc1dpdGhTaWRlLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBzaWRlID0gX2JbMF0sIGhhc2ggPSBfYlsxXTtcbiAgICAgICAgcmV0dXJuIGhhc2hpbmdfMS5ibGFrZTJiKGNvbmNhdF9zcGxpdF8xLmNvbmNhdChJTlRFUk5BTF9OT0RFX1BSRUZJWCwgc2lkZSA9PT0gJ1InID8gY29uY2F0X3NwbGl0XzEuY29uY2F0KGhhc2gsIGFjYykgOiBjb25jYXRfc3BsaXRfMS5jb25jYXQoYWNjLCBoYXNoKSkpO1xuICAgIH0sIGxlYWZIYXNoKTtcbiAgICByZXR1cm4gcm9vdEhhc2hGcm9tUHJvb2YuZXZlcnkoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYgPT09IHJvb3RIYXNoW2ldOyB9KTtcbn1cbmV4cG9ydHMubWVya2xlVmVyaWZ5ID0gbWVya2xlVmVyaWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVya2xlLXZlcmlmeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEB0cy1pZ25vcmVcbnZhciByYW5kb21fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcmFuZG9tXCIpKTtcbnZhciBzZWVkX3dvcmRzX2xpc3RfMSA9IHJlcXVpcmUoXCIuL3NlZWQtd29yZHMtbGlzdFwiKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9zdHJpbmctYnl0ZXNcIik7XG52YXIgX3JhbmRvbSA9IGZ1bmN0aW9uIChjb3VudCkgeyByZXR1cm4gc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhyYW5kb21fMS5kZWZhdWx0LmdldEJ5dGVzU3luYyhjb3VudCksICdyYXcnKTsgfTtcbnZhciBlbnN1cmVCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGIgPSBuZXcgQnVmZmVyKDEpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuIFVzZSBOb2RlLmpzIG9yIEJyb3dzZXJpZnkgZm9yIGJyb3dzZXIgc3VwcG9ydC4nKTtcbiAgICB9XG59O1xuZXhwb3J0cy5yYW5kb20gPSBmdW5jdGlvbiAoY291bnQsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnQXJyYXk4JzpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKF9yYW5kb20oY291bnQpKTtcbiAgICAgICAgY2FzZSAnQXJyYXkxNic6XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShleHBvcnRzLnJhbmRvbShjb3VudCwgJ1VpbnQxNkFycmF5JykpO1xuICAgICAgICBjYXNlICdBcnJheTMyJzpcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGV4cG9ydHMucmFuZG9tKGNvdW50LCAnVWludDMyQXJyYXknKSk7XG4gICAgICAgIGNhc2UgJ0J1ZmZlcic6XG4gICAgICAgICAgICBlbnN1cmVCdWZmZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShfcmFuZG9tKGNvdW50KSk7XG4gICAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIF9yYW5kb20oY291bnQpO1xuICAgICAgICBjYXNlICdVaW50MTZBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KGNvdW50KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF9yYW5kb20oMikucmVkdWNlKGZ1bmN0aW9uIChhLCBiLCBpKSB7IHJldHVybiBhIHwgYiA8PCA4ICogKDEgLSBpKTsgfSwgMCk7IH0pO1xuICAgICAgICBjYXNlICdVaW50MzJBcnJheSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGNvdW50KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF9yYW5kb20oNCkucmVkdWNlKGZ1bmN0aW9uIChhLCBiLCBpKSB7IHJldHVybiBhIHwgYiA8PCA4ICogKDEgLSBpKTsgfSwgMCk7IH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyAnIGlzIHVuc3VwcG9ydGVkLicpO1xuICAgIH1cbn07XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBleHBvcnRzLnJhbmRvbShsZW5ndGgsICdVaW50OEFycmF5Jyk7XG59O1xuZXhwb3J0cy5yYW5kb21TZWVkID0gZnVuY3Rpb24gKHdvcmRzQ291bnQpIHtcbiAgICBpZiAod29yZHNDb3VudCA9PT0gdm9pZCAwKSB7IHdvcmRzQ291bnQgPSAxNTsgfVxuICAgIHJldHVybiBleHBvcnRzLnJhbmRvbSh3b3Jkc0NvdW50LCAnQXJyYXkzMicpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHNlZWRfd29yZHNfbGlzdF8xLnNlZWRXb3Jkc0xpc3RbeCAlIHNlZWRfd29yZHNfbGlzdF8xLnNlZWRXb3Jkc0xpc3QubGVuZ3RoXTsgfSlcbiAgICAgICAgLmpvaW4oJyAnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF90aGlzID0gdGhpcztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEB0cy1pZ25vcmVcbnZhciBwa2kgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BraVwiKSk7XG4vLyBAdHMtaWdub3JlXG52YXIgbWQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL21kXCIpKTtcbi8vIEB0cy1pZ25vcmVcbnZhciBtZDUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL21kNVwiKSk7XG4vLyBAdHMtaWdub3JlXG52YXIgdXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvdXRpbFwiKSk7XG52YXIgYmFzZV94eF8xID0gcmVxdWlyZShcIi4uL2NvbnZlcnNpb25zL2Jhc2UteHhcIik7XG52YXIgc3RyaW5nX2J5dGVzXzEgPSByZXF1aXJlKFwiLi4vY29udmVyc2lvbnMvc3RyaW5nLWJ5dGVzXCIpO1xudmFyIHNoYTMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImpzLXNoYTNcIikpO1xuLy8gSEFDSy4gTW9ua2V5IHBhdGNoIG5vZGUtZm9yZ2UgbGlicmFyeSB0byBwcm92aWRlIG9pZHMgZm9yIG1pc3NpbmcgaGFzaCBhbGdvcml0aG1zXG5wa2kub2lkc1snc2hhMjI0J10gPSAnMi4xNi44NDAuMS4xMDEuMy40LjIuNCc7XG5wa2kub2lkc1snMi4xNi44NDAuMS4xMDEuMy40LjIuNCddID0gJ3NoYTIyNCc7XG5wa2kub2lkc1snc2hhMy0yMjQnXSA9ICcyLjE2Ljg0MC4xLjEwMS4zLjQuMi43JztcbnBraS5vaWRzWycyLjE2Ljg0MC4xLjEwMS4zLjQuMi43J10gPSAnc2hhMy0yMjQnO1xucGtpLm9pZHNbJ3NoYTMtMjU2J10gPSAnMi4xNi44NDAuMS4xMDEuMy40LjIuOCc7XG5wa2kub2lkc1snMi4xNi44NDAuMS4xMDEuMy40LjIuOCddID0gJ3NoYTMtMjU2JztcbnBraS5vaWRzWydzaGEzLTM4NCddID0gJzIuMTYuODQwLjEuMTAxLjMuNC4yLjknO1xucGtpLm9pZHNbJzIuMTYuODQwLjEuMTAxLjMuNC4yLjknXSA9ICdzaGEzLTM4NCc7XG5wa2kub2lkc1snc2hhMy01MTInXSA9ICcyLjE2Ljg0MC4xLjEwMS4zLjQuMi4xMCc7XG5wa2kub2lkc1snMi4xNi44NDAuMS4xMDEuMy40LjIuMTAnXSA9ICdzaGEzLTUxMic7XG5leHBvcnRzLnBlbVRvQnl0ZXMgPSBmdW5jdGlvbiAocGVtKSB7IHJldHVybiBiYXNlX3h4XzEuYmFzZTY0RGVjb2RlKHBlbS50cmltKClcbiAgICAuc3BsaXQoL1xcclxcbnxcXG4vKVxuICAgIC5zbGljZSgxLCAtMSkuam9pbignJylcbiAgICAudHJpbSgpKTsgfTtcbnZhciBwZW1UeXBlTWFwID0ge1xuICAgIHJzYVByaXZhdGVOb25FbmNyeXB0ZWQ6ICdSU0EgUFJJVkFURSBLRVknLFxuICAgIHJzYVB1YmxpYzogJ1BVQkxJQyBLRVknLFxufTtcbmV4cG9ydHMuYnl0ZXNUb1BlbSA9IGZ1bmN0aW9uIChieXRlcywgdHlwZSkge1xuICAgIHZhciBoZWFkZXIgPSBcIi0tLS0tQkVHSU4gXCIgKyBwZW1UeXBlTWFwW3R5cGVdICsgXCItLS0tLVxcblwiO1xuICAgIHZhciBmb290ZXIgPSBcIi0tLS0tRU5EIFwiICsgcGVtVHlwZU1hcFt0eXBlXSArIFwiLS0tLS1cXG5cIjtcbiAgICB2YXIgYjY0Y2hhcmFjdGVycyA9IGJhc2VfeHhfMS5iYXNlNjRFbmNvZGUoYnl0ZXMpO1xuICAgIGlmIChiNjRjaGFyYWN0ZXJzLmxlbmd0aCAlIDY0ICE9PSAwKSB7XG4gICAgICAgIGI2NGNoYXJhY3RlcnMgKz0gJyAnLnJlcGVhdCg2NCAtIGI2NGNoYXJhY3RlcnMubGVuZ3RoICUgNjQpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gaGVhZGVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGI2NGNoYXJhY3RlcnMubGVuZ3RoIC8gNjQpOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IGI2NGNoYXJhY3RlcnMuc2xpY2UoaSAqIDY0LCAoaSArIDEpICogNjQpICsgJ1xcbic7XG4gICAgfVxuICAgIHJlc3VsdCArPSBmb290ZXI7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnJzYUtleVBhaXJTeW5jID0gZnVuY3Rpb24gKGJpdHMsIGUpIHtcbiAgICB2YXIga3AgPSBwa2kucnNhLmdlbmVyYXRlS2V5UGFpcihiaXRzLCBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByc2FQcml2YXRlOiBleHBvcnRzLnBlbVRvQnl0ZXMocGtpLnByaXZhdGVLZXlUb1BlbShrcC5wcml2YXRlS2V5KSksXG4gICAgICAgIHJzYVB1YmxpYzogZXhwb3J0cy5wZW1Ub0J5dGVzKHBraS5wdWJsaWNLZXlUb1BlbShrcC5wdWJsaWNLZXkpKSxcbiAgICB9O1xufTtcbmV4cG9ydHMucnNhS2V5UGFpciA9IGZ1bmN0aW9uIChiaXRzLCBlKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyKGJpdHMsIGUsIGZ1bmN0aW9uIChlcnIsIGtwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByc2FQcml2YXRlOiBleHBvcnRzLnBlbVRvQnl0ZXMocGtpLnByaXZhdGVLZXlUb1BlbShrcC5wcml2YXRlS2V5KSksXG4gICAgICAgICAgICAgICAgICAgICAgICByc2FQdWJsaWM6IGV4cG9ydHMucGVtVG9CeXRlcyhwa2kucHVibGljS2V5VG9QZW0oa3AucHVibGljS2V5KSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSldO1xuICAgIH0pO1xufSk7IH07XG52YXIgZGlnZXN0Q3JlYXRvclBsYWNlSG9sZGVyID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWdlc3QgXCIgKyB0eXBlICsgXCIgaXMgdW5zdXBwb3J0ZWRcIik7XG59OyB9O1xudmFyIE1lc3NhZ2VEaWdlc3RBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VEaWdlc3RBZGFwdGVyKHNoYTNEaWdlc3QsIGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLnNoYTNEaWdlc3QgPSBzaGEzRGlnZXN0O1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICB9XG4gICAgTWVzc2FnZURpZ2VzdEFkYXB0ZXIubWFrZUNyZWF0b3IgPSBmdW5jdGlvbiAoc2hhM0hhc2gsIGFsZ29yaXRobU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHsgY3JlYXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWVzc2FnZURpZ2VzdEFkYXB0ZXIoc2hhM0hhc2guY3JlYXRlKCksIGFsZ29yaXRobU5hbWUpOyB9IH07XG4gICAgfTtcbiAgICBNZXNzYWdlRGlnZXN0QWRhcHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1zZywgZW5jb2RpbmcpIHtcbiAgICAgICAgdGhpcy5zaGEzRGlnZXN0LnVwZGF0ZShzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKG1zZywgZW5jb2RpbmcgPT0gbnVsbCA/ICdyYXcnIDogZW5jb2RpbmcpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBNZXNzYWdlRGlnZXN0QWRhcHRlci5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBVaW50OEFycmF5LmZyb20odGhpcy5zaGEzRGlnZXN0LmRpZ2VzdCgpKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuY3JlYXRlQnVmZmVyKHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcoYnl0ZXMsICdyYXcnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVzc2FnZURpZ2VzdEFkYXB0ZXI7XG59KCkpO1xudmFyIGRpZ2VzdE1hcCA9IHtcbiAgICAnTUQ1JzogbWQ1LFxuICAgICdTSEExJzogbWQuYWxnb3JpdGhtcy5zaGExLFxuICAgICdTSEEyMjQnOiBkaWdlc3RDcmVhdG9yUGxhY2VIb2xkZXIoJ1NIQTIyNCcpLFxuICAgICdTSEEyNTYnOiBtZC5hbGdvcml0aG1zLnNoYTI1NixcbiAgICAnU0hBMzg0JzogbWQuYWxnb3JpdGhtcy5zaGEzODQsXG4gICAgJ1NIQTUxMic6IG1kLmFsZ29yaXRobXMuc2hhNTEyLFxuICAgICdTSEEzLTIyNCc6IE1lc3NhZ2VEaWdlc3RBZGFwdGVyLm1ha2VDcmVhdG9yKHNoYTMuc2hhM18yMjQsICdzaGEzLTIyNCcpLFxuICAgICdTSEEzLTI1Nic6IE1lc3NhZ2VEaWdlc3RBZGFwdGVyLm1ha2VDcmVhdG9yKHNoYTMuc2hhM18yNTYsICdzaGEzLTI1NicpLFxuICAgICdTSEEzLTM4NCc6IE1lc3NhZ2VEaWdlc3RBZGFwdGVyLm1ha2VDcmVhdG9yKHNoYTMuc2hhM18zODQsICdzaGEzLTM4NCcpLFxuICAgICdTSEEzLTUxMic6IE1lc3NhZ2VEaWdlc3RBZGFwdGVyLm1ha2VDcmVhdG9yKHNoYTMuc2hhM181MTIsICdzaGEzLTUxMicpLFxufTtcbmV4cG9ydHMucnNhU2lnbiA9IGZ1bmN0aW9uIChyc2FQcml2YXRlS2V5LCBtZXNzYWdlLCBkaWdlc3QpIHtcbiAgICBpZiAoZGlnZXN0ID09PSB2b2lkIDApIHsgZGlnZXN0ID0gJ1NIQTI1Nic7IH1cbiAgICB2YXIgcyA9IGV4cG9ydHMuYnl0ZXNUb1BlbShyc2FQcml2YXRlS2V5LCAncnNhUHJpdmF0ZU5vbkVuY3J5cHRlZCcpO1xuICAgIHZhciBzayA9IHBraS5wcml2YXRlS2V5RnJvbVBlbShzKTtcbiAgICB2YXIgX2RpZ2VzdCA9IGRpZ2VzdE1hcFtkaWdlc3RdLmNyZWF0ZSgpO1xuICAgIF9kaWdlc3QudXBkYXRlKHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcobWVzc2FnZSwgJ3JhdycpKTtcbiAgICByZXR1cm4gc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhzay5zaWduKF9kaWdlc3QpLCAncmF3Jyk7XG59O1xuZXhwb3J0cy5yc2FWZXJpZnkgPSBmdW5jdGlvbiAocnNhUHVibGljS2V5LCBtZXNzYWdlLCBzaWduYXR1cmUsIGRpZ2VzdCkge1xuICAgIGlmIChkaWdlc3QgPT09IHZvaWQgMCkgeyBkaWdlc3QgPSAnU0hBMjU2JzsgfVxuICAgIHZhciBwayA9IHBraS5wdWJsaWNLZXlGcm9tUGVtKGV4cG9ydHMuYnl0ZXNUb1BlbShyc2FQdWJsaWNLZXksICdyc2FQdWJsaWMnKSk7XG4gICAgdmFyIF9kaWdlc3QgPSBkaWdlc3RNYXBbZGlnZXN0XS5jcmVhdGUoKTtcbiAgICBfZGlnZXN0LnVwZGF0ZShzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKG1lc3NhZ2UpLCAncmF3Jyk7XG4gICAgcmV0dXJuIHBrLnZlcmlmeShfZGlnZXN0LmRpZ2VzdCgpLmdldEJ5dGVzKCksIHN0cmluZ19ieXRlc18xLmJ5dGVzVG9TdHJpbmcoc2lnbmF0dXJlLCAncmF3JykpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJzYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9zdHJpbmctYnl0ZXNcIik7XG4vLyBAdHMtaWdub3JlXG52YXIgZm9yZ2VNZDUgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL21kNVwiKSk7XG52YXIgY29uY2F0X3NwbGl0XzEgPSByZXF1aXJlKFwiLi9jb25jYXQtc3BsaXRcIik7XG52YXIgZW5jcnlwdGlvbl8xID0gcmVxdWlyZShcIi4vZW5jcnlwdGlvblwiKTtcbnZhciBiYXNlX3h4XzEgPSByZXF1aXJlKFwiLi4vY29udmVyc2lvbnMvYmFzZS14eFwiKTtcbnZhciBoYXNoaW5nXzEgPSByZXF1aXJlKFwiLi9oYXNoaW5nXCIpO1xudmFyIHJhbmRvbV8xID0gcmVxdWlyZShcIi4vcmFuZG9tXCIpO1xuZnVuY3Rpb24gc3RyZW5ndGhlblBhc3N3b3JkKHBhc3N3b3JkLCByb3VuZHMpIHtcbiAgICBpZiAocm91bmRzID09PSB2b2lkIDApIHsgcm91bmRzID0gNTAwMDsgfVxuICAgIHdoaWxlIChyb3VuZHMtLSkge1xuICAgICAgICB2YXIgYnl0ZXMgPSBzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKHBhc3N3b3JkKTtcbiAgICAgICAgcGFzc3dvcmQgPSBiYXNlX3h4XzEuYmFzZTE2RW5jb2RlKGhhc2hpbmdfMS5zaGEyNTYoYnl0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3N3b3JkO1xufVxuZnVuY3Rpb24gZXZwS2RmKHBhc3NwaHJhc2UsIHNhbHQsIG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkgeyBvdXRwdXQgPSA0ODsgfVxuICAgIHZhciBwYXNzUGx1c1NhbHQgPSBzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKGNvbmNhdF9zcGxpdF8xLmNvbmNhdChwYXNzcGhyYXNlLCBzYWx0KSwgJ3JhdycpO1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgZmluYWxfa2V5ID0ga2V5O1xuICAgIHdoaWxlIChmaW5hbF9rZXkubGVuZ3RoIDwgb3V0cHV0KSB7XG4gICAgICAgIGtleSA9IGZvcmdlTWQ1LmNyZWF0ZSgpLnVwZGF0ZShrZXkgKyBwYXNzUGx1c1NhbHQpLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG4gICAgICAgIGZpbmFsX2tleSArPSBrZXk7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbF9rZXk7XG59XG4vKipcbiAqIEVuY3J5cHRzIGFyYml0cmFyeSB1dGY4IHN0cmluZyB3aXRoIHV0ZjggcGFzc3dvcmQuIEV2cCBrZXkgZGVyaXZpbmcgZnVuY3Rpb24gaXMgdXNlZCB0byBnZXQgZW5jcnlwdGlvbiBrZXkgYW5kIElWIGZyb21cbiAqIHBhc3N3b3JkLiBBRVMtQ0JDIGFsZ29yaXRobSBpcyB1c2VkIGZvciBlbmNyeXB0aW9uLiBPdXRwdXQgZm9ybWF0IGlzIGJhc2U2NCBlbmNvZGVkIE9wZW5TU0xcbiAqIEBwYXJhbSBzZWVkIC0gdXRmOCBzdHJpbmcgdG8gZW5jcnlwdFxuICogQHBhcmFtIHBhc3N3b3JkIC0gdXRmOCBwYXNzd29yZFxuICogQHBhcmFtIGVuY3J5cHRpb25Sb3VuZHMgLSBob3cgbWFueSB0aW1lcyBwYXNzd29yZCB3aWxsIGJlIGhhc2hlZC4gRGVmYXVsdCA9IDUwMDBcbiAqL1xuZXhwb3J0cy5lbmNyeXB0U2VlZCA9IGZ1bmN0aW9uIChzZWVkLCBwYXNzd29yZCwgZW5jcnlwdGlvblJvdW5kcykge1xuICAgIHZhciBwYXNzcGhyYXNlID0gc3RyZW5ndGhlblBhc3N3b3JkKHBhc3N3b3JkLCBlbmNyeXB0aW9uUm91bmRzKTtcbiAgICB2YXIgc2FsdCA9IHJhbmRvbV8xLnJhbmRvbUJ5dGVzKDgpO1xuICAgIHZhciBrZXlfaXYgPSBldnBLZGYoc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhwYXNzcGhyYXNlLCAncmF3JyksIHNhbHQpO1xuICAgIHZhciBrZXkgPSBzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKGtleV9pdi5zbGljZSgwLCAzMiksICdyYXcnKTtcbiAgICB2YXIgaXYgPSBzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKGtleV9pdi5zbGljZSgzMiksICdyYXcnKTtcbiAgICB2YXIgZW5jcnlwdGVkID0gZW5jcnlwdGlvbl8xLmFlc0VuY3J5cHQoc3RyaW5nX2J5dGVzXzEuc3RyaW5nVG9CeXRlcyhzZWVkKSwga2V5LCAnQ0JDJywgaXYpO1xuICAgIHJldHVybiBiYXNlX3h4XzEuYmFzZTY0RW5jb2RlKGNvbmNhdF9zcGxpdF8xLmNvbmNhdChzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKCdTYWx0ZWRfXycpLCBzYWx0LCBlbmNyeXB0ZWQpKTtcbn07XG5leHBvcnRzLmRlY3J5cHRTZWVkID0gZnVuY3Rpb24gKGVuY3J5cHRlZFNlZWQsIHBhc3N3b3JkLCBlbmNyeXB0aW9uUm91bmRzKSB7XG4gICAgdmFyIHBhc3NwaHJhc2UgPSBzdHJlbmd0aGVuUGFzc3dvcmQocGFzc3dvcmQsIGVuY3J5cHRpb25Sb3VuZHMpO1xuICAgIHZhciBlbmNCeXRlcyA9IGJhc2VfeHhfMS5iYXNlNjREZWNvZGUoZW5jcnlwdGVkU2VlZCk7XG4gICAgdmFyIHNhbHQgPSBlbmNCeXRlcy5zbGljZSg4LCAxNik7XG4gICAgdmFyIGtleV9pdiA9IGV2cEtkZihzdHJpbmdfYnl0ZXNfMS5zdHJpbmdUb0J5dGVzKHBhc3NwaHJhc2UsICdyYXcnKSwgc2FsdCk7XG4gICAgdmFyIGtleSA9IHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXMoa2V5X2l2LnNsaWNlKDAsIDMyKSwgJ3JhdycpO1xuICAgIHZhciBpdiA9IHN0cmluZ19ieXRlc18xLnN0cmluZ1RvQnl0ZXMoa2V5X2l2LnNsaWNlKDMyKSwgJ3JhdycpO1xuICAgIHJldHVybiBzdHJpbmdfYnl0ZXNfMS5ieXRlc1RvU3RyaW5nKGVuY3J5cHRpb25fMS5hZXNEZWNyeXB0KGVuY0J5dGVzLnNsaWNlKDE2KSwga2V5LCAnQ0JDJywgaXYpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWVkLWVjcnlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VlZFdvcmRzTGlzdCA9IFtcbiAgICAnYWJhbmRvbicsICdhYmlsaXR5JywgJ2FibGUnLCAnYWJvdXQnLCAnYWJvdmUnLCAnYWJzZW50JywgJ2Fic29yYicsICdhYnN0cmFjdCcsICdhYnN1cmQnLCAnYWJ1c2UnLCAnYWNjZXNzJyxcbiAgICAnYWNjaWRlbnQnLCAnYWNjb3VudCcsICdhY2N1c2UnLCAnYWNoaWV2ZScsICdhY2lkJywgJ2Fjb3VzdGljJywgJ2FjcXVpcmUnLCAnYWNyb3NzJywgJ2FjdCcsICdhY3Rpb24nLFxuICAgICdhY3RvcicsICdhY3RyZXNzJywgJ2FjdHVhbCcsICdhZGFwdCcsICdhZGQnLCAnYWRkaWN0JywgJ2FkZHJlc3MnLCAnYWRqdXN0JywgJ2FkbWl0JywgJ2FkdWx0JywgJ2FkdmFuY2UnLFxuICAgICdhZHZpY2UnLCAnYWVyb2JpYycsICdhZmZhaXInLCAnYWZmb3JkJywgJ2FmcmFpZCcsICdhZ2FpbicsICdhZ2UnLCAnYWdlbnQnLCAnYWdyZWUnLCAnYWhlYWQnLCAnYWltJywgJ2FpcicsXG4gICAgJ2FpcnBvcnQnLCAnYWlzbGUnLCAnYWxhcm0nLCAnYWxidW0nLCAnYWxjb2hvbCcsICdhbGVydCcsICdhbGllbicsICdhbGwnLCAnYWxsZXknLCAnYWxsb3cnLCAnYWxtb3N0JyxcbiAgICAnYWxvbmUnLCAnYWxwaGEnLCAnYWxyZWFkeScsICdhbHNvJywgJ2FsdGVyJywgJ2Fsd2F5cycsICdhbWF0ZXVyJywgJ2FtYXppbmcnLCAnYW1vbmcnLCAnYW1vdW50JywgJ2FtdXNlZCcsXG4gICAgJ2FuYWx5c3QnLCAnYW5jaG9yJywgJ2FuY2llbnQnLCAnYW5nZXInLCAnYW5nbGUnLCAnYW5ncnknLCAnYW5pbWFsJywgJ2Fua2xlJywgJ2Fubm91bmNlJywgJ2FubnVhbCcsXG4gICAgJ2Fub3RoZXInLCAnYW5zd2VyJywgJ2FudGVubmEnLCAnYW50aXF1ZScsICdhbnhpZXR5JywgJ2FueScsICdhcGFydCcsICdhcG9sb2d5JywgJ2FwcGVhcicsICdhcHBsZScsXG4gICAgJ2FwcHJvdmUnLCAnYXByaWwnLCAnYXJjaCcsICdhcmN0aWMnLCAnYXJlYScsICdhcmVuYScsICdhcmd1ZScsICdhcm0nLCAnYXJtZWQnLCAnYXJtb3InLCAnYXJteScsICdhcm91bmQnLFxuICAgICdhcnJhbmdlJywgJ2FycmVzdCcsICdhcnJpdmUnLCAnYXJyb3cnLCAnYXJ0JywgJ2FydGVmYWN0JywgJ2FydGlzdCcsICdhcnR3b3JrJywgJ2FzaycsICdhc3BlY3QnLCAnYXNzYXVsdCcsXG4gICAgJ2Fzc2V0JywgJ2Fzc2lzdCcsICdhc3N1bWUnLCAnYXN0aG1hJywgJ2F0aGxldGUnLCAnYXRvbScsICdhdHRhY2snLCAnYXR0ZW5kJywgJ2F0dGl0dWRlJywgJ2F0dHJhY3QnLFxuICAgICdhdWN0aW9uJywgJ2F1ZGl0JywgJ2F1Z3VzdCcsICdhdW50JywgJ2F1dGhvcicsICdhdXRvJywgJ2F1dHVtbicsICdhdmVyYWdlJywgJ2F2b2NhZG8nLCAnYXZvaWQnLCAnYXdha2UnLFxuICAgICdhd2FyZScsICdhd2F5JywgJ2F3ZXNvbWUnLCAnYXdmdWwnLCAnYXdrd2FyZCcsICdheGlzJywgJ2JhYnknLCAnYmFjaGVsb3InLCAnYmFjb24nLCAnYmFkZ2UnLCAnYmFnJyxcbiAgICAnYmFsYW5jZScsICdiYWxjb255JywgJ2JhbGwnLCAnYmFtYm9vJywgJ2JhbmFuYScsICdiYW5uZXInLCAnYmFyJywgJ2JhcmVseScsICdiYXJnYWluJywgJ2JhcnJlbCcsICdiYXNlJyxcbiAgICAnYmFzaWMnLCAnYmFza2V0JywgJ2JhdHRsZScsICdiZWFjaCcsICdiZWFuJywgJ2JlYXV0eScsICdiZWNhdXNlJywgJ2JlY29tZScsICdiZWVmJywgJ2JlZm9yZScsICdiZWdpbicsXG4gICAgJ2JlaGF2ZScsICdiZWhpbmQnLCAnYmVsaWV2ZScsICdiZWxvdycsICdiZWx0JywgJ2JlbmNoJywgJ2JlbmVmaXQnLCAnYmVzdCcsICdiZXRyYXknLCAnYmV0dGVyJywgJ2JldHdlZW4nLFxuICAgICdiZXlvbmQnLCAnYmljeWNsZScsICdiaWQnLCAnYmlrZScsICdiaW5kJywgJ2Jpb2xvZ3knLCAnYmlyZCcsICdiaXJ0aCcsICdiaXR0ZXInLCAnYmxhY2snLCAnYmxhZGUnLCAnYmxhbWUnLFxuICAgICdibGFua2V0JywgJ2JsYXN0JywgJ2JsZWFrJywgJ2JsZXNzJywgJ2JsaW5kJywgJ2Jsb29kJywgJ2Jsb3Nzb20nLCAnYmxvdXNlJywgJ2JsdWUnLCAnYmx1cicsICdibHVzaCcsXG4gICAgJ2JvYXJkJywgJ2JvYXQnLCAnYm9keScsICdib2lsJywgJ2JvbWInLCAnYm9uZScsICdib251cycsICdib29rJywgJ2Jvb3N0JywgJ2JvcmRlcicsICdib3JpbmcnLCAnYm9ycm93JyxcbiAgICAnYm9zcycsICdib3R0b20nLCAnYm91bmNlJywgJ2JveCcsICdib3knLCAnYnJhY2tldCcsICdicmFpbicsICdicmFuZCcsICdicmFzcycsICdicmF2ZScsICdicmVhZCcsICdicmVlemUnLFxuICAgICdicmljaycsICdicmlkZ2UnLCAnYnJpZWYnLCAnYnJpZ2h0JywgJ2JyaW5nJywgJ2JyaXNrJywgJ2Jyb2Njb2xpJywgJ2Jyb2tlbicsICdicm9uemUnLCAnYnJvb20nLCAnYnJvdGhlcicsXG4gICAgJ2Jyb3duJywgJ2JydXNoJywgJ2J1YmJsZScsICdidWRkeScsICdidWRnZXQnLCAnYnVmZmFsbycsICdidWlsZCcsICdidWxiJywgJ2J1bGsnLCAnYnVsbGV0JywgJ2J1bmRsZScsXG4gICAgJ2J1bmtlcicsICdidXJkZW4nLCAnYnVyZ2VyJywgJ2J1cnN0JywgJ2J1cycsICdidXNpbmVzcycsICdidXN5JywgJ2J1dHRlcicsICdidXllcicsICdidXp6JywgJ2NhYmJhZ2UnLFxuICAgICdjYWJpbicsICdjYWJsZScsICdjYWN0dXMnLCAnY2FnZScsICdjYWtlJywgJ2NhbGwnLCAnY2FsbScsICdjYW1lcmEnLCAnY2FtcCcsICdjYW4nLCAnY2FuYWwnLCAnY2FuY2VsJyxcbiAgICAnY2FuZHknLCAnY2Fubm9uJywgJ2Nhbm9lJywgJ2NhbnZhcycsICdjYW55b24nLCAnY2FwYWJsZScsICdjYXBpdGFsJywgJ2NhcHRhaW4nLCAnY2FyJywgJ2NhcmJvbicsICdjYXJkJyxcbiAgICAnY2FyZ28nLCAnY2FycGV0JywgJ2NhcnJ5JywgJ2NhcnQnLCAnY2FzZScsICdjYXNoJywgJ2Nhc2lubycsICdjYXN0bGUnLCAnY2FzdWFsJywgJ2NhdCcsICdjYXRhbG9nJywgJ2NhdGNoJyxcbiAgICAnY2F0ZWdvcnknLCAnY2F0dGxlJywgJ2NhdWdodCcsICdjYXVzZScsICdjYXV0aW9uJywgJ2NhdmUnLCAnY2VpbGluZycsICdjZWxlcnknLCAnY2VtZW50JywgJ2NlbnN1cycsXG4gICAgJ2NlbnR1cnknLCAnY2VyZWFsJywgJ2NlcnRhaW4nLCAnY2hhaXInLCAnY2hhbGsnLCAnY2hhbXBpb24nLCAnY2hhbmdlJywgJ2NoYW9zJywgJ2NoYXB0ZXInLCAnY2hhcmdlJyxcbiAgICAnY2hhc2UnLCAnY2hhdCcsICdjaGVhcCcsICdjaGVjaycsICdjaGVlc2UnLCAnY2hlZicsICdjaGVycnknLCAnY2hlc3QnLCAnY2hpY2tlbicsICdjaGllZicsICdjaGlsZCcsXG4gICAgJ2NoaW1uZXknLCAnY2hvaWNlJywgJ2Nob29zZScsICdjaHJvbmljJywgJ2NodWNrbGUnLCAnY2h1bmsnLCAnY2h1cm4nLCAnY2lnYXInLCAnY2lubmFtb24nLCAnY2lyY2xlJyxcbiAgICAnY2l0aXplbicsICdjaXR5JywgJ2NpdmlsJywgJ2NsYWltJywgJ2NsYXAnLCAnY2xhcmlmeScsICdjbGF3JywgJ2NsYXknLCAnY2xlYW4nLCAnY2xlcmsnLCAnY2xldmVyJywgJ2NsaWNrJyxcbiAgICAnY2xpZW50JywgJ2NsaWZmJywgJ2NsaW1iJywgJ2NsaW5pYycsICdjbGlwJywgJ2Nsb2NrJywgJ2Nsb2cnLCAnY2xvc2UnLCAnY2xvdGgnLCAnY2xvdWQnLCAnY2xvd24nLCAnY2x1YicsXG4gICAgJ2NsdW1wJywgJ2NsdXN0ZXInLCAnY2x1dGNoJywgJ2NvYWNoJywgJ2NvYXN0JywgJ2NvY29udXQnLCAnY29kZScsICdjb2ZmZWUnLCAnY29pbCcsICdjb2luJywgJ2NvbGxlY3QnLFxuICAgICdjb2xvcicsICdjb2x1bW4nLCAnY29tYmluZScsICdjb21lJywgJ2NvbWZvcnQnLCAnY29taWMnLCAnY29tbW9uJywgJ2NvbXBhbnknLCAnY29uY2VydCcsICdjb25kdWN0JyxcbiAgICAnY29uZmlybScsICdjb25ncmVzcycsICdjb25uZWN0JywgJ2NvbnNpZGVyJywgJ2NvbnRyb2wnLCAnY29udmluY2UnLCAnY29vaycsICdjb29sJywgJ2NvcHBlcicsICdjb3B5JyxcbiAgICAnY29yYWwnLCAnY29yZScsICdjb3JuJywgJ2NvcnJlY3QnLCAnY29zdCcsICdjb3R0b24nLCAnY291Y2gnLCAnY291bnRyeScsICdjb3VwbGUnLCAnY291cnNlJywgJ2NvdXNpbicsXG4gICAgJ2NvdmVyJywgJ2NveW90ZScsICdjcmFjaycsICdjcmFkbGUnLCAnY3JhZnQnLCAnY3JhbScsICdjcmFuZScsICdjcmFzaCcsICdjcmF0ZXInLCAnY3Jhd2wnLCAnY3JhenknLFxuICAgICdjcmVhbScsICdjcmVkaXQnLCAnY3JlZWsnLCAnY3JldycsICdjcmlja2V0JywgJ2NyaW1lJywgJ2NyaXNwJywgJ2NyaXRpYycsICdjcm9wJywgJ2Nyb3NzJywgJ2Nyb3VjaCcsXG4gICAgJ2Nyb3dkJywgJ2NydWNpYWwnLCAnY3J1ZWwnLCAnY3J1aXNlJywgJ2NydW1ibGUnLCAnY3J1bmNoJywgJ2NydXNoJywgJ2NyeScsICdjcnlzdGFsJywgJ2N1YmUnLCAnY3VsdHVyZScsXG4gICAgJ2N1cCcsICdjdXBib2FyZCcsICdjdXJpb3VzJywgJ2N1cnJlbnQnLCAnY3VydGFpbicsICdjdXJ2ZScsICdjdXNoaW9uJywgJ2N1c3RvbScsICdjdXRlJywgJ2N5Y2xlJywgJ2RhZCcsXG4gICAgJ2RhbWFnZScsICdkYW1wJywgJ2RhbmNlJywgJ2RhbmdlcicsICdkYXJpbmcnLCAnZGFzaCcsICdkYXVnaHRlcicsICdkYXduJywgJ2RheScsICdkZWFsJywgJ2RlYmF0ZScsXG4gICAgJ2RlYnJpcycsICdkZWNhZGUnLCAnZGVjZW1iZXInLCAnZGVjaWRlJywgJ2RlY2xpbmUnLCAnZGVjb3JhdGUnLCAnZGVjcmVhc2UnLCAnZGVlcicsICdkZWZlbnNlJywgJ2RlZmluZScsXG4gICAgJ2RlZnknLCAnZGVncmVlJywgJ2RlbGF5JywgJ2RlbGl2ZXInLCAnZGVtYW5kJywgJ2RlbWlzZScsICdkZW5pYWwnLCAnZGVudGlzdCcsICdkZW55JywgJ2RlcGFydCcsICdkZXBlbmQnLFxuICAgICdkZXBvc2l0JywgJ2RlcHRoJywgJ2RlcHV0eScsICdkZXJpdmUnLCAnZGVzY3JpYmUnLCAnZGVzZXJ0JywgJ2Rlc2lnbicsICdkZXNrJywgJ2Rlc3BhaXInLCAnZGVzdHJveScsXG4gICAgJ2RldGFpbCcsICdkZXRlY3QnLCAnZGV2ZWxvcCcsICdkZXZpY2UnLCAnZGV2b3RlJywgJ2RpYWdyYW0nLCAnZGlhbCcsICdkaWFtb25kJywgJ2RpYXJ5JywgJ2RpY2UnLCAnZGllc2VsJyxcbiAgICAnZGlldCcsICdkaWZmZXInLCAnZGlnaXRhbCcsICdkaWduaXR5JywgJ2RpbGVtbWEnLCAnZGlubmVyJywgJ2Rpbm9zYXVyJywgJ2RpcmVjdCcsICdkaXJ0JywgJ2Rpc2FncmVlJyxcbiAgICAnZGlzY292ZXInLCAnZGlzZWFzZScsICdkaXNoJywgJ2Rpc21pc3MnLCAnZGlzb3JkZXInLCAnZGlzcGxheScsICdkaXN0YW5jZScsICdkaXZlcnQnLCAnZGl2aWRlJywgJ2Rpdm9yY2UnLFxuICAgICdkaXp6eScsICdkb2N0b3InLCAnZG9jdW1lbnQnLCAnZG9nJywgJ2RvbGwnLCAnZG9scGhpbicsICdkb21haW4nLCAnZG9uYXRlJywgJ2RvbmtleScsICdkb25vcicsICdkb29yJyxcbiAgICAnZG9zZScsICdkb3VibGUnLCAnZG92ZScsICdkcmFmdCcsICdkcmFnb24nLCAnZHJhbWEnLCAnZHJhc3RpYycsICdkcmF3JywgJ2RyZWFtJywgJ2RyZXNzJywgJ2RyaWZ0JywgJ2RyaWxsJyxcbiAgICAnZHJpbmsnLCAnZHJpcCcsICdkcml2ZScsICdkcm9wJywgJ2RydW0nLCAnZHJ5JywgJ2R1Y2snLCAnZHVtYicsICdkdW5lJywgJ2R1cmluZycsICdkdXN0JywgJ2R1dGNoJywgJ2R1dHknLFxuICAgICdkd2FyZicsICdkeW5hbWljJywgJ2VhZ2VyJywgJ2VhZ2xlJywgJ2Vhcmx5JywgJ2Vhcm4nLCAnZWFydGgnLCAnZWFzaWx5JywgJ2Vhc3QnLCAnZWFzeScsICdlY2hvJywgJ2Vjb2xvZ3knLFxuICAgICdlY29ub215JywgJ2VkZ2UnLCAnZWRpdCcsICdlZHVjYXRlJywgJ2VmZm9ydCcsICdlZ2cnLCAnZWlnaHQnLCAnZWl0aGVyJywgJ2VsYm93JywgJ2VsZGVyJywgJ2VsZWN0cmljJyxcbiAgICAnZWxlZ2FudCcsICdlbGVtZW50JywgJ2VsZXBoYW50JywgJ2VsZXZhdG9yJywgJ2VsaXRlJywgJ2Vsc2UnLCAnZW1iYXJrJywgJ2VtYm9keScsICdlbWJyYWNlJywgJ2VtZXJnZScsXG4gICAgJ2Vtb3Rpb24nLCAnZW1wbG95JywgJ2VtcG93ZXInLCAnZW1wdHknLCAnZW5hYmxlJywgJ2VuYWN0JywgJ2VuZCcsICdlbmRsZXNzJywgJ2VuZG9yc2UnLCAnZW5lbXknLCAnZW5lcmd5JyxcbiAgICAnZW5mb3JjZScsICdlbmdhZ2UnLCAnZW5naW5lJywgJ2VuaGFuY2UnLCAnZW5qb3knLCAnZW5saXN0JywgJ2Vub3VnaCcsICdlbnJpY2gnLCAnZW5yb2xsJywgJ2Vuc3VyZScsXG4gICAgJ2VudGVyJywgJ2VudGlyZScsICdlbnRyeScsICdlbnZlbG9wZScsICdlcGlzb2RlJywgJ2VxdWFsJywgJ2VxdWlwJywgJ2VyYScsICdlcmFzZScsICdlcm9kZScsICdlcm9zaW9uJyxcbiAgICAnZXJyb3InLCAnZXJ1cHQnLCAnZXNjYXBlJywgJ2Vzc2F5JywgJ2Vzc2VuY2UnLCAnZXN0YXRlJywgJ2V0ZXJuYWwnLCAnZXRoaWNzJywgJ2V2aWRlbmNlJywgJ2V2aWwnLCAnZXZva2UnLFxuICAgICdldm9sdmUnLCAnZXhhY3QnLCAnZXhhbXBsZScsICdleGNlc3MnLCAnZXhjaGFuZ2UnLCAnZXhjaXRlJywgJ2V4Y2x1ZGUnLCAnZXhjdXNlJywgJ2V4ZWN1dGUnLCAnZXhlcmNpc2UnLFxuICAgICdleGhhdXN0JywgJ2V4aGliaXQnLCAnZXhpbGUnLCAnZXhpc3QnLCAnZXhpdCcsICdleG90aWMnLCAnZXhwYW5kJywgJ2V4cGVjdCcsICdleHBpcmUnLCAnZXhwbGFpbicsICdleHBvc2UnLFxuICAgICdleHByZXNzJywgJ2V4dGVuZCcsICdleHRyYScsICdleWUnLCAnZXllYnJvdycsICdmYWJyaWMnLCAnZmFjZScsICdmYWN1bHR5JywgJ2ZhZGUnLCAnZmFpbnQnLCAnZmFpdGgnLFxuICAgICdmYWxsJywgJ2ZhbHNlJywgJ2ZhbWUnLCAnZmFtaWx5JywgJ2ZhbW91cycsICdmYW4nLCAnZmFuY3knLCAnZmFudGFzeScsICdmYXJtJywgJ2Zhc2hpb24nLCAnZmF0JywgJ2ZhdGFsJyxcbiAgICAnZmF0aGVyJywgJ2ZhdGlndWUnLCAnZmF1bHQnLCAnZmF2b3JpdGUnLCAnZmVhdHVyZScsICdmZWJydWFyeScsICdmZWRlcmFsJywgJ2ZlZScsICdmZWVkJywgJ2ZlZWwnLCAnZmVtYWxlJyxcbiAgICAnZmVuY2UnLCAnZmVzdGl2YWwnLCAnZmV0Y2gnLCAnZmV2ZXInLCAnZmV3JywgJ2ZpYmVyJywgJ2ZpY3Rpb24nLCAnZmllbGQnLCAnZmlndXJlJywgJ2ZpbGUnLCAnZmlsbScsXG4gICAgJ2ZpbHRlcicsICdmaW5hbCcsICdmaW5kJywgJ2ZpbmUnLCAnZmluZ2VyJywgJ2ZpbmlzaCcsICdmaXJlJywgJ2Zpcm0nLCAnZmlyc3QnLCAnZmlzY2FsJywgJ2Zpc2gnLCAnZml0JyxcbiAgICAnZml0bmVzcycsICdmaXgnLCAnZmxhZycsICdmbGFtZScsICdmbGFzaCcsICdmbGF0JywgJ2ZsYXZvcicsICdmbGVlJywgJ2ZsaWdodCcsICdmbGlwJywgJ2Zsb2F0JywgJ2Zsb2NrJyxcbiAgICAnZmxvb3InLCAnZmxvd2VyJywgJ2ZsdWlkJywgJ2ZsdXNoJywgJ2ZseScsICdmb2FtJywgJ2ZvY3VzJywgJ2ZvZycsICdmb2lsJywgJ2ZvbGQnLCAnZm9sbG93JywgJ2Zvb2QnLFxuICAgICdmb290JywgJ2ZvcmNlJywgJ2ZvcmVzdCcsICdmb3JnZXQnLCAnZm9yaycsICdmb3J0dW5lJywgJ2ZvcnVtJywgJ2ZvcndhcmQnLCAnZm9zc2lsJywgJ2Zvc3RlcicsICdmb3VuZCcsXG4gICAgJ2ZveCcsICdmcmFnaWxlJywgJ2ZyYW1lJywgJ2ZyZXF1ZW50JywgJ2ZyZXNoJywgJ2ZyaWVuZCcsICdmcmluZ2UnLCAnZnJvZycsICdmcm9udCcsICdmcm9zdCcsICdmcm93bicsXG4gICAgJ2Zyb3plbicsICdmcnVpdCcsICdmdWVsJywgJ2Z1bicsICdmdW5ueScsICdmdXJuYWNlJywgJ2Z1cnknLCAnZnV0dXJlJywgJ2dhZGdldCcsICdnYWluJywgJ2dhbGF4eScsXG4gICAgJ2dhbGxlcnknLCAnZ2FtZScsICdnYXAnLCAnZ2FyYWdlJywgJ2dhcmJhZ2UnLCAnZ2FyZGVuJywgJ2dhcmxpYycsICdnYXJtZW50JywgJ2dhcycsICdnYXNwJywgJ2dhdGUnLFxuICAgICdnYXRoZXInLCAnZ2F1Z2UnLCAnZ2F6ZScsICdnZW5lcmFsJywgJ2dlbml1cycsICdnZW5yZScsICdnZW50bGUnLCAnZ2VudWluZScsICdnZXN0dXJlJywgJ2dob3N0JywgJ2dpYW50JyxcbiAgICAnZ2lmdCcsICdnaWdnbGUnLCAnZ2luZ2VyJywgJ2dpcmFmZmUnLCAnZ2lybCcsICdnaXZlJywgJ2dsYWQnLCAnZ2xhbmNlJywgJ2dsYXJlJywgJ2dsYXNzJywgJ2dsaWRlJyxcbiAgICAnZ2xpbXBzZScsICdnbG9iZScsICdnbG9vbScsICdnbG9yeScsICdnbG92ZScsICdnbG93JywgJ2dsdWUnLCAnZ29hdCcsICdnb2RkZXNzJywgJ2dvbGQnLCAnZ29vZCcsICdnb29zZScsXG4gICAgJ2dvcmlsbGEnLCAnZ29zcGVsJywgJ2dvc3NpcCcsICdnb3Zlcm4nLCAnZ293bicsICdncmFiJywgJ2dyYWNlJywgJ2dyYWluJywgJ2dyYW50JywgJ2dyYXBlJywgJ2dyYXNzJyxcbiAgICAnZ3Jhdml0eScsICdncmVhdCcsICdncmVlbicsICdncmlkJywgJ2dyaWVmJywgJ2dyaXQnLCAnZ3JvY2VyeScsICdncm91cCcsICdncm93JywgJ2dydW50JywgJ2d1YXJkJywgJ2d1ZXNzJyxcbiAgICAnZ3VpZGUnLCAnZ3VpbHQnLCAnZ3VpdGFyJywgJ2d1bicsICdneW0nLCAnaGFiaXQnLCAnaGFpcicsICdoYWxmJywgJ2hhbW1lcicsICdoYW1zdGVyJywgJ2hhbmQnLCAnaGFwcHknLFxuICAgICdoYXJib3InLCAnaGFyZCcsICdoYXJzaCcsICdoYXJ2ZXN0JywgJ2hhdCcsICdoYXZlJywgJ2hhd2snLCAnaGF6YXJkJywgJ2hlYWQnLCAnaGVhbHRoJywgJ2hlYXJ0JywgJ2hlYXZ5JyxcbiAgICAnaGVkZ2Vob2cnLCAnaGVpZ2h0JywgJ2hlbGxvJywgJ2hlbG1ldCcsICdoZWxwJywgJ2hlbicsICdoZXJvJywgJ2hpZGRlbicsICdoaWdoJywgJ2hpbGwnLCAnaGludCcsICdoaXAnLFxuICAgICdoaXJlJywgJ2hpc3RvcnknLCAnaG9iYnknLCAnaG9ja2V5JywgJ2hvbGQnLCAnaG9sZScsICdob2xpZGF5JywgJ2hvbGxvdycsICdob21lJywgJ2hvbmV5JywgJ2hvb2QnLCAnaG9wZScsXG4gICAgJ2hvcm4nLCAnaG9ycm9yJywgJ2hvcnNlJywgJ2hvc3BpdGFsJywgJ2hvc3QnLCAnaG90ZWwnLCAnaG91cicsICdob3ZlcicsICdodWInLCAnaHVnZScsICdodW1hbicsICdodW1ibGUnLFxuICAgICdodW1vcicsICdodW5kcmVkJywgJ2h1bmdyeScsICdodW50JywgJ2h1cmRsZScsICdodXJyeScsICdodXJ0JywgJ2h1c2JhbmQnLCAnaHlicmlkJywgJ2ljZScsICdpY29uJywgJ2lkZWEnLFxuICAgICdpZGVudGlmeScsICdpZGxlJywgJ2lnbm9yZScsICdpbGwnLCAnaWxsZWdhbCcsICdpbGxuZXNzJywgJ2ltYWdlJywgJ2ltaXRhdGUnLCAnaW1tZW5zZScsICdpbW11bmUnLFxuICAgICdpbXBhY3QnLCAnaW1wb3NlJywgJ2ltcHJvdmUnLCAnaW1wdWxzZScsICdpbmNoJywgJ2luY2x1ZGUnLCAnaW5jb21lJywgJ2luY3JlYXNlJywgJ2luZGV4JywgJ2luZGljYXRlJyxcbiAgICAnaW5kb29yJywgJ2luZHVzdHJ5JywgJ2luZmFudCcsICdpbmZsaWN0JywgJ2luZm9ybScsICdpbmhhbGUnLCAnaW5oZXJpdCcsICdpbml0aWFsJywgJ2luamVjdCcsICdpbmp1cnknLFxuICAgICdpbm1hdGUnLCAnaW5uZXInLCAnaW5ub2NlbnQnLCAnaW5wdXQnLCAnaW5xdWlyeScsICdpbnNhbmUnLCAnaW5zZWN0JywgJ2luc2lkZScsICdpbnNwaXJlJywgJ2luc3RhbGwnLFxuICAgICdpbnRhY3QnLCAnaW50ZXJlc3QnLCAnaW50bycsICdpbnZlc3QnLCAnaW52aXRlJywgJ2ludm9sdmUnLCAnaXJvbicsICdpc2xhbmQnLCAnaXNvbGF0ZScsICdpc3N1ZScsICdpdGVtJyxcbiAgICAnaXZvcnknLCAnamFja2V0JywgJ2phZ3VhcicsICdqYXInLCAnamF6eicsICdqZWFsb3VzJywgJ2plYW5zJywgJ2plbGx5JywgJ2pld2VsJywgJ2pvYicsICdqb2luJywgJ2pva2UnLFxuICAgICdqb3VybmV5JywgJ2pveScsICdqdWRnZScsICdqdWljZScsICdqdW1wJywgJ2p1bmdsZScsICdqdW5pb3InLCAnanVuaycsICdqdXN0JywgJ2thbmdhcm9vJywgJ2tlZW4nLCAna2VlcCcsXG4gICAgJ2tldGNodXAnLCAna2V5JywgJ2tpY2snLCAna2lkJywgJ2tpZG5leScsICdraW5kJywgJ2tpbmdkb20nLCAna2lzcycsICdraXQnLCAna2l0Y2hlbicsICdraXRlJywgJ2tpdHRlbicsXG4gICAgJ2tpd2knLCAna25lZScsICdrbmlmZScsICdrbm9jaycsICdrbm93JywgJ2xhYicsICdsYWJlbCcsICdsYWJvcicsICdsYWRkZXInLCAnbGFkeScsICdsYWtlJywgJ2xhbXAnLFxuICAgICdsYW5ndWFnZScsICdsYXB0b3AnLCAnbGFyZ2UnLCAnbGF0ZXInLCAnbGF0aW4nLCAnbGF1Z2gnLCAnbGF1bmRyeScsICdsYXZhJywgJ2xhdycsICdsYXduJywgJ2xhd3N1aXQnLFxuICAgICdsYXllcicsICdsYXp5JywgJ2xlYWRlcicsICdsZWFmJywgJ2xlYXJuJywgJ2xlYXZlJywgJ2xlY3R1cmUnLCAnbGVmdCcsICdsZWcnLCAnbGVnYWwnLCAnbGVnZW5kJywgJ2xlaXN1cmUnLFxuICAgICdsZW1vbicsICdsZW5kJywgJ2xlbmd0aCcsICdsZW5zJywgJ2xlb3BhcmQnLCAnbGVzc29uJywgJ2xldHRlcicsICdsZXZlbCcsICdsaWFyJywgJ2xpYmVydHknLCAnbGlicmFyeScsXG4gICAgJ2xpY2Vuc2UnLCAnbGlmZScsICdsaWZ0JywgJ2xpZ2h0JywgJ2xpa2UnLCAnbGltYicsICdsaW1pdCcsICdsaW5rJywgJ2xpb24nLCAnbGlxdWlkJywgJ2xpc3QnLCAnbGl0dGxlJyxcbiAgICAnbGl2ZScsICdsaXphcmQnLCAnbG9hZCcsICdsb2FuJywgJ2xvYnN0ZXInLCAnbG9jYWwnLCAnbG9jaycsICdsb2dpYycsICdsb25lbHknLCAnbG9uZycsICdsb29wJywgJ2xvdHRlcnknLFxuICAgICdsb3VkJywgJ2xvdW5nZScsICdsb3ZlJywgJ2xveWFsJywgJ2x1Y2t5JywgJ2x1Z2dhZ2UnLCAnbHVtYmVyJywgJ2x1bmFyJywgJ2x1bmNoJywgJ2x1eHVyeScsICdseXJpY3MnLFxuICAgICdtYWNoaW5lJywgJ21hZCcsICdtYWdpYycsICdtYWduZXQnLCAnbWFpZCcsICdtYWlsJywgJ21haW4nLCAnbWFqb3InLCAnbWFrZScsICdtYW1tYWwnLCAnbWFuJywgJ21hbmFnZScsXG4gICAgJ21hbmRhdGUnLCAnbWFuZ28nLCAnbWFuc2lvbicsICdtYW51YWwnLCAnbWFwbGUnLCAnbWFyYmxlJywgJ21hcmNoJywgJ21hcmdpbicsICdtYXJpbmUnLCAnbWFya2V0JyxcbiAgICAnbWFycmlhZ2UnLCAnbWFzaycsICdtYXNzJywgJ21hc3RlcicsICdtYXRjaCcsICdtYXRlcmlhbCcsICdtYXRoJywgJ21hdHJpeCcsICdtYXR0ZXInLCAnbWF4aW11bScsICdtYXplJyxcbiAgICAnbWVhZG93JywgJ21lYW4nLCAnbWVhc3VyZScsICdtZWF0JywgJ21lY2hhbmljJywgJ21lZGFsJywgJ21lZGlhJywgJ21lbG9keScsICdtZWx0JywgJ21lbWJlcicsICdtZW1vcnknLFxuICAgICdtZW50aW9uJywgJ21lbnUnLCAnbWVyY3knLCAnbWVyZ2UnLCAnbWVyaXQnLCAnbWVycnknLCAnbWVzaCcsICdtZXNzYWdlJywgJ21ldGFsJywgJ21ldGhvZCcsICdtaWRkbGUnLFxuICAgICdtaWRuaWdodCcsICdtaWxrJywgJ21pbGxpb24nLCAnbWltaWMnLCAnbWluZCcsICdtaW5pbXVtJywgJ21pbm9yJywgJ21pbnV0ZScsICdtaXJhY2xlJywgJ21pcnJvcicsICdtaXNlcnknLFxuICAgICdtaXNzJywgJ21pc3Rha2UnLCAnbWl4JywgJ21peGVkJywgJ21peHR1cmUnLCAnbW9iaWxlJywgJ21vZGVsJywgJ21vZGlmeScsICdtb20nLCAnbW9tZW50JywgJ21vbml0b3InLFxuICAgICdtb25rZXknLCAnbW9uc3RlcicsICdtb250aCcsICdtb29uJywgJ21vcmFsJywgJ21vcmUnLCAnbW9ybmluZycsICdtb3NxdWl0bycsICdtb3RoZXInLCAnbW90aW9uJywgJ21vdG9yJyxcbiAgICAnbW91bnRhaW4nLCAnbW91c2UnLCAnbW92ZScsICdtb3ZpZScsICdtdWNoJywgJ211ZmZpbicsICdtdWxlJywgJ211bHRpcGx5JywgJ211c2NsZScsICdtdXNldW0nLCAnbXVzaHJvb20nLFxuICAgICdtdXNpYycsICdtdXN0JywgJ211dHVhbCcsICdteXNlbGYnLCAnbXlzdGVyeScsICdteXRoJywgJ25haXZlJywgJ25hbWUnLCAnbmFwa2luJywgJ25hcnJvdycsICduYXN0eScsXG4gICAgJ25hdGlvbicsICduYXR1cmUnLCAnbmVhcicsICduZWNrJywgJ25lZWQnLCAnbmVnYXRpdmUnLCAnbmVnbGVjdCcsICduZWl0aGVyJywgJ25lcGhldycsICduZXJ2ZScsICduZXN0JyxcbiAgICAnbmV0JywgJ25ldHdvcmsnLCAnbmV1dHJhbCcsICduZXZlcicsICduZXdzJywgJ25leHQnLCAnbmljZScsICduaWdodCcsICdub2JsZScsICdub2lzZScsICdub21pbmVlJyxcbiAgICAnbm9vZGxlJywgJ25vcm1hbCcsICdub3J0aCcsICdub3NlJywgJ25vdGFibGUnLCAnbm90ZScsICdub3RoaW5nJywgJ25vdGljZScsICdub3ZlbCcsICdub3cnLCAnbnVjbGVhcicsXG4gICAgJ251bWJlcicsICdudXJzZScsICdudXQnLCAnb2FrJywgJ29iZXknLCAnb2JqZWN0JywgJ29ibGlnZScsICdvYnNjdXJlJywgJ29ic2VydmUnLCAnb2J0YWluJywgJ29idmlvdXMnLFxuICAgICdvY2N1cicsICdvY2VhbicsICdvY3RvYmVyJywgJ29kb3InLCAnb2ZmJywgJ29mZmVyJywgJ29mZmljZScsICdvZnRlbicsICdvaWwnLCAnb2theScsICdvbGQnLCAnb2xpdmUnLFxuICAgICdvbHltcGljJywgJ29taXQnLCAnb25jZScsICdvbmUnLCAnb25pb24nLCAnb25saW5lJywgJ29ubHknLCAnb3BlbicsICdvcGVyYScsICdvcGluaW9uJywgJ29wcG9zZScsXG4gICAgJ29wdGlvbicsICdvcmFuZ2UnLCAnb3JiaXQnLCAnb3JjaGFyZCcsICdvcmRlcicsICdvcmRpbmFyeScsICdvcmdhbicsICdvcmllbnQnLCAnb3JpZ2luYWwnLCAnb3JwaGFuJyxcbiAgICAnb3N0cmljaCcsICdvdGhlcicsICdvdXRkb29yJywgJ291dGVyJywgJ291dHB1dCcsICdvdXRzaWRlJywgJ292YWwnLCAnb3ZlbicsICdvdmVyJywgJ293bicsICdvd25lcicsXG4gICAgJ294eWdlbicsICdveXN0ZXInLCAnb3pvbmUnLCAncGFjdCcsICdwYWRkbGUnLCAncGFnZScsICdwYWlyJywgJ3BhbGFjZScsICdwYWxtJywgJ3BhbmRhJywgJ3BhbmVsJywgJ3BhbmljJyxcbiAgICAncGFudGhlcicsICdwYXBlcicsICdwYXJhZGUnLCAncGFyZW50JywgJ3BhcmsnLCAncGFycm90JywgJ3BhcnR5JywgJ3Bhc3MnLCAncGF0Y2gnLCAncGF0aCcsICdwYXRpZW50JyxcbiAgICAncGF0cm9sJywgJ3BhdHRlcm4nLCAncGF1c2UnLCAncGF2ZScsICdwYXltZW50JywgJ3BlYWNlJywgJ3BlYW51dCcsICdwZWFyJywgJ3BlYXNhbnQnLCAncGVsaWNhbicsICdwZW4nLFxuICAgICdwZW5hbHR5JywgJ3BlbmNpbCcsICdwZW9wbGUnLCAncGVwcGVyJywgJ3BlcmZlY3QnLCAncGVybWl0JywgJ3BlcnNvbicsICdwZXQnLCAncGhvbmUnLCAncGhvdG8nLCAncGhyYXNlJyxcbiAgICAncGh5c2ljYWwnLCAncGlhbm8nLCAncGljbmljJywgJ3BpY3R1cmUnLCAncGllY2UnLCAncGlnJywgJ3BpZ2VvbicsICdwaWxsJywgJ3BpbG90JywgJ3BpbmsnLCAncGlvbmVlcicsXG4gICAgJ3BpcGUnLCAncGlzdG9sJywgJ3BpdGNoJywgJ3BpenphJywgJ3BsYWNlJywgJ3BsYW5ldCcsICdwbGFzdGljJywgJ3BsYXRlJywgJ3BsYXknLCAncGxlYXNlJywgJ3BsZWRnZScsXG4gICAgJ3BsdWNrJywgJ3BsdWcnLCAncGx1bmdlJywgJ3BvZW0nLCAncG9ldCcsICdwb2ludCcsICdwb2xhcicsICdwb2xlJywgJ3BvbGljZScsICdwb25kJywgJ3BvbnknLCAncG9vbCcsXG4gICAgJ3BvcHVsYXInLCAncG9ydGlvbicsICdwb3NpdGlvbicsICdwb3NzaWJsZScsICdwb3N0JywgJ3BvdGF0bycsICdwb3R0ZXJ5JywgJ3BvdmVydHknLCAncG93ZGVyJywgJ3Bvd2VyJyxcbiAgICAncHJhY3RpY2UnLCAncHJhaXNlJywgJ3ByZWRpY3QnLCAncHJlZmVyJywgJ3ByZXBhcmUnLCAncHJlc2VudCcsICdwcmV0dHknLCAncHJldmVudCcsICdwcmljZScsICdwcmlkZScsXG4gICAgJ3ByaW1hcnknLCAncHJpbnQnLCAncHJpb3JpdHknLCAncHJpc29uJywgJ3ByaXZhdGUnLCAncHJpemUnLCAncHJvYmxlbScsICdwcm9jZXNzJywgJ3Byb2R1Y2UnLCAncHJvZml0JyxcbiAgICAncHJvZ3JhbScsICdwcm9qZWN0JywgJ3Byb21vdGUnLCAncHJvb2YnLCAncHJvcGVydHknLCAncHJvc3BlcicsICdwcm90ZWN0JywgJ3Byb3VkJywgJ3Byb3ZpZGUnLCAncHVibGljJyxcbiAgICAncHVkZGluZycsICdwdWxsJywgJ3B1bHAnLCAncHVsc2UnLCAncHVtcGtpbicsICdwdW5jaCcsICdwdXBpbCcsICdwdXBweScsICdwdXJjaGFzZScsICdwdXJpdHknLCAncHVycG9zZScsXG4gICAgJ3B1cnNlJywgJ3B1c2gnLCAncHV0JywgJ3B1enpsZScsICdweXJhbWlkJywgJ3F1YWxpdHknLCAncXVhbnR1bScsICdxdWFydGVyJywgJ3F1ZXN0aW9uJywgJ3F1aWNrJywgJ3F1aXQnLFxuICAgICdxdWl6JywgJ3F1b3RlJywgJ3JhYmJpdCcsICdyYWNjb29uJywgJ3JhY2UnLCAncmFjaycsICdyYWRhcicsICdyYWRpbycsICdyYWlsJywgJ3JhaW4nLCAncmFpc2UnLCAncmFsbHknLFxuICAgICdyYW1wJywgJ3JhbmNoJywgJ3JhbmRvbScsICdyYW5nZScsICdyYXBpZCcsICdyYXJlJywgJ3JhdGUnLCAncmF0aGVyJywgJ3JhdmVuJywgJ3JhdycsICdyYXpvcicsICdyZWFkeScsXG4gICAgJ3JlYWwnLCAncmVhc29uJywgJ3JlYmVsJywgJ3JlYnVpbGQnLCAncmVjYWxsJywgJ3JlY2VpdmUnLCAncmVjaXBlJywgJ3JlY29yZCcsICdyZWN5Y2xlJywgJ3JlZHVjZScsXG4gICAgJ3JlZmxlY3QnLCAncmVmb3JtJywgJ3JlZnVzZScsICdyZWdpb24nLCAncmVncmV0JywgJ3JlZ3VsYXInLCAncmVqZWN0JywgJ3JlbGF4JywgJ3JlbGVhc2UnLCAncmVsaWVmJyxcbiAgICAncmVseScsICdyZW1haW4nLCAncmVtZW1iZXInLCAncmVtaW5kJywgJ3JlbW92ZScsICdyZW5kZXInLCAncmVuZXcnLCAncmVudCcsICdyZW9wZW4nLCAncmVwYWlyJywgJ3JlcGVhdCcsXG4gICAgJ3JlcGxhY2UnLCAncmVwb3J0JywgJ3JlcXVpcmUnLCAncmVzY3VlJywgJ3Jlc2VtYmxlJywgJ3Jlc2lzdCcsICdyZXNvdXJjZScsICdyZXNwb25zZScsICdyZXN1bHQnLCAncmV0aXJlJyxcbiAgICAncmV0cmVhdCcsICdyZXR1cm4nLCAncmV1bmlvbicsICdyZXZlYWwnLCAncmV2aWV3JywgJ3Jld2FyZCcsICdyaHl0aG0nLCAncmliJywgJ3JpYmJvbicsICdyaWNlJywgJ3JpY2gnLFxuICAgICdyaWRlJywgJ3JpZGdlJywgJ3JpZmxlJywgJ3JpZ2h0JywgJ3JpZ2lkJywgJ3JpbmcnLCAncmlvdCcsICdyaXBwbGUnLCAncmlzaycsICdyaXR1YWwnLCAncml2YWwnLCAncml2ZXInLFxuICAgICdyb2FkJywgJ3JvYXN0JywgJ3JvYm90JywgJ3JvYnVzdCcsICdyb2NrZXQnLCAncm9tYW5jZScsICdyb29mJywgJ3Jvb2tpZScsICdyb29tJywgJ3Jvc2UnLCAncm90YXRlJyxcbiAgICAncm91Z2gnLCAncm91bmQnLCAncm91dGUnLCAncm95YWwnLCAncnViYmVyJywgJ3J1ZGUnLCAncnVnJywgJ3J1bGUnLCAncnVuJywgJ3J1bndheScsICdydXJhbCcsICdzYWQnLFxuICAgICdzYWRkbGUnLCAnc2FkbmVzcycsICdzYWZlJywgJ3NhaWwnLCAnc2FsYWQnLCAnc2FsbW9uJywgJ3NhbG9uJywgJ3NhbHQnLCAnc2FsdXRlJywgJ3NhbWUnLCAnc2FtcGxlJywgJ3NhbmQnLFxuICAgICdzYXRpc2Z5JywgJ3NhdG9zaGknLCAnc2F1Y2UnLCAnc2F1c2FnZScsICdzYXZlJywgJ3NheScsICdzY2FsZScsICdzY2FuJywgJ3NjYXJlJywgJ3NjYXR0ZXInLCAnc2NlbmUnLFxuICAgICdzY2hlbWUnLCAnc2Nob29sJywgJ3NjaWVuY2UnLCAnc2Npc3NvcnMnLCAnc2NvcnBpb24nLCAnc2NvdXQnLCAnc2NyYXAnLCAnc2NyZWVuJywgJ3NjcmlwdCcsICdzY3J1YicsICdzZWEnLFxuICAgICdzZWFyY2gnLCAnc2Vhc29uJywgJ3NlYXQnLCAnc2Vjb25kJywgJ3NlY3JldCcsICdzZWN0aW9uJywgJ3NlY3VyaXR5JywgJ3NlZWQnLCAnc2VlaycsICdzZWdtZW50JywgJ3NlbGVjdCcsXG4gICAgJ3NlbGwnLCAnc2VtaW5hcicsICdzZW5pb3InLCAnc2Vuc2UnLCAnc2VudGVuY2UnLCAnc2VyaWVzJywgJ3NlcnZpY2UnLCAnc2Vzc2lvbicsICdzZXR0bGUnLCAnc2V0dXAnLFxuICAgICdzZXZlbicsICdzaGFkb3cnLCAnc2hhZnQnLCAnc2hhbGxvdycsICdzaGFyZScsICdzaGVkJywgJ3NoZWxsJywgJ3NoZXJpZmYnLCAnc2hpZWxkJywgJ3NoaWZ0JywgJ3NoaW5lJyxcbiAgICAnc2hpcCcsICdzaGl2ZXInLCAnc2hvY2snLCAnc2hvZScsICdzaG9vdCcsICdzaG9wJywgJ3Nob3J0JywgJ3Nob3VsZGVyJywgJ3Nob3ZlJywgJ3NocmltcCcsICdzaHJ1ZycsXG4gICAgJ3NodWZmbGUnLCAnc2h5JywgJ3NpYmxpbmcnLCAnc2ljaycsICdzaWRlJywgJ3NpZWdlJywgJ3NpZ2h0JywgJ3NpZ24nLCAnc2lsZW50JywgJ3NpbGsnLCAnc2lsbHknLCAnc2lsdmVyJyxcbiAgICAnc2ltaWxhcicsICdzaW1wbGUnLCAnc2luY2UnLCAnc2luZycsICdzaXJlbicsICdzaXN0ZXInLCAnc2l0dWF0ZScsICdzaXgnLCAnc2l6ZScsICdza2F0ZScsICdza2V0Y2gnLCAnc2tpJyxcbiAgICAnc2tpbGwnLCAnc2tpbicsICdza2lydCcsICdza3VsbCcsICdzbGFiJywgJ3NsYW0nLCAnc2xlZXAnLCAnc2xlbmRlcicsICdzbGljZScsICdzbGlkZScsICdzbGlnaHQnLCAnc2xpbScsXG4gICAgJ3Nsb2dhbicsICdzbG90JywgJ3Nsb3cnLCAnc2x1c2gnLCAnc21hbGwnLCAnc21hcnQnLCAnc21pbGUnLCAnc21va2UnLCAnc21vb3RoJywgJ3NuYWNrJywgJ3NuYWtlJywgJ3NuYXAnLFxuICAgICdzbmlmZicsICdzbm93JywgJ3NvYXAnLCAnc29jY2VyJywgJ3NvY2lhbCcsICdzb2NrJywgJ3NvZGEnLCAnc29mdCcsICdzb2xhcicsICdzb2xkaWVyJywgJ3NvbGlkJyxcbiAgICAnc29sdXRpb24nLCAnc29sdmUnLCAnc29tZW9uZScsICdzb25nJywgJ3Nvb24nLCAnc29ycnknLCAnc29ydCcsICdzb3VsJywgJ3NvdW5kJywgJ3NvdXAnLCAnc291cmNlJywgJ3NvdXRoJyxcbiAgICAnc3BhY2UnLCAnc3BhcmUnLCAnc3BhdGlhbCcsICdzcGF3bicsICdzcGVhaycsICdzcGVjaWFsJywgJ3NwZWVkJywgJ3NwZWxsJywgJ3NwZW5kJywgJ3NwaGVyZScsICdzcGljZScsXG4gICAgJ3NwaWRlcicsICdzcGlrZScsICdzcGluJywgJ3NwaXJpdCcsICdzcGxpdCcsICdzcG9pbCcsICdzcG9uc29yJywgJ3Nwb29uJywgJ3Nwb3J0JywgJ3Nwb3QnLCAnc3ByYXknLFxuICAgICdzcHJlYWQnLCAnc3ByaW5nJywgJ3NweScsICdzcXVhcmUnLCAnc3F1ZWV6ZScsICdzcXVpcnJlbCcsICdzdGFibGUnLCAnc3RhZGl1bScsICdzdGFmZicsICdzdGFnZScsICdzdGFpcnMnLFxuICAgICdzdGFtcCcsICdzdGFuZCcsICdzdGFydCcsICdzdGF0ZScsICdzdGF5JywgJ3N0ZWFrJywgJ3N0ZWVsJywgJ3N0ZW0nLCAnc3RlcCcsICdzdGVyZW8nLCAnc3RpY2snLCAnc3RpbGwnLFxuICAgICdzdGluZycsICdzdG9jaycsICdzdG9tYWNoJywgJ3N0b25lJywgJ3N0b29sJywgJ3N0b3J5JywgJ3N0b3ZlJywgJ3N0cmF0ZWd5JywgJ3N0cmVldCcsICdzdHJpa2UnLCAnc3Ryb25nJyxcbiAgICAnc3RydWdnbGUnLCAnc3R1ZGVudCcsICdzdHVmZicsICdzdHVtYmxlJywgJ3N0eWxlJywgJ3N1YmplY3QnLCAnc3VibWl0JywgJ3N1YndheScsICdzdWNjZXNzJywgJ3N1Y2gnLFxuICAgICdzdWRkZW4nLCAnc3VmZmVyJywgJ3N1Z2FyJywgJ3N1Z2dlc3QnLCAnc3VpdCcsICdzdW1tZXInLCAnc3VuJywgJ3N1bm55JywgJ3N1bnNldCcsICdzdXBlcicsICdzdXBwbHknLFxuICAgICdzdXByZW1lJywgJ3N1cmUnLCAnc3VyZmFjZScsICdzdXJnZScsICdzdXJwcmlzZScsICdzdXJyb3VuZCcsICdzdXJ2ZXknLCAnc3VzcGVjdCcsICdzdXN0YWluJywgJ3N3YWxsb3cnLFxuICAgICdzd2FtcCcsICdzd2FwJywgJ3N3YXJtJywgJ3N3ZWFyJywgJ3N3ZWV0JywgJ3N3aWZ0JywgJ3N3aW0nLCAnc3dpbmcnLCAnc3dpdGNoJywgJ3N3b3JkJywgJ3N5bWJvbCcsXG4gICAgJ3N5bXB0b20nLCAnc3lydXAnLCAnc3lzdGVtJywgJ3RhYmxlJywgJ3RhY2tsZScsICd0YWcnLCAndGFpbCcsICd0YWxlbnQnLCAndGFsaycsICd0YW5rJywgJ3RhcGUnLCAndGFyZ2V0JyxcbiAgICAndGFzaycsICd0YXN0ZScsICd0YXR0b28nLCAndGF4aScsICd0ZWFjaCcsICd0ZWFtJywgJ3RlbGwnLCAndGVuJywgJ3RlbmFudCcsICd0ZW5uaXMnLCAndGVudCcsICd0ZXJtJyxcbiAgICAndGVzdCcsICd0ZXh0JywgJ3RoYW5rJywgJ3RoYXQnLCAndGhlbWUnLCAndGhlbicsICd0aGVvcnknLCAndGhlcmUnLCAndGhleScsICd0aGluZycsICd0aGlzJywgJ3Rob3VnaHQnLFxuICAgICd0aHJlZScsICd0aHJpdmUnLCAndGhyb3cnLCAndGh1bWInLCAndGh1bmRlcicsICd0aWNrZXQnLCAndGlkZScsICd0aWdlcicsICd0aWx0JywgJ3RpbWJlcicsICd0aW1lJywgJ3RpbnknLFxuICAgICd0aXAnLCAndGlyZWQnLCAndGlzc3VlJywgJ3RpdGxlJywgJ3RvYXN0JywgJ3RvYmFjY28nLCAndG9kYXknLCAndG9kZGxlcicsICd0b2UnLCAndG9nZXRoZXInLCAndG9pbGV0JyxcbiAgICAndG9rZW4nLCAndG9tYXRvJywgJ3RvbW9ycm93JywgJ3RvbmUnLCAndG9uZ3VlJywgJ3RvbmlnaHQnLCAndG9vbCcsICd0b290aCcsICd0b3AnLCAndG9waWMnLCAndG9wcGxlJyxcbiAgICAndG9yY2gnLCAndG9ybmFkbycsICd0b3J0b2lzZScsICd0b3NzJywgJ3RvdGFsJywgJ3RvdXJpc3QnLCAndG93YXJkJywgJ3Rvd2VyJywgJ3Rvd24nLCAndG95JywgJ3RyYWNrJyxcbiAgICAndHJhZGUnLCAndHJhZmZpYycsICd0cmFnaWMnLCAndHJhaW4nLCAndHJhbnNmZXInLCAndHJhcCcsICd0cmFzaCcsICd0cmF2ZWwnLCAndHJheScsICd0cmVhdCcsICd0cmVlJyxcbiAgICAndHJlbmQnLCAndHJpYWwnLCAndHJpYmUnLCAndHJpY2snLCAndHJpZ2dlcicsICd0cmltJywgJ3RyaXAnLCAndHJvcGh5JywgJ3Ryb3VibGUnLCAndHJ1Y2snLCAndHJ1ZScsXG4gICAgJ3RydWx5JywgJ3RydW1wZXQnLCAndHJ1c3QnLCAndHJ1dGgnLCAndHJ5JywgJ3R1YmUnLCAndHVpdGlvbicsICd0dW1ibGUnLCAndHVuYScsICd0dW5uZWwnLCAndHVya2V5JyxcbiAgICAndHVybicsICd0dXJ0bGUnLCAndHdlbHZlJywgJ3R3ZW50eScsICd0d2ljZScsICd0d2luJywgJ3R3aXN0JywgJ3R3bycsICd0eXBlJywgJ3R5cGljYWwnLCAndWdseScsXG4gICAgJ3VtYnJlbGxhJywgJ3VuYWJsZScsICd1bmF3YXJlJywgJ3VuY2xlJywgJ3VuY292ZXInLCAndW5kZXInLCAndW5kbycsICd1bmZhaXInLCAndW5mb2xkJywgJ3VuaGFwcHknLFxuICAgICd1bmlmb3JtJywgJ3VuaXF1ZScsICd1bml0JywgJ3VuaXZlcnNlJywgJ3Vua25vd24nLCAndW5sb2NrJywgJ3VudGlsJywgJ3VudXN1YWwnLCAndW52ZWlsJywgJ3VwZGF0ZScsXG4gICAgJ3VwZ3JhZGUnLCAndXBob2xkJywgJ3Vwb24nLCAndXBwZXInLCAndXBzZXQnLCAndXJiYW4nLCAndXJnZScsICd1c2FnZScsICd1c2UnLCAndXNlZCcsICd1c2VmdWwnLCAndXNlbGVzcycsXG4gICAgJ3VzdWFsJywgJ3V0aWxpdHknLCAndmFjYW50JywgJ3ZhY3V1bScsICd2YWd1ZScsICd2YWxpZCcsICd2YWxsZXknLCAndmFsdmUnLCAndmFuJywgJ3ZhbmlzaCcsICd2YXBvcicsXG4gICAgJ3ZhcmlvdXMnLCAndmFzdCcsICd2YXVsdCcsICd2ZWhpY2xlJywgJ3ZlbHZldCcsICd2ZW5kb3InLCAndmVudHVyZScsICd2ZW51ZScsICd2ZXJiJywgJ3ZlcmlmeScsICd2ZXJzaW9uJyxcbiAgICAndmVyeScsICd2ZXNzZWwnLCAndmV0ZXJhbicsICd2aWFibGUnLCAndmlicmFudCcsICd2aWNpb3VzJywgJ3ZpY3RvcnknLCAndmlkZW8nLCAndmlldycsICd2aWxsYWdlJyxcbiAgICAndmludGFnZScsICd2aW9saW4nLCAndmlydHVhbCcsICd2aXJ1cycsICd2aXNhJywgJ3Zpc2l0JywgJ3Zpc3VhbCcsICd2aXRhbCcsICd2aXZpZCcsICd2b2NhbCcsICd2b2ljZScsXG4gICAgJ3ZvaWQnLCAndm9sY2FubycsICd2b2x1bWUnLCAndm90ZScsICd2b3lhZ2UnLCAnd2FnZScsICd3YWdvbicsICd3YWl0JywgJ3dhbGsnLCAnd2FsbCcsICd3YWxudXQnLCAnd2FudCcsXG4gICAgJ3dhcmZhcmUnLCAnd2FybScsICd3YXJyaW9yJywgJ3dhc2gnLCAnd2FzcCcsICd3YXN0ZScsICd3YXRlcicsICd3YXZlJywgJ3dheScsICd3ZWFsdGgnLCAnd2VhcG9uJywgJ3dlYXInLFxuICAgICd3ZWFzZWwnLCAnd2VhdGhlcicsICd3ZWInLCAnd2VkZGluZycsICd3ZWVrZW5kJywgJ3dlaXJkJywgJ3dlbGNvbWUnLCAnd2VzdCcsICd3ZXQnLCAnd2hhbGUnLCAnd2hhdCcsXG4gICAgJ3doZWF0JywgJ3doZWVsJywgJ3doZW4nLCAnd2hlcmUnLCAnd2hpcCcsICd3aGlzcGVyJywgJ3dpZGUnLCAnd2lkdGgnLCAnd2lmZScsICd3aWxkJywgJ3dpbGwnLCAnd2luJyxcbiAgICAnd2luZG93JywgJ3dpbmUnLCAnd2luZycsICd3aW5rJywgJ3dpbm5lcicsICd3aW50ZXInLCAnd2lyZScsICd3aXNkb20nLCAnd2lzZScsICd3aXNoJywgJ3dpdG5lc3MnLCAnd29sZicsXG4gICAgJ3dvbWFuJywgJ3dvbmRlcicsICd3b29kJywgJ3dvb2wnLCAnd29yZCcsICd3b3JrJywgJ3dvcmxkJywgJ3dvcnJ5JywgJ3dvcnRoJywgJ3dyYXAnLCAnd3JlY2snLCAnd3Jlc3RsZScsXG4gICAgJ3dyaXN0JywgJ3dyaXRlJywgJ3dyb25nJywgJ3lhcmQnLCAneWVhcicsICd5ZWxsb3cnLCAneW91JywgJ3lvdW5nJywgJ3lvdXRoJywgJ3plYnJhJywgJ3plcm8nLCAnem9uZScsICd6b28nLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlZWQtd29yZHMtbGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBheGxzaWduXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2xpYnMvYXhsc2lnblwiKSk7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9wYXJhbVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGFkZHJlc3Nfa2V5c19zZWVkXzEgPSByZXF1aXJlKFwiLi9hZGRyZXNzLWtleXMtc2VlZFwiKTtcbnZhciByYW5kb21fMSA9IHJlcXVpcmUoXCIuL3JhbmRvbVwiKTtcbmV4cG9ydHMuc2lnbkJ5dGVzID0gZnVuY3Rpb24gKHNlZWRPclByaXZhdGVLZXksIGJ5dGVzLCByYW5kb20pIHtcbiAgICByZXR1cm4gYXhsc2lnbl8xLmRlZmF1bHQuc2lnbihwYXJhbV8xLl9mcm9tSW4odXRpbF8xLmlzUHJpdmF0ZUtleShzZWVkT3JQcml2YXRlS2V5KVxuICAgICAgICA/IHNlZWRPclByaXZhdGVLZXkucHJpdmF0ZUtleVxuICAgICAgICA6IGFkZHJlc3Nfa2V5c19zZWVkXzEucHJpdmF0ZUtleShzZWVkT3JQcml2YXRlS2V5KSksIHBhcmFtXzEuX2Zyb21JbihieXRlcyksIHBhcmFtXzEuX2Zyb21JbihyYW5kb20gfHwgcmFuZG9tXzEucmFuZG9tQnl0ZXMoNjQpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNQdWJsaWNLZXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbC5wdWJsaWNLZXkgIT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmlzUHJpdmF0ZUtleSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnByaXZhdGVLZXkgIT09IHVuZGVmaW5lZDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIGNoYWluX2lkXzEgPSByZXF1aXJlKFwiLi4vZXh0ZW5zaW9ucy9jaGFpbi1pZFwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL2NvbnZlcnNpb25zL3BhcmFtXCIpO1xudmFyIGhhc2hpbmdfMSA9IHJlcXVpcmUoXCIuL2hhc2hpbmdcIik7XG52YXIgYWRkcmVzc19rZXlzX3NlZWRfMSA9IHJlcXVpcmUoXCIuL2FkZHJlc3Mta2V5cy1zZWVkXCIpO1xudmFyIGF4bHNpZ25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbGlicy9heGxzaWduXCIpKTtcbmV4cG9ydHMudmVyaWZ5QWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyLCBvcHRpb25hbCkge1xuICAgIHZhciBjaGFpbklkID0gb3B0aW9uYWwgPyBvcHRpb25hbC5jaGFpbklkIDogdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBhZGRyZXNzQnl0ZXMgPSBwYXJhbV8xLl9mcm9tSW4oYWRkcik7XG4gICAgICAgIGlmIChhZGRyZXNzQnl0ZXNbMF0gIT0gMSB8fCAoY2hhaW5JZCA/IGFkZHJlc3NCeXRlc1sxXSAhPSBjaGFpbl9pZF8xLkNoYWlkSWQudG9OdW1iZXIoY2hhaW5JZCkgOiBmYWxzZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBrZXkgPSBhZGRyZXNzQnl0ZXMuc2xpY2UoMCwgMjIpO1xuICAgICAgICB2YXIgY2hlY2sgPSBhZGRyZXNzQnl0ZXMuc2xpY2UoMjIsIDI2KTtcbiAgICAgICAgdmFyIGtleUhhc2ggPSBoYXNoaW5nXzEuX2hhc2hDaGFpbihrZXkpLnNsaWNlKDAsIDQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoZWNrW2ldICE9IGtleUhhc2hbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25hbCAmJiBvcHRpb25hbC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHZhciBhID0gYWRkcmVzc19rZXlzX3NlZWRfMS5hZGRyZXNzKHsgcHVibGljS2V5OiBvcHRpb25hbC5wdWJsaWNLZXkgfSwgY2hhaW5JZCk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc0J5dGVzLmxlbmd0aCAhPT0gYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGFkZHJlc3NCeXRlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydHMudmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgYnl0ZXMsIHNpZ25hdHVyZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBheGxzaWduXzEuZGVmYXVsdC52ZXJpZnkocGFyYW1fMS5fZnJvbUluKHB1YmxpY0tleSksIHBhcmFtXzEuX2Zyb21JbihieXRlcyksIHBhcmFtXzEuX2Zyb21JbihzaWduYXR1cmUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy52ZXJpZnlQdWJsaWNLZXkgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7IHJldHVybiBwYXJhbV8xLl9mcm9tSW4ocHVibGljS2V5KS5sZW5ndGggPT09IGludGVyZmFjZV8xLlBVQkxJQ19LRVlfTEVOR1RIOyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyaWZpY2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4uL2NyeXB0by9pbnRlcmZhY2VcIik7XG52YXIgaW50ZXJmYWNlXzIgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2ludGVyZmFjZVwiKTtcbmV4cG9ydHMuQ2hhaWRJZCA9IHtcbiAgICB0b051bWJlcjogZnVuY3Rpb24gKGNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgY2hhaW5JZCA9PT0gJ3N0cmluZycgPyBjaGFpbklkLmNoYXJDb2RlQXQoMCkgOiBjaGFpbklkKTtcbiAgICB9LFxuICAgIGlzTWFpbm5ldDogZnVuY3Rpb24gKGNoYWluSWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQ2hhaWRJZC50b051bWJlcihjaGFpbklkKSA9PT0gaW50ZXJmYWNlXzEuTUFJTl9ORVRfQ0hBSU5fSUQ7XG4gICAgfSxcbiAgICBpc1Rlc3RuZXQ6IGZ1bmN0aW9uIChjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkNoYWlkSWQudG9OdW1iZXIoY2hhaW5JZCkgPT09IGludGVyZmFjZV8yLlRFU1RfTkVUX0NIQUlOX0lEO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhaW4taWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9wYXJhbVwiKTtcbnZhciBzdHJpbmdfYnl0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb252ZXJzaW9ucy9zdHJpbmctYnl0ZXNcIik7XG5leHBvcnRzLlNlZWQgPSB7XG4gICAgaXNTZWVkV2l0aE5vbmNlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwubm9uY2UgIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHRvQmluYXJ5OiBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5TZWVkLmlzU2VlZFdpdGhOb25jZShzZWVkKSA/XG4gICAgICAgICAgICB7IHNlZWQ6IGV4cG9ydHMuU2VlZC50b0JpbmFyeShzZWVkLnNlZWQpLnNlZWQsIG5vbmNlOiBzZWVkLm5vbmNlIH0gOlxuICAgICAgICAgICAgeyBzZWVkOiBwYXJhbV8xLl9mcm9tUmF3SW4oc2VlZCksIG5vbmNlOiB1bmRlZmluZWQgfTtcbiAgICB9LFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX2J5dGVzXzEuYnl0ZXNUb1N0cmluZyhleHBvcnRzLlNlZWQudG9CaW5hcnkoc2VlZCkuc2VlZCk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjcnlwdG9fMSA9IHJlcXVpcmUoXCIuL2NyeXB0by9jcnlwdG9cIik7XG52YXIgc2VlZF93b3Jkc19saXN0XzEgPSByZXF1aXJlKFwiLi9jcnlwdG8vc2VlZC13b3Jkcy1saXN0XCIpO1xuZXhwb3J0cy5zZWVkV29yZHNMaXN0ID0gc2VlZF93b3Jkc19saXN0XzEuc2VlZFdvcmRzTGlzdDtcbnZhciBjaGFpbl9pZF8xID0gcmVxdWlyZShcIi4vZXh0ZW5zaW9ucy9jaGFpbi1pZFwiKTtcbmV4cG9ydHMuQ2hhaWRJZCA9IGNoYWluX2lkXzEuQ2hhaWRJZDtcbnZhciBzZWVkXzEgPSByZXF1aXJlKFwiLi9leHRlbnNpb25zL3NlZWRcIik7XG5leHBvcnRzLlNlZWQgPSBzZWVkXzEuU2VlZDtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9jcnlwdG8vdXRpbFwiKTtcbmV4cG9ydHMuaXNQcml2YXRlS2V5ID0gdXRpbF8xLmlzUHJpdmF0ZUtleTtcbmV4cG9ydHMuaXNQdWJsaWNLZXkgPSB1dGlsXzEuaXNQdWJsaWNLZXk7XG52YXIgY3J5cHRvXzIgPSByZXF1aXJlKFwiLi9jcnlwdG8vY3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBjcnlwdG9fMi5jcnlwdG87XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jcnlwdG8vaW50ZXJmYWNlXCIpKTtcbmV4cG9ydHMuc2lnbkJ5dGVzID0gKF9hID0gY3J5cHRvXzEuY3J5cHRvKHsgb3V0cHV0OiAnQmFzZTU4JyB9KSwgX2Euc2lnbkJ5dGVzKSwgZXhwb3J0cy5rZXlQYWlyID0gX2Eua2V5UGFpciwgZXhwb3J0cy5wdWJsaWNLZXkgPSBfYS5wdWJsaWNLZXksIGV4cG9ydHMucHJpdmF0ZUtleSA9IF9hLnByaXZhdGVLZXksIGV4cG9ydHMuYWRkcmVzcyA9IF9hLmFkZHJlc3MsIGV4cG9ydHMuYnVpbGRBZGRyZXNzID0gX2EuYnVpbGRBZGRyZXNzLCBleHBvcnRzLmJsYWtlMmIgPSBfYS5ibGFrZTJiLCBleHBvcnRzLmtlY2NhayA9IF9hLmtlY2NhaywgZXhwb3J0cy5zaGEyNTYgPSBfYS5zaGEyNTYsIGV4cG9ydHMuc2hhcmVkS2V5ID0gX2Euc2hhcmVkS2V5LCBleHBvcnRzLnNlZWRXaXRoTm9uY2UgPSBfYS5zZWVkV2l0aE5vbmNlLCBleHBvcnRzLmJhc2U2NEVuY29kZSA9IF9hLmJhc2U2NEVuY29kZSwgZXhwb3J0cy5iYXNlNjREZWNvZGUgPSBfYS5iYXNlNjREZWNvZGUsIGV4cG9ydHMuYmFzZTU4RW5jb2RlID0gX2EuYmFzZTU4RW5jb2RlLCBleHBvcnRzLmJhc2U1OERlY29kZSA9IF9hLmJhc2U1OERlY29kZSwgZXhwb3J0cy5iYXNlMTZFbmNvZGUgPSBfYS5iYXNlMTZFbmNvZGUsIGV4cG9ydHMuYmFzZTE2RGVjb2RlID0gX2EuYmFzZTE2RGVjb2RlLCBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBfYS5zdHJpbmdUb0J5dGVzLCBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBfYS5ieXRlc1RvU3RyaW5nLCBleHBvcnRzLnJhbmRvbSA9IF9hLnJhbmRvbSwgZXhwb3J0cy5yYW5kb21TZWVkID0gX2EucmFuZG9tU2VlZCwgZXhwb3J0cy5yYW5kb21CeXRlcyA9IF9hLnJhbmRvbUJ5dGVzLCBleHBvcnRzLnZlcmlmeVNpZ25hdHVyZSA9IF9hLnZlcmlmeVNpZ25hdHVyZSwgZXhwb3J0cy52ZXJpZnlQdWJsaWNLZXkgPSBfYS52ZXJpZnlQdWJsaWNLZXksIGV4cG9ydHMudmVyaWZ5QWRkcmVzcyA9IF9hLnZlcmlmeUFkZHJlc3MsIGV4cG9ydHMubWVzc2FnZURlY3J5cHQgPSBfYS5tZXNzYWdlRGVjcnlwdCwgZXhwb3J0cy5tZXNzYWdlRW5jcnlwdCA9IF9hLm1lc3NhZ2VFbmNyeXB0LCBleHBvcnRzLmFlc0RlY3J5cHQgPSBfYS5hZXNEZWNyeXB0LCBleHBvcnRzLmFlc0VuY3J5cHQgPSBfYS5hZXNFbmNyeXB0LCBleHBvcnRzLmVuY3J5cHRTZWVkID0gX2EuZW5jcnlwdFNlZWQsIGV4cG9ydHMuZGVjcnlwdFNlZWQgPSBfYS5kZWNyeXB0U2VlZCwgZXhwb3J0cy5yc2FLZXlQYWlyID0gX2EucnNhS2V5UGFpciwgZXhwb3J0cy5yc2FLZXlQYWlyU3luYyA9IF9hLnJzYUtleVBhaXJTeW5jLCBleHBvcnRzLnJzYVNpZ24gPSBfYS5yc2FTaWduLCBleHBvcnRzLnJzYVZlcmlmeSA9IF9hLnJzYVZlcmlmeSwgZXhwb3J0cy5tZXJrbGVWZXJpZnkgPSBfYS5tZXJrbGVWZXJpZnksIGV4cG9ydHMuc3BsaXQgPSBfYS5zcGxpdCwgZXhwb3J0cy5jb25jYXQgPSBfYS5jb25jYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBVdGY4QXJyYXlUb1N0ciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoYXJDYWNoZSA9IG5ldyBBcnJheSgxMjgpOyAvLyBQcmVhbGxvY2F0ZSB0aGUgY2FjaGUgZm9yIHRoZSBjb21tb24gc2luZ2xlIGJ5dGUgY2hhcnNcbiAgICB2YXIgY2hhckZyb21Db2RlUHQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHZhciBjb2RlUHQsIGJ5dGUxO1xuICAgICAgICB2YXIgYnVmZkxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZkxlbjspIHtcbiAgICAgICAgICAgIGJ5dGUxID0gYXJyYXlbaSsrXTtcbiAgICAgICAgICAgIGlmIChieXRlMSA8PSAweDdGKSB7XG4gICAgICAgICAgICAgICAgY29kZVB0ID0gYnl0ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlMSA8PSAweERGKSB7XG4gICAgICAgICAgICAgICAgY29kZVB0ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgKGFycmF5W2krK10gJiAweDNGKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGUxIDw9IDB4RUYpIHtcbiAgICAgICAgICAgICAgICBjb2RlUHQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKChhcnJheVtpKytdICYgMHgzRikgPDwgNikgfCAoYXJyYXlbaSsrXSAmIDB4M0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjb2RlUHQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMTgpIHwgKChhcnJheVtpKytdICYgMHgzRikgPDwgMTIpIHwgKChhcnJheVtpKytdICYgMHgzRikgPDwgNikgfCAoYXJyYXlbaSsrXSAmIDB4M0YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZVB0ID0gNjM7IC8vIENhbm5vdCBjb252ZXJ0TG9uZ0ZpZWxkcyBmb3VyIGJ5dGUgY29kZSBwb2ludHMsIHNvIHVzZSBcIj9cIiBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhckNhY2hlW2NvZGVQdF0gfHwgKGNoYXJDYWNoZVtjb2RlUHRdID0gY2hhckZyb21Db2RlUHQoY29kZVB0KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgfTtcbn0pO1xuZXhwb3J0cy51dGY4QXJyYXlUb1N0ciA9IFV0ZjhBcnJheVRvU3RyKCk7XG5mdW5jdGlvbiBzdHJUb1V0ZjhBcnJheShzdHIpIHtcbiAgICB2YXIgdXRmOCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPCAweDgwKVxuICAgICAgICAgICAgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDYpICYgMHgzZiksIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG4gICAgICAgICAgICAvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG4gICAgICAgICAgICAvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuICAgICAgICAgICAgY2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZikgPDwgMTApXG4gICAgICAgICAgICAgICAgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpO1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4gMTgpLCAweDgwIHwgKChjaGFyY29kZSA+PiAxMikgJiAweDNmKSwgMHg4MCB8ICgoY2hhcmNvZGUgPj4gNikgJiAweDNmKSwgMHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHV0ZjgpO1xufVxuZXhwb3J0cy5zdHJUb1V0ZjhBcnJheSA9IHN0clRvVXRmOEFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRmOC5qcy5tYXAiLCIndXNlIHN0cmljdCdcbi8vIEN1cnZlMjU1MTkgc2lnbmF0dXJlcyAoYW5kIGFsc28ga2V5IGFncmVlbWVudClcbi8vIGxpa2UgaW4gdGhlIGVhcmx5IEF4b2xvdGwuXG4vL1xuLy8gV3JpdHRlbiBieSBEbWl0cnkgQ2hlc3RueWtoLlxuLy8gWW91IGNhbiB1c2UgaXQgdW5kZXIgTUlUIG9yIENDMCBsaWNlbnNlLlxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZVxuLy8gQ3VydmUyNTUxOSBzaWduYXR1cmVzIGlkZWEgYW5kIG1hdGggYnkgVHJldm9yIFBlcnJpblxuLy8gaHR0cHM6Ly9tb2Rlcm5jcnlwdG8ub3JnL21haWwtYXJjaGl2ZS9jdXJ2ZXMvMjAxNC8wMDAyMDUuaHRtbFxuLy8gRGVyaXZlZCBmcm9tIFR3ZWV0TmFDbC5qcyAoaHR0cHM6Ly90d2VldG5hY2wuanMub3JnLylcbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xudmFyIGF4bHNpZ24gPSBPYmplY3QuY3JlYXRlKG51bGwpXG52YXIgZ2YgPSBmdW5jdGlvbiAoaW5pdCkge1xuICB2YXIgaSwgciA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpXG4gIGlmIChpbml0KVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbml0Lmxlbmd0aDsgaSsrKVxuICAgICAgcltpXSA9IGluaXRbaV1cbiAgcmV0dXJuIHJcbn1cbnZhciBfMCA9IG5ldyBVaW50OEFycmF5KDE2KVxudmFyIF85ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG5fOVswXSA9IDlcbnZhciBnZjAgPSBnZigpLCBnZjEgPSBnZihbMV0pLCBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLCBEID0gZ2YoWzB4NzhhMywgMHgxMzU5LCAweDRkY2EsIDB4NzVlYiwgMHhkOGFiLCAweDQxNDEsIDB4MGE0ZCwgMHgwMDcwLCAweGU4OTgsIDB4Nzc3OSwgMHg0MDc5LCAweDhjYzcsIDB4ZmU3MywgMHgyYjZmLCAweDZjZWUsIDB4NTIwM10pLCBEMiA9IGdmKFsweGYxNTksIDB4MjZiMiwgMHg5Yjk0LCAweGViZDYsIDB4YjE1NiwgMHg4MjgzLCAweDE0OWEsIDB4MDBlMCwgMHhkMTMwLCAweGVlZjMsIDB4ODBmMiwgMHgxOThlLCAweGZjZTcsIDB4NTZkZiwgMHhkOWRjLCAweDI0MDZdKSwgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSwgWSA9IGdmKFsweDY2NTgsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjZdKSwgSSA9IGdmKFsweGEwYjAsIDB4NGEwZSwgMHgxYjI3LCAweGM0ZWUsIDB4ZTQ3OCwgMHhhZDJmLCAweDE4MDYsIDB4MmY0MywgMHhkN2E3LCAweDNkZmIsIDB4MDA5OSwgMHgyYjRkLCAweGRmMGIsIDB4NGZjMSwgMHgyNDgwLCAweDJiODNdKVxuZnVuY3Rpb24gdHM2NCh4LCBpLCBoLCBsKSB7XG4gIHhbaV0gPSAoaCA+PiAyNCkgJiAweGZmXG4gIHhbaSArIDFdID0gKGggPj4gMTYpICYgMHhmZlxuICB4W2kgKyAyXSA9IChoID4+IDgpICYgMHhmZlxuICB4W2kgKyAzXSA9IGggJiAweGZmXG4gIHhbaSArIDRdID0gKGwgPj4gMjQpICYgMHhmZlxuICB4W2kgKyA1XSA9IChsID4+IDE2KSAmIDB4ZmZcbiAgeFtpICsgNl0gPSAobCA+PiA4KSAmIDB4ZmZcbiAgeFtpICsgN10gPSBsICYgMHhmZlxufVxuZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gIHZhciBpLCBkID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgIGQgfD0geFt4aSArIGldIF4geVt5aSArIGldXG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxXG59XG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzMyKHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCwgeGksIHksIHlpLCAzMilcbn1cbmZ1bmN0aW9uIHNldDI1NTE5KHIsIGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIHJbaV0gPSBhW2ldIHwgMFxufVxuZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICB2YXIgaSwgdiwgYyA9IDFcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2ID0gb1tpXSArIGMgKyA2NTUzNVxuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgICBvW2ldID0gdiAtIGMgKiA2NTUzNlxuICB9XG4gIG9bMF0gKz0gYyAtIDEgKyAzNyAqIChjIC0gMSlcbn1cbmZ1bmN0aW9uIHNlbDI1NTE5KHAsIHEsIGIpIHtcbiAgdmFyIHQsIGMgPSB+KGIgLSAxKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSlcbiAgICBwW2ldIF49IHRcbiAgICBxW2ldIF49IHRcbiAgfVxufVxuZnVuY3Rpb24gcGFjazI1NTE5KG8sIG4pIHtcbiAgdmFyIGksIGosIGJcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICB0W2ldID0gbltpXVxuICBjYXIyNTUxOSh0KVxuICBjYXIyNTUxOSh0KVxuICBjYXIyNTUxOSh0KVxuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWRcbiAgICBmb3IgKGkgPSAxOyBpIDwgMTU7IGkrKykge1xuICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAoKG1baSAtIDFdID4+IDE2KSAmIDEpXG4gICAgICBtW2kgLSAxXSAmPSAweGZmZmZcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0gPj4gMTYpICYgMSlcbiAgICBiID0gKG1bMTVdID4+IDE2KSAmIDFcbiAgICBtWzE0XSAmPSAweGZmZmZcbiAgICBzZWwyNTUxOSh0LCBtLCAxIC0gYilcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIG9bMiAqIGldID0gdFtpXSAmIDB4ZmZcbiAgICBvWzIgKiBpICsgMV0gPSB0W2ldID4+IDhcbiAgfVxufVxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKVxuICBwYWNrMjU1MTkoYywgYSlcbiAgcGFjazI1NTE5KGQsIGIpXG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApXG59XG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gIHBhY2syNTUxOShkLCBhKVxuICByZXR1cm4gZFswXSAmIDFcbn1cbmZ1bmN0aW9uIHVucGFjazI1NTE5KG8sIG4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIG9baV0gPSBuWzIgKiBpXSArIChuWzIgKiBpICsgMV0gPDwgOClcbiAgb1sxNV0gJj0gMHg3ZmZmXG59XG5mdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIG9baV0gPSBhW2ldICsgYltpXVxufVxuZnVuY3Rpb24gWihvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBvW2ldID0gYVtpXSAtIGJbaV1cbn1cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYywgdDAgPSAwLCB0MSA9IDAsIHQyID0gMCwgdDMgPSAwLCB0NCA9IDAsIHQ1ID0gMCwgdDYgPSAwLCB0NyA9IDAsIHQ4ID0gMCwgdDkgPSAwLCB0MTAgPSAwLCB0MTEgPSAwLCB0MTIgPSAwLCB0MTMgPSAwLCB0MTQgPSAwLCB0MTUgPSAwLCB0MTYgPSAwLCB0MTcgPSAwLCB0MTggPSAwLCB0MTkgPSAwLCB0MjAgPSAwLCB0MjEgPSAwLCB0MjIgPSAwLCB0MjMgPSAwLCB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLCBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdLCBiNiA9IGJbNl0sIGI3ID0gYls3XSwgYjggPSBiWzhdLCBiOSA9IGJbOV0sIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXSwgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV1cbiAgdiA9IGFbMF1cbiAgdDAgKz0gdiAqIGIwXG4gIHQxICs9IHYgKiBiMVxuICB0MiArPSB2ICogYjJcbiAgdDMgKz0gdiAqIGIzXG4gIHQ0ICs9IHYgKiBiNFxuICB0NSArPSB2ICogYjVcbiAgdDYgKz0gdiAqIGI2XG4gIHQ3ICs9IHYgKiBiN1xuICB0OCArPSB2ICogYjhcbiAgdDkgKz0gdiAqIGI5XG4gIHQxMCArPSB2ICogYjEwXG4gIHQxMSArPSB2ICogYjExXG4gIHQxMiArPSB2ICogYjEyXG4gIHQxMyArPSB2ICogYjEzXG4gIHQxNCArPSB2ICogYjE0XG4gIHQxNSArPSB2ICogYjE1XG4gIHYgPSBhWzFdXG4gIHQxICs9IHYgKiBiMFxuICB0MiArPSB2ICogYjFcbiAgdDMgKz0gdiAqIGIyXG4gIHQ0ICs9IHYgKiBiM1xuICB0NSArPSB2ICogYjRcbiAgdDYgKz0gdiAqIGI1XG4gIHQ3ICs9IHYgKiBiNlxuICB0OCArPSB2ICogYjdcbiAgdDkgKz0gdiAqIGI4XG4gIHQxMCArPSB2ICogYjlcbiAgdDExICs9IHYgKiBiMTBcbiAgdDEyICs9IHYgKiBiMTFcbiAgdDEzICs9IHYgKiBiMTJcbiAgdDE0ICs9IHYgKiBiMTNcbiAgdDE1ICs9IHYgKiBiMTRcbiAgdDE2ICs9IHYgKiBiMTVcbiAgdiA9IGFbMl1cbiAgdDIgKz0gdiAqIGIwXG4gIHQzICs9IHYgKiBiMVxuICB0NCArPSB2ICogYjJcbiAgdDUgKz0gdiAqIGIzXG4gIHQ2ICs9IHYgKiBiNFxuICB0NyArPSB2ICogYjVcbiAgdDggKz0gdiAqIGI2XG4gIHQ5ICs9IHYgKiBiN1xuICB0MTAgKz0gdiAqIGI4XG4gIHQxMSArPSB2ICogYjlcbiAgdDEyICs9IHYgKiBiMTBcbiAgdDEzICs9IHYgKiBiMTFcbiAgdDE0ICs9IHYgKiBiMTJcbiAgdDE1ICs9IHYgKiBiMTNcbiAgdDE2ICs9IHYgKiBiMTRcbiAgdDE3ICs9IHYgKiBiMTVcbiAgdiA9IGFbM11cbiAgdDMgKz0gdiAqIGIwXG4gIHQ0ICs9IHYgKiBiMVxuICB0NSArPSB2ICogYjJcbiAgdDYgKz0gdiAqIGIzXG4gIHQ3ICs9IHYgKiBiNFxuICB0OCArPSB2ICogYjVcbiAgdDkgKz0gdiAqIGI2XG4gIHQxMCArPSB2ICogYjdcbiAgdDExICs9IHYgKiBiOFxuICB0MTIgKz0gdiAqIGI5XG4gIHQxMyArPSB2ICogYjEwXG4gIHQxNCArPSB2ICogYjExXG4gIHQxNSArPSB2ICogYjEyXG4gIHQxNiArPSB2ICogYjEzXG4gIHQxNyArPSB2ICogYjE0XG4gIHQxOCArPSB2ICogYjE1XG4gIHYgPSBhWzRdXG4gIHQ0ICs9IHYgKiBiMFxuICB0NSArPSB2ICogYjFcbiAgdDYgKz0gdiAqIGIyXG4gIHQ3ICs9IHYgKiBiM1xuICB0OCArPSB2ICogYjRcbiAgdDkgKz0gdiAqIGI1XG4gIHQxMCArPSB2ICogYjZcbiAgdDExICs9IHYgKiBiN1xuICB0MTIgKz0gdiAqIGI4XG4gIHQxMyArPSB2ICogYjlcbiAgdDE0ICs9IHYgKiBiMTBcbiAgdDE1ICs9IHYgKiBiMTFcbiAgdDE2ICs9IHYgKiBiMTJcbiAgdDE3ICs9IHYgKiBiMTNcbiAgdDE4ICs9IHYgKiBiMTRcbiAgdDE5ICs9IHYgKiBiMTVcbiAgdiA9IGFbNV1cbiAgdDUgKz0gdiAqIGIwXG4gIHQ2ICs9IHYgKiBiMVxuICB0NyArPSB2ICogYjJcbiAgdDggKz0gdiAqIGIzXG4gIHQ5ICs9IHYgKiBiNFxuICB0MTAgKz0gdiAqIGI1XG4gIHQxMSArPSB2ICogYjZcbiAgdDEyICs9IHYgKiBiN1xuICB0MTMgKz0gdiAqIGI4XG4gIHQxNCArPSB2ICogYjlcbiAgdDE1ICs9IHYgKiBiMTBcbiAgdDE2ICs9IHYgKiBiMTFcbiAgdDE3ICs9IHYgKiBiMTJcbiAgdDE4ICs9IHYgKiBiMTNcbiAgdDE5ICs9IHYgKiBiMTRcbiAgdDIwICs9IHYgKiBiMTVcbiAgdiA9IGFbNl1cbiAgdDYgKz0gdiAqIGIwXG4gIHQ3ICs9IHYgKiBiMVxuICB0OCArPSB2ICogYjJcbiAgdDkgKz0gdiAqIGIzXG4gIHQxMCArPSB2ICogYjRcbiAgdDExICs9IHYgKiBiNVxuICB0MTIgKz0gdiAqIGI2XG4gIHQxMyArPSB2ICogYjdcbiAgdDE0ICs9IHYgKiBiOFxuICB0MTUgKz0gdiAqIGI5XG4gIHQxNiArPSB2ICogYjEwXG4gIHQxNyArPSB2ICogYjExXG4gIHQxOCArPSB2ICogYjEyXG4gIHQxOSArPSB2ICogYjEzXG4gIHQyMCArPSB2ICogYjE0XG4gIHQyMSArPSB2ICogYjE1XG4gIHYgPSBhWzddXG4gIHQ3ICs9IHYgKiBiMFxuICB0OCArPSB2ICogYjFcbiAgdDkgKz0gdiAqIGIyXG4gIHQxMCArPSB2ICogYjNcbiAgdDExICs9IHYgKiBiNFxuICB0MTIgKz0gdiAqIGI1XG4gIHQxMyArPSB2ICogYjZcbiAgdDE0ICs9IHYgKiBiN1xuICB0MTUgKz0gdiAqIGI4XG4gIHQxNiArPSB2ICogYjlcbiAgdDE3ICs9IHYgKiBiMTBcbiAgdDE4ICs9IHYgKiBiMTFcbiAgdDE5ICs9IHYgKiBiMTJcbiAgdDIwICs9IHYgKiBiMTNcbiAgdDIxICs9IHYgKiBiMTRcbiAgdDIyICs9IHYgKiBiMTVcbiAgdiA9IGFbOF1cbiAgdDggKz0gdiAqIGIwXG4gIHQ5ICs9IHYgKiBiMVxuICB0MTAgKz0gdiAqIGIyXG4gIHQxMSArPSB2ICogYjNcbiAgdDEyICs9IHYgKiBiNFxuICB0MTMgKz0gdiAqIGI1XG4gIHQxNCArPSB2ICogYjZcbiAgdDE1ICs9IHYgKiBiN1xuICB0MTYgKz0gdiAqIGI4XG4gIHQxNyArPSB2ICogYjlcbiAgdDE4ICs9IHYgKiBiMTBcbiAgdDE5ICs9IHYgKiBiMTFcbiAgdDIwICs9IHYgKiBiMTJcbiAgdDIxICs9IHYgKiBiMTNcbiAgdDIyICs9IHYgKiBiMTRcbiAgdDIzICs9IHYgKiBiMTVcbiAgdiA9IGFbOV1cbiAgdDkgKz0gdiAqIGIwXG4gIHQxMCArPSB2ICogYjFcbiAgdDExICs9IHYgKiBiMlxuICB0MTIgKz0gdiAqIGIzXG4gIHQxMyArPSB2ICogYjRcbiAgdDE0ICs9IHYgKiBiNVxuICB0MTUgKz0gdiAqIGI2XG4gIHQxNiArPSB2ICogYjdcbiAgdDE3ICs9IHYgKiBiOFxuICB0MTggKz0gdiAqIGI5XG4gIHQxOSArPSB2ICogYjEwXG4gIHQyMCArPSB2ICogYjExXG4gIHQyMSArPSB2ICogYjEyXG4gIHQyMiArPSB2ICogYjEzXG4gIHQyMyArPSB2ICogYjE0XG4gIHQyNCArPSB2ICogYjE1XG4gIHYgPSBhWzEwXVxuICB0MTAgKz0gdiAqIGIwXG4gIHQxMSArPSB2ICogYjFcbiAgdDEyICs9IHYgKiBiMlxuICB0MTMgKz0gdiAqIGIzXG4gIHQxNCArPSB2ICogYjRcbiAgdDE1ICs9IHYgKiBiNVxuICB0MTYgKz0gdiAqIGI2XG4gIHQxNyArPSB2ICogYjdcbiAgdDE4ICs9IHYgKiBiOFxuICB0MTkgKz0gdiAqIGI5XG4gIHQyMCArPSB2ICogYjEwXG4gIHQyMSArPSB2ICogYjExXG4gIHQyMiArPSB2ICogYjEyXG4gIHQyMyArPSB2ICogYjEzXG4gIHQyNCArPSB2ICogYjE0XG4gIHQyNSArPSB2ICogYjE1XG4gIHYgPSBhWzExXVxuICB0MTEgKz0gdiAqIGIwXG4gIHQxMiArPSB2ICogYjFcbiAgdDEzICs9IHYgKiBiMlxuICB0MTQgKz0gdiAqIGIzXG4gIHQxNSArPSB2ICogYjRcbiAgdDE2ICs9IHYgKiBiNVxuICB0MTcgKz0gdiAqIGI2XG4gIHQxOCArPSB2ICogYjdcbiAgdDE5ICs9IHYgKiBiOFxuICB0MjAgKz0gdiAqIGI5XG4gIHQyMSArPSB2ICogYjEwXG4gIHQyMiArPSB2ICogYjExXG4gIHQyMyArPSB2ICogYjEyXG4gIHQyNCArPSB2ICogYjEzXG4gIHQyNSArPSB2ICogYjE0XG4gIHQyNiArPSB2ICogYjE1XG4gIHYgPSBhWzEyXVxuICB0MTIgKz0gdiAqIGIwXG4gIHQxMyArPSB2ICogYjFcbiAgdDE0ICs9IHYgKiBiMlxuICB0MTUgKz0gdiAqIGIzXG4gIHQxNiArPSB2ICogYjRcbiAgdDE3ICs9IHYgKiBiNVxuICB0MTggKz0gdiAqIGI2XG4gIHQxOSArPSB2ICogYjdcbiAgdDIwICs9IHYgKiBiOFxuICB0MjEgKz0gdiAqIGI5XG4gIHQyMiArPSB2ICogYjEwXG4gIHQyMyArPSB2ICogYjExXG4gIHQyNCArPSB2ICogYjEyXG4gIHQyNSArPSB2ICogYjEzXG4gIHQyNiArPSB2ICogYjE0XG4gIHQyNyArPSB2ICogYjE1XG4gIHYgPSBhWzEzXVxuICB0MTMgKz0gdiAqIGIwXG4gIHQxNCArPSB2ICogYjFcbiAgdDE1ICs9IHYgKiBiMlxuICB0MTYgKz0gdiAqIGIzXG4gIHQxNyArPSB2ICogYjRcbiAgdDE4ICs9IHYgKiBiNVxuICB0MTkgKz0gdiAqIGI2XG4gIHQyMCArPSB2ICogYjdcbiAgdDIxICs9IHYgKiBiOFxuICB0MjIgKz0gdiAqIGI5XG4gIHQyMyArPSB2ICogYjEwXG4gIHQyNCArPSB2ICogYjExXG4gIHQyNSArPSB2ICogYjEyXG4gIHQyNiArPSB2ICogYjEzXG4gIHQyNyArPSB2ICogYjE0XG4gIHQyOCArPSB2ICogYjE1XG4gIHYgPSBhWzE0XVxuICB0MTQgKz0gdiAqIGIwXG4gIHQxNSArPSB2ICogYjFcbiAgdDE2ICs9IHYgKiBiMlxuICB0MTcgKz0gdiAqIGIzXG4gIHQxOCArPSB2ICogYjRcbiAgdDE5ICs9IHYgKiBiNVxuICB0MjAgKz0gdiAqIGI2XG4gIHQyMSArPSB2ICogYjdcbiAgdDIyICs9IHYgKiBiOFxuICB0MjMgKz0gdiAqIGI5XG4gIHQyNCArPSB2ICogYjEwXG4gIHQyNSArPSB2ICogYjExXG4gIHQyNiArPSB2ICogYjEyXG4gIHQyNyArPSB2ICogYjEzXG4gIHQyOCArPSB2ICogYjE0XG4gIHQyOSArPSB2ICogYjE1XG4gIHYgPSBhWzE1XVxuICB0MTUgKz0gdiAqIGIwXG4gIHQxNiArPSB2ICogYjFcbiAgdDE3ICs9IHYgKiBiMlxuICB0MTggKz0gdiAqIGIzXG4gIHQxOSArPSB2ICogYjRcbiAgdDIwICs9IHYgKiBiNVxuICB0MjEgKz0gdiAqIGI2XG4gIHQyMiArPSB2ICogYjdcbiAgdDIzICs9IHYgKiBiOFxuICB0MjQgKz0gdiAqIGI5XG4gIHQyNSArPSB2ICogYjEwXG4gIHQyNiArPSB2ICogYjExXG4gIHQyNyArPSB2ICogYjEyXG4gIHQyOCArPSB2ICogYjEzXG4gIHQyOSArPSB2ICogYjE0XG4gIHQzMCArPSB2ICogYjE1XG4gIHQwICs9IDM4ICogdDE2XG4gIHQxICs9IDM4ICogdDE3XG4gIHQyICs9IDM4ICogdDE4XG4gIHQzICs9IDM4ICogdDE5XG4gIHQ0ICs9IDM4ICogdDIwXG4gIHQ1ICs9IDM4ICogdDIxXG4gIHQ2ICs9IDM4ICogdDIyXG4gIHQ3ICs9IDM4ICogdDIzXG4gIHQ4ICs9IDM4ICogdDI0XG4gIHQ5ICs9IDM4ICogdDI1XG4gIHQxMCArPSAzOCAqIHQyNlxuICB0MTEgKz0gMzggKiB0MjdcbiAgdDEyICs9IDM4ICogdDI4XG4gIHQxMyArPSAzOCAqIHQyOVxuICB0MTQgKz0gMzggKiB0MzBcbiAgLy8gdDE1IGxlZnQgYXMgaXNcbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxXG4gIHYgPSB0MCArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQwID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0MSA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQyICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDIgPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0MyArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQzID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDQgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0NCA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQ1ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDUgPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0NiArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQ2ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDcgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0NyA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQ4ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDggPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0OSArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQ5ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEwICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEwID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDExICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDExID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEyICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEyID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEzICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEzID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDE0ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDE0ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDE1ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDE1ID0gdiAtIGMgKiA2NTUzNlxuICB0MCArPSBjIC0gMSArIDM3ICogKGMgLSAxKVxuICAvLyBzZWNvbmQgY2FyXG4gIGMgPSAxXG4gIHYgPSB0MCArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQwID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0MSA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQyICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDIgPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0MyArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQzID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDQgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0NCA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQ1ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDUgPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0NiArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQ2ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDcgKyBjICsgNjU1MzVcbiAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KVxuICB0NyA9IHYgLSBjICogNjU1MzZcbiAgdiA9IHQ4ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDggPSB2IC0gYyAqIDY1NTM2XG4gIHYgPSB0OSArIGMgKyA2NTUzNVxuICBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpXG4gIHQ5ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEwICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEwID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDExICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDExID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEyICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEyID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDEzICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDEzID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDE0ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDE0ID0gdiAtIGMgKiA2NTUzNlxuICB2ID0gdDE1ICsgYyArIDY1NTM1XG4gIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNilcbiAgdDE1ID0gdiAtIGMgKiA2NTUzNlxuICB0MCArPSBjIC0gMSArIDM3ICogKGMgLSAxKVxuICBvWzBdID0gdDBcbiAgb1sxXSA9IHQxXG4gIG9bMl0gPSB0MlxuICBvWzNdID0gdDNcbiAgb1s0XSA9IHQ0XG4gIG9bNV0gPSB0NVxuICBvWzZdID0gdDZcbiAgb1s3XSA9IHQ3XG4gIG9bOF0gPSB0OFxuICBvWzldID0gdDlcbiAgb1sxMF0gPSB0MTBcbiAgb1sxMV0gPSB0MTFcbiAgb1sxMl0gPSB0MTJcbiAgb1sxM10gPSB0MTNcbiAgb1sxNF0gPSB0MTRcbiAgb1sxNV0gPSB0MTVcbn1cbmZ1bmN0aW9uIFMobywgYSkge1xuICBNKG8sIGEsIGEpXG59XG5mdW5jdGlvbiBpbnYyNTUxOShvLCBpKSB7XG4gIHZhciBjID0gZ2YoKVxuICB2YXIgYVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKylcbiAgICBjW2FdID0gaVthXVxuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKVxuICAgIGlmIChhICE9PSAyICYmIGEgIT09IDQpXG4gICAgICBNKGMsIGMsIGkpXG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgb1thXSA9IGNbYV1cbn1cbmZ1bmN0aW9uIHBvdzI1MjMobywgaSkge1xuICB2YXIgYyA9IGdmKClcbiAgdmFyIGFcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspXG4gICAgY1thXSA9IGlbYV1cbiAgZm9yIChhID0gMjUwOyBhID49IDA7IGEtLSkge1xuICAgIFMoYywgYylcbiAgICBpZiAoYSAhPT0gMSlcbiAgICAgIE0oYywgYywgaSlcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKylcbiAgICBvW2FdID0gY1thXVxufVxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoODApXG4gIHZhciByLCBpXG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLCBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpXG4gIGZvciAoaSA9IDA7IGkgPCAzMTsgaSsrKVxuICAgIHpbaV0gPSBuW2ldXG4gIHpbMzFdID0gKG5bMzFdICYgMTI3KSB8IDY0XG4gIHpbMF0gJj0gMjQ4XG4gIHVucGFjazI1NTE5KHgsIHApXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgYltpXSA9IHhbaV1cbiAgICBkW2ldID0gYVtpXSA9IGNbaV0gPSAwXG4gIH1cbiAgYVswXSA9IGRbMF0gPSAxXG4gIGZvciAoaSA9IDI1NDsgaSA+PSAwOyAtLWkpIHtcbiAgICByID0gKHpbaSA+Pj4gM10gPj4+IChpICYgNykpICYgMVxuICAgIHNlbDI1NTE5KGEsIGIsIHIpXG4gICAgc2VsMjU1MTkoYywgZCwgcilcbiAgICBBKGUsIGEsIGMpXG4gICAgWihhLCBhLCBjKVxuICAgIEEoYywgYiwgZClcbiAgICBaKGIsIGIsIGQpXG4gICAgUyhkLCBlKVxuICAgIFMoZiwgYSlcbiAgICBNKGEsIGMsIGEpXG4gICAgTShjLCBiLCBlKVxuICAgIEEoZSwgYSwgYylcbiAgICBaKGEsIGEsIGMpXG4gICAgUyhiLCBhKVxuICAgIFooYywgZCwgZilcbiAgICBNKGEsIGMsIF8xMjE2NjUpXG4gICAgQShhLCBhLCBkKVxuICAgIE0oYywgYywgYSlcbiAgICBNKGEsIGQsIGYpXG4gICAgTShkLCBiLCB4KVxuICAgIFMoYiwgZSlcbiAgICBzZWwyNTUxOShhLCBiLCByKVxuICAgIHNlbDI1NTE5KGMsIGQsIHIpXG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2kgKyAxNl0gPSBhW2ldXG4gICAgeFtpICsgMzJdID0gY1tpXVxuICAgIHhbaSArIDQ4XSA9IGJbaV1cbiAgICB4W2kgKyA2NF0gPSBkW2ldXG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpXG4gIHZhciB4MTYgPSB4LnN1YmFycmF5KDE2KVxuICBpbnYyNTUxOSh4MzIsIHgzMilcbiAgTSh4MTYsIHgxNiwgeDMyKVxuICBwYWNrMjU1MTkocSwgeDE2KVxuICByZXR1cm4gMFxufVxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKSB7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBfOSlcbn1cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3LFxuXVxuZnVuY3Rpb24gY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKSB7XG4gIHZhciB3aCA9IG5ldyBJbnQzMkFycmF5KDE2KSwgd2wgPSBuZXcgSW50MzJBcnJheSgxNilcbiAgdmFyIGJoMCwgYmgxLCBiaDIsIGJoMywgYmg0LCBiaDUsIGJoNiwgYmg3LCBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNywgdGgsIHRsLCBpLCBqLCBoLCBsLCBhLCBiLCBjLCBkXG4gIHZhciBhaDAgPSBoaFswXSwgYWgxID0gaGhbMV0sIGFoMiA9IGhoWzJdLCBhaDMgPSBoaFszXSwgYWg0ID0gaGhbNF0sIGFoNSA9IGhoWzVdLCBhaDYgPSBoaFs2XSwgYWg3ID0gaGhbN10sIGFsMCA9IGhsWzBdLCBhbDEgPSBobFsxXSwgYWwyID0gaGxbMl0sIGFsMyA9IGhsWzNdLCBhbDQgPSBobFs0XSwgYWw1ID0gaGxbNV0sIGFsNiA9IGhsWzZdLCBhbDcgPSBobFs3XVxuICB2YXIgcG9zID0gMFxuICB3aGlsZSAobiA+PSAxMjgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgaiA9IDggKiBpICsgcG9zXG4gICAgICB3aFtpXSA9IChtW2ogKyAwXSA8PCAyNCkgfCAobVtqICsgMV0gPDwgMTYpIHwgKG1baiArIDJdIDw8IDgpIHwgbVtqICsgM11cbiAgICAgIHdsW2ldID0gKG1baiArIDRdIDw8IDI0KSB8IChtW2ogKyA1XSA8PCAxNikgfCAobVtqICsgNl0gPDwgOCkgfCBtW2ogKyA3XVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwXG4gICAgICBiaDEgPSBhaDFcbiAgICAgIGJoMiA9IGFoMlxuICAgICAgYmgzID0gYWgzXG4gICAgICBiaDQgPSBhaDRcbiAgICAgIGJoNSA9IGFoNVxuICAgICAgYmg2ID0gYWg2XG4gICAgICBiaDcgPSBhaDdcbiAgICAgIGJsMCA9IGFsMFxuICAgICAgYmwxID0gYWwxXG4gICAgICBibDIgPSBhbDJcbiAgICAgIGJsMyA9IGFsM1xuICAgICAgYmw0ID0gYWw0XG4gICAgICBibDUgPSBhbDVcbiAgICAgIGJsNiA9IGFsNlxuICAgICAgYmw3ID0gYWw3XG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBhaDdcbiAgICAgIGwgPSBhbDdcbiAgICAgIGEgPSBsICYgMHhmZmZmXG4gICAgICBiID0gbCA+Pj4gMTZcbiAgICAgIGMgPSBoICYgMHhmZmZmXG4gICAgICBkID0gaCA+Pj4gMTZcbiAgICAgIC8vIFNpZ21hMVxuICAgICAgaCA9ICgoYWg0ID4+PiAxNCkgfCAoYWw0IDw8ICgzMiAtIDE0KSkpIF4gKChhaDQgPj4+IDE4KSB8IChhbDQgPDwgKDMyIC0gMTgpKSkgXiAoKGFsNCA+Pj4gKDQxIC0gMzIpKSB8IChhaDQgPDwgKDMyIC0gKDQxIC0gMzIpKSkpXG4gICAgICBsID0gKChhbDQgPj4+IDE0KSB8IChhaDQgPDwgKDMyIC0gMTQpKSkgXiAoKGFsNCA+Pj4gMTgpIHwgKGFoNCA8PCAoMzIgLSAxOCkpKSBeICgoYWg0ID4+PiAoNDEgLSAzMikpIHwgKGFsNCA8PCAoMzIgLSAoNDEgLSAzMikpKSlcbiAgICAgIGEgKz0gbCAmIDB4ZmZmZlxuICAgICAgYiArPSBsID4+PiAxNlxuICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICBkICs9IGggPj4+IDE2XG4gICAgICAvLyBDaFxuICAgICAgaCA9IChhaDQgJiBhaDUpIF4gKH5haDQgJiBhaDYpXG4gICAgICBsID0gKGFsNCAmIGFsNSkgXiAofmFsNCAmIGFsNilcbiAgICAgIGEgKz0gbCAmIDB4ZmZmZlxuICAgICAgYiArPSBsID4+PiAxNlxuICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICBkICs9IGggPj4+IDE2XG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpICogMl1cbiAgICAgIGwgPSBLW2kgKiAyICsgMV1cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZlxuICAgICAgYiArPSBsID4+PiAxNlxuICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICBkICs9IGggPj4+IDE2XG4gICAgICAvLyB3XG4gICAgICBoID0gd2hbaSAlIDE2XVxuICAgICAgbCA9IHdsW2kgJSAxNl1cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZlxuICAgICAgYiArPSBsID4+PiAxNlxuICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICBkICs9IGggPj4+IDE2XG4gICAgICBiICs9IGEgPj4+IDE2XG4gICAgICBjICs9IGIgPj4+IDE2XG4gICAgICBkICs9IGMgPj4+IDE2XG4gICAgICB0aCA9IGMgJiAweGZmZmYgfCBkIDw8IDE2XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2XG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aFxuICAgICAgbCA9IHRsXG4gICAgICBhID0gbCAmIDB4ZmZmZlxuICAgICAgYiA9IGwgPj4+IDE2XG4gICAgICBjID0gaCAmIDB4ZmZmZlxuICAgICAgZCA9IGggPj4+IDE2XG4gICAgICAvLyBTaWdtYTBcbiAgICAgIGggPSAoKGFoMCA+Pj4gMjgpIHwgKGFsMCA8PCAoMzIgLSAyOCkpKSBeICgoYWwwID4+PiAoMzQgLSAzMikpIHwgKGFoMCA8PCAoMzIgLSAoMzQgLSAzMikpKSkgXiAoKGFsMCA+Pj4gKDM5IC0gMzIpKSB8IChhaDAgPDwgKDMyIC0gKDM5IC0gMzIpKSkpXG4gICAgICBsID0gKChhbDAgPj4+IDI4KSB8IChhaDAgPDwgKDMyIC0gMjgpKSkgXiAoKGFoMCA+Pj4gKDM0IC0gMzIpKSB8IChhbDAgPDwgKDMyIC0gKDM0IC0gMzIpKSkpIF4gKChhaDAgPj4+ICgzOSAtIDMyKSkgfCAoYWwwIDw8ICgzMiAtICgzOSAtIDMyKSkpKVxuICAgICAgYSArPSBsICYgMHhmZmZmXG4gICAgICBiICs9IGwgPj4+IDE2XG4gICAgICBjICs9IGggJiAweGZmZmZcbiAgICAgIGQgKz0gaCA+Pj4gMTZcbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKVxuICAgICAgbCA9IChhbDAgJiBhbDEpIF4gKGFsMCAmIGFsMikgXiAoYWwxICYgYWwyKVxuICAgICAgYSArPSBsICYgMHhmZmZmXG4gICAgICBiICs9IGwgPj4+IDE2XG4gICAgICBjICs9IGggJiAweGZmZmZcbiAgICAgIGQgKz0gaCA+Pj4gMTZcbiAgICAgIGIgKz0gYSA+Pj4gMTZcbiAgICAgIGMgKz0gYiA+Pj4gMTZcbiAgICAgIGQgKz0gYyA+Pj4gMTZcbiAgICAgIGJoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KVxuICAgICAgYmw3ID0gKGEgJiAweGZmZmYpIHwgKGIgPDwgMTYpXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSBiaDNcbiAgICAgIGwgPSBibDNcbiAgICAgIGEgPSBsICYgMHhmZmZmXG4gICAgICBiID0gbCA+Pj4gMTZcbiAgICAgIGMgPSBoICYgMHhmZmZmXG4gICAgICBkID0gaCA+Pj4gMTZcbiAgICAgIGggPSB0aFxuICAgICAgbCA9IHRsXG4gICAgICBhICs9IGwgJiAweGZmZmZcbiAgICAgIGIgKz0gbCA+Pj4gMTZcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZlxuICAgICAgZCArPSBoID4+PiAxNlxuICAgICAgYiArPSBhID4+PiAxNlxuICAgICAgYyArPSBiID4+PiAxNlxuICAgICAgZCArPSBjID4+PiAxNlxuICAgICAgYmgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICAgIGFoMSA9IGJoMFxuICAgICAgYWgyID0gYmgxXG4gICAgICBhaDMgPSBiaDJcbiAgICAgIGFoNCA9IGJoM1xuICAgICAgYWg1ID0gYmg0XG4gICAgICBhaDYgPSBiaDVcbiAgICAgIGFoNyA9IGJoNlxuICAgICAgYWgwID0gYmg3XG4gICAgICBhbDEgPSBibDBcbiAgICAgIGFsMiA9IGJsMVxuICAgICAgYWwzID0gYmwyXG4gICAgICBhbDQgPSBibDNcbiAgICAgIGFsNSA9IGJsNFxuICAgICAgYWw2ID0gYmw1XG4gICAgICBhbDcgPSBibDZcbiAgICAgIGFsMCA9IGJsN1xuICAgICAgaWYgKGkgJSAxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal1cbiAgICAgICAgICBsID0gd2xbal1cbiAgICAgICAgICBhID0gbCAmIDB4ZmZmZlxuICAgICAgICAgIGIgPSBsID4+PiAxNlxuICAgICAgICAgIGMgPSBoICYgMHhmZmZmXG4gICAgICAgICAgZCA9IGggPj4+IDE2XG4gICAgICAgICAgaCA9IHdoWyhqICsgOSkgJSAxNl1cbiAgICAgICAgICBsID0gd2xbKGogKyA5KSAlIDE2XVxuICAgICAgICAgIGEgKz0gbCAmIDB4ZmZmZlxuICAgICAgICAgIGIgKz0gbCA+Pj4gMTZcbiAgICAgICAgICBjICs9IGggJiAweGZmZmZcbiAgICAgICAgICBkICs9IGggPj4+IDE2XG4gICAgICAgICAgLy8gc2lnbWEwXG4gICAgICAgICAgdGggPSB3aFsoaiArIDEpICUgMTZdXG4gICAgICAgICAgdGwgPSB3bFsoaiArIDEpICUgMTZdXG4gICAgICAgICAgaCA9ICgodGggPj4+IDEpIHwgKHRsIDw8ICgzMiAtIDEpKSkgXiAoKHRoID4+PiA4KSB8ICh0bCA8PCAoMzIgLSA4KSkpIF4gKHRoID4+PiA3KVxuICAgICAgICAgIGwgPSAoKHRsID4+PiAxKSB8ICh0aCA8PCAoMzIgLSAxKSkpIF4gKCh0bCA+Pj4gOCkgfCAodGggPDwgKDMyIC0gOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMiAtIDcpKSlcbiAgICAgICAgICBhICs9IGwgJiAweGZmZmZcbiAgICAgICAgICBiICs9IGwgPj4+IDE2XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICAgICAgZCArPSBoID4+PiAxNlxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGogKyAxNCkgJSAxNl1cbiAgICAgICAgICB0bCA9IHdsWyhqICsgMTQpICUgMTZdXG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzIgLSAxOSkpKSBeICgodGwgPj4+ICg2MSAtIDMyKSkgfCAodGggPDwgKDMyIC0gKDYxIC0gMzIpKSkpIF4gKHRoID4+PiA2KVxuICAgICAgICAgIGwgPSAoKHRsID4+PiAxOSkgfCAodGggPDwgKDMyIC0gMTkpKSkgXiAoKHRoID4+PiAoNjEgLSAzMikpIHwgKHRsIDw8ICgzMiAtICg2MSAtIDMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMiAtIDYpKSlcbiAgICAgICAgICBhICs9IGwgJiAweGZmZmZcbiAgICAgICAgICBiICs9IGwgPj4+IDE2XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmXG4gICAgICAgICAgZCArPSBoID4+PiAxNlxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTZcbiAgICAgICAgICBjICs9IGIgPj4+IDE2XG4gICAgICAgICAgZCArPSBjID4+PiAxNlxuICAgICAgICAgIHdoW2pdID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwXG4gICAgbCA9IGFsMFxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbMF1cbiAgICBsID0gaGxbMF1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzBdID0gYWgwID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWgxXG4gICAgbCA9IGFsMVxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbMV1cbiAgICBsID0gaGxbMV1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzFdID0gYWgxID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWgyXG4gICAgbCA9IGFsMlxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbMl1cbiAgICBsID0gaGxbMl1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzJdID0gYWgyID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWgzXG4gICAgbCA9IGFsM1xuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbM11cbiAgICBsID0gaGxbM11cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzNdID0gYWgzID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWg0XG4gICAgbCA9IGFsNFxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbNF1cbiAgICBsID0gaGxbNF1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzRdID0gYWg0ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWg1XG4gICAgbCA9IGFsNVxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbNV1cbiAgICBsID0gaGxbNV1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzVdID0gYWg1ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWg2XG4gICAgbCA9IGFsNlxuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbNl1cbiAgICBsID0gaGxbNl1cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzZdID0gYWg2ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBoID0gYWg3XG4gICAgbCA9IGFsN1xuICAgIGEgPSBsICYgMHhmZmZmXG4gICAgYiA9IGwgPj4+IDE2XG4gICAgYyA9IGggJiAweGZmZmZcbiAgICBkID0gaCA+Pj4gMTZcbiAgICBoID0gaGhbN11cbiAgICBsID0gaGxbN11cbiAgICBhICs9IGwgJiAweGZmZmZcbiAgICBiICs9IGwgPj4+IDE2XG4gICAgYyArPSBoICYgMHhmZmZmXG4gICAgZCArPSBoID4+PiAxNlxuICAgIGIgKz0gYSA+Pj4gMTZcbiAgICBjICs9IGIgPj4+IDE2XG4gICAgZCArPSBjID4+PiAxNlxuICAgIGhoWzddID0gYWg3ID0gKGMgJiAweGZmZmYpIHwgKGQgPDwgMTYpXG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNilcbiAgICBwb3MgKz0gMTI4XG4gICAgbiAtPSAxMjhcbiAgfVxuICByZXR1cm4gblxufVxuZnVuY3Rpb24gY3J5cHRvX2hhc2gob3V0LCBtLCBuKSB7XG4gIHZhciBoaCA9IG5ldyBJbnQzMkFycmF5KDgpXG4gIHZhciBobCA9IG5ldyBJbnQzMkFycmF5KDgpXG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICB2YXIgaSwgYiA9IG5cbiAgaGhbMF0gPSAweDZhMDllNjY3XG4gIGhoWzFdID0gMHhiYjY3YWU4NVxuICBoaFsyXSA9IDB4M2M2ZWYzNzJcbiAgaGhbM10gPSAweGE1NGZmNTNhXG4gIGhoWzRdID0gMHg1MTBlNTI3ZlxuICBoaFs1XSA9IDB4OWIwNTY4OGNcbiAgaGhbNl0gPSAweDFmODNkOWFiXG4gIGhoWzddID0gMHg1YmUwY2QxOVxuICBobFswXSA9IDB4ZjNiY2M5MDhcbiAgaGxbMV0gPSAweDg0Y2FhNzNiXG4gIGhsWzJdID0gMHhmZTk0ZjgyYlxuICBobFszXSA9IDB4NWYxZDM2ZjFcbiAgaGxbNF0gPSAweGFkZTY4MmQxXG4gIGhsWzVdID0gMHgyYjNlNmMxZlxuICBobFs2XSA9IDB4ZmI0MWJkNmJcbiAgaGxbN10gPSAweDEzN2UyMTc5XG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbilcbiAgbiAlPSAxMjhcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKylcbiAgICB4W2ldID0gbVtiIC0gbiArIGldXG4gIHhbbl0gPSAxMjhcbiAgbiA9IDI1NiAtIDEyOCAqIChuIDwgMTEyID8gMSA6IDApXG4gIHhbbiAtIDldID0gMFxuICB0czY0KHgsIG4gLSA4LCAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKVxuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIHgsIG4pXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgdHM2NChvdXQsIDggKiBpLCBoaFtpXSwgaGxbaV0pXG4gIHJldHVybiAwXG59XG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSwgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKSwgZyA9IGdmKCksIGggPSBnZigpLCB0ID0gZ2YoKVxuICBaKGEsIHBbMV0sIHBbMF0pXG4gIFoodCwgcVsxXSwgcVswXSlcbiAgTShhLCBhLCB0KVxuICBBKGIsIHBbMF0sIHBbMV0pXG4gIEEodCwgcVswXSwgcVsxXSlcbiAgTShiLCBiLCB0KVxuICBNKGMsIHBbM10sIHFbM10pXG4gIE0oYywgYywgRDIpXG4gIE0oZCwgcFsyXSwgcVsyXSlcbiAgQShkLCBkLCBkKVxuICBaKGUsIGIsIGEpXG4gIFooZiwgZCwgYylcbiAgQShnLCBkLCBjKVxuICBBKGgsIGIsIGEpXG4gIE0ocFswXSwgZSwgZilcbiAgTShwWzFdLCBoLCBnKVxuICBNKHBbMl0sIGcsIGYpXG4gIE0ocFszXSwgZSwgaClcbn1cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKVxuICB9XG59XG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKClcbiAgaW52MjU1MTkoemksIHBbMl0pXG4gIE0odHgsIHBbMF0sIHppKVxuICBNKHR5LCBwWzFdLCB6aSlcbiAgcGFjazI1NTE5KHIsIHR5KVxuICByWzMxXSBePSBwYXIyNTUxOSh0eCkgPDwgN1xufVxuZnVuY3Rpb24gc2NhbGFybXVsdChwLCBxLCBzKSB7XG4gIHZhciBiLCBpXG4gIHNldDI1NTE5KHBbMF0sIGdmMClcbiAgc2V0MjU1MTkocFsxXSwgZ2YxKVxuICBzZXQyNTUxOShwWzJdLCBnZjEpXG4gIHNldDI1NTE5KHBbM10sIGdmMClcbiAgZm9yIChpID0gMjU1OyBpID49IDA7IC0taSkge1xuICAgIGIgPSAoc1soaSAvIDgpIHwgMF0gPj4gKGkgJiA3KSkgJiAxXG4gICAgY3N3YXAocCwgcSwgYilcbiAgICBhZGQocSwgcClcbiAgICBhZGQocCwgcClcbiAgICBjc3dhcChwLCBxLCBiKVxuICB9XG59XG5mdW5jdGlvbiBzY2FsYXJiYXNlKHAsIHMpIHtcbiAgdmFyIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV1cbiAgc2V0MjU1MTkocVswXSwgWClcbiAgc2V0MjU1MTkocVsxXSwgWSlcbiAgc2V0MjU1MTkocVsyXSwgZ2YxKVxuICBNKHFbM10sIFgsIFkpXG4gIHNjYWxhcm11bHQocCwgcSwgcylcbn1cbnZhciBMID0gbmV3IEZsb2F0NjRBcnJheShbMHhlZCwgMHhkMywgMHhmNSwgMHg1YywgMHgxYSwgMHg2MywgMHgxMiwgMHg1OCwgMHhkNiwgMHg5YywgMHhmNywgMHhhMiwgMHhkZSwgMHhmOSwgMHhkZSwgMHgxNCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgxMF0pXG5mdW5jdGlvbiBtb2RMKHIsIHgpIHtcbiAgdmFyIGNhcnJ5LCBpLCBqLCBrXG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDBcbiAgICBmb3IgKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgIHhbal0gKz0gY2FycnkgLSAxNiAqIHhbaV0gKiBMW2ogLSAoaSAtIDMyKV1cbiAgICAgIGNhcnJ5ID0gKHhbal0gKyAxMjgpID4+IDhcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTZcbiAgICB9XG4gICAgeFtqXSArPSBjYXJyeVxuICAgIHhbaV0gPSAwXG4gIH1cbiAgY2FycnkgPSAwXG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB7XG4gICAgeFtqXSArPSBjYXJyeSAtICh4WzMxXSA+PiA0KSAqIExbal1cbiAgICBjYXJyeSA9IHhbal0gPj4gOFxuICAgIHhbal0gJj0gMjU1XG4gIH1cbiAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspXG4gICAgeFtqXSAtPSBjYXJyeSAqIExbal1cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2kgKyAxXSArPSB4W2ldID4+IDhcbiAgICByW2ldID0geFtpXSAmIDI1NVxuICB9XG59XG5mdW5jdGlvbiByZWR1Y2Uocikge1xuICB2YXIgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKVxuICAgIHhbaV0gPSByW2ldXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKVxuICAgIHJbaV0gPSAwXG4gIG1vZEwociwgeClcbn1cbi8vIExpa2UgY3J5cHRvX3NpZ24sIGJ1dCB1c2VzIHNlY3JldCBrZXkgZGlyZWN0bHkgaW4gaGFzaC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2RpcmVjdChzbSwgbSwgbiwgc2spIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NClcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KVxuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXVxuICB2YXIgaSwgalxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgIHNtWzY0ICsgaV0gPSBtW2ldXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIHNtWzMyICsgaV0gPSBza1tpXVxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4gKyAzMilcbiAgcmVkdWNlKHIpXG4gIHNjYWxhcmJhc2UocCwgcilcbiAgcGFjayhzbSwgcClcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgc21baSArIDMyXSA9IHNrWzMyICsgaV1cbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NClcbiAgcmVkdWNlKGgpXG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKVxuICAgIHhbaV0gPSAwXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIHhbaV0gPSByW2ldXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IDMyOyBqKyspIHtcbiAgICAgIHhbaSArIGpdICs9IGhbaV0gKiBza1tqXVxuICAgIH1cbiAgfVxuICBtb2RMKHNtLnN1YmFycmF5KDMyKSwgeClcbiAgcmV0dXJuIG4gKyA2NFxufVxuLy8gTm90ZTogc20gbXVzdCBiZSBuKzEyOC5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2RpcmVjdF9ybmQoc20sIG0sIG4sIHNrLCBybmQpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCksIGggPSBuZXcgVWludDhBcnJheSg2NCksIHIgPSBuZXcgVWludDhBcnJheSg2NClcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDY0KVxuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXVxuICB2YXIgaSwgalxuICAvLyBIYXNoIHNlcGFyYXRpb24uXG4gIHNtWzBdID0gMHhmZVxuICBmb3IgKGkgPSAxOyBpIDwgMzI7IGkrKylcbiAgICBzbVtpXSA9IDB4ZmZcbiAgLy8gU2VjcmV0IGtleS5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgc21bMzIgKyBpXSA9IHNrW2ldXG4gIC8vIE1lc3NhZ2UuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgc21bNjQgKyBpXSA9IG1baV1cbiAgLy8gUmFuZG9tIHN1ZmZpeC5cbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspXG4gICAgc21bbiArIDY0ICsgaV0gPSBybmRbaV1cbiAgY3J5cHRvX2hhc2gociwgc20sIG4gKyAxMjgpXG4gIHJlZHVjZShyKVxuICBzY2FsYXJiYXNlKHAsIHIpXG4gIHBhY2soc20sIHApXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIHNtW2kgKyAzMl0gPSBza1szMiArIGldXG4gIGNyeXB0b19oYXNoKGgsIHNtLCBuICsgNjQpXG4gIHJlZHVjZShoKVxuICAvLyBXaXBlIG91dCByYW5kb20gc3VmZml4LlxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKylcbiAgICBzbVtuICsgNjQgKyBpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspXG4gICAgeFtpXSA9IDBcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgeFtpXSA9IHJbaV1cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpICsgal0gKz0gaFtpXSAqIHNrW2pdXG4gICAgfVxuICB9XG4gIG1vZEwoc20uc3ViYXJyYXkoMzIsIG4gKyA2NCksIHgpXG4gIHJldHVybiBuICsgNjRcbn1cbmZ1bmN0aW9uIGN1cnZlMjU1MTlfc2lnbihzbSwgbSwgbiwgc2ssIG9wdF9ybmQpIHtcbiAgLy8gSWYgb3B0X3JuZCBpcyBwcm92aWRlZCwgc20gbXVzdCBoYXZlIG4gKyAxMjgsXG4gIC8vIG90aGVyd2lzZSBpdCBtdXN0IGhhdmUgbiArIDY0IGJ5dGVzLlxuICAvLyBDb252ZXJ0IEN1cnZlMjU1MTkgc2VjcmV0IGtleSBpbnRvIEVkMjU1MTkgc2VjcmV0IGtleSAoaW5jbHVkZXMgcHViIGtleSkuXG4gIHZhciBlZHNrID0gbmV3IFVpbnQ4QXJyYXkoNjQpXG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBlZHNrW2ldID0gc2tbaV1cbiAgLy8gRW5zdXJlIHByaXZhdGUga2V5IGlzIGluIHRoZSBjb3JyZWN0IGZvcm1hdC5cbiAgZWRza1swXSAmPSAyNDhcbiAgZWRza1szMV0gJj0gMTI3XG4gIGVkc2tbMzFdIHw9IDY0XG4gIHNjYWxhcmJhc2UocCwgZWRzaylcbiAgcGFjayhlZHNrLnN1YmFycmF5KDMyKSwgcClcbiAgLy8gUmVtZW1iZXIgc2lnbiBiaXQuXG4gIHZhciBzaWduQml0ID0gZWRza1s2M10gJiAxMjhcbiAgdmFyIHNtbGVuXG4gIGlmIChvcHRfcm5kKSB7XG4gICAgc21sZW4gPSBjcnlwdG9fc2lnbl9kaXJlY3Rfcm5kKHNtLCBtLCBuLCBlZHNrLCBvcHRfcm5kKVxuICB9XG4gIGVsc2Uge1xuICAgIHNtbGVuID0gY3J5cHRvX3NpZ25fZGlyZWN0KHNtLCBtLCBuLCBlZHNrKVxuICB9XG4gIC8vIENvcHkgc2lnbiBiaXQgZnJvbSBwdWJsaWMga2V5IGludG8gc2lnbmF0dXJlLlxuICBzbVs2M10gfD0gc2lnbkJpdFxuICByZXR1cm4gc21sZW5cbn1cbmZ1bmN0aW9uIHVucGFja25lZyhyLCBwKSB7XG4gIHZhciB0ID0gZ2YoKSwgY2hrID0gZ2YoKSwgbnVtID0gZ2YoKSwgZGVuID0gZ2YoKSwgZGVuMiA9IGdmKCksIGRlbjQgPSBnZigpLCBkZW42ID0gZ2YoKVxuICBzZXQyNTUxOShyWzJdLCBnZjEpXG4gIHVucGFjazI1NTE5KHJbMV0sIHApXG4gIFMobnVtLCByWzFdKVxuICBNKGRlbiwgbnVtLCBEKVxuICBaKG51bSwgbnVtLCByWzJdKVxuICBBKGRlbiwgclsyXSwgZGVuKVxuICBTKGRlbjIsIGRlbilcbiAgUyhkZW40LCBkZW4yKVxuICBNKGRlbjYsIGRlbjQsIGRlbjIpXG4gIE0odCwgZGVuNiwgbnVtKVxuICBNKHQsIHQsIGRlbilcbiAgcG93MjUyMyh0LCB0KVxuICBNKHQsIHQsIG51bSlcbiAgTSh0LCB0LCBkZW4pXG4gIE0odCwgdCwgZGVuKVxuICBNKHJbMF0sIHQsIGRlbilcbiAgUyhjaGssIHJbMF0pXG4gIE0oY2hrLCBjaGssIGRlbilcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSlcbiAgICBNKHJbMF0sIHJbMF0sIEkpXG4gIFMoY2hrLCByWzBdKVxuICBNKGNoaywgY2hrLCBkZW4pXG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpXG4gICAgcmV0dXJuIC0xXG4gIGlmIChwYXIyNTUxOShyWzBdKSA9PT0gKHBbMzFdID4+IDcpKVxuICAgIFooclswXSwgZ2YwLCByWzBdKVxuICBNKHJbM10sIHJbMF0sIHJbMV0pXG4gIHJldHVybiAwXG59XG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9vcGVuKG0sIHNtLCBuLCBwaykge1xuICB2YXIgaSwgbWxlblxuICB2YXIgdCA9IG5ldyBVaW50OEFycmF5KDMyKSwgaCA9IG5ldyBVaW50OEFycmF5KDY0KVxuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSwgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXVxuICBtbGVuID0gLTFcbiAgaWYgKG4gPCA2NClcbiAgICByZXR1cm4gLTFcbiAgaWYgKHVucGFja25lZyhxLCBwaykpXG4gICAgcmV0dXJuIC0xXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgbVtpXSA9IHNtW2ldXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKVxuICAgIG1baSArIDMyXSA9IHBrW2ldXG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pXG4gIHJlZHVjZShoKVxuICBzY2FsYXJtdWx0KHAsIHEsIGgpXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKVxuICBhZGQocCwgcSlcbiAgcGFjayh0LCBwKVxuICBuIC09IDY0XG4gIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgICBtW2ldID0gMFxuICAgIHJldHVybiAtMVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspXG4gICAgbVtpXSA9IHNtW2kgKyA2NF1cbiAgbWxlbiA9IG5cbiAgcmV0dXJuIG1sZW5cbn1cbi8vIENvbnZlcnRzIEN1cnZlMjU1MTkgcHVibGljIGtleSBiYWNrIHRvIEVkMjU1MTkgcHVibGljIGtleS5cbi8vIGVkd2FyZHNZID0gKG1vbnRnb21lcnlYIC0gMSkgLyAobW9udGdvbWVyeVggKyAxKVxuZnVuY3Rpb24gY29udmVydFB1YmxpY0tleShwaykge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKSwgeCA9IGdmKCksIGEgPSBnZigpLCBiID0gZ2YoKVxuICB1bnBhY2syNTUxOSh4LCBwaylcbiAgQShhLCB4LCBnZjEpXG4gIFooYiwgeCwgZ2YxKVxuICBpbnYyNTUxOShhLCBhKVxuICBNKGEsIGEsIGIpXG4gIHBhY2syNTUxOSh6LCBhKVxuICByZXR1cm4gelxufVxuZnVuY3Rpb24gY3VydmUyNTUxOV9zaWduX29wZW4obSwgc20sIG4sIHBrKSB7XG4gIC8vIENvbnZlcnQgQ3VydmUyNTUxOSBwdWJsaWMga2V5IGludG8gRWQyNTUxOSBwdWJsaWMga2V5LlxuICB2YXIgZWRwayA9IGNvbnZlcnRQdWJsaWNLZXkocGspXG4gIC8vIFJlc3RvcmUgc2lnbiBiaXQgZnJvbSBzaWduYXR1cmUuXG4gIGVkcGtbMzFdIHw9IHNtWzYzXSAmIDEyOFxuICAvLyBSZW1vdmUgc2lnbiBiaXQgZnJvbSBzaWduYXR1cmUuXG4gIHNtWzYzXSAmPSAxMjdcbiAgLy8gVmVyaWZ5IHNpZ25lZCBtZXNzYWdlLlxuICByZXR1cm4gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgZWRwaylcbn1cbi8qIEhpZ2gtbGV2ZWwgQVBJICovXG5mdW5jdGlvbiBjaGVja0FycmF5VHlwZXMoKSB7XG4gIHZhciBhcmdzID0gW11cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV1cbiAgfVxuICB2YXIgdCwgaVxuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50c1tpXSkpICE9PSAnW29iamVjdCBVaW50OEFycmF5XScpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIHR5cGUgJyArIHQgKyAnLCB1c2UgVWludDhBcnJheScpXG4gIH1cbn1cbmF4bHNpZ24uc2hhcmVkS2V5ID0gZnVuY3Rpb24gKHNlY3JldEtleSwgcHVibGljS2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhwdWJsaWNLZXksIHNlY3JldEtleSlcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSBsZW5ndGgnKVxuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBzZWNyZXQga2V5IGxlbmd0aCcpXG4gIHZhciBzaGFyZWRLZXkgPSBuZXcgVWludDhBcnJheSgzMilcbiAgY3J5cHRvX3NjYWxhcm11bHQoc2hhcmVkS2V5LCBzZWNyZXRLZXksIHB1YmxpY0tleSlcbiAgcmV0dXJuIHNoYXJlZEtleVxufVxuYXhsc2lnbi5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIChzZWNyZXRLZXksIG1zZywgb3B0X3JhbmRvbSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzZWNyZXRLZXkpXG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHNlY3JldCBrZXkgbGVuZ3RoJylcbiAgaWYgKG9wdF9yYW5kb20pIHtcbiAgICBjaGVja0FycmF5VHlwZXMob3B0X3JhbmRvbSlcbiAgICBpZiAob3B0X3JhbmRvbS5sZW5ndGggIT09IDY0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyByYW5kb20gZGF0YSBsZW5ndGgnKVxuICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSgxMjggKyBtc2cubGVuZ3RoKVxuICAgIGN1cnZlMjU1MTlfc2lnbihidWYsIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5LCBvcHRfcmFuZG9tKVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuc3ViYXJyYXkoMCwgNjQgKyBtc2cubGVuZ3RoKSlcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoNjQgKyBtc2cubGVuZ3RoKVxuICAgIGN1cnZlMjU1MTlfc2lnbihzaWduZWRNc2csIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5KVxuICAgIHJldHVybiBzaWduZWRNc2dcbiAgfVxufVxuYXhsc2lnbi5vcGVuTWVzc2FnZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNpZ25lZE1zZykge1xuICBjaGVja0FycmF5VHlwZXMoc2lnbmVkTXNnLCBwdWJsaWNLZXkpXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHB1YmxpYyBrZXkgbGVuZ3RoJylcbiAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KHNpZ25lZE1zZy5sZW5ndGgpXG4gIHZhciBtbGVuID0gY3VydmUyNTUxOV9zaWduX29wZW4odG1wLCBzaWduZWRNc2csIHNpZ25lZE1zZy5sZW5ndGgsIHB1YmxpY0tleSlcbiAgaWYgKG1sZW4gPCAwKVxuICAgIHJldHVybiBudWxsXG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkobWxlbilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKVxuICAgIG1baV0gPSB0bXBbaV1cbiAgcmV0dXJuIG1cbn1cbmF4bHNpZ24uc2lnbiA9IGZ1bmN0aW9uIChzZWNyZXRLZXksIG1zZywgb3B0X3JhbmRvbSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5LCBtc2cpXG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIHNlY3JldCBrZXkgbGVuZ3RoJylcbiAgaWYgKG9wdF9yYW5kb20pIHtcbiAgICBjaGVja0FycmF5VHlwZXMob3B0X3JhbmRvbSlcbiAgICBpZiAob3B0X3JhbmRvbS5sZW5ndGggIT09IDY0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyByYW5kb20gZGF0YSBsZW5ndGgnKVxuICB9XG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheSgob3B0X3JhbmRvbSA/IDEyOCA6IDY0KSArIG1zZy5sZW5ndGgpXG4gIGN1cnZlMjU1MTlfc2lnbihidWYsIG1zZywgbXNnLmxlbmd0aCwgc2VjcmV0S2V5LCBvcHRfcmFuZG9tKVxuICB2YXIgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoNjQpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKVxuICAgIHNpZ25hdHVyZVtpXSA9IGJ1ZltpXVxuICByZXR1cm4gc2lnbmF0dXJlXG59XG5heGxzaWduLnZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIG1zZywgc2lnbmF0dXJlKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIHNpZ25hdHVyZSwgcHVibGljS2V5KVxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gNjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBzaWduYXR1cmUgbGVuZ3RoJylcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcHVibGljIGtleSBsZW5ndGgnKVxuICB2YXIgc20gPSBuZXcgVWludDhBcnJheSg2NCArIG1zZy5sZW5ndGgpXG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoNjQgKyBtc2cubGVuZ3RoKVxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKylcbiAgICBzbVtpXSA9IHNpZ25hdHVyZVtpXVxuICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHNtW2kgKyA2NF0gPSBtc2dbaV1cbiAgcmV0dXJuIChjdXJ2ZTI1NTE5X3NpZ25fb3BlbihtLCBzbSwgc20ubGVuZ3RoLCBwdWJsaWNLZXkpID49IDApXG59XG5heGxzaWduLmdlbmVyYXRlS2V5UGFpciA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWVkKVxuICBpZiAoc2VlZC5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcignd3Jvbmcgc2VlZCBsZW5ndGgnKVxuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheSgzMilcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBza1tpXSA9IHNlZWRbaV1cbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShwaywgc2spXG4gIC8vIFR1cm4gc2VjcmV0IGtleSBpbnRvIHRoZSBjb3JyZWN0IGZvcm1hdC5cbiAgc2tbMF0gJj0gMjQ4XG4gIHNrWzMxXSAmPSAxMjdcbiAgc2tbMzFdIHw9IDY0XG4gIC8vIFJlbW92ZSBzaWduIGJpdCBmcm9tIHB1YmxpYyBrZXkuXG4gIHBrWzMxXSAmPSAxMjdcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWM6IHBrLFxuICAgIHByaXZhdGU6IHNrLFxuICB9XG59XG5leHBvcnRzWydkZWZhdWx0J10gPSBheGxzaWduXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6JztcbnZhciBBTFBIQUJFVF9NQVAgPSBBTFBIQUJFVC5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChtYXAsIGMsIGkpIHtcbiAgICBtYXBbY10gPSBpO1xuICAgIHJldHVybiBtYXA7XG59LCB7fSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZW5jb2RlOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICghYnVmZmVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgdmFyIGRpZ2l0cyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGlnaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzW2pdIDw8PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlnaXRzWzBdICs9IGJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGRpZ2l0cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGRpZ2l0c1trXSArPSBjYXJyeTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChkaWdpdHNba10gLyA1OCkgfCAwO1xuICAgICAgICAgICAgICAgIGRpZ2l0c1trXSAlPSA1ODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSkge1xuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgNTgpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gNTgpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgYnVmZmVyW2ldID09PSAwICYmIGkgPCBidWZmZXIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBkaWdpdHMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlnaXRzLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKGRpZ2l0KSB7XG4gICAgICAgICAgICByZXR1cm4gQUxQSEFCRVRbZGlnaXRdO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICB9LFxuICAgIGRlY29kZTogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBpZiAoIXN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHZhciBieXRlcyA9IFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgaWYgKCEoYyBpbiBBTFBIQUJFVF9NQVApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJUaGVyZSBpcyBubyBjaGFyYWN0ZXIgXFxcIlwiICsgYyArIFwiXFxcIiBpbiB0aGUgQmFzZTU4IHNlcXVlbmNlIVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBieXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2pdICo9IDU4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnl0ZXNbMF0gKz0gQUxQSEFCRVRfTUFQW2NdO1xuICAgICAgICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBieXRlc1tqXSArPSBjYXJyeTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IGJ5dGVzW2pdID4+IDg7XG4gICAgICAgICAgICAgICAgYnl0ZXNbal0gJj0gMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgc3RyaW5nW2ldID09PSAnMScgJiYgaSA8IHN0cmluZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNTguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIEVSUk9SX01TR19JTlBVVCA9ICdJbnB1dCBtdXN0IGJlIGFuIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXknO1xuLy8gRm9yIGNvbnZlbmllbmNlLCBsZXQgcGVvcGxlIGhhc2ggYSBzdHJpbmcsIG5vdCBqdXN0IGEgVWludDhBcnJheVxuZnVuY3Rpb24gbm9ybWFsaXplSW5wdXQoaW5wdXQpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0ID0gaW5wdXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIHJldCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChpbnB1dCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldCA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGlucHV0LCAndXRmOCcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUl9NU0dfSU5QVVQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuLy8gQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nXG4vLyBGb3IgZXhhbXBsZSwgdG9IZXgoWzI1NSwgMCwgMjU1XSkgcmV0dXJucyBcImZmMDBmZlwiXG5mdW5jdGlvbiB0b0hleChieXRlcykge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYnl0ZXMsIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiAobiA8IDE2ID8gJzAnIDogJycpICsgbi50b1N0cmluZygxNik7XG4gICAgfSkuam9pbignJyk7XG59XG4vLyBDb252ZXJ0cyBhbnkgdmFsdWUgaW4gWzAuLi4yXjMyLTFdIHRvIGFuIDgtY2hhcmFjdGVyIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHVpbnQzMlRvSGV4KHZhbCkge1xuICAgIHJldHVybiAoMHgxMDAwMDAwMDAgKyB2YWwpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG59XG4vLyBGb3IgZGVidWdnaW5nOiBwcmludHMgb3V0IGhhc2ggc3RhdGUgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBSRkNcbi8vIHNhbXBsZSBjb21wdXRhdGlvbiBleGFjdGx5LCBzbyB0aGF0IHlvdSBjYW4gZGlmZlxuZnVuY3Rpb24gZGVidWdQcmludChsYWJlbCwgYXJyLCBzaXplKSB7XG4gICAgdmFyIG1zZyA9ICdcXG4nICsgbGFiZWwgKyAnID0gJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBpZiAoc2l6ZSA9PT0gMzIpIHtcbiAgICAgICAgICAgIG1zZyArPSB1aW50MzJUb0hleChhcnJbaV0pLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBtc2cgKz0gJyAnO1xuICAgICAgICAgICAgbXNnICs9IHVpbnQzMlRvSGV4KGFycltpICsgMV0pLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PT0gNjQpIHtcbiAgICAgICAgICAgIG1zZyArPSB1aW50MzJUb0hleChhcnJbaSArIDFdKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbXNnICs9IHVpbnQzMlRvSGV4KGFycltpXSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2l6ZSAnICsgc2l6ZSk7XG4gICAgICAgIGlmIChpICUgNiA9PT0gNCkge1xuICAgICAgICAgICAgbXNnICs9ICdcXG4nICsgbmV3IEFycmF5KGxhYmVsLmxlbmd0aCArIDQpLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpIDwgYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIG1zZyArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGb3IgcGVyZm9ybWFuY2UgdGVzdGluZzogZ2VuZXJhdGVzIE4gYnl0ZXMgb2YgaW5wdXQsIGhhc2hlcyBNIHRpbWVzXG4vLyBNZWFzdXJlcyBhbmQgcHJpbnRzIE1CL3NlY29uZCBoYXNoIHBlcmZvcm1hbmNlIGVhY2ggdGltZVxuZnVuY3Rpb24gdGVzdFNwZWVkKGhhc2hGbiwgTiwgTSkge1xuICAgIHZhciBzdGFydE1zID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgaW5wdXRbaV0gPSBpICUgMjU2O1xuICAgIH1cbiAgICB2YXIgZ2VuTXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBzdGFydE1zID0gZ2VuTXM7XG4gICAgZm9yIChpID0gMDsgaSA8IE07IGkrKykge1xuICAgICAgICB2YXIgaGFzaEhleCA9IGhhc2hGbihpbnB1dCk7XG4gICAgICAgIHZhciBoYXNoTXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIG1zID0gaGFzaE1zIC0gc3RhcnRNcztcbiAgICAgICAgc3RhcnRNcyA9IGhhc2hNcztcbiAgICB9XG59XG4vLyBCbGFrZTJCIGluIHB1cmUgSmF2YXNjcmlwdFxuLy8gQWRhcHRlZCBmcm9tIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gaW4gUkZDNzY5M1xuLy8gUG9ydGVkIHRvIEphdmFzY3JpcHQgYnkgREMgLSBodHRwczovL2dpdGh1Yi5jb20vZGNwb3NjaFxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IHZbYixiKzFdXG4vLyB2IHNob3VsZCBiZSBhIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBBREQ2NEFBKHYsIGEsIGIpIHtcbiAgICB2YXIgbzAgPSB2W2FdICsgdltiXTtcbiAgICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdO1xuICAgIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgICAgICBvMSsrO1xuICAgIH1cbiAgICB2W2FdID0gbzA7XG4gICAgdlthICsgMV0gPSBvMTtcbn1cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSBiXG4vLyBiMCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgYiwgYjEgcmVwcmVzZW50cyB0aGUgaGlnaCAzMiBiaXRzXG5mdW5jdGlvbiBBREQ2NEFDKHYsIGEsIGIwLCBiMSkge1xuICAgIHZhciBvMCA9IHZbYV0gKyBiMDtcbiAgICBpZiAoYjAgPCAwKSB7XG4gICAgICAgIG8wICs9IDB4MTAwMDAwMDAwO1xuICAgIH1cbiAgICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxO1xuICAgIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgICAgICBvMSsrO1xuICAgIH1cbiAgICB2W2FdID0gbzA7XG4gICAgdlthICsgMV0gPSBvMTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gYnl0ZSBhY2Nlc3NcbmZ1bmN0aW9uIEIyQl9HRVQzMihhcnIsIGkpIHtcbiAgICByZXR1cm4gKGFycltpXSBeXG4gICAgICAgIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgICAgICAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgICAgICAgKGFycltpICsgM10gPDwgMjQpKTtcbn1cbi8vIEcgTWl4aW5nIGZ1bmN0aW9uXG4vLyBUaGUgUk9UUnMgYXJlIGlubGluZWQgZm9yIHNwZWVkXG5mdW5jdGlvbiBCMkJfRyhhLCBiLCBjLCBkLCBpeCwgaXkpIHtcbiAgICB2YXIgeDAgPSBtW2l4XTtcbiAgICB2YXIgeDEgPSBtW2l4ICsgMV07XG4gICAgdmFyIHkwID0gbVtpeV07XG4gICAgdmFyIHkxID0gbVtpeSArIDFdO1xuICAgIEFERDY0QUEodiwgYSwgYik7IC8vIHZbYSxhKzFdICs9IHZbYixiKzFdIC4uLiBpbiBKUyB3ZSBtdXN0IHN0b3JlIGEgdWludDY0IGFzIHR3byB1aW50MzJzXG4gICAgQURENjRBQyh2LCBhLCB4MCwgeDEpOyAvLyB2W2EsIGErMV0gKz0geCAuLi4geDAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIHgsIHgxIGlzIHRoZSBoaWdoIDMyIGJpdHNcbiAgICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IDMyIGJpdHNcbiAgICB2YXIgeG9yMCA9IHZbZF0gXiB2W2FdO1xuICAgIHZhciB4b3IxID0gdltkICsgMV0gXiB2W2EgKyAxXTtcbiAgICB2W2RdID0geG9yMTtcbiAgICB2W2QgKyAxXSA9IHhvcjA7XG4gICAgQURENjRBQSh2LCBjLCBkKTtcbiAgICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICAgIHhvcjAgPSB2W2JdIF4gdltjXTtcbiAgICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXTtcbiAgICB2W2JdID0gKHhvcjAgPj4+IDI0KSBeICh4b3IxIDw8IDgpO1xuICAgIHZbYiArIDFdID0gKHhvcjEgPj4+IDI0KSBeICh4b3IwIDw8IDgpO1xuICAgIEFERDY0QUEodiwgYSwgYik7XG4gICAgQURENjRBQyh2LCBhLCB5MCwgeTEpO1xuICAgIC8vIHZbZCxkKzFdID0gKHZbZCxkKzFdIHhvciB2W2EsYSsxXSkgcm90YXRlZCByaWdodCBieSAxNiBiaXRzXG4gICAgeG9yMCA9IHZbZF0gXiB2W2FdO1xuICAgIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdO1xuICAgIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpO1xuICAgIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KTtcbiAgICBBREQ2NEFBKHYsIGMsIGQpO1xuICAgIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSA2MyBiaXRzXG4gICAgeG9yMCA9IHZbYl0gXiB2W2NdO1xuICAgIHhvcjEgPSB2W2IgKyAxXSBeIHZbYyArIDFdO1xuICAgIHZbYl0gPSAoeG9yMSA+Pj4gMzEpIF4gKHhvcjAgPDwgMSk7XG4gICAgdltiICsgMV0gPSAoeG9yMCA+Pj4gMzEpIF4gKHhvcjEgPDwgMSk7XG59XG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4RjNCQ0M5MDgsIDB4NkEwOUU2NjcsIDB4ODRDQUE3M0IsIDB4QkI2N0FFODUsXG4gICAgMHhGRTk0RjgyQiwgMHgzQzZFRjM3MiwgMHg1RjFEMzZGMSwgMHhBNTRGRjUzQSxcbiAgICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAgIDB4RkI0MUJENkIsIDB4MUY4M0Q5QUIsIDB4MTM3RTIxNzksIDB4NUJFMENEMTlcbl0pO1xudmFyIFNJR01BOCA9IFtcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gICAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICAgIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gICAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbiAgICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAgIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gICAgNiwgMTUsIDE0LCA5LCAxMSwgMywgMCwgOCwgMTIsIDIsIDEzLCA3LCAxLCA0LCAxMCwgNSxcbiAgICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gICAgMTQsIDEwLCA0LCA4LCA5LCAxNSwgMTMsIDYsIDEsIDEyLCAwLCAyLCAxMSwgNywgNSwgM1xuXTtcbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICogMjtcbn0pKTtcbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpO1xudmFyIG0gPSBuZXcgVWludDMyQXJyYXkoMzIpO1xuZnVuY3Rpb24gYmxha2UyYkNvbXByZXNzKGN0eCwgbGFzdCkge1xuICAgIHZhciBpID0gMDtcbiAgICAvLyBpbml0IHdvcmsgdmFyaWFibGVzXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgdltpXSA9IGN0eC5oW2ldO1xuICAgICAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV07XG4gICAgfVxuICAgIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICAgIHZbMjRdID0gdlsyNF0gXiBjdHgudDtcbiAgICB2WzI1XSA9IHZbMjVdIF4gKGN0eC50IC8gMHgxMDAwMDAwMDApO1xuICAgIC8vIGhpZ2ggNjQgYml0cyBub3Qgc3VwcG9ydGVkLCBvZmZzZXQgbWF5IG5vdCBiZSBoaWdoZXIgdGhhbiAyKio1My0xXG4gICAgLy8gbGFzdCBibG9jayBmbGFnIHNldCA/XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgICAgdlsyOF0gPSB+dlsyOF07XG4gICAgICAgIHZbMjldID0gfnZbMjldO1xuICAgIH1cbiAgICAvLyBnZXQgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIG1baV0gPSBCMkJfR0VUMzIoY3R4LmIsIDQgKiBpKTtcbiAgICB9XG4gICAgLy8gdHdlbHZlIHJvdW5kcyBvZiBtaXhpbmdcbiAgICAvLyB1bmNvbW1lbnQgdGhlIERlYnVnUHJpbnQgY2FsbHMgdG8gbG9nIHRoZSBjb21wdXRhdGlvblxuICAgIC8vIGFuZCBtYXRjaCB0aGUgUkZDIHNhbXBsZSBkb2N1bWVudGF0aW9uXG4gICAgLy8gdXRpbC5kZWJ1Z1ByaW50KCcgICAgICAgICAgbVsxNl0nLCBtLCA2NClcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyB1dGlsLmRlYnVnUHJpbnQoJyAgIChpPScgKyAoaSA8IDEwID8gJyAnIDogJycpICsgaSArICcpIHZbMTZdJywgdiwgNjQpXG4gICAgICAgIEIyQl9HKDAsIDgsIDE2LCAyNCwgU0lHTUE4MltpICogMTYgKyAwXSwgU0lHTUE4MltpICogMTYgKyAxXSk7XG4gICAgICAgIEIyQl9HKDIsIDEwLCAxOCwgMjYsIFNJR01BODJbaSAqIDE2ICsgMl0sIFNJR01BODJbaSAqIDE2ICsgM10pO1xuICAgICAgICBCMkJfRyg0LCAxMiwgMjAsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDRdLCBTSUdNQTgyW2kgKiAxNiArIDVdKTtcbiAgICAgICAgQjJCX0coNiwgMTQsIDIyLCAzMCwgU0lHTUE4MltpICogMTYgKyA2XSwgU0lHTUE4MltpICogMTYgKyA3XSk7XG4gICAgICAgIEIyQl9HKDAsIDEwLCAyMCwgMzAsIFNJR01BODJbaSAqIDE2ICsgOF0sIFNJR01BODJbaSAqIDE2ICsgOV0pO1xuICAgICAgICBCMkJfRygyLCAxMiwgMjIsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDEwXSwgU0lHTUE4MltpICogMTYgKyAxMV0pO1xuICAgICAgICBCMkJfRyg0LCAxNCwgMTYsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDEyXSwgU0lHTUE4MltpICogMTYgKyAxM10pO1xuICAgICAgICBCMkJfRyg2LCA4LCAxOCwgMjgsIFNJR01BODJbaSAqIDE2ICsgMTRdLCBTSUdNQTgyW2kgKiAxNiArIDE1XSk7XG4gICAgfVxuICAgIC8vIHV0aWwuZGVidWdQcmludCgnICAgKGk9MTIpIHZbMTZdJywgdiwgNjQpXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgY3R4LmhbaV0gPSBjdHguaFtpXSBeIHZbaV0gXiB2W2kgKyAxNl07XG4gICAgfVxuICAgIC8vIHV0aWwuZGVidWdQcmludCgnaFs4XScsIGN0eC5oLCA2NClcbn1cbi8vIENyZWF0ZXMgYSBCTEFLRTJiIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDY0IGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gYmxha2UyYkluaXQob3V0bGVuLCBrZXkpIHtcbiAgICBpZiAob3V0bGVuID09PSAwIHx8IG91dGxlbiA+IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvdXRwdXQgbGVuZ3RoLCBleHBlY3RlZCAwIDwgbGVuZ3RoIDw9IDY0Jyk7XG4gICAgfVxuICAgIGlmIChrZXkgJiYga2V5Lmxlbmd0aCA+IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBrZXksIGV4cGVjdGVkIFVpbnQ4QXJyYXkgd2l0aCAwIDwgbGVuZ3RoIDw9IDY0Jyk7XG4gICAgfVxuICAgIC8vIHN0YXRlLCAncGFyYW0gYmxvY2snXG4gICAgdmFyIGN0eCA9IHtcbiAgICAgICAgYjogbmV3IFVpbnQ4QXJyYXkoMTI4KSxcbiAgICAgICAgaDogbmV3IFVpbnQzMkFycmF5KDE2KSxcbiAgICAgICAgdDogMCxcbiAgICAgICAgYzogMCxcbiAgICAgICAgb3V0bGVuOiBvdXRsZW4gLy8gb3V0cHV0IGxlbmd0aCBpbiBieXRlc1xuICAgIH07XG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGN0eC5oW2ldID0gQkxBS0UyQl9JVjMyW2ldO1xuICAgIH1cbiAgICB2YXIga2V5bGVuID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDA7XG4gICAgY3R4LmhbMF0gXj0gMHgwMTAxMDAwMCBeIChrZXlsZW4gPDwgOCkgXiBvdXRsZW47XG4gICAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gICAgaWYgKGtleSkge1xuICAgICAgICBibGFrZTJiVXBkYXRlKGN0eCwga2V5KTtcbiAgICAgICAgLy8gYXQgdGhlIGVuZFxuICAgICAgICBjdHguYyA9IDEyODtcbiAgICB9XG4gICAgcmV0dXJuIGN0eDtcbn1cbmV4cG9ydHMuYmxha2UyYkluaXQgPSBibGFrZTJiSW5pdDtcbi8vIFVwZGF0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJiVXBkYXRlKGN0eCwgaW5wdXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjdHguYyA9PT0gMTI4KSB7IC8vIGJ1ZmZlciBmdWxsID9cbiAgICAgICAgICAgIGN0eC50ICs9IGN0eC5jOyAvLyBhZGQgY291bnRlcnNcbiAgICAgICAgICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIGZhbHNlKTsgLy8gY29tcHJlc3MgKG5vdCBsYXN0KVxuICAgICAgICAgICAgY3R4LmMgPSAwOyAvLyBjb3VudGVyIHRvIHplcm9cbiAgICAgICAgfVxuICAgICAgICBjdHguYltjdHguYysrXSA9IGlucHV0W2ldO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxha2UyYlVwZGF0ZSA9IGJsYWtlMmJVcGRhdGU7XG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2UyYkZpbmFsKGN0eCkge1xuICAgIGN0eC50ICs9IGN0eC5jOyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG4gICAgd2hpbGUgKGN0eC5jIDwgMTI4KSB7IC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgICAgICBjdHguYltjdHguYysrXSA9IDA7XG4gICAgfVxuICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIHRydWUpOyAvLyBmaW5hbCBibG9jayBmbGFnID0gMVxuICAgIC8vIGxpdHRsZSBlbmRpYW4gY29udmVydCBhbmQgc3RvcmVcbiAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoY3R4Lm91dGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHgub3V0bGVuOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gY3R4LmhbaSA+PiAyXSA+PiAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5ibGFrZTJiRmluYWwgPSBibGFrZTJiRmluYWw7XG4vLyBDb21wdXRlcyB0aGUgQkxBS0UyQiBoYXNoIG9mIGEgc3RyaW5nIG9yIGJ5dGUgYXJyYXksIGFuZCByZXR1cm5zIGEgVWludDhBcnJheVxuLy9cbi8vIFJldHVybnMgYSBuLWJ5dGUgVWludDhBcnJheVxuLy9cbi8vIFBhcmFtZXRlcnM6XG4vLyAtIGlucHV0IC0gdGhlIGlucHV0IGJ5dGVzLCBhcyBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMmIoaW5wdXQsIGtleSwgb3V0bGVuKSB7XG4gICAgLy8gcHJlcHJvY2VzcyBpbnB1dHNcbiAgICBvdXRsZW4gPSBvdXRsZW4gfHwgNjQ7XG4gICAgaW5wdXQgPSBub3JtYWxpemVJbnB1dChpbnB1dCk7XG4gICAgLy8gZG8gdGhlIG1hdGhcbiAgICB2YXIgY3R4ID0gYmxha2UyYkluaXQob3V0bGVuLCBrZXkpO1xuICAgIGJsYWtlMmJVcGRhdGUoY3R4LCBpbnB1dCk7XG4gICAgcmV0dXJuIGJsYWtlMmJGaW5hbChjdHgpO1xufVxuZXhwb3J0cy5ibGFrZTJiID0gYmxha2UyYjtcbi8vIENvbXB1dGVzIHRoZSBCTEFLRTJCIGhhc2ggb2YgYSBzdHJpbmcgb3IgYnl0ZSBhcnJheVxuLy9cbi8vIFJldHVybnMgYW4gbi1ieXRlIGhhc2ggaW4gaGV4LCBhbGwgbG93ZXJjYXNlXG4vL1xuLy8gUGFyYW1ldGVyczpcbi8vIC0gaW5wdXQgLSB0aGUgaW5wdXQgYnl0ZXMsIGFzIGEgc3RyaW5nLCBCdWZmZXIsIG9yIFVpbnQ4QXJyYXlcbi8vIC0ga2V5IC0gb3B0aW9uYWwga2V5IFVpbnQ4QXJyYXksIHVwIHRvIDY0IGJ5dGVzXG4vLyAtIG91dGxlbiAtIG9wdGlvbmFsIG91dHB1dCBsZW5ndGggaW4gYnl0ZXMsIGRlZmF1bHQgNjRcbmZ1bmN0aW9uIGJsYWtlMmJIZXgoaW5wdXQsIGtleSwgb3V0bGVuKSB7XG4gICAgdmFyIG91dHB1dCA9IGJsYWtlMmIoaW5wdXQsIGtleSwgb3V0bGVuKTtcbiAgICByZXR1cm4gdG9IZXgob3V0cHV0KTtcbn1cbmV4cG9ydHMuYmxha2UyYkhleCA9IGJsYWtlMmJIZXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjUuN1xuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBzaGEzID0ge307XG52YXIgSEVYX0NIQVJTID0gJzAxMjM0NTY3ODlhYmNkZWYnLnNwbGl0KCcnKTtcbnZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdO1xudmFyIEtFQ0NBS19QQURESU5HID0gWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XTtcbnZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTtcbnZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xudmFyIFJDID0gWzEsIDAsIDMyODk4LCAwLCAzMjkwNiwgMjE0NzQ4MzY0OCwgMjE0NzUxNjQxNiwgMjE0NzQ4MzY0OCwgMzI5MDcsIDAsIDIxNDc0ODM2NDksXG4gIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcbiAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG4gIDIxNDc0ODM2NDgsIDMyNzcwLCAyMTQ3NDgzNjQ4LCAxMjgsIDIxNDc0ODM2NDgsIDMyNzc4LCAwLCAyMTQ3NDgzNjU4LCAyMTQ3NDgzNjQ4LFxuICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XG52YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xudmFyIFNIQUtFX0JJVFMgPSBbMTI4LCAyNTZdO1xudmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheSddO1xudmFyIGNyZWF0ZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICB9O1xufTtcbnZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICB9O1xufTtcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTtcbiAgfTtcbiAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xuICB9XG4gIHJldHVybiBtZXRob2Q7XG59O1xudmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgdmFyIG1ldGhvZCA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7XG4gICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gIH07XG4gIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kO1xufTtcbnZhciBhbGdvcml0aG1zID0gW1xuICB7IG5hbWU6ICdrZWNjYWsnLCBwYWRkaW5nOiBLRUNDQUtfUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgeyBuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kIH0sXG4gIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9XG5dO1xudmFyIG1ldGhvZHMgPSB7fSwgbWV0aG9kTmFtZXMgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgYWxnb3JpdGhtcy5sZW5ndGg7ICsraSkge1xuICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcbiAgdmFyIGJpdHMgPSBhbGdvcml0aG0uYml0cztcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG4gICAgbWV0aG9kTmFtZXMucHVzaChtZXRob2ROYW1lKTtcbiAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gIHRoaXMuYmxvY2tzID0gW107XG4gIHRoaXMucyA9IFtdO1xuICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xuICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgdGhpcy5ibG9jayA9IDA7XG4gIHRoaXMuc3RhcnQgPSAwO1xuICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xuICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xuICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcbiAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XG4gICAgdGhpcy5zW2ldID0gMDtcbiAgfVxufVxuS2VjY2FrLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICB2YXIgbm90U3RyaW5nID0gdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnO1xuICBpZiAobm90U3RyaW5nICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICB9XG4gIHZhciBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCwgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGJ5dGVDb3VudCA9IHRoaXMuYnl0ZUNvdW50O1xuICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAodGhpcy5yZXNldCkge1xuICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBibG9ja0NvdW50ICsgMTsgKytpKSB7XG4gICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gbWVzc2FnZVtpbmRleF0gPDwgU0hJRlRbaSsrICYgM107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gaSAtIGJ5dGVDb3VudDtcbiAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgICAgfVxuICAgICAgZihzKTtcbiAgICAgIHRoaXMucmVzZXQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5LZWNjYWsucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG4gIHZhciBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xuICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xuICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xuICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICB9XG4gIH1cbiAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgc1tpXSBePSBibG9ja3NbaV07XG4gIH1cbiAgZihzKTtcbn07XG5LZWNjYWsucHJvdG90eXBlLnRvU3RyaW5nID0gS2VjY2FrLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmluYWxpemUoKTtcbiAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzO1xuICB2YXIgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICB2YXIgaGV4ID0gJycsIGJsb2NrO1xuICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcbiAgICB9XG4gICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICBmKHMpO1xuICAgICAgaSA9IDA7XG4gICAgfVxuICB9XG4gIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgYmxvY2sgPSBzW2ldO1xuICAgIGlmIChleHRyYUJ5dGVzID4gMCkge1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcyA+IDEpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhleDtcbn07XG5LZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZpbmFsaXplKCk7XG4gIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcztcbiAgdmFyIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7XG4gIHZhciBidWZmZXI7XG4gIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTtcbiAgfVxuICBlbHNlIHtcbiAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICB9XG4gIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICBhcnJheVtqXSA9IHNbaV07XG4gICAgfVxuICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgZihzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICBhcnJheVtpXSA9IHNbaV07XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcbktlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcbktlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5maW5hbGl6ZSgpO1xuICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3M7XG4gIHZhciBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgb2Zmc2V0LCBibG9jaztcbiAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XG4gICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuICAgIH1cbiAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcbiAgICAgIGYocyk7XG4gICAgfVxuICB9XG4gIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgIGJsb2NrID0gc1tpXTtcbiAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcbiAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn07XG52YXIgZiA9IGZ1bmN0aW9uIChzKSB7XG4gIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LCBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcbiAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcbiAgICBjMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXTtcbiAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcbiAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcbiAgICBjMyA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXTtcbiAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcbiAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcbiAgICBjNiA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XTtcbiAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcbiAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcbiAgICBjOSA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XTtcbiAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xuICAgIGwgPSBjOSBeICgoYzMgPDwgMSkgfCAoYzIgPj4+IDMxKSk7XG4gICAgc1swXSBePSBoO1xuICAgIHNbMV0gXj0gbDtcbiAgICBzWzEwXSBePSBoO1xuICAgIHNbMTFdIF49IGw7XG4gICAgc1syMF0gXj0gaDtcbiAgICBzWzIxXSBePSBsO1xuICAgIHNbMzBdIF49IGg7XG4gICAgc1szMV0gXj0gbDtcbiAgICBzWzQwXSBePSBoO1xuICAgIHNbNDFdIF49IGw7XG4gICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcbiAgICBsID0gYzEgXiAoKGM1IDw8IDEpIHwgKGM0ID4+PiAzMSkpO1xuICAgIHNbMl0gXj0gaDtcbiAgICBzWzNdIF49IGw7XG4gICAgc1sxMl0gXj0gaDtcbiAgICBzWzEzXSBePSBsO1xuICAgIHNbMjJdIF49IGg7XG4gICAgc1syM10gXj0gbDtcbiAgICBzWzMyXSBePSBoO1xuICAgIHNbMzNdIF49IGw7XG4gICAgc1s0Ml0gXj0gaDtcbiAgICBzWzQzXSBePSBsO1xuICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XG4gICAgbCA9IGMzIF4gKChjNyA8PCAxKSB8IChjNiA+Pj4gMzEpKTtcbiAgICBzWzRdIF49IGg7XG4gICAgc1s1XSBePSBsO1xuICAgIHNbMTRdIF49IGg7XG4gICAgc1sxNV0gXj0gbDtcbiAgICBzWzI0XSBePSBoO1xuICAgIHNbMjVdIF49IGw7XG4gICAgc1szNF0gXj0gaDtcbiAgICBzWzM1XSBePSBsO1xuICAgIHNbNDRdIF49IGg7XG4gICAgc1s0NV0gXj0gbDtcbiAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xuICAgIGwgPSBjNSBeICgoYzkgPDwgMSkgfCAoYzggPj4+IDMxKSk7XG4gICAgc1s2XSBePSBoO1xuICAgIHNbN10gXj0gbDtcbiAgICBzWzE2XSBePSBoO1xuICAgIHNbMTddIF49IGw7XG4gICAgc1syNl0gXj0gaDtcbiAgICBzWzI3XSBePSBsO1xuICAgIHNbMzZdIF49IGg7XG4gICAgc1szN10gXj0gbDtcbiAgICBzWzQ2XSBePSBoO1xuICAgIHNbNDddIF49IGw7XG4gICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcbiAgICBsID0gYzcgXiAoKGMxIDw8IDEpIHwgKGMwID4+PiAzMSkpO1xuICAgIHNbOF0gXj0gaDtcbiAgICBzWzldIF49IGw7XG4gICAgc1sxOF0gXj0gaDtcbiAgICBzWzE5XSBePSBsO1xuICAgIHNbMjhdIF49IGg7XG4gICAgc1syOV0gXj0gbDtcbiAgICBzWzM4XSBePSBoO1xuICAgIHNbMzldIF49IGw7XG4gICAgc1s0OF0gXj0gaDtcbiAgICBzWzQ5XSBePSBsO1xuICAgIGIwID0gc1swXTtcbiAgICBiMSA9IHNbMV07XG4gICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XG4gICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XG4gICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XG4gICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XG4gICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XG4gICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XG4gICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xuICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcbiAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XG4gICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xuICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xuICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xuICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcbiAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XG4gICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xuICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcbiAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcbiAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcbiAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XG4gICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xuICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xuICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xuICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xuICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xuICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcbiAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XG4gICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XG4gICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XG4gICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xuICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcbiAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcbiAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcbiAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcbiAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcbiAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcbiAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcbiAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcbiAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcbiAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XG4gICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xuICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcbiAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XG4gICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XG4gICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XG4gICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XG4gICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XG4gICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XG4gICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XG4gICAgc1swXSA9IGIwIF4gKH5iMiAmIGI0KTtcbiAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpO1xuICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuICAgIHNbMTFdID0gYjExIF4gKH5iMTMgJiBiMTUpO1xuICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpO1xuICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuICAgIHNbMzBdID0gYjMwIF4gKH5iMzIgJiBiMzQpO1xuICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpO1xuICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuICAgIHNbNDFdID0gYjQxIF4gKH5iNDMgJiBiNDUpO1xuICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7XG4gICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcbiAgICBzWzEyXSA9IGIxMiBeICh+YjE0ICYgYjE2KTtcbiAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTtcbiAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcbiAgICBzWzIzXSA9IGIyMyBeICh+YjI1ICYgYjI3KTtcbiAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTtcbiAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcbiAgICBzWzQyXSA9IGI0MiBeICh+YjQ0ICYgYjQ2KTtcbiAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTtcbiAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuICAgIHNbNV0gPSBiNSBeICh+YjcgJiBiOSk7XG4gICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7XG4gICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG4gICAgc1syNF0gPSBiMjQgXiAofmIyNiAmIGIyOCk7XG4gICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7XG4gICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG4gICAgc1szNV0gPSBiMzUgXiAofmIzNyAmIGIzOSk7XG4gICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7XG4gICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG4gICAgc1s2XSA9IGI2IF4gKH5iOCAmIGIwKTtcbiAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpO1xuICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuICAgIHNbMTddID0gYjE3IF4gKH5iMTkgJiBiMTEpO1xuICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApO1xuICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuICAgIHNbMzZdID0gYjM2IF4gKH5iMzggJiBiMzApO1xuICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpO1xuICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuICAgIHNbNDddID0gYjQ3IF4gKH5iNDkgJiBiNDEpO1xuICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7XG4gICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcbiAgICBzWzE4XSA9IGIxOCBeICh+YjEwICYgYjEyKTtcbiAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTtcbiAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcbiAgICBzWzI5XSA9IGIyOSBeICh+YjIxICYgYjIzKTtcbiAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTtcbiAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcbiAgICBzWzQ4XSA9IGI0OCBeICh+YjQwICYgYjQyKTtcbiAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTtcbiAgICBzWzBdIF49IFJDW25dO1xuICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICB9XG59O1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBtZXRob2RzLmtlY2Nha18yNTY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EQVRBX0ZJRUxEX1RZUEUgPSBleHBvcnRzLlRSQU5TQUNUSU9OX1RZUEUgPSBleHBvcnRzLkJJTkFSWV9EQVRBX1RZUEUgPSBleHBvcnRzLlNUUklOR19EQVRBX1RZUEUgPSBleHBvcnRzLkJPT0xFQU5fREFUQV9UWVBFID0gZXhwb3J0cy5JTlRFR0VSX0RBVEFfVFlQRSA9IGV4cG9ydHMuRVRIRVJFVU0gPSBleHBvcnRzLklOVk9LRV9FWFBSRVNTSU9OX1RZUEUgPSBleHBvcnRzLlVQREFURV9BU1NFVF9JTkZPX1RZUEUgPSBleHBvcnRzLklOVk9LRV9TQ1JJUFRfVFlQRSA9IGV4cG9ydHMuU0VUX0FTU0VUX1NDUklQVF9UWVBFID0gZXhwb3J0cy5TUE9OU09SU0hJUF9UWVBFID0gZXhwb3J0cy5TRVRfU0NSSVBUX1RZUEUgPSBleHBvcnRzLkRBVEFfVFlQRSA9IGV4cG9ydHMuTUFTU19UUkFOU0ZFUl9UWVBFID0gZXhwb3J0cy5BTElBU19UWVBFID0gZXhwb3J0cy5DQU5DRUxfTEVBU0VfVFlQRSA9IGV4cG9ydHMuTEVBU0VfVFlQRSA9IGV4cG9ydHMuRVhDSEFOR0VfVFlQRSA9IGV4cG9ydHMuQlVSTl9UWVBFID0gZXhwb3J0cy5SRUlTU1VFX1RZUEUgPSBleHBvcnRzLlRSQU5TRkVSX1RZUEUgPSBleHBvcnRzLklTU1VFX1RZUEUgPSBleHBvcnRzLlBBWU1FTlRfVFlQRSA9IGV4cG9ydHMuR0VORVNJU19UWVBFID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhcnRzXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMuR0VORVNJU19UWVBFID0gMTtcbmV4cG9ydHMuUEFZTUVOVF9UWVBFID0gMjtcbmV4cG9ydHMuSVNTVUVfVFlQRSA9IDM7XG5leHBvcnRzLlRSQU5TRkVSX1RZUEUgPSA0O1xuZXhwb3J0cy5SRUlTU1VFX1RZUEUgPSA1O1xuZXhwb3J0cy5CVVJOX1RZUEUgPSA2O1xuZXhwb3J0cy5FWENIQU5HRV9UWVBFID0gNztcbmV4cG9ydHMuTEVBU0VfVFlQRSA9IDg7XG5leHBvcnRzLkNBTkNFTF9MRUFTRV9UWVBFID0gOTtcbmV4cG9ydHMuQUxJQVNfVFlQRSA9IDEwO1xuZXhwb3J0cy5NQVNTX1RSQU5TRkVSX1RZUEUgPSAxMTtcbmV4cG9ydHMuREFUQV9UWVBFID0gMTI7XG5leHBvcnRzLlNFVF9TQ1JJUFRfVFlQRSA9IDEzO1xuZXhwb3J0cy5TUE9OU09SU0hJUF9UWVBFID0gMTQ7XG5leHBvcnRzLlNFVF9BU1NFVF9TQ1JJUFRfVFlQRSA9IDE1O1xuZXhwb3J0cy5JTlZPS0VfU0NSSVBUX1RZUEUgPSAxNjtcbmV4cG9ydHMuVVBEQVRFX0FTU0VUX0lORk9fVFlQRSA9IDE3O1xuZXhwb3J0cy5JTlZPS0VfRVhQUkVTU0lPTl9UWVBFID0gMTg7XG5leHBvcnRzLkVUSEVSRVVNID0gMTk7XG5leHBvcnRzLklOVEVHRVJfREFUQV9UWVBFID0gJ2ludGVnZXInO1xuZXhwb3J0cy5CT09MRUFOX0RBVEFfVFlQRSA9ICdib29sZWFuJztcbmV4cG9ydHMuU1RSSU5HX0RBVEFfVFlQRSA9ICdzdHJpbmcnO1xuZXhwb3J0cy5CSU5BUllfREFUQV9UWVBFID0gJ2JpbmFyeSc7XG5leHBvcnRzLlRSQU5TQUNUSU9OX1RZUEUgPSB7XG4gICAgR0VORVNJUzogZXhwb3J0cy5HRU5FU0lTX1RZUEUsXG4gICAgUEFZTUVOVDogZXhwb3J0cy5QQVlNRU5UX1RZUEUsXG4gICAgSVNTVUU6IGV4cG9ydHMuSVNTVUVfVFlQRSxcbiAgICBUUkFOU0ZFUjogZXhwb3J0cy5UUkFOU0ZFUl9UWVBFLFxuICAgIFJFSVNTVUU6IGV4cG9ydHMuUkVJU1NVRV9UWVBFLFxuICAgIEJVUk46IGV4cG9ydHMuQlVSTl9UWVBFLFxuICAgIEVYQ0hBTkdFOiBleHBvcnRzLkVYQ0hBTkdFX1RZUEUsXG4gICAgTEVBU0U6IGV4cG9ydHMuTEVBU0VfVFlQRSxcbiAgICBDQU5DRUxfTEVBU0U6IGV4cG9ydHMuQ0FOQ0VMX0xFQVNFX1RZUEUsXG4gICAgQUxJQVM6IGV4cG9ydHMuQUxJQVNfVFlQRSxcbiAgICBNQVNTX1RSQU5TRkVSOiBleHBvcnRzLk1BU1NfVFJBTlNGRVJfVFlQRSxcbiAgICBEQVRBOiBleHBvcnRzLkRBVEFfVFlQRSxcbiAgICBTRVRfU0NSSVBUOiBleHBvcnRzLlNFVF9TQ1JJUFRfVFlQRSxcbiAgICBTUE9OU09SU0hJUDogZXhwb3J0cy5TUE9OU09SU0hJUF9UWVBFLFxuICAgIFNFVF9BU1NFVF9TQ1JJUFQ6IGV4cG9ydHMuU0VUX0FTU0VUX1NDUklQVF9UWVBFLFxuICAgIElOVk9LRV9TQ1JJUFQ6IGV4cG9ydHMuSU5WT0tFX1NDUklQVF9UWVBFLFxuICAgIFVQREFURV9BU1NFVF9JTkZPOiBleHBvcnRzLlVQREFURV9BU1NFVF9JTkZPX1RZUEUsXG4gICAgSU5WT0tFX0VYUFJFU1NJT046IGV4cG9ydHMuSU5WT0tFX0VYUFJFU1NJT05fVFlQRSxcbiAgICBFVEhFUkVVTTogZXhwb3J0cy5FVEhFUkVVTSxcbn07XG5leHBvcnRzLkRBVEFfRklFTERfVFlQRSA9IHtcbiAgICBJTlRFR0VSOiBleHBvcnRzLklOVEVHRVJfREFUQV9UWVBFLFxuICAgIEJPT0xFQU46IGV4cG9ydHMuQk9PTEVBTl9EQVRBX1RZUEUsXG4gICAgU1RSSU5HOiBleHBvcnRzLlNUUklOR19EQVRBX1RZUEUsXG4gICAgQklOQVJZOiBleHBvcnRzLkJJTkFSWV9EQVRBX1RZUEUsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzcmNfMSA9IHJlcXVpcmUoXCIuLi9zcmNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFkYXB0ZXIoKSB7XG4gICAgfVxuICAgIHJldHVybiBBZGFwdGVyO1xufSgpKTtcbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9BZGFwdGVyXCIpO1xudmFyIF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbnZhciBXaW5kb3dQcm90b2NvbF8xID0gcmVxdWlyZShcIi4uL3Byb3RvY29scy9XaW5kb3dQcm90b2NvbFwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzL3V0aWxzXCIpO1xudmFyIEVNUFRZX09QVElPTlMgPSB7IG9yaWdpbnM6IFtdLCBhdmFpbGFibGVDaGFuZWxJZDogW10gfTtcbnZhciBXaW5kb3dBZGFwdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaW5kb3dBZGFwdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvd0FkYXB0ZXIobGlzdGVuLCBkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IF9fMS51bmlxdWVJZCgnd2EnKTtcbiAgICAgICAgX3RoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBXaW5kb3dBZGFwdGVyLnByZXBhcmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5saXN0ZW4gPSBsaXN0ZW47XG4gICAgICAgIF90aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgICAgIF90aGlzLmxpc3Rlbi5mb3JFYWNoKGZ1bmN0aW9uIChwcm90b2NvbCkgeyByZXR1cm4gcHJvdG9jb2wub24oJ21lc3NhZ2UnLCBfdGhpcy5vbk1lc3NhZ2UsIF90aGlzKTsgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2luZG93QWRhcHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIF9fMS5jb25zb2xlLmluZm8oJ1dpbmRvd0FkYXB0ZXI6IEFkZCBpZnJhbWUgbWVzc2FnZSBsaXN0ZW5lcicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdpbmRvd0FkYXB0ZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IF9fYXNzaWduKHt9LCBkYXRhLCB7IGNoYW5lbElkOiB0aGlzLm9wdGlvbnMuY2hhbmVsSWQgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2guZm9yRWFjaChmdW5jdGlvbiAocHJvdG9jb2wpIHsgcmV0dXJuIHByb3RvY29sLmRpc3BhdGNoKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgX18xLmNvbnNvbGUuaW5mbygnV2luZG93QWRhcHRlcjogU2VuZCBtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgV2luZG93QWRhcHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW4uZm9yRWFjaChmdW5jdGlvbiAocHJvdG9jb2wpIHsgcmV0dXJuIHByb3RvY29sLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2guZm9yRWFjaChmdW5jdGlvbiAocHJvdG9jb2wpIHsgcmV0dXJuIHByb3RvY29sLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIF9fMS5jb25zb2xlLmluZm8oJ1dpbmRvd0FkYXB0ZXI6IERlc3Ryb3knKTtcbiAgICB9O1xuICAgIFdpbmRvd0FkYXB0ZXIucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5hY2Nlc3NFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fMS5jb25zb2xlLndhcm4oJ1dpbmRvd0FkYXB0ZXI6IFVuaGFuZGxlZCBleGNlcHRpb24hJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpbmRvd0FkYXB0ZXIucHJvdG90eXBlLmFjY2Vzc0V2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gJ29iamVjdCcgfHwgZXZlbnQuZGF0YS50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIF9fMS5jb25zb2xlLmluZm8oJ1dpbmRvd0FkYXB0ZXI6IEJsb2NrIGV2ZW50LiBXcm9uZyBldmVudCBmb3JtYXQhJywgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3JpZ2lucy5oYXMoJyonKSAmJiAhdGhpcy5vcHRpb25zLm9yaWdpbnMuaGFzKGV2ZW50Lm9yaWdpbikpIHtcbiAgICAgICAgICAgIF9fMS5jb25zb2xlLmluZm8oXCJTaW1wbGVXaW5kb3dBZGFwdGVyOiBCbG9jayBldmVudCBieSBvcmlnaW4gXFxcIlwiICsgZXZlbnQub3JpZ2luICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmF2YWlsYWJsZUNoYW5lbElkLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhY2Nlc3MgPSAhIShldmVudC5kYXRhLmNoYW5lbElkICYmIHRoaXMub3B0aW9ucy5hdmFpbGFibGVDaGFuZWxJZC5oYXMoZXZlbnQuZGF0YS5jaGFuZWxJZCkpO1xuICAgICAgICBpZiAoIWFjY2Vzcykge1xuICAgICAgICAgICAgX18xLmNvbnNvbGUuaW5mbyhcIlNpbXBsZVdpbmRvd0FkYXB0ZXI6IEJsb2NrIGV2ZW50IGJ5IGNoYW5lbCBpZCBcXFwiXCIgKyBldmVudC5kYXRhLmNoYW5lbElkICsgXCJcXFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2Nlc3M7XG4gICAgfTtcbiAgICBXaW5kb3dBZGFwdGVyLmNyZWF0ZVNpbXBsZVdpbmRvd0FkYXB0ZXIgPSBmdW5jdGlvbiAoaWZyYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLmdldENvbnRlbnRPcmlnaW4oaWZyYW1lKTtcbiAgICAgICAgdmFyIG15T3B0aW9ucyA9IHRoaXMucHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgbXlPcHRpb25zLm9yaWdpbnMuYWRkKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RlbiA9IG5ldyBXaW5kb3dQcm90b2NvbF8xLldpbmRvd1Byb3RvY29sKHdpbmRvdywgV2luZG93UHJvdG9jb2xfMS5XaW5kb3dQcm90b2NvbC5QUk9UT0NPTF9UWVBFUy5MSVNURU4pO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBsaXN0ZW4ub24oJ21lc3NhZ2UnLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWZyYW1lQ29udGVudChpZnJhbWUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAod2luKSB7XG4gICAgICAgICAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgV2luZG93UHJvdG9jb2xfMS5XaW5kb3dQcm90b2NvbCh3aW4ud2luLCBXaW5kb3dQcm90b2NvbF8xLldpbmRvd1Byb3RvY29sLlBST1RPQ09MX1RZUEVTLkRJU1BBVENIKTtcbiAgICAgICAgICAgIHZhciBhZGFwdGVyID0gbmV3IFdpbmRvd0FkYXB0ZXIoW2xpc3Rlbl0sIFtkaXNwYXRjaF0sIF90aGlzLnVuUHJlcGFyZU9wdGlvbnMobXlPcHRpb25zKSk7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBhZGFwdGVyLm9uTWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpc3Rlbi5vZmYoJ21lc3NhZ2UnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdpbmRvd0FkYXB0ZXIucHJlcGFyZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBFTVBUWV9PUFRJT05TOyB9XG4gICAgICAgIHZhciBjb25jYXQgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7IHJldHVybiBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgaXRlbSkgeyByZXR1cm4gc2V0LmFkZChpdGVtKTsgfSwgaW5pdGlhbFZhbHVlKTsgfTsgfTtcbiAgICAgICAgdmFyIGdldENvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZGF0YSwgaW5pdGlhbCkgeyByZXR1cm4gdXRpbHNfMS5waXBlKF9fMS50b0FycmF5LCBjb25jYXQoaW5pdGlhbCkpKGRhdGEpOyB9O1xuICAgICAgICB2YXIgb3JpZ2lucyA9IGdldENvbGxlY3Rpb24ob3B0aW9ucy5vcmlnaW5zIHx8IFtdLCBuZXcgX18xLlVuaXFQcmltaXRpdmVDb2xsZWN0aW9uKFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSkpO1xuICAgICAgICB2YXIgY2hhbmVsSWQgPSBnZXRDb2xsZWN0aW9uKG9wdGlvbnMuYXZhaWxhYmxlQ2hhbmVsSWQgfHwgW10sIG5ldyBfXzEuVW5pcVByaW1pdGl2ZUNvbGxlY3Rpb24oKSk7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7fSwgb3B0aW9ucywgeyBvcmlnaW5zOiBvcmlnaW5zLCBhdmFpbGFibGVDaGFuZWxJZDogY2hhbmVsSWQgfSk7XG4gICAgfTtcbiAgICBXaW5kb3dBZGFwdGVyLnVuUHJlcGFyZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3JpZ2luczogb3B0aW9ucy5vcmlnaW5zLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGF2YWlsYWJsZUNoYW5lbElkOiBvcHRpb25zLmF2YWlsYWJsZUNoYW5lbElkLnRvQXJyYXkoKSxcbiAgICAgICAgICAgIGNoYW5lbElkOiBvcHRpb25zLmNoYW5lbElkXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBXaW5kb3dBZGFwdGVyLmdldElmcmFtZUNvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB3aW46IHdpbmRvdy5vcGVuZXIgfHwgd2luZG93LnBhcmVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb250ZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgd2luOiBjb250ZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50LmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyB3aW46IGNvbnRlbnQuY29udGVudFdpbmRvdyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY29udGVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh7IHdpbjogY29udGVudC5jb250ZW50V2luZG93IH0pOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICBjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2luZG93QWRhcHRlci5nZXRDb250ZW50T3JpZ2luID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGRvY3VtZW50LnJlZmVycmVyKS5vcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b3Aub3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkwoY29udGVudC5zcmMpLm9yaWdpbiB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd0FkYXB0ZXI7XG59KEFkYXB0ZXJfMS5BZGFwdGVyKSk7XG5leHBvcnRzLldpbmRvd0FkYXB0ZXIgPSBXaW5kb3dBZGFwdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBFdmVudFR5cGU7XG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFdmVudFwiXSA9IDBdID0gXCJFdmVudFwiO1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJBY3Rpb25cIl0gPSAxXSA9IFwiQWN0aW9uXCI7XG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIlJlc3BvbnNlXCJdID0gMl0gPSBcIlJlc3BvbnNlXCI7XG59KShFdmVudFR5cGUgPSBleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xudmFyIFJlc3BvbnNlU3RhdHVzO1xuKGZ1bmN0aW9uIChSZXNwb25zZVN0YXR1cykge1xuICAgIFJlc3BvbnNlU3RhdHVzW1Jlc3BvbnNlU3RhdHVzW1wiU3VjY2Vzc1wiXSA9IDBdID0gXCJTdWNjZXNzXCI7XG4gICAgUmVzcG9uc2VTdGF0dXNbUmVzcG9uc2VTdGF0dXNbXCJFcnJvclwiXSA9IDFdID0gXCJFcnJvclwiO1xufSkoUmVzcG9uc2VTdGF0dXMgPSBleHBvcnRzLlJlc3BvbnNlU3RhdHVzIHx8IChleHBvcnRzLlJlc3BvbnNlU3RhdHVzID0ge30pKTtcbnZhciBCdXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVzKGFkYXB0ZXIsIGRlZmF1bHRUaW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaWQgPSB1dGlsc18xLnVuaXF1ZUlkKCdidXMnKTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IGRlZmF1bHRUaW1lb3V0IHx8IDUwMDA7XG4gICAgICAgIHRoaXMuX2FkYXB0ZXIgPSBhZGFwdGVyO1xuICAgICAgICB0aGlzLl9hZGFwdGVyLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfdGhpcy5fb25NZXNzYWdlKGRhdGEpOyB9KTtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVJlcXVlc3RIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdXRpbHNfMS5jb25zb2xlLmluZm8oXCJDcmVhdGUgQnVzIHdpdGggaWQgXFxcIlwiICsgdGhpcy5pZCArIFwiXFxcIlwiKTtcbiAgICB9XG4gICAgQnVzLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fYWRhcHRlci5zZW5kKEJ1cy5fY3JlYXRlRXZlbnQobmFtZSwgZGF0YSkpO1xuICAgICAgICB1dGlsc18xLmNvbnNvbGUuaW5mbyhcIkRpc3BhdGNoIGV2ZW50IFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVzLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIHRpbWVvdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHV0aWxzXzEudW5pcXVlSWQoX3RoaXMuaWQgKyBcIi1hY3Rpb25cIik7XG4gICAgICAgICAgICB2YXIgd2FpdCA9IHRpbWVvdXQgfHwgX3RoaXMuX3RpbWVvdXQ7XG4gICAgICAgICAgICB2YXIgdGltZXI7XG4gICAgICAgICAgICBpZiAoKHRpbWVvdXQgfHwgX3RoaXMuX3RpbWVvdXQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fYWN0aXZlUmVxdWVzdEhhc2hbaWRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJUaW1lb3V0IGVycm9yIGZvciByZXF1ZXN0IHdpdGggbmFtZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGFuZCB0aW1lb3V0IFwiICsgd2FpdCArIFwiIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5jb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYW5jZWxUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZlUmVxdWVzdEhhc2hbaWRdID0ge1xuICAgICAgICAgICAgICAgIHJlamVjdDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbFRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfMS5jb25zb2xlLmVycm9yKFwiRXJyb3IgcmVxdWVzdCB3aXRoIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXNvbHZlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuY29uc29sZS5pbmZvKFwiUmVxdWVzdCB3aXRoIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzdWNjZXNzIHJlc29sdmVkIVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuX2FkYXB0ZXIuc2VuZCh7IGlkOiBpZCwgdHlwZTogMSAvKiBBY3Rpb24gKi8sIG5hbWU6IG5hbWUsIGRhdGE6IGRhdGEgfSk7XG4gICAgICAgICAgICB1dGlsc18xLmNvbnNvbGUuaW5mbyhcIlJlcXVlc3Qgd2l0aCBuYW1lIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQnVzLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgY29udGV4dCwgZmFsc2UpO1xuICAgIH07XG4gICAgQnVzLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihuYW1lLCBoYW5kbGVyLCBjb250ZXh0LCB0cnVlKTtcbiAgICB9O1xuICAgIEJ1cy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9ldmVudEhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5vZmYobmFtZSwgaGFuZGxlcik7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudEhhbmRsZXJzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV0uc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub2ZmKG5hbWUsIGluZm8uaGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV0gPSB0aGlzLl9ldmVudEhhbmRsZXJzW25hbWVdLmZpbHRlcihmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5oYW5kbGVyICE9PSBoYW5kbGVyOyB9KTtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudEhhbmRsZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCdXMucHJvdG90eXBlLnJlZ2lzdGVyUmVxdWVzdEhhbmRsZXIgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJzW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSByZXF1ZXN0IGhhbmRsZXIhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJzW25hbWVdID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCdXMucHJvdG90eXBlLnVucmVnaXN0ZXJIYW5kbGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RIYW5kbGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RIYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJ1cy5wcm90b3R5cGUuY2hhbmdlQWRhcHRlciA9IGZ1bmN0aW9uIChhZGFwdGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBidXMgPSBuZXcgQnVzKGFkYXB0ZXIsIHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9ldmVudEhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5fZXZlbnRIYW5kbGVyc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICBidXMub25jZShuYW1lLCBpbmZvLmhhbmRsZXIsIGluZm8uY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidXMub24obmFtZSwgaW5mby5oYW5kbGVyLCBpbmZvLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdEhhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBidXMucmVnaXN0ZXJSZXF1ZXN0SGFuZGxlcihuYW1lLCBfdGhpcy5fcmVxdWVzdEhhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBidXM7XG4gICAgfTtcbiAgICBCdXMucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzXzEuY29uc29sZS5pbmZvKCdEZXN0cm95IEJ1cycpO1xuICAgICAgICB0aGlzLm9mZigpO1xuICAgICAgICB0aGlzLl9hZGFwdGVyLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIEJ1cy5wcm90b3R5cGUuX2FkZEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRIYW5kbGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyc1tuYW1lXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV0ucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIG9uY2U6IG9uY2UsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVzLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBFdmVudCAqLzpcbiAgICAgICAgICAgICAgICB1dGlsc18xLmNvbnNvbGUuaW5mbyhcIkhhcyBldmVudCB3aXRoIG5hbWUgXFxcIlwiICsgU3RyaW5nKG1lc3NhZ2UubmFtZSkgKyBcIlxcXCJcIiwgbWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQoU3RyaW5nKG1lc3NhZ2UubmFtZSksIG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEgLyogQWN0aW9uICovOlxuICAgICAgICAgICAgICAgIHV0aWxzXzEuY29uc29sZS5pbmZvKFwiU3RhcnQgYWN0aW9uIHdpdGggaWQgXFxcIlwiICsgbWVzc2FnZS5pZCArIFwiXFxcIiBhbmQgbmFtZSBcXFwiXCIgKyBTdHJpbmcobWVzc2FnZS5uYW1lKSArIFwiXFxcIlwiLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIFJlc3BvbnNlICovOlxuICAgICAgICAgICAgICAgIHV0aWxzXzEuY29uc29sZS5pbmZvKFwiU3RhcnQgcmVzcG9uc2Ugd2l0aCBuYW1lIFxcXCJcIiArIG1lc3NhZ2UuaWQgKyBcIlxcXCIgYW5kIHN0YXR1cyBcXFwiXCIgKyBtZXNzYWdlLnN0YXR1cyArIFwiXFxcIlwiLCBtZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmVFbmRBY3Rpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1cy5wcm90b3R5cGUuX2NyZWF0ZVJlc3BvbnNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlbmRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdXRpbHNfMS5jb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIF90aGlzLl9hZGFwdGVyLnNlbmQoe1xuICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogUmVzcG9uc2UgKi8sXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAxIC8qIEVycm9yICovLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RIYW5kbGVyc1tTdHJpbmcobWVzc2FnZS5uYW1lKV0pIHtcbiAgICAgICAgICAgIHNlbmRFcnJvcihuZXcgRXJyb3IoXCJIYXMgbm8gaGFuZGxlciBmb3IgXFxcIlwiICsgU3RyaW5nKG1lc3NhZ2UubmFtZSkgKyBcIlxcXCIgYWN0aW9uIVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVxdWVzdEhhbmRsZXJzW1N0cmluZyhtZXNzYWdlLm5hbWUpXShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKEJ1cy5faXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRhcHRlci5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiAvKiBSZXNwb25zZSAqLyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCAvKiBTdWNjZXNzICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBzZW5kRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRhcHRlci5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogUmVzcG9uc2UgKi8sXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogMCAvKiBTdWNjZXNzICovLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZXN1bHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgc2VuZEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdXMucHJvdG90eXBlLl9maXJlRW5kQWN0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVJlcXVlc3RIYXNoW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEVycm9yICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVSZXF1ZXN0SGFzaFttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAwIC8qIFN1Y2Nlc3MgKi86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVJlcXVlc3RIYXNoW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWN0aXZlUmVxdWVzdEhhc2hbbWVzc2FnZS5pZF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1cy5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyc1tuYW1lXSA9IHRoaXMuX2V2ZW50SGFuZGxlcnNbbmFtZV1cbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChoYW5kbGVySW5mbykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVySW5mby5oYW5kbGVyLmNhbGwoaGFuZGxlckluZm8uY29udGV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB1dGlsc18xLmNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhaGFuZGxlckluZm8ub25jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRIYW5kbGVyc1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEhhbmRsZXJzW25hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBCdXMuX2NyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMCAvKiBFdmVudCAqLyxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJ1cy5faXNQcm9taXNlID0gZnVuY3Rpb24gKHNvbWUpIHtcbiAgICAgICAgcmV0dXJuIHNvbWUgJiYgc29tZS50aGVuICYmIHR5cGVvZiBzb21lLnRoZW4gPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbiAgICByZXR1cm4gQnVzO1xufSgpKTtcbmV4cG9ydHMuQnVzID0gQnVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uZmlnO1xuKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICB2YXIgY29uc29sZTtcbiAgICAoZnVuY3Rpb24gKGNvbnNvbGUpIHtcbiAgICAgICAgY29uc29sZS5MT0dfTEVWRUwgPSB7XG4gICAgICAgICAgICBQUk9EVUNUSU9OOiAwLFxuICAgICAgICAgICAgRVJST1JTOiAxLFxuICAgICAgICAgICAgVkVSQk9TRTogMlxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZ0xldmVsID0gY29uc29sZS5MT0dfTEVWRUwuUFJPRFVDVElPTjtcbiAgICAgICAgY29uc29sZS5tZXRob2RzRGF0YSA9IHtcbiAgICAgICAgICAgIGxvZzogeyBzYXZlOiBmYWxzZSwgbG9nTGV2ZWw6IGNvbnNvbGUuTE9HX0xFVkVMLlZFUkJPU0UgfSxcbiAgICAgICAgICAgIGluZm86IHsgc2F2ZTogZmFsc2UsIGxvZ0xldmVsOiBjb25zb2xlLkxPR19MRVZFTC5WRVJCT1NFIH0sXG4gICAgICAgICAgICB3YXJuOiB7IHNhdmU6IGZhbHNlLCBsb2dMZXZlbDogY29uc29sZS5MT0dfTEVWRUwuVkVSQk9TRSB9LFxuICAgICAgICAgICAgZXJyb3I6IHsgc2F2ZTogdHJ1ZSwgbG9nTGV2ZWw6IGNvbnNvbGUuTE9HX0xFVkVMLkVSUk9SUyB9XG4gICAgICAgIH07XG4gICAgfSkoY29uc29sZSA9IGNvbmZpZy5jb25zb2xlIHx8IChjb25maWcuY29uc29sZSA9IHt9KSk7XG59KShjb25maWcgPSBleHBvcnRzLmNvbmZpZyB8fCAoZXhwb3J0cy5jb25maWcgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vYnVzL0J1c1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9hZGFwdGVycy9BZGFwdGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2FkYXB0ZXJzL1dpbmRvd0FkYXB0ZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcHJvdG9jb2xzL1dpbmRvd1Byb3RvY29sXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvbmZpZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHR5cGVkX3RzX2V2ZW50c18xID0gcmVxdWlyZShcInR5cGVkLXRzLWV2ZW50c1wiKTtcbnZhciBXaW5kb3dQcm90b2NvbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93UHJvdG9jb2wsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2luZG93UHJvdG9jb2wod2luLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndpbiA9IHdpbjtcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIF90aGlzLmhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ21lc3NhZ2UnLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09PSBXaW5kb3dQcm90b2NvbC5QUk9UT0NPTF9UWVBFUy5MSVNURU4pIHtcbiAgICAgICAgICAgIF90aGlzLndpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgX3RoaXMuaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2luZG93UHJvdG9jb2wucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy53aW4ucG9zdE1lc3NhZ2UoZGF0YSwgJyonKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXaW5kb3dQcm90b2NvbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gV2luZG93UHJvdG9jb2wuUFJPVE9DT0xfVFlQRVMuTElTVEVOKSB7XG4gICAgICAgICAgICB0aGlzLndpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW4gPSBXaW5kb3dQcm90b2NvbC5fZmFrZVdpbjtcbiAgICB9O1xuICAgIFdpbmRvd1Byb3RvY29sLl9mYWtlV2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlOiBlbXB0eSxcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGVtcHR5LFxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZW1wdHlcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBXaW5kb3dQcm90b2NvbDtcbn0odHlwZWRfdHNfZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLldpbmRvd1Byb3RvY29sID0gV2luZG93UHJvdG9jb2w7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuKGZ1bmN0aW9uIChXaW5kb3dQcm90b2NvbCkge1xuICAgIFdpbmRvd1Byb3RvY29sLlBST1RPQ09MX1RZUEVTID0ge1xuICAgICAgICBMSVNURU46ICdsaXN0ZW4nLFxuICAgICAgICBESVNQQVRDSDogJ2Rpc3BhdGNoJ1xuICAgIH07XG59KShXaW5kb3dQcm90b2NvbCA9IGV4cG9ydHMuV2luZG93UHJvdG9jb2wgfHwgKGV4cG9ydHMuV2luZG93UHJvdG9jb2wgPSB7fSkpO1xuZXhwb3J0cy5XaW5kb3dQcm90b2NvbCA9IFdpbmRvd1Byb3RvY29sO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVW5pcVByaW1pdGl2ZUNvbGxlY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5pcVByaW1pdGl2ZUNvbGxlY3Rpb24obGlzdCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLmhhc2ggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgbGlzdC5mb3JFYWNoKHRoaXMuYWRkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBVbmlxUHJpbWl0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5oYXNoW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaXplID0gT2JqZWN0LmtleXModGhpcy5oYXNoKS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgVW5pcVByaW1pdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLmhhc2g7XG4gICAgfTtcbiAgICBVbmlxUHJpbWl0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaGFzaCk7XG4gICAgfTtcbiAgICByZXR1cm4gVW5pcVByaW1pdGl2ZUNvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5VbmlxUHJpbWl0aXZlQ29sbGVjdGlvbiA9IFVuaXFQcmltaXRpdmVDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4uLy4uL2NvbmZpZ1wiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBjb25zb2xlTW9kdWxlID0gKGZ1bmN0aW9uIChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QuY29uc29sZTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiBnbG9iYWwpO1xudmFyIHN0b3JhZ2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gYWRkTmFtZXNwYWNlKHR5cGUpIHtcbiAgICBpZiAoIXN0b3JhZ2VbdHlwZV0pIHtcbiAgICAgICAgc3RvcmFnZVt0eXBlXSA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhdmVFdmVudCh0eXBlLCBhcmdzKSB7XG4gICAgc3RvcmFnZVt0eXBlXS5wdXNoKGFyZ3MpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb25zb2xlKCkge1xuICAgIHJldHVybiB1dGlsc18xLmtleXMoY29uZmlnXzEuY29uZmlnLmNvbnNvbGUubWV0aG9kc0RhdGEpLnJlZHVjZShmdW5jdGlvbiAoYXBpLCBtZXRob2QpIHtcbiAgICAgICAgYXBpW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnXzEuY29uZmlnLmNvbnNvbGUubG9nTGV2ZWwgPCBjb25maWdfMS5jb25maWcuY29uc29sZS5tZXRob2RzRGF0YVttZXRob2RdLmxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ18xLmNvbmZpZy5jb25zb2xlLm1ldGhvZHNEYXRhW21ldGhvZF0uc2F2ZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGROYW1lc3BhY2UobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUV2ZW50KG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZU1vZHVsZVttZXRob2RdLmFwcGx5KGNvbnNvbGVNb2R1bGUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZXhwb3J0cy5jb25zb2xlID0gX19hc3NpZ24oe30sIGdlbmVyYXRlQ29uc29sZSgpLCB7IGdldFNhdmVkTWVzc2FnZXM6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBzdG9yYWdlW3R5cGVdIHx8IFtdO1xuICAgIH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb25zb2xlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1VuaXFQcmltaXRpdmVDb2xsZWN0aW9uXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24ga2V5cyhvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pO1xufVxuZXhwb3J0cy5rZXlzID0ga2V5cztcbnZhciBzYWx0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICogTWF0aC5yYW5kb20oKSk7XG52YXIgY291bnRlciA9IDA7XG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgXCItXCIgKyBzYWx0ICsgXCItXCIgKyBjb3VudGVyKys7XG59XG5leHBvcnRzLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG5mdW5jdGlvbiB0b0FycmF5KHNvbWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzb21lKSA/IHNvbWUgOiBbc29tZV07XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuZnVuY3Rpb24gcGlwZSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBhcmdzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjYikgeyByZXR1cm4gY2IoYWNjKTsgfSwgZGF0YSk7IH07XG59XG5leHBvcnRzLnBpcGUgPSBwaXBlO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuOC4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIElOUFVUX0VSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7XG4gIHZhciBGSU5BTElaRV9FUlJPUiA9ICdmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZCc7XG4gIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbiAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTtcbiAgaWYgKHJvb3QuSlNfU0hBM19OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdO1xuICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07XG4gIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07XG4gIHZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTtcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxuICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcbiAgICAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSxcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcbiAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XG4gIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07XG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheScsICdkaWdlc3QnXTtcbiAgdmFyIENTSEFLRV9CWVRFUEFEID0ge1xuICAgICcxMjgnOiAxNjgsXG4gICAgJzI1Nic6IDEzNlxuICB9O1xuXG4gIGlmIChyb290LkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1snY3NoYWtlJyArIGJpdHNdLnVwZGF0ZShtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kLCBjcmVhdGVNZXRob2QsIGJpdHMsIHBhZGRpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVNZXRob2QoYml0cywgcGFkZGluZywgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIGlmICghbiAmJiAhcykge1xuICAgICAgICByZXR1cm4gbWV0aG9kc1snc2hha2UnICsgYml0c10uY3JlYXRlKG91dHB1dEJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbbiwgc10sIHcpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzLCBuLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUttYWNPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbmV3IEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbJ0tNQUMnLCBzXSwgdykuYnl0ZXBhZChba2V5XSwgdyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5LCBvdXRwdXRCaXRzLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBhbGdvcml0aG1zID0gW1xuICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2ttYWMnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVLbWFjTWV0aG9kIH1cbiAgXTtcblxuICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxnb3JpdGhtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xuICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgJ18nICsgYml0c1tqXTtcbiAgICAgIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gICAgICBpZiAoYWxnb3JpdGhtLm5hbWUgIT09ICdzaGEzJykge1xuICAgICAgICB2YXIgbmV3TWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgYml0c1tqXTtcbiAgICAgICAgbWV0aG9kTmFtZXMucHVzaChuZXdNZXRob2ROYW1lKTtcbiAgICAgICAgbWV0aG9kc1tuZXdNZXRob2ROYW1lXSA9IG1ldGhvZHNbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgIHRoaXMucyA9IFtdO1xuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy5vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmxvY2sgPSAwO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcbiAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcbiAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XG4gICAgICB0aGlzLnNbaV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihGSU5BTElaRV9FUlJPUik7XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGJ5dGVDb3VudCA9IHRoaXMuYnl0ZUNvdW50LCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmKHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh4LCByaWdodCkge1xuICAgIHZhciBvID0geCAmIDI1NSwgbiA9IDE7XG4gICAgdmFyIGJ5dGVzID0gW29dO1xuICAgIHggPSB4ID4+IDg7XG4gICAgbyA9IHggJiAyNTU7XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG8pO1xuICAgICAgeCA9IHggPj4gODtcbiAgICAgIG8gPSB4ICYgMjU1O1xuICAgICAgKytuO1xuICAgIH1cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIGJ5dGVzLnB1c2gobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzLnVuc2hpZnQobik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2Ygc3RyO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBzdHIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgYnl0ZXMgPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJ5dGVzICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGUoYnl0ZXMgKiA4KTtcbiAgICB0aGlzLnVwZGF0ZShzdHIpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3Rycywgdykge1xuICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7XG4gICAgfVxuICAgIHZhciBwYWRkaW5nQnl0ZXMgPSB3IC0gYnl0ZXMgJSB3O1xuICAgIHZhciB6ZXJvcyA9IFtdO1xuICAgIHplcm9zLmxlbmd0aCA9IHBhZGRpbmdCeXRlcztcbiAgICB0aGlzLnVwZGF0ZSh6ZXJvcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleCwgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xuICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBibG9ja3NbYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xuICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgfVxuICAgIGYocyk7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBhcnJheVtpXSA9IHNbaV07XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcblxuICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgZnVuY3Rpb24gS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgS2VjY2FrLmNhbGwodGhpcywgYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gIH1cblxuICBLbWFjLnByb3RvdHlwZSA9IG5ldyBLZWNjYWsoKTtcblxuICBLbWFjLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsIHRydWUpO1xuICAgIHJldHVybiBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSxcbiAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNyxcbiAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMyxcbiAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XG4gICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XG4gICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XG4gICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XG5cbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XG4gICAgICBsID0gYzkgXiAoKGMzIDw8IDEpIHwgKGMyID4+PiAzMSkpO1xuICAgICAgc1swXSBePSBoO1xuICAgICAgc1sxXSBePSBsO1xuICAgICAgc1sxMF0gXj0gaDtcbiAgICAgIHNbMTFdIF49IGw7XG4gICAgICBzWzIwXSBePSBoO1xuICAgICAgc1syMV0gXj0gbDtcbiAgICAgIHNbMzBdIF49IGg7XG4gICAgICBzWzMxXSBePSBsO1xuICAgICAgc1s0MF0gXj0gaDtcbiAgICAgIHNbNDFdIF49IGw7XG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xuICAgICAgbCA9IGMxIF4gKChjNSA8PCAxKSB8IChjNCA+Pj4gMzEpKTtcbiAgICAgIHNbMl0gXj0gaDtcbiAgICAgIHNbM10gXj0gbDtcbiAgICAgIHNbMTJdIF49IGg7XG4gICAgICBzWzEzXSBePSBsO1xuICAgICAgc1syMl0gXj0gaDtcbiAgICAgIHNbMjNdIF49IGw7XG4gICAgICBzWzMyXSBePSBoO1xuICAgICAgc1szM10gXj0gbDtcbiAgICAgIHNbNDJdIF49IGg7XG4gICAgICBzWzQzXSBePSBsO1xuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMyBeICgoYzcgPDwgMSkgfCAoYzYgPj4+IDMxKSk7XG4gICAgICBzWzRdIF49IGg7XG4gICAgICBzWzVdIF49IGw7XG4gICAgICBzWzE0XSBePSBoO1xuICAgICAgc1sxNV0gXj0gbDtcbiAgICAgIHNbMjRdIF49IGg7XG4gICAgICBzWzI1XSBePSBsO1xuICAgICAgc1szNF0gXj0gaDtcbiAgICAgIHNbMzVdIF49IGw7XG4gICAgICBzWzQ0XSBePSBoO1xuICAgICAgc1s0NV0gXj0gbDtcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XG4gICAgICBsID0gYzUgXiAoKGM5IDw8IDEpIHwgKGM4ID4+PiAzMSkpO1xuICAgICAgc1s2XSBePSBoO1xuICAgICAgc1s3XSBePSBsO1xuICAgICAgc1sxNl0gXj0gaDtcbiAgICAgIHNbMTddIF49IGw7XG4gICAgICBzWzI2XSBePSBoO1xuICAgICAgc1syN10gXj0gbDtcbiAgICAgIHNbMzZdIF49IGg7XG4gICAgICBzWzM3XSBePSBsO1xuICAgICAgc1s0Nl0gXj0gaDtcbiAgICAgIHNbNDddIF49IGw7XG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xuICAgICAgbCA9IGM3IF4gKChjMSA8PCAxKSB8IChjMCA+Pj4gMzEpKTtcbiAgICAgIHNbOF0gXj0gaDtcbiAgICAgIHNbOV0gXj0gbDtcbiAgICAgIHNbMThdIF49IGg7XG4gICAgICBzWzE5XSBePSBsO1xuICAgICAgc1syOF0gXj0gaDtcbiAgICAgIHNbMjldIF49IGw7XG4gICAgICBzWzM4XSBePSBoO1xuICAgICAgc1szOV0gXj0gbDtcbiAgICAgIHNbNDhdIF49IGg7XG4gICAgICBzWzQ5XSBePSBsO1xuXG4gICAgICBiMCA9IHNbMF07XG4gICAgICBiMSA9IHNbMV07XG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcbiAgICAgIGIzMyA9IChzWzEwXSA8PCA0KSB8IChzWzExXSA+Pj4gMjgpO1xuICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcbiAgICAgIGI0NiA9IChzWzMxXSA8PCA5KSB8IChzWzMwXSA+Pj4gMjMpO1xuICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XG4gICAgICBiMjkgPSAoc1s0MV0gPDwgMTgpIHwgKHNbNDBdID4+PiAxNCk7XG4gICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XG4gICAgICBiMiA9IChzWzEzXSA8PCAxMikgfCAoc1sxMl0gPj4+IDIwKTtcbiAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xuICAgICAgYjM1ID0gKHNbMjNdIDw8IDEwKSB8IChzWzIyXSA+Pj4gMjIpO1xuICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xuICAgICAgYjQ4ID0gKHNbNDJdIDw8IDIpIHwgKHNbNDNdID4+PiAzMCk7XG4gICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcbiAgICAgIGI0MSA9IChzWzRdIDw8IDMwKSB8IChzWzVdID4+PiAyKTtcbiAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XG4gICAgICBiNCA9IChzWzI1XSA8PCAxMSkgfCAoc1syNF0gPj4+IDIxKTtcbiAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xuICAgICAgYjM3ID0gKHNbMzVdIDw8IDE1KSB8IChzWzM0XSA+Pj4gMTcpO1xuICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcbiAgICAgIGIxMCA9IChzWzZdIDw8IDI4KSB8IChzWzddID4+PiA0KTtcbiAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xuICAgICAgYjQzID0gKHNbMTZdIDw8IDIzKSB8IChzWzE3XSA+Pj4gOSk7XG4gICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xuICAgICAgYjYgPSAoc1szNl0gPDwgMjEpIHwgKHNbMzddID4+PiAxMSk7XG4gICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xuICAgICAgYjM5ID0gKHNbNDZdIDw8IDI0KSB8IChzWzQ3XSA+Pj4gOCk7XG4gICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XG4gICAgICBiMTIgPSAoc1sxOF0gPDwgMjApIHwgKHNbMTldID4+PiAxMik7XG4gICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcbiAgICAgIGI0NSA9IChzWzI4XSA8PCA3KSB8IChzWzI5XSA+Pj4gMjUpO1xuICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcbiAgICAgIGI4ID0gKHNbNDhdIDw8IDE0KSB8IChzWzQ5XSA+Pj4gMTgpO1xuICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XG5cbiAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XG4gICAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpO1xuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XG4gICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcbiAgICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpO1xuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XG4gICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcbiAgICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpO1xuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XG4gICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcbiAgICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7XG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xuICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XG4gICAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTtcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xuICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XG4gICAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTtcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xuICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XG4gICAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTtcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XG4gICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xuICAgICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7XG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcbiAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xuICAgICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7XG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcbiAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xuICAgICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7XG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcbiAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XG4gICAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpO1xuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XG4gICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcbiAgICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApO1xuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XG4gICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcbiAgICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpO1xuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XG4gICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcbiAgICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7XG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xuICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XG4gICAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTtcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xuICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XG4gICAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTtcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xuICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XG4gICAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTtcblxuICAgICAgc1swXSBePSBSQ1tuXTtcbiAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcbiAgICB9XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmVmOiBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1nbG9iYWxcbnZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuXHQvLyBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0Ly8gSG93ZXZlciwgdGhpcyBjYXVzZXMgQ1NQIHZpb2xhdGlvbnMgaW4gQ2hyb21lIGFwcHMuXG5cdGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0aWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH1cblx0dGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbCA9IGdldEdsb2JhbCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBnbG9iYWwuZmV0Y2g7XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdCBhbmQgV2VicGFjay5cbmlmIChnbG9iYWwuZmV0Y2gpIHtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsLmZldGNoLmJpbmQoZ2xvYmFsKTtcbn1cblxuZXhwb3J0cy5IZWFkZXJzID0gZ2xvYmFsLkhlYWRlcnM7XG5leHBvcnRzLlJlcXVlc3QgPSBnbG9iYWwuUmVxdWVzdDtcbmV4cG9ydHMuUmVzcG9uc2UgPSBnbG9iYWwuUmVzcG9uc2U7IiwiLyoqXG4gKiBBZHZhbmNlZCBFbmNyeXB0aW9uIFN0YW5kYXJkIChBRVMpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIHB1YmxpYyBkb21haW4gbGlicmFyeSAnanNjcnlwdG8nIHdoaWNoXG4gKiB3YXMgd3JpdHRlbiBieTpcbiAqXG4gKiBFbWlseSBTdGFyayAoZXN0YXJrQHN0YW5mb3JkLmVkdSlcbiAqIE1pa2UgSGFtYnVyZyAobWhhbWJ1cmdAc3RhbmZvcmQuZWR1KVxuICogRGFuIEJvbmVoIChkYWJvQGNzLnN0YW5mb3JkLmVkdSlcbiAqXG4gKiBQYXJ0cyBvZiB0aGlzIGNvZGUgYXJlIGJhc2VkIG9uIHRoZSBPcGVuU1NMIGltcGxlbWVudGF0aW9uIG9mIEFFUzpcbiAqIGh0dHA6Ly93d3cub3BlbnNzbC5vcmdcbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vY2lwaGVyJyk7XG5yZXF1aXJlKCcuL2NpcGhlck1vZGVzJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuLyogQUVTIEFQSSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5hZXMgPSBmb3JnZS5hZXMgfHwge307XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqIGNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnRFbmNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogZmFsc2UsXG4gICAgbW9kZTogbW9kZVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignQUVTLTxtb2RlPicsIGtleSk7XG4gKiBkZWNpcGhlci5zdGFydCh7aXY6IGl2fSk7XG4gKlxuICogQ3JlYXRlcyBhbiBBRVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKiBUaGUgb3V0cHV0IHdpbGwgYmUgc3RvcmVkIGluIHRoZSAnb3V0cHV0JyBtZW1iZXIgb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLFxuICogYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGl2IHRoZSBpbml0aWFsaXphdGlvbiB2ZWN0b3IgdG8gdXNlLlxuICogQHBhcmFtIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKiBAcGFyYW0gbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mb3JnZS5hZXMuc3RhcnREZWNyeXB0aW5nID0gZnVuY3Rpb24oa2V5LCBpdiwgb3V0cHV0LCBtb2RlKSB7XG4gIHZhciBjaXBoZXIgPSBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgZGVjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICpcbiAqIENyZWF0ZXMgYW4gQUVTIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzLCBhbiBhcnJheSBvZiBieXRlcywgYVxuICogYnl0ZSBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtb2RlIHRoZSBjaXBoZXIgbW9kZSB0byB1c2UgKGRlZmF1bHQ6ICdDQkMnKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBtb2RlKSB7XG4gIHJldHVybiBfY3JlYXRlQ2lwaGVyKHtcbiAgICBrZXk6IGtleSxcbiAgICBvdXRwdXQ6IG51bGwsXG4gICAgZGVjcnlwdDogdHJ1ZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEFFUyBjaXBoZXIgYWxnb3JpdGhtIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIG1vZGUgdGhlIG1vZGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBRVMgYWxnb3JpdGhtIG9iamVjdC5cbiAqL1xuZm9yZ2UuYWVzLkFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm5hbWUgPSBuYW1lO1xuICBzZWxmLm1vZGUgPSBuZXcgbW9kZSh7XG4gICAgYmxvY2tTaXplOiAxNixcbiAgICBjaXBoZXI6IHtcbiAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uKGluQmxvY2ssIG91dEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfdXBkYXRlQmxvY2soc2VsZi5fdywgaW5CbG9jaywgb3V0QmxvY2ssIGZhbHNlKTtcbiAgICAgIH0sXG4gICAgICBkZWNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX3csIGluQmxvY2ssIG91dEJsb2NrLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBzZWxmLl9pbml0ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoaXMgQUVTIGFsZ29yaXRobSBieSBleHBhbmRpbmcgaXRzIGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2UuXG4gKiAgICAgICAgICBrZXkgdGhlIGtleSB0byB1c2Ugd2l0aCB0aGlzIGFsZ29yaXRobS5cbiAqICAgICAgICAgIGRlY3J5cHQgdHJ1ZSBpZiB0aGUgYWxnb3JpdGhtIHNob3VsZCBiZSBpbml0aWFsaXplZCBmb3IgZGVjcnlwdGlvbixcbiAqICAgICAgICAgICAgZmFsc2UgZm9yIGVuY3J5cHRpb24uXG4gKi9cbmZvcmdlLmFlcy5BbGdvcml0aG0ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKHRoaXMuX2luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciB0bXA7XG5cbiAgLyogTm90ZTogVGhlIGtleSBtYXkgYmUgYSBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5IG9mIGJ5dGVzLCBhIGJ5dGVcbiAgICBidWZmZXIsIG9yIGFuIGFycmF5IG9mIDMyLWJpdCBpbnRlZ2Vycy4gSWYgdGhlIGtleSBpcyBpbiBieXRlcywgdGhlblxuICAgIGl0IG11c3QgYmUgMTYsIDI0LCBvciAzMiBieXRlcyBpbiBsZW5ndGguIElmIGl0IGlzIGluIDMyLWJpdFxuICAgIGludGVnZXJzLCBpdCBtdXN0IGJlIDQsIDYsIG9yIDggaW50ZWdlcnMgbG9uZy4gKi9cblxuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH0gZWxzZSBpZihmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSAmJlxuICAgIChrZXkubGVuZ3RoID09PSAxNiB8fCBrZXkubGVuZ3RoID09PSAyNCB8fCBrZXkubGVuZ3RoID09PSAzMikpIHtcbiAgICAvLyBjb252ZXJ0IGtleSBpbnRlZ2VyIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB0bXAgPSBrZXk7XG4gICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXkucHV0Qnl0ZSh0bXBbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnZlcnQga2V5IGJ5dGUgYnVmZmVyIGludG8gMzItYml0IGludGVnZXIgYXJyYXlcbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShrZXkpKSB7XG4gICAgdG1wID0ga2V5O1xuICAgIGtleSA9IFtdO1xuXG4gICAgLy8ga2V5IGxlbmd0aHMgb2YgMTYsIDI0LCAzMiBieXRlcyBhbGxvd2VkXG4gICAgdmFyIGxlbiA9IHRtcC5sZW5ndGgoKTtcbiAgICBpZihsZW4gPT09IDE2IHx8IGxlbiA9PT0gMjQgfHwgbGVuID09PSAzMikge1xuICAgICAgbGVuID0gbGVuID4+PiAyO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleS5wdXNoKHRtcC5nZXRJbnQzMigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZXkgbXVzdCBiZSBhbiBhcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgYnkgbm93XG4gIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSB8fFxuICAgICEoa2V5Lmxlbmd0aCA9PT0gNCB8fCBrZXkubGVuZ3RoID09PSA2IHx8IGtleS5sZW5ndGggPT09IDgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYXJhbWV0ZXIuJyk7XG4gIH1cblxuICAvLyBlbmNyeXB0aW9uIG9wZXJhdGlvbiBpcyBhbHdheXMgdXNlZCBmb3IgdGhlc2UgbW9kZXNcbiAgdmFyIG1vZGUgPSB0aGlzLm1vZGUubmFtZTtcbiAgdmFyIGVuY3J5cHRPcCA9IChbJ0NGQicsICdPRkInLCAnQ1RSJywgJ0dDTSddLmluZGV4T2YobW9kZSkgIT09IC0xKTtcblxuICAvLyBkbyBrZXkgZXhwYW5zaW9uXG4gIHRoaXMuX3cgPSBfZXhwYW5kS2V5KGtleSwgb3B0aW9ucy5kZWNyeXB0ICYmICFlbmNyeXB0T3ApO1xuICB0aGlzLl9pbml0ID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXhwYW5kcyBhIGtleS4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIGV4cGFuZCwgYXMgYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBleHBhbmQgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIGtleS5cbiAqL1xuZm9yZ2UuYWVzLl9leHBhbmRLZXkgPSBmdW5jdGlvbihrZXksIGRlY3J5cHQpIHtcbiAgaWYoIWluaXQpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIF9leHBhbmRLZXkoa2V5LCBkZWNyeXB0KTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIHNpbmdsZSBibG9jay4gVHlwaWNhbGx5IG9ubHkgdXNlZCBmb3IgdGVzdGluZy5cbiAqXG4gKiBAcGFyYW0gdyB0aGUgZXhwYW5kZWQga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpbnB1dCBhbiBhcnJheSBvZiBibG9jay1zaXplIDMyLWJpdCB3b3Jkcy5cbiAqIEBwYXJhbSBvdXRwdXQgYW4gYXJyYXkgb2YgYmxvY2stc2l6ZSAzMi1iaXQgd29yZHMuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIGRlY3J5cHQsIGZhbHNlIHRvIGVuY3J5cHQuXG4gKi9cbmZvcmdlLmFlcy5fdXBkYXRlQmxvY2sgPSBfdXBkYXRlQmxvY2s7XG5cbi8qKiBSZWdpc3RlciBBRVMgYWxnb3JpdGhtcyAqKi9cblxucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1FQ0InLCBmb3JnZS5jaXBoZXIubW9kZXMuZWNiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ0JDJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNiYyk7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0FFUy1PRkInLCBmb3JnZS5jaXBoZXIubW9kZXMub2ZiKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdBRVMtQ1RSJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmN0cik7XG5yZWdpc3RlckFsZ29yaXRobSgnQUVTLUdDTScsIGZvcmdlLmNpcGhlci5tb2Rlcy5nY20pO1xuXG5mdW5jdGlvbiByZWdpc3RlckFsZ29yaXRobShuYW1lLCBtb2RlKSB7XG4gIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpO1xuICB9O1xuICBmb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgZmFjdG9yeSk7XG59XG5cbi8qKiBBRVMgaW1wbGVtZW50YXRpb24gKiovXG5cbnZhciBpbml0ID0gZmFsc2U7IC8vIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbnZhciBOYiA9IDQ7ICAgICAgIC8vIG51bWJlciBvZiB3b3JkcyBjb21wcmlzaW5nIHRoZSBzdGF0ZSAoQUVTID0gNClcbnZhciBzYm94OyAgICAgICAgIC8vIG5vbi1saW5lYXIgc3Vic3RpdHV0aW9uIHRhYmxlIHVzZWQgaW4ga2V5IGV4cGFuc2lvblxudmFyIGlzYm94OyAgICAgICAgLy8gaW52ZXJzaW9uIG9mIHNib3hcbnZhciByY29uOyAgICAgICAgIC8vIHJvdW5kIGNvbnN0YW50IHdvcmQgYXJyYXlcbnZhciBtaXg7ICAgICAgICAgIC8vIG1peC1jb2x1bW5zIHRhYmxlXG52YXIgaW1peDsgICAgICAgICAvLyBpbnZlcnNlIG1peC1jb2x1bW5zIHRhYmxlXG5cbi8qKlxuICogUGVyZm9ybXMgaW5pdGlhbGl6YXRpb24sIGllOiBwcmVjb21wdXRlcyB0YWJsZXMgdG8gb3B0aW1pemUgZm9yIHNwZWVkLlxuICpcbiAqIE9uZSB3YXkgdG8gdW5kZXJzdGFuZCBob3cgQUVTIHdvcmtzIGlzIHRvIGltYWdpbmUgdGhhdCAnYWRkaXRpb24nIGFuZFxuICogJ211bHRpcGxpY2F0aW9uJyBhcmUgaW50ZXJmYWNlcyB0aGF0IHJlcXVpcmUgY2VydGFpbiBtYXRoZW1hdGljYWxcbiAqIHByb3BlcnRpZXMgdG8gaG9sZCB0cnVlIChpZTogdGhleSBhcmUgYXNzb2NpYXRpdmUpIGJ1dCB0aGV5IG1pZ2h0IGhhdmVcbiAqIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbnMgYW5kIHByb2R1Y2UgZGlmZmVyZW50IGtpbmRzIG9mIHJlc3VsdHMgLi4uXG4gKiBwcm92aWRlZCB0aGF0IHRoZWlyIG1hdGhlbWF0aWNhbCBwcm9wZXJ0aWVzIHJlbWFpbiB0cnVlLiBBRVMgZGVmaW5lc1xuICogaXRzIG93biBtZXRob2RzIG9mIGFkZGl0aW9uIGFuZCBtdWx0aXBsaWNhdGlvbiBidXQga2VlcHMgc29tZSBpbXBvcnRhbnRcbiAqIHByb3BlcnRpZXMgdGhlIHNhbWUsIGllOiBhc3NvY2lhdGl2aXR5IGFuZCBkaXN0cmlidXRpdml0eS4gVGhlXG4gKiBleHBsYW5hdGlvbiBiZWxvdyB0cmllcyB0byBzaGVkIHNvbWUgbGlnaHQgb24gaG93IEFFUyBkZWZpbmVzIGFkZGl0aW9uXG4gKiBhbmQgbXVsdGlwbGljYXRpb24gb2YgYnl0ZXMgYW5kIDMyLWJpdCB3b3JkcyBpbiBvcmRlciB0byBwZXJmb3JtIGl0c1xuICogZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiBhbGdvcml0aG1zLlxuICpcbiAqIFRoZSBiYXNpY3M6XG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdmlld3MgYnl0ZXMgYXMgYmluYXJ5IHJlcHJlc2VudGF0aW9ucyBvZiBwb2x5bm9taWFsc1xuICogdGhhdCBoYXZlIGVpdGhlciAxIG9yIDAgYXMgdGhlIGNvZWZmaWNpZW50cy4gSXQgZGVmaW5lcyB0aGUgYWRkaXRpb25cbiAqIG9yIHN1YnRyYWN0aW9uIG9mIHR3byBieXRlcyBhcyB0aGUgWE9SIG9wZXJhdGlvbi4gSXQgYWxzbyBkZWZpbmVzIHRoZVxuICogbXVsdGlwbGljYXRpb24gb2YgdHdvIGJ5dGVzIGFzIGEgZmluaXRlIGZpZWxkIHJlZmVycmVkIHRvIGFzIEdGKDJeOClcbiAqIChOb3RlOiAnR0YnIG1lYW5zIFwiR2Fsb2lzIEZpZWxkXCIgd2hpY2ggaXMgYSBmaWVsZCB0aGF0IGNvbnRhaW5zIGEgZmluaXRlXG4gKiBudW1iZXIgb2YgZWxlbWVudHMgc28gR0YoMl44KSBoYXMgMjU2IGVsZW1lbnRzKS5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgYW55IHR3byBieXRlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYmluYXJ5IHBvbHlub21pYWxzO1xuICogd2hlbiB0aGV5IG11bHRpcGxpZWQgdG9nZXRoZXIgYW5kIG1vZHVsYXJseSByZWR1Y2VkIGJ5IGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIHRoZSA4dGggZGVncmVlLCB0aGUgcmVzdWx0cyBhcmUgdGhlIGZpZWxkIEdGKDJeOCkuIFRoZVxuICogc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCB0aGF0IEFFUyB1c2VzIGluIGhleGFkZWNpbWFsIGlzIDB4MTFiLlxuICogVGhpcyBtdWx0aXBsaWNhdGlvbiBpcyBhc3NvY2lhdGl2ZSB3aXRoIDB4MDEgYXMgdGhlIGlkZW50aXR5OlxuICpcbiAqIChiICogMHgwMSA9IEdGKGIsIDB4MDEpID0gYikuXG4gKlxuICogVGhlIG9wZXJhdGlvbiBHRihiLCAweDAyKSBjYW4gYmUgcGVyZm9ybWVkIGF0IHRoZSBieXRlIGxldmVsIGJ5IGxlZnRcbiAqIHNoaWZ0aW5nIGIgb25jZSBhbmQgdGhlbiBYT1InaW5nIGl0ICh0byBwZXJmb3JtIHRoZSBtb2R1bGFyIHJlZHVjdGlvbilcbiAqIHdpdGggMHgxMWIgaWYgYiBpcyA+PSAxMjguIFJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHRoZSBtdWx0aXBsaWNhdGlvblxuICogb2YgMHgwMiBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgdGhlIG11bHRpcGxpY2F0aW9uIG9mIGFueSB0d28gYnl0ZXMuXG4gKlxuICogRm9yIGluc3RhbmNlLCBtdWx0aXBseWluZyAweDU3IGFuZCAweDEzLCBkZW5vdGVkIGFzIEdGKDB4NTcsIDB4MTMpLCBjYW5cbiAqIGJlIHBlcmZvcm1lZCBieSBmYWN0b3JpbmcgMHgxMyBpbnRvIDB4MDEsIDB4MDIsIGFuZCAweDEwLiBUaGVuIHRoZXNlXG4gKiBmYWN0b3JzIGNhbiBlYWNoIGJlIG11bHRpcGxpZWQgYnkgMHg1NyBhbmQgdGhlbiBhZGRlZCB0b2dldGhlci4gVG8gZG9cbiAqIHRoZSBtdWx0aXBsaWNhdGlvbiwgdmFsdWVzIGZvciAweDU3IG11bHRpcGxpZWQgYnkgZWFjaCBvZiB0aGVzZSAzIGZhY3RvcnNcbiAqIGNhbiBiZSBwcmVjb21wdXRlZCBhbmQgc3RvcmVkIGluIGEgdGFibGUuIFRvIGFkZCB0aGVtLCB0aGUgdmFsdWVzIGZyb21cbiAqIHRoZSB0YWJsZSBhcmUgWE9SJ2QgdG9nZXRoZXIuXG4gKlxuICogQUVTIGFsc28gZGVmaW5lcyBhZGRpdGlvbiBhbmQgbXVsdGlwbGljYXRpb24gb2Ygd29yZHMsIHRoYXQgaXMgNC1ieXRlXG4gKiBudW1iZXJzIHJlcHJlc2VudGVkIGFzIHBvbHlub21pYWxzIG9mIDMgZGVncmVlcyB3aGVyZSB0aGUgY29lZmZpY2llbnRzXG4gKiBhcmUgdGhlIHZhbHVlcyBvZiB0aGUgYnl0ZXMuXG4gKlxuICogVGhlIHdvcmQgW2EwLCBhMSwgYTIsIGEzXSBpcyBhIHBvbHlub21pYWwgYTN4XjMgKyBhMnheMiArIGExeCArIGEwLlxuICpcbiAqIEFkZGl0aW9uIGlzIHBlcmZvcm1lZCBieSBYT1InaW5nIGxpa2UgcG93ZXJzIG9mIHguIE11bHRpcGxpY2F0aW9uXG4gKiBpcyBwZXJmb3JtZWQgaW4gdHdvIHN0ZXBzLCB0aGUgZmlyc3QgaXMgYW4gYWxnZWJyaWFjIGV4cGFuc2lvbiBhc1xuICogeW91IHdvdWxkIGRvIG5vcm1hbGx5ICh3aGVyZSBhZGRpdGlvbiBpcyBYT1IpLiBCdXQgdGhlIHJlc3VsdCBpc1xuICogYSBwb2x5bm9taWFsIGxhcmdlciB0aGFuIDMgZGVncmVlcyBhbmQgdGh1cyBpdCBjYW5ub3QgZml0IGluIGEgd29yZC4gU29cbiAqIG5leHQgdGhlIHJlc3VsdCBpcyBtb2R1bGFybHkgcmVkdWNlZCBieSBhbiBBRVMtc3BlY2lmaWMgcG9seW5vbWlhbCBvZlxuICogZGVncmVlIDQgd2hpY2ggd2lsbCBhbHdheXMgcHJvZHVjZSBhIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIDQgZGVncmVlc1xuICogc3VjaCB0aGF0IGl0IHdpbGwgZml0IGluIGEgd29yZC4gSW4gQUVTLCB0aGlzIHBvbHlub21pYWwgaXMgeF40ICsgMS5cbiAqXG4gKiBUaGUgbW9kdWxhciBwcm9kdWN0IG9mIHR3byBwb2x5bm9taWFscyAnYScgYW5kICdiJyBpcyB0aHVzOlxuICpcbiAqIGQoeCkgPSBkM3heMyArIGQyeF4yICsgZDF4ICsgZDBcbiAqIHdpdGhcbiAqIGQwID0gR0YoYTAsIGIwKSBeIEdGKGEzLCBiMSkgXiBHRihhMiwgYjIpIF4gR0YoYTEsIGIzKVxuICogZDEgPSBHRihhMSwgYjApIF4gR0YoYTAsIGIxKSBeIEdGKGEzLCBiMikgXiBHRihhMiwgYjMpXG4gKiBkMiA9IEdGKGEyLCBiMCkgXiBHRihhMSwgYjEpIF4gR0YoYTAsIGIyKSBeIEdGKGEzLCBiMylcbiAqIGQzID0gR0YoYTMsIGIwKSBeIEdGKGEyLCBiMSkgXiBHRihhMSwgYjIpIF4gR0YoYTAsIGIzKVxuICpcbiAqIEFzIGEgbWF0cml4OlxuICpcbiAqIFtkMF0gPSBbYTAgYTMgYTIgYTFdW2IwXVxuICogW2QxXSAgIFthMSBhMCBhMyBhMl1bYjFdXG4gKiBbZDJdICAgW2EyIGExIGEwIGEzXVtiMl1cbiAqIFtkM10gICBbYTMgYTIgYTEgYTBdW2IzXVxuICpcbiAqIFNwZWNpYWwgcG9seW5vbWlhbHMgZGVmaW5lZCBieSBBRVMgKDB4MDIgPT0gezAyfSk6XG4gKiBhKHgpICAgID0gezAzfXheMyArIHswMX14XjIgKyB7MDF9eCArIHswMn1cbiAqIGFeLTEoeCkgPSB7MGJ9eF4zICsgezBkfXheMiArIHswOX14ICsgezBlfS5cbiAqXG4gKiBUaGVzZSBwb2x5bm9taWFscyBhcmUgdXNlZCBpbiB0aGUgTWl4Q29sdW1ucygpIGFuZCBJbnZlcnNlTWl4Q29sdW1ucygpXG4gKiBvcGVyYXRpb25zLCByZXNwZWN0aXZlbHksIHRvIGNhdXNlIGVhY2ggZWxlbWVudCBpbiB0aGUgc3RhdGUgdG8gYWZmZWN0XG4gKiB0aGUgb3V0cHV0IChyZWZlcnJlZCB0byBhcyBkaWZmdXNpbmcpLlxuICpcbiAqIFJvdFdvcmQoKSB1c2VzOiBhMCA9IGExID0gYTIgPSB7MDB9IGFuZCBhMyA9IHswMX0sIHdoaWNoIGlzIHRoZVxuICogcG9seW5vbWlhbCB4My5cbiAqXG4gKiBUaGUgU2hpZnRSb3dzKCkgbWV0aG9kIG1vZGlmaWVzIHRoZSBsYXN0IDMgcm93cyBpbiB0aGUgc3RhdGUgKHdoZXJlXG4gKiB0aGUgc3RhdGUgaXMgNCB3b3JkcyB3aXRoIDQgYnl0ZXMgcGVyIHdvcmQpIGJ5IHNoaWZ0aW5nIGJ5dGVzIGN5Y2xpY2FsbHkuXG4gKiBUaGUgMXN0IGJ5dGUgaW4gdGhlIHNlY29uZCByb3cgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGUgcm93LiBUaGUgMXN0XG4gKiBhbmQgMm5kIGJ5dGVzIGluIHRoZSB0aGlyZCByb3cgYXJlIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhlIHJvdy4gVGhlIDFzdCxcbiAqIDJuZCwgYW5kIDNyZCBieXRlcyBhcmUgbW92ZWQgaW4gdGhlIGZvdXJ0aCByb3cuXG4gKlxuICogTW9yZSBkZXRhaWxzIG9uIGhvdyBBRVMgYXJpdGhtZXRpYyB3b3JrczpcbiAqXG4gKiBJbiB0aGUgcG9seW5vbWlhbCByZXByZXNlbnRhdGlvbiBvZiBiaW5hcnkgbnVtYmVycywgWE9SIHBlcmZvcm1zIGFkZGl0aW9uXG4gKiBhbmQgc3VidHJhY3Rpb24gYW5kIG11bHRpcGxpY2F0aW9uIGluIEdGKDJeOCkgZGVub3RlZCBhcyBHRihhLCBiKVxuICogY29ycmVzcG9uZHMgd2l0aCB0aGUgbXVsdGlwbGljYXRpb24gb2YgcG9seW5vbWlhbHMgbW9kdWxvIGFuIGlycmVkdWNpYmxlXG4gKiBwb2x5bm9taWFsIG9mIGRlZ3JlZSA4LiBJbiBvdGhlciB3b3JkcywgZm9yIEFFUywgR0YoYSwgYikgd2lsbCBtdWx0aXBseVxuICogcG9seW5vbWlhbCAnYScgd2l0aCBwb2x5bm9taWFsICdiJyBhbmQgdGhlbiBkbyBhIG1vZHVsYXIgcmVkdWN0aW9uIGJ5XG4gKiBhbiBBRVMtc3BlY2lmaWMgaXJyZWR1Y2libGUgcG9seW5vbWlhbCBvZiBkZWdyZWUgOC5cbiAqXG4gKiBBIHBvbHlub21pYWwgaXMgaXJyZWR1Y2libGUgaWYgaXRzIG9ubHkgZGl2aXNvcnMgYXJlIG9uZSBhbmQgaXRzZWxmLiBGb3JcbiAqIHRoZSBBRVMgYWxnb3JpdGhtLCB0aGlzIGlycmVkdWNpYmxlIHBvbHlub21pYWwgaXM6XG4gKlxuICogbSh4KSA9IHheOCArIHheNCArIHheMyArIHggKyAxLFxuICpcbiAqIG9yIHswMX17MWJ9IGluIGhleGFkZWNpbWFsIG5vdGF0aW9uLCB3aGVyZSBlYWNoIGNvZWZmaWNpZW50IGlzIGEgYml0OlxuICogMTAwMDExMDExID0gMjgzID0gMHgxMWIuXG4gKlxuICogRm9yIGV4YW1wbGUsIEdGKDB4NTcsIDB4ODMpID0gMHhjMSBiZWNhdXNlXG4gKlxuICogMHg1NyA9IDg3ICA9IDAxMDEwMTExID0geF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqIDB4ODUgPSAxMzEgPSAxMDAwMDEwMSA9IHheNyArIHggKyAxXG4gKlxuICogKHheNiArIHheNCArIHheMiArIHggKyAxKSAqICh4XjcgKyB4ICsgMSlcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF43ICtcbiAqICAgIHheNyArIHheNSArIHheMyArIHheMiArIHggK1xuICogICAgeF42ICsgeF40ICsgeF4yICsgeCArIDFcbiAqID0gIHheMTMgKyB4XjExICsgeF45ICsgeF44ICsgeF42ICsgeF41ICsgeF40ICsgeF4zICsgMSA9IHlcbiAqICAgIHkgbW9kdWxvICh4XjggKyB4XjQgKyB4XjMgKyB4ICsgMSlcbiAqID0gIHheNyArIHheNiArIDEuXG4gKlxuICogVGhlIG1vZHVsYXIgcmVkdWN0aW9uIGJ5IG0oeCkgZ3VhcmFudGVlcyB0aGUgcmVzdWx0IHdpbGwgYmUgYSBiaW5hcnlcbiAqIHBvbHlub21pYWwgb2YgbGVzcyB0aGFuIGRlZ3JlZSA4LCBzbyB0aGF0IGl0IGNhbiBmaXQgaW4gYSBieXRlLlxuICpcbiAqIFRoZSBvcGVyYXRpb24gdG8gbXVsdGlwbHkgYSBiaW5hcnkgcG9seW5vbWlhbCBiIHdpdGggeCAodGhlIHBvbHlub21pYWxcbiAqIHggaW4gYmluYXJ5IHJlcHJlc2VudGF0aW9uIGlzIDAwMDAwMDEwKSBpczpcbiAqXG4gKiBiXzd4XjggKyBiXzZ4XjcgKyBiXzV4XjYgKyBiXzR4XjUgKyBiXzN4XjQgKyBiXzJ4XjMgKyBiXzF4XjIgKyBiXzB4XjFcbiAqXG4gKiBUbyBnZXQgR0YoYiwgeCkgd2UgbXVzdCByZWR1Y2UgdGhhdCBieSBtKHgpLiBJZiBiXzcgaXMgMCAodGhhdCBpcyB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGlzIDAgaW4gYikgdGhlbiB0aGUgcmVzdWx0IGlzIGFscmVhZHkgcmVkdWNlZC4gSWZcbiAqIGl0IGlzIDEsIHRoZW4gd2UgY2FuIHJlZHVjZSBpdCBieSBzdWJ0cmFjdGluZyBtKHgpIHZpYSBhbiBYT1IuXG4gKlxuICogSXQgZm9sbG93cyB0aGF0IG11bHRpcGxpY2F0aW9uIGJ5IHggKDAwMDAwMDEwIG9yIDB4MDIpIGNhbiBiZSBpbXBsZW1lbnRlZFxuICogYnkgcGVyZm9ybWluZyBhIGxlZnQgc2hpZnQgZm9sbG93ZWQgYnkgYSBjb25kaXRpb25hbCBiaXR3aXNlIFhPUiB3aXRoXG4gKiAweDFiLiBUaGlzIG9wZXJhdGlvbiBvbiBieXRlcyBpcyBkZW5vdGVkIGJ5IHh0aW1lKCkuIE11bHRpcGxpY2F0aW9uIGJ5XG4gKiBoaWdoZXIgcG93ZXJzIG9mIHggY2FuIGJlIGltcGxlbWVudGVkIGJ5IHJlcGVhdGVkIGFwcGxpY2F0aW9uIG9mIHh0aW1lKCkuXG4gKlxuICogQnkgYWRkaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLCBtdWx0aXBsaWNhdGlvbiBieSBhbnkgY29uc3RhbnQgY2FuIGJlXG4gKiBpbXBsZW1lbnRlZC4gRm9yIGluc3RhbmNlOlxuICpcbiAqIEdGKDB4NTcsIDB4MTMpID0gMHhmZSBiZWNhdXNlOlxuICpcbiAqIHh0aW1lKGIpID0gKGIgJiAxMjgpID8gKGIgPDwgMSBeIDB4MTFiKSA6IChiIDw8IDEpXG4gKlxuICogTm90ZTogV2UgWE9SIHdpdGggMHgxMWIgaW5zdGVhZCBvZiAweDFiIGJlY2F1c2UgaW4gamF2YXNjcmlwdCBvdXJcbiAqIGRhdGF0eXBlIGZvciBiIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGJ5dGUsIHNvIGEgbGVmdCBzaGlmdCB3aWxsIG5vdFxuICogYXV0b21hdGljYWxseSBlbGltaW5hdGUgYml0cyB0aGF0IG92ZXJmbG93IGEgYnl0ZSAuLi4gYnkgWE9SJ2luZyB0aGVcbiAqIG92ZXJmbG93IGJpdCB3aXRoIDEgKHRoZSBleHRyYSBvbmUgZnJvbSAweDExYikgd2UgemVybyBpdCBvdXQuXG4gKlxuICogR0YoMHg1NywgMHgwMikgPSB4dGltZSgweDU3KSA9IDB4YWVcbiAqIEdGKDB4NTcsIDB4MDQpID0geHRpbWUoMHhhZSkgPSAweDQ3XG4gKiBHRigweDU3LCAweDA4KSA9IHh0aW1lKDB4NDcpID0gMHg4ZVxuICogR0YoMHg1NywgMHgxMCkgPSB4dGltZSgweDhlKSA9IDB4MDdcbiAqXG4gKiBHRigweDU3LCAweDEzKSA9IEdGKDB4NTcsICgweDAxIF4gMHgwMiBeIDB4MTApKVxuICpcbiAqIEFuZCBieSB0aGUgZGlzdHJpYnV0aXZlIHByb3BlcnR5IChzaW5jZSBYT1IgaXMgYWRkaXRpb24gYW5kIEdGKCkgaXNcbiAqIG11bHRpcGxpY2F0aW9uKTpcbiAqXG4gKiA9IEdGKDB4NTcsIDB4MDEpIF4gR0YoMHg1NywgMHgwMikgXiBHRigweDU3LCAweDEwKVxuICogPSAweDU3IF4gMHhhZSBeIDB4MDdcbiAqID0gMHhmZS5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgaW5pdCA9IHRydWU7XG5cbiAgLyogUG9wdWxhdGUgdGhlIFJjb24gdGFibGUuIFRoZXNlIGFyZSB0aGUgdmFsdWVzIGdpdmVuIGJ5XG4gICAgW3heKGktMSksezAwfSx7MDB9LHswMH1dIHdoZXJlIHheKGktMSkgYXJlIHBvd2VycyBvZiB4IChhbmQgeCA9IDB4MDIpXG4gICAgaW4gdGhlIGZpZWxkIG9mIEdGKDJeOCksIHdoZXJlIGkgc3RhcnRzIGF0IDEuXG5cbiAgICByY29uWzBdID0gWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdXG4gICAgcmNvblsxXSA9IFsweDAxLCAweDAwLCAweDAwLCAweDAwXSAyXigxLTEpID0gMl4wID0gMVxuICAgIHJjb25bMl0gPSBbMHgwMiwgMHgwMCwgMHgwMCwgMHgwMF0gMl4oMi0xKSA9IDJeMSA9IDJcbiAgICAuLi5cbiAgICByY29uWzldICA9IFsweDFCLCAweDAwLCAweDAwLCAweDAwXSAyXig5LTEpICA9IDJeOCA9IDB4MUJcbiAgICByY29uWzEwXSA9IFsweDM2LCAweDAwLCAweDAwLCAweDAwXSAyXigxMC0xKSA9IDJeOSA9IDB4MzZcblxuICAgIFdlIG9ubHkgc3RvcmUgdGhlIGZpcnN0IGJ5dGUgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBvbmUgdXNlZC5cbiAgKi9cbiAgcmNvbiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFCLCAweDM2XTtcblxuICAvLyBjb21wdXRlIHh0aW1lIHRhYmxlIHdoaWNoIG1hcHMgaSBvbnRvIEdGKGksIDB4MDIpXG4gIHZhciB4dGltZSA9IG5ldyBBcnJheSgyNTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICB4dGltZVtpXSA9IGkgPDwgMTtcbiAgICB4dGltZVtpICsgMTI4XSA9IChpICsgMTI4KSA8PCAxIF4gMHgxMUI7XG4gIH1cblxuICAvLyBjb21wdXRlIGFsbCBvdGhlciB0YWJsZXNcbiAgc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBpc2JveCA9IG5ldyBBcnJheSgyNTYpO1xuICBtaXggPSBuZXcgQXJyYXkoNCk7XG4gIGltaXggPSBuZXcgQXJyYXkoNCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBtaXhbaV0gPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBpbWl4W2ldID0gbmV3IEFycmF5KDI1Nik7XG4gIH1cbiAgdmFyIGUgPSAwLCBlaSA9IDAsIGUyLCBlNCwgZTgsIHN4LCBzeDIsIG1lLCBpbWU7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgIC8qIFdlIG5lZWQgdG8gZ2VuZXJhdGUgdGhlIFN1YkJ5dGVzKCkgc2JveCBhbmQgaXNib3ggdGFibGVzIHNvIHRoYXRcbiAgICAgIHdlIGNhbiBwZXJmb3JtIGJ5dGUgc3Vic3RpdHV0aW9ucy4gVGhpcyByZXF1aXJlcyB1cyB0byB0cmF2ZXJzZVxuICAgICAgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiBHRiwgZmluZCB0aGVpciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlcyxcbiAgICAgIGFuZCBhcHBseSB0byBlYWNoIHRoZSBmb2xsb3dpbmcgYWZmaW5lIHRyYW5zZm9ybWF0aW9uOlxuXG4gICAgICBiaScgPSBiaSBeIGIoaSArIDQpIG1vZCA4IF4gYihpICsgNSkgbW9kIDggXiBiKGkgKyA2KSBtb2QgOCBeXG4gICAgICAgICAgICBiKGkgKyA3KSBtb2QgOCBeIGNpXG4gICAgICBmb3IgMCA8PSBpIDwgOCwgd2hlcmUgYmkgaXMgdGhlIGl0aCBiaXQgb2YgdGhlIGJ5dGUsIGFuZCBjaSBpcyB0aGVcbiAgICAgIGl0aCBiaXQgb2YgYSBieXRlIGMgd2l0aCB0aGUgdmFsdWUgezYzfSBvciB7MDExMDAwMTF9LlxuXG4gICAgICBJdCBpcyBwb3NzaWJsZSB0byB0cmF2ZXJzZSBldmVyeSBwb3NzaWJsZSB2YWx1ZSBpbiBhIEdhbG9pcyBmaWVsZFxuICAgICAgdXNpbmcgd2hhdCBpcyByZWZlcnJlZCB0byBhcyBhICdnZW5lcmF0b3InLiBUaGVyZSBhcmUgbWFueVxuICAgICAgZ2VuZXJhdG9ycyAoMTI4IG91dCBvZiAyNTYpOiAzLDUsNiw5LDExLDgyIHRvIG5hbWUgYSBmZXcuIFRvIGZ1bGx5XG4gICAgICB0cmF2ZXJzZSBHRiB3ZSBpdGVyYXRlIDI1NSB0aW1lcywgbXVsdGlwbHlpbmcgYnkgb3VyIGdlbmVyYXRvclxuICAgICAgZWFjaCB0aW1lLlxuXG4gICAgICBPbiBlYWNoIGl0ZXJhdGlvbiB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIGZvclxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudC5cblxuICAgICAgU3VwcG9zZSB0aGVyZSBpcyBhbiBlbGVtZW50IGluIEdGICdlJy4gRm9yIGEgZ2l2ZW4gZ2VuZXJhdG9yICdnJyxcbiAgICAgIGUgPSBnXnguIFRoZSBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGUgaXMgZ14oMjU1IC0geCkuIEl0IHR1cm5zXG4gICAgICBvdXQgdGhhdCBpZiB1c2UgdGhlIGludmVyc2Ugb2YgYSBnZW5lcmF0b3IgYXMgYW5vdGhlciBnZW5lcmF0b3JcbiAgICAgIGl0IHdpbGwgcHJvZHVjZSBhbGwgb2YgdGhlIGNvcnJlc3BvbmRpbmcgbXVsdGlwbGljYXRpdmUgaW52ZXJzZXNcbiAgICAgIGF0IHRoZSBzYW1lIHRpbWUuIEZvciB0aGlzIHJlYXNvbiwgd2UgY2hvb3NlIDUgYXMgb3VyIGludmVyc2VcbiAgICAgIGdlbmVyYXRvciBiZWNhdXNlIGl0IG9ubHkgcmVxdWlyZXMgMiBtdWx0aXBsaWVzIGFuZCAxIGFkZCBhbmQgaXRzXG4gICAgICBpbnZlcnNlLCA4MiwgcmVxdWlyZXMgcmVsYXRpdmVseSBmZXcgb3BlcmF0aW9ucyBhcyB3ZWxsLlxuXG4gICAgICBJbiBvcmRlciB0byBhcHBseSB0aGUgYWZmaW5lIHRyYW5zZm9ybWF0aW9uLCB0aGUgbXVsdGlwbGljYXRpdmVcbiAgICAgIGludmVyc2UgJ2VpJyBvZiAnZScgY2FuIGJlIHJlcGVhdGVkbHkgWE9SJ2QgKDQgdGltZXMpIHdpdGggYVxuICAgICAgYml0LWN5Y2xpbmcgb2YgJ2VpJy4gVG8gZG8gdGhpcyAnZWknIGlzIGZpcnN0IHN0b3JlZCBpbiAncycgYW5kXG4gICAgICAneCcuIFRoZW4gJ3MnIGlzIGxlZnQgc2hpZnRlZCBhbmQgdGhlIGhpZ2ggYml0IG9mICdzJyBpcyBtYWRlIHRoZVxuICAgICAgbG93IGJpdC4gVGhlIHJlc3VsdGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3MnLiBUaGVuICd4JyBpcyBYT1InZFxuICAgICAgd2l0aCAncycgYW5kIHN0b3JlZCBpbiAneCcuIE9uIGVhY2ggc3Vic2VxdWVudCBpdGVyYXRpb24gdGhlIHNhbWVcbiAgICAgIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQuIFdoZW4gNCBpdGVyYXRpb25zIGFyZSBjb21wbGV0ZSwgJ3gnIGlzXG4gICAgICBYT1InZCB3aXRoICdjJyAoMHg2MykgYW5kIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBpcyBzdG9yZWQgaW4gJ3gnLlxuICAgICAgRm9yIGV4YW1wbGU6XG5cbiAgICAgIHMgPSAwMTAwMDAwMVxuICAgICAgeCA9IDAxMDAwMDAxXG5cbiAgICAgIGl0ZXJhdGlvbiAxOiBzID0gMTAwMDAwMTAsIHggXj0gc1xuICAgICAgaXRlcmF0aW9uIDI6IHMgPSAwMDAwMDEwMSwgeCBePSBzXG4gICAgICBpdGVyYXRpb24gMzogcyA9IDAwMDAxMDEwLCB4IF49IHNcbiAgICAgIGl0ZXJhdGlvbiA0OiBzID0gMDAwMTAxMDAsIHggXj0gc1xuICAgICAgeCBePSAweDYzXG5cbiAgICAgIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCBhIGxvb3Agd2hlcmUgcyA9IChzIDw8IDEpIHwgKHMgPj4gNykuIEhvd2V2ZXIsXG4gICAgICBpdCBjYW4gYWxzbyBiZSBkb25lIGJ5IHVzaW5nIGEgc2luZ2xlIDE2LWJpdCAoaW4gdGhpcyBjYXNlIDMyLWJpdClcbiAgICAgIG51bWJlciAnc3gnLiBTaW5jZSBYT1IgaXMgYW4gYXNzb2NpYXRpdmUgb3BlcmF0aW9uLCB3ZSBjYW4gc2V0ICdzeCdcbiAgICAgIHRvICdlaScgYW5kIHRoZW4gWE9SIGl0IHdpdGggJ3N4JyBsZWZ0LXNoaWZ0ZWQgMSwyLDMsIGFuZCA0IHRpbWVzLlxuICAgICAgVGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyB3aWxsIGZsb3cgaW50byB0aGUgaGlnaCA4IGJpdCBwb3NpdGlvbnNcbiAgICAgIGFuZCBiZSBjb3JyZWN0bHkgWE9SJ2Qgd2l0aCBvbmUgYW5vdGhlci4gQWxsIHRoYXQgcmVtYWlucyB3aWxsIGJlXG4gICAgICB0byBjeWNsZSB0aGUgaGlnaCA4IGJpdHMgYnkgWE9SJ2luZyB0aGVtIGFsbCB3aXRoIHRoZSBsb3dlciA4IGJpdHNcbiAgICAgIGFmdGVyd2FyZHMuXG5cbiAgICAgIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgcG9wdWxhdGluZyBzYm94IGFuZCBpc2JveCB3ZSBjYW4gcHJlY29tcHV0ZVxuICAgICAgdGhlIG11bHRpcGxpY2F0aW9uIHdlJ2xsIG5lZWQgdG8gZG8gdG8gZG8gTWl4Q29sdW1ucygpIGxhdGVyLlxuICAgICovXG5cbiAgICAvLyBhcHBseSBhZmZpbmUgdHJhbnNmb3JtYXRpb25cbiAgICBzeCA9IGVpIF4gKGVpIDw8IDEpIF4gKGVpIDw8IDIpIF4gKGVpIDw8IDMpIF4gKGVpIDw8IDQpO1xuICAgIHN4ID0gKHN4ID4+IDgpIF4gKHN4ICYgMjU1KSBeIDB4NjM7XG5cbiAgICAvLyB1cGRhdGUgdGFibGVzXG4gICAgc2JveFtlXSA9IHN4O1xuICAgIGlzYm94W3N4XSA9IGU7XG5cbiAgICAvKiBNaXhpbmcgY29sdW1ucyBpcyBkb25lIHVzaW5nIG1hdHJpeCBtdWx0aXBsaWNhdGlvbi4gVGhlIGNvbHVtbnNcbiAgICAgIHRoYXQgYXJlIHRvIGJlIG1peGVkIGFyZSBlYWNoIGEgc2luZ2xlIHdvcmQgaW4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICBUaGUgc3RhdGUgaGFzIE5iIGNvbHVtbnMgKDQgY29sdW1ucykuIFRoZXJlZm9yZSBlYWNoIGNvbHVtbiBpcyBhXG4gICAgICA0IGJ5dGUgd29yZC4gU28gdG8gbWl4IHRoZSBjb2x1bW5zIGluIGEgc2luZ2xlIGNvbHVtbiAnYycgd2hlcmVcbiAgICAgIGl0cyByb3dzIGFyZSByMCwgcjEsIHIyLCBhbmQgcjMsIHdlIHVzZSB0aGUgZm9sbG93aW5nIG1hdHJpeFxuICAgICAgbXVsdGlwbGljYXRpb246XG5cbiAgICAgIFsyIDMgMSAxXSpbcjAsY109W3InMCxjXVxuICAgICAgWzEgMiAzIDFdIFtyMSxjXSBbcicxLGNdXG4gICAgICBbMSAxIDIgM10gW3IyLGNdIFtyJzIsY11cbiAgICAgIFszIDEgMSAyXSBbcjMsY10gW3InMyxjXVxuXG4gICAgICByMCwgcjEsIHIyLCBhbmQgcjMgYXJlIGVhY2ggMSBieXRlIG9mIG9uZSBvZiB0aGUgd29yZHMgaW4gdGhlXG4gICAgICBzdGF0ZSAoYSBjb2x1bW4pLiBUbyBkbyBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIGVhY2ggbWl4ZWRcbiAgICAgIGNvbHVtbiBjJyB3ZSBtdWx0aXBseSB0aGUgY29ycmVzcG9uZGluZyByb3cgZnJvbSB0aGUgbGVmdCBtYXRyaXhcbiAgICAgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uIGZyb20gdGhlIHJpZ2h0IG1hdHJpeC4gSW4gdG90YWwsIHdlXG4gICAgICBnZXQgNCBlcXVhdGlvbnM6XG5cbiAgICAgIHIwLGMnID0gMipyMCxjICsgMypyMSxjICsgMSpyMixjICsgMSpyMyxjXG4gICAgICByMSxjJyA9IDEqcjAsYyArIDIqcjEsYyArIDMqcjIsYyArIDEqcjMsY1xuICAgICAgcjIsYycgPSAxKnIwLGMgKyAxKnIxLGMgKyAyKnIyLGMgKyAzKnIzLGNcbiAgICAgIHIzLGMnID0gMypyMCxjICsgMSpyMSxjICsgMSpyMixjICsgMipyMyxjXG5cbiAgICAgIEFzIHVzdWFsLCB0aGUgbXVsdGlwbGljYXRpb24gaXMgYXMgcHJldmlvdXNseSBkZWZpbmVkIGFuZCB0aGVcbiAgICAgIGFkZGl0aW9uIGlzIFhPUi4gSW4gb3JkZXIgdG8gb3B0aW1pemUgbWl4aW5nIGNvbHVtbnMgd2UgY2FuIHN0b3JlXG4gICAgICB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0cyBpbiB0YWJsZXMuIElmIHlvdSB0aGluayBvZiB0aGUgd2hvbGVcbiAgICAgIGNvbHVtbiBhcyBhIHdvcmQgKGl0IG1pZ2h0IGhlbHAgdG8gdmlzdWFsaXplIGJ5IG1lbnRhbGx5IHJvdGF0aW5nXG4gICAgICB0aGUgZXF1YXRpb25zIGFib3ZlIGJ5IGNvdW50ZXJjbG9ja3dpc2UgOTAgZGVncmVlcykgdGhlbiB5b3UgY2FuXG4gICAgICBzZWUgdGhhdCBpdCB3b3VsZCBiZSB1c2VmdWwgdG8gbWFwIHRoZSBtdWx0aXBsaWNhdGlvbnMgcGVyZm9ybWVkIG9uXG4gICAgICBlYWNoIGJ5dGUgKHIwLCByMSwgcjIsIHIzKSBvbnRvIGEgd29yZCBhcyB3ZWxsLiBGb3IgaW5zdGFuY2UsIHdlXG4gICAgICBjb3VsZCBtYXAgMipyMCwxKnIwLDEqcjAsMypyMCBvbnRvIGEgd29yZCBieSBzdG9yaW5nIDIqcjAgaW4gdGhlXG4gICAgICBoaWdoZXN0IDggYml0cyBhbmQgMypyMCBpbiB0aGUgbG93ZXN0IDggYml0cyAod2l0aCB0aGUgb3RoZXIgdHdvXG4gICAgICByZXNwZWN0aXZlbHkgaW4gdGhlIG1pZGRsZSkuIFRoaXMgbWVhbnMgdGhhdCBhIHRhYmxlIGNhbiBiZVxuICAgICAgY29uc3RydWN0ZWQgdGhhdCB1c2VzIHIwIGFzIGFuIGluZGV4IHRvIHRoZSB3b3JkLiBXZSBjYW4gZG8gdGhlXG4gICAgICBzYW1lIHdpdGggcjEsIHIyLCBhbmQgcjMsIGNyZWF0aW5nIGEgdG90YWwgb2YgNCB0YWJsZXMuXG5cbiAgICAgIFRvIGNvbnN0cnVjdCBhIGZ1bGwgYycsIHdlIGNhbiBqdXN0IGxvb2sgdXAgZWFjaCBieXRlIG9mIGMgaW5cbiAgICAgIHRoZWlyIHJlc3BlY3RpdmUgdGFibGVzIGFuZCBYT1IgdGhlIHJlc3VsdHMgdG9nZXRoZXIuXG5cbiAgICAgIEFsc28sIHRvIGJ1aWxkIGVhY2ggdGFibGUgd2Ugb25seSBoYXZlIHRvIGNhbGN1bGF0ZSB0aGUgd29yZFxuICAgICAgZm9yIDIsMSwxLDMgZm9yIGV2ZXJ5IGJ5dGUgLi4uIHdoaWNoIHdlIGNhbiBkbyBvbiBlYWNoIGl0ZXJhdGlvblxuICAgICAgb2YgdGhpcyBsb29wIHNpbmNlIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIGV2ZXJ5IGJ5dGUuIEFmdGVyIHdlIGhhdmVcbiAgICAgIGNhbGN1bGF0ZWQgMiwxLDEsMyB3ZSBjYW4gZ2V0IHRoZSByZXN1bHRzIGZvciB0aGUgb3RoZXIgdGFibGVzXG4gICAgICBieSBjeWNsaW5nIHRoZSBieXRlIGF0IHRoZSBlbmQgdG8gdGhlIGJlZ2lubmluZy4gRm9yIGluc3RhbmNlXG4gICAgICB3ZSBjYW4gdGFrZSB0aGUgcmVzdWx0IG9mIHRhYmxlIDIsMSwxLDMgYW5kIHByb2R1Y2UgdGFibGUgMywyLDEsMVxuICAgICAgYnkgbW92aW5nIHRoZSByaWdodCBtb3N0IGJ5dGUgdG8gdGhlIGxlZnQgbW9zdCBwb3NpdGlvbiBqdXN0IGxpa2VcbiAgICAgIGhvdyB5b3UgY2FuIGltYWdpbmUgdGhlIDMgbW92ZWQgb3V0IG9mIDIsMSwxLDMgYW5kIHRvIHRoZSBmcm9udFxuICAgICAgdG8gcHJvZHVjZSAzLDIsMSwxLlxuXG4gICAgICBUaGVyZSBpcyBhbm90aGVyIG9wdGltaXphdGlvbiBpbiB0aGF0IHRoZSBzYW1lIG11bHRpcGxlcyBvZlxuICAgICAgdGhlIGN1cnJlbnQgZWxlbWVudCB3ZSBuZWVkIGluIG9yZGVyIHRvIGFkdmFuY2Ugb3VyIGdlbmVyYXRvclxuICAgICAgdG8gdGhlIG5leHQgaXRlcmF0aW9uIGNhbiBiZSByZXVzZWQgaW4gcGVyZm9ybWluZyB0aGUgMiwxLDEsM1xuICAgICAgY2FsY3VsYXRpb24uIFdlIGFsc28gY2FsY3VsYXRlIHRoZSBpbnZlcnNlIG1peCBjb2x1bW4gdGFibGVzLFxuICAgICAgd2l0aCBlLDksZCxiIGJlaW5nIHRoZSBpbnZlcnNlIG9mIDIsMSwxLDMuXG5cbiAgICAgIFdoZW4gd2UncmUgZG9uZSwgYW5kIHdlIG5lZWQgdG8gYWN0dWFsbHkgbWl4IGNvbHVtbnMsIHRoZSBmaXJzdFxuICAgICAgYnl0ZSBvZiBlYWNoIHN0YXRlIHdvcmQgc2hvdWxkIGJlIHB1dCB0aHJvdWdoIG1peFswXSAoMiwxLDEsMyksXG4gICAgICB0aGUgc2Vjb25kIHRocm91Z2ggbWl4WzFdICgzLDIsMSwxKSBhbmQgc28gZm9ydGguIFRoZW4gdGhleSBzaG91bGRcbiAgICAgIGJlIFhPUidkIHRvZ2V0aGVyIHRvIHByb2R1Y2UgdGhlIGZ1bGx5IG1peGVkIGNvbHVtbi5cbiAgICAqL1xuXG4gICAgLy8gY2FsY3VsYXRlIG1peCBhbmQgaW1peCB0YWJsZSB2YWx1ZXNcbiAgICBzeDIgPSB4dGltZVtzeF07XG4gICAgZTIgPSB4dGltZVtlXTtcbiAgICBlNCA9IHh0aW1lW2UyXTtcbiAgICBlOCA9IHh0aW1lW2U0XTtcbiAgICBtZSA9XG4gICAgICAoc3gyIDw8IDI0KSBeICAvLyAyXG4gICAgICAoc3ggPDwgMTYpIF4gICAvLyAxXG4gICAgICAoc3ggPDwgOCkgXiAgICAvLyAxXG4gICAgICAoc3ggXiBzeDIpOyAgICAvLyAzXG4gICAgaW1lID1cbiAgICAgIChlMiBeIGU0IF4gZTgpIDw8IDI0IF4gIC8vIEUgKDE0KVxuICAgICAgKGUgXiBlOCkgPDwgMTYgXiAgICAgICAgLy8gOVxuICAgICAgKGUgXiBlNCBeIGU4KSA8PCA4IF4gICAgLy8gRCAoMTMpXG4gICAgICAoZSBeIGUyIF4gZTgpOyAgICAgICAgICAvLyBCICgxMSlcbiAgICAvLyBwcm9kdWNlIGVhY2ggb2YgdGhlIG1peCB0YWJsZXMgYnkgcm90YXRpbmcgdGhlIDIsMSwxLDMgdmFsdWVcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgNDsgKytuKSB7XG4gICAgICBtaXhbbl1bZV0gPSBtZTtcbiAgICAgIGltaXhbbl1bc3hdID0gaW1lO1xuICAgICAgLy8gY3ljbGUgdGhlIHJpZ2h0IG1vc3QgYnl0ZSB0byB0aGUgbGVmdCBtb3N0IHBvc2l0aW9uXG4gICAgICAvLyBpZTogMiwxLDEsMyBiZWNvbWVzIDMsMiwxLDFcbiAgICAgIG1lID0gbWUgPDwgMjQgfCBtZSA+Pj4gODtcbiAgICAgIGltZSA9IGltZSA8PCAyNCB8IGltZSA+Pj4gODtcbiAgICB9XG5cbiAgICAvLyBnZXQgbmV4dCBlbGVtZW50IGFuZCBpbnZlcnNlXG4gICAgaWYoZSA9PT0gMCkge1xuICAgICAgLy8gMSBpcyB0aGUgaW52ZXJzZSBvZiAxXG4gICAgICBlID0gZWkgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlID0gMmUgKyAyKjIqMiooMTBlKSkgPSBtdWx0aXBseSBlIGJ5IDgyIChjaG9zZW4gZ2VuZXJhdG9yKVxuICAgICAgLy8gZWkgPSBlaSArIDIqMiplaSA9IG11bHRpcGx5IGVpIGJ5IDUgKGludmVyc2UgZ2VuZXJhdG9yKVxuICAgICAgZSA9IGUyIF4geHRpbWVbeHRpbWVbeHRpbWVbZTIgXiBlOF1dXTtcbiAgICAgIGVpIF49IHh0aW1lW3h0aW1lW2VpXV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEga2V5IHNjaGVkdWxlIHVzaW5nIHRoZSBBRVMga2V5IGV4cGFuc2lvbiBhbGdvcml0aG0uXG4gKlxuICogVGhlIEFFUyBhbGdvcml0aG0gdGFrZXMgdGhlIENpcGhlciBLZXksIEssIGFuZCBwZXJmb3JtcyBhIEtleSBFeHBhbnNpb25cbiAqIHJvdXRpbmUgdG8gZ2VuZXJhdGUgYSBrZXkgc2NoZWR1bGUuIFRoZSBLZXkgRXhwYW5zaW9uIGdlbmVyYXRlcyBhIHRvdGFsXG4gKiBvZiBOYiooTnIgKyAxKSB3b3JkczogdGhlIGFsZ29yaXRobSByZXF1aXJlcyBhbiBpbml0aWFsIHNldCBvZiBOYiB3b3JkcyxcbiAqIGFuZCBlYWNoIG9mIHRoZSBOciByb3VuZHMgcmVxdWlyZXMgTmIgd29yZHMgb2Yga2V5IGRhdGEuIFRoZSByZXN1bHRpbmdcbiAqIGtleSBzY2hlZHVsZSBjb25zaXN0cyBvZiBhIGxpbmVhciBhcnJheSBvZiA0LWJ5dGUgd29yZHMsIGRlbm90ZWQgW3dpIF0sXG4gKiB3aXRoIGkgaW4gdGhlIHJhbmdlIDAgPD0gaSA8IE5iKE5yICsgMSkuXG4gKlxuICogS2V5RXhwYW5zaW9uKGJ5dGUga2V5WzQqTmtdLCB3b3JkIHdbTmIqKE5yKzEpXSwgTmspXG4gKiBBRVMtMTI4IChOYj00LCBOaz00LCBOcj0xMClcbiAqIEFFUy0xOTIgKE5iPTQsIE5rPTYsIE5yPTEyKVxuICogQUVTLTI1NiAoTmI9NCwgTms9OCwgTnI9MTQpXG4gKiBOb3RlOiBOcj1Oays2LlxuICpcbiAqIE5iIGlzIHRoZSBudW1iZXIgb2YgY29sdW1ucyAoMzItYml0IHdvcmRzKSBjb21wcmlzaW5nIHRoZSBTdGF0ZSAob3JcbiAqIG51bWJlciBvZiBieXRlcyBpbiBhIGJsb2NrKS4gRm9yIEFFUywgTmI9NC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gc2NoZWR1bGUgKGFzIGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gZGVjcnlwdCB0cnVlIHRvIG1vZGlmeSB0aGUga2V5IHNjaGVkdWxlIHRvIGRlY3J5cHQsIGZhbHNlIG5vdCB0by5cbiAqXG4gKiBAcmV0dXJuIHRoZSBnZW5lcmF0ZWQga2V5IHNjaGVkdWxlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kS2V5KGtleSwgZGVjcnlwdCkge1xuICAvLyBjb3B5IHRoZSBrZXkncyB3b3JkcyB0byBpbml0aWFsaXplIHRoZSBrZXkgc2NoZWR1bGVcbiAgdmFyIHcgPSBrZXkuc2xpY2UoMCk7XG5cbiAgLyogUm90V29yZCgpIHdpbGwgcm90YXRlIGEgd29yZCwgbW92aW5nIHRoZSBmaXJzdCBieXRlIHRvIHRoZSBsYXN0XG4gICAgYnl0ZSdzIHBvc2l0aW9uIChzaGlmdGluZyB0aGUgb3RoZXIgYnl0ZXMgbGVmdCkuXG5cbiAgICBXZSB3aWxsIGJlIGdldHRpbmcgdGhlIHZhbHVlIG9mIFJjb24gYXQgaSAvIE5rLiAnaScgd2lsbCBpdGVyYXRlXG4gICAgZnJvbSBOayB0byAoTmIgKiBOcisxKS4gTmsgPSA0ICg0IGJ5dGUga2V5KSwgTmIgPSA0ICg0IHdvcmRzIGluXG4gICAgYSBibG9jayksIE5yID0gTmsgKyA2ICgxMCkuIFRoZXJlZm9yZSAnaScgd2lsbCBpdGVyYXRlIGZyb21cbiAgICA0IHRvIDQ0IChleGNsdXNpdmUpLiBFYWNoIHRpbWUgd2UgaXRlcmF0ZSA0IHRpbWVzLCBpIC8gTmsgd2lsbFxuICAgIGluY3JlYXNlIGJ5IDEuIFdlIHVzZSBhIGNvdW50ZXIgaU5rIHRvIGtlZXAgdHJhY2sgb2YgdGhpcy5cbiAgICovXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgcm91bmRzIGV4cGFuZGluZyB0aGUga2V5XG4gIHZhciB0ZW1wLCBpTmsgPSAxO1xuICB2YXIgTmsgPSB3Lmxlbmd0aDtcbiAgdmFyIE5yMSA9IE5rICsgNiArIDE7XG4gIHZhciBlbmQgPSBOYiAqIE5yMTtcbiAgZm9yKHZhciBpID0gTms7IGkgPCBlbmQ7ICsraSkge1xuICAgIHRlbXAgPSB3W2kgLSAxXTtcbiAgICBpZihpICUgTmsgPT09IDApIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKFJvdFdvcmQodGVtcCkpIF4gUmNvbltpIC8gTmtdXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAxNiAmIDI1NV0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDggJiAyNTVdIDw8IDE2IF5cbiAgICAgICAgc2JveFt0ZW1wICYgMjU1XSA8PCA4IF5cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gXiAocmNvbltpTmtdIDw8IDI0KTtcbiAgICAgIGlOaysrO1xuICAgIH0gZWxzZSBpZihOayA+IDYgJiYgKGkgJSBOayA9PT0gNCkpIHtcbiAgICAgIC8vIHRlbXAgPSBTdWJXb3JkKHRlbXApXG4gICAgICB0ZW1wID1cbiAgICAgICAgc2JveFt0ZW1wID4+PiAyNF0gPDwgMjQgXlxuICAgICAgICBzYm94W3RlbXAgPj4+IDE2ICYgMjU1XSA8PCAxNiBeXG4gICAgICAgIHNib3hbdGVtcCA+Pj4gOCAmIDI1NV0gPDwgOCBeXG4gICAgICAgIHNib3hbdGVtcCAmIDI1NV07XG4gICAgfVxuICAgIHdbaV0gPSB3W2kgLSBOa10gXiB0ZW1wO1xuICB9XG5cbiAgLyogV2hlbiB3ZSBhcmUgdXBkYXRpbmcgYSBjaXBoZXIgYmxvY2sgd2UgYWx3YXlzIHVzZSB0aGUgY29kZSBwYXRoIGZvclxuICAgICBlbmNyeXB0aW9uIHdoZXRoZXIgd2UgYXJlIGRlY3J5cHRpbmcgb3Igbm90ICh0byBzaG9ydGVuIGNvZGUgYW5kXG4gICAgIHNpbXBsaWZ5IHRoZSBnZW5lcmF0aW9uIG9mIGxvb2sgdXAgdGFibGVzKS4gSG93ZXZlciwgYmVjYXVzZSB0aGVyZVxuICAgICBhcmUgZGlmZmVyZW5jZXMgaW4gdGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtLCBvdGhlciB0aGFuIGp1c3Qgc3dhcHBpbmdcbiAgICAgaW4gZGlmZmVyZW50IGxvb2sgdXAgdGFibGVzLCB3ZSBtdXN0IHRyYW5zZm9ybSBvdXIga2V5IHNjaGVkdWxlIHRvXG4gICAgIGFjY291bnQgZm9yIHRoZXNlIGNoYW5nZXM6XG5cbiAgICAgMS4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGdldHMgaXRzIGtleSByb3VuZHMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgMi4gVGhlIGRlY3J5cHRpb24gYWxnb3JpdGhtIGFkZHMgdGhlIHJvdW5kIGtleSBiZWZvcmUgbWl4aW5nIGNvbHVtbnNcbiAgICAgICBpbnN0ZWFkIG9mIGFmdGVyd2FyZHMuXG5cbiAgICAgV2UgZG9uJ3QgbmVlZCB0byBtb2RpZnkgb3VyIGtleSBzY2hlZHVsZSB0byBoYW5kbGUgdGhlIGZpcnN0IGNhc2UsXG4gICAgIHdlIGNhbiBqdXN0IHRyYXZlcnNlIHRoZSBrZXkgc2NoZWR1bGUgaW4gcmV2ZXJzZSBvcmRlciB3aGVuIGRlY3J5cHRpbmcuXG5cbiAgICAgVGhlIHNlY29uZCBjYXNlIHJlcXVpcmVzIGEgbGl0dGxlIHdvcmsuXG5cbiAgICAgVGhlIHRhYmxlcyB3ZSBidWlsdCBmb3IgcGVyZm9ybWluZyByb3VuZHMgd2lsbCB0YWtlIGFuIGlucHV0IGFuZCB0aGVuXG4gICAgIHBlcmZvcm0gU3ViQnl0ZXMoKSBhbmQgTWl4Q29sdW1ucygpIG9yLCBmb3IgdGhlIGRlY3J5cHQgdmVyc2lvbixcbiAgICAgSW52U3ViQnl0ZXMoKSBhbmQgSW52TWl4Q29sdW1ucygpLiBCdXQgdGhlIGRlY3J5cHQgYWxnb3JpdGhtIHJlcXVpcmVzXG4gICAgIHVzIHRvIEFkZFJvdW5kS2V5KCkgYmVmb3JlIEludk1peENvbHVtbnMoKS4gVGhpcyBtZWFucyB3ZSdsbCBuZWVkIHRvXG4gICAgIGFwcGx5IHNvbWUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByb3VuZCBrZXkgdG8gaW52ZXJzZS1taXggaXRzIGNvbHVtbnNcbiAgICAgc28gdGhleSdsbCBiZSBjb3JyZWN0IGZvciBtb3ZpbmcgQWRkUm91bmRLZXkoKSB0byBhZnRlciB0aGUgc3RhdGUgaGFzXG4gICAgIGhhZCBpdHMgY29sdW1ucyBpbnZlcnNlLW1peGVkLlxuXG4gICAgIFRvIGludmVyc2UtbWl4IHRoZSBjb2x1bW5zIG9mIHRoZSBzdGF0ZSB3aGVuIHdlJ3JlIGRlY3J5cHRpbmcgd2UgdXNlIGFcbiAgICAgbG9va3VwIHRhYmxlIHRoYXQgd2lsbCBhcHBseSBJbnZTdWJCeXRlcygpIGFuZCBJbnZNaXhDb2x1bW5zKCkgYXQgdGhlXG4gICAgIHNhbWUgdGltZS4gSG93ZXZlciwgdGhlIHJvdW5kIGtleSdzIGJ5dGVzIGFyZSBub3QgaW52ZXJzZS1zdWJzdGl0dXRlZFxuICAgICBpbiB0aGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uIFRvIGdldCBhcm91bmQgdGhpcyBwcm9ibGVtLCB3ZSBjYW4gZmlyc3RcbiAgICAgc3Vic3RpdHV0ZSB0aGUgYnl0ZXMgaW4gdGhlIHJvdW5kIGtleSBzbyB0aGF0IHdoZW4gd2UgYXBwbHkgdGhlXG4gICAgIHRyYW5zZm9ybWF0aW9uIHZpYSB0aGUgSW52U3ViQnl0ZXMoKStJbnZNaXhDb2x1bW5zKCkgdGFibGUsIGl0IHdpbGxcbiAgICAgdW5kbyBvdXIgc3Vic3RpdHV0aW9uIGxlYXZpbmcgdXMgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUgdGhhdCB3ZVxuICAgICB3YW50IC0tIGFuZCB0aGVuIGludmVyc2UtbWl4IHRoYXQgdmFsdWUuXG5cbiAgICAgVGhpcyBjaGFuZ2Ugd2lsbCBjb3JyZWN0bHkgYWx0ZXIgb3VyIGtleSBzY2hlZHVsZSBzbyB0aGF0IHdlIGNhbiBYT1JcbiAgICAgZWFjaCByb3VuZCBrZXkgd2l0aCBvdXIgYWxyZWFkeSB0cmFuc2Zvcm1lZCBkZWNyeXB0aW9uIHN0YXRlLiBUaGlzXG4gICAgIGFsbG93cyB1cyB0byB1c2UgdGhlIHNhbWUgY29kZSBwYXRoIGFzIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobS5cblxuICAgICBXZSBtYWtlIG9uZSBtb3JlIGNoYW5nZSB0byB0aGUgZGVjcnlwdGlvbiBrZXkuIFNpbmNlIHRoZSBkZWNyeXB0aW9uXG4gICAgIGFsZ29yaXRobSBydW5zIGluIHJldmVyc2UgZnJvbSB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0sIHdlIHJldmVyc2VcbiAgICAgdGhlIG9yZGVyIG9mIHRoZSByb3VuZCBrZXlzIHRvIGF2b2lkIGhhdmluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGtleVxuICAgICBzY2hlZHVsZSBiYWNrd2FyZHMgd2hlbiBydW5uaW5nIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBsYXRlciBpblxuICAgICBkZWNyeXB0aW9uIG1vZGUuIEluIGFkZGl0aW9uIHRvIHJldmVyc2luZyB0aGUgb3JkZXIgb2YgdGhlIHJvdW5kIGtleXMsXG4gICAgIHdlIGFsc28gc3dhcCBlYWNoIHJvdW5kIGtleSdzIDJuZCBhbmQgNHRoIHJvd3MuIFNlZSB0aGUgY29tbWVudHNcbiAgICAgc2VjdGlvbiB3aGVyZSByb3VuZHMgYXJlIHBlcmZvcm1lZCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSB0aGlzIGlzXG4gICAgIGRvbmUuIFRoZXNlIGNoYW5nZXMgYXJlIGRvbmUgaW5saW5lIHdpdGggdGhlIG90aGVyIHN1YnN0aXR1dGlvblxuICAgICBkZXNjcmliZWQgYWJvdmUuXG4gICovXG4gIGlmKGRlY3J5cHQpIHtcbiAgICB2YXIgdG1wO1xuICAgIHZhciBtMCA9IGltaXhbMF07XG4gICAgdmFyIG0xID0gaW1peFsxXTtcbiAgICB2YXIgbTIgPSBpbWl4WzJdO1xuICAgIHZhciBtMyA9IGltaXhbM107XG4gICAgdmFyIHduZXcgPSB3LnNsaWNlKDApO1xuICAgIGVuZCA9IHcubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIHdpID0gZW5kIC0gTmI7IGkgPCBlbmQ7IGkgKz0gTmIsIHdpIC09IE5iKSB7XG4gICAgICAvLyBkbyBub3Qgc3ViIHRoZSBmaXJzdCBvciBsYXN0IHJvdW5kIGtleSAocm91bmQga2V5cyBhcmUgTmJcbiAgICAgIC8vIHdvcmRzKSBhcyBubyBjb2x1bW4gbWl4aW5nIGlzIHBlcmZvcm1lZCBiZWZvcmUgdGhleSBhcmUgYWRkZWQsXG4gICAgICAvLyBidXQgZG8gY2hhbmdlIHRoZSBrZXkgb3JkZXJcbiAgICAgIGlmKGkgPT09IDAgfHwgaSA9PT0gKGVuZCAtIE5iKSkge1xuICAgICAgICB3bmV3W2ldID0gd1t3aV07XG4gICAgICAgIHduZXdbaSArIDFdID0gd1t3aSArIDNdO1xuICAgICAgICB3bmV3W2kgKyAyXSA9IHdbd2kgKyAyXTtcbiAgICAgICAgd25ld1tpICsgM10gPSB3W3dpICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdWJzdGl0dXRlIGVhY2ggcm91bmQga2V5IGJ5dGUgYmVjYXVzZSB0aGUgaW52ZXJzZS1taXhcbiAgICAgICAgLy8gdGFibGUgd2lsbCBpbnZlcnNlLXN1YnN0aXR1dGUgaXQgKGVmZmVjdGl2ZWx5IGNhbmNlbCB0aGVcbiAgICAgICAgLy8gc3Vic3RpdHV0aW9uIGJlY2F1c2Ugcm91bmQga2V5IGJ5dGVzIGFyZW4ndCBzdWInZCBpblxuICAgICAgICAvLyBkZWNyeXB0aW9uIG1vZGUpIGFuZCBzd2FwIGluZGV4ZXMgMyBhbmQgMVxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgTmI7ICsrbikge1xuICAgICAgICAgIHRtcCA9IHdbd2kgKyBuXTtcbiAgICAgICAgICB3bmV3W2kgKyAoMyYtbildID1cbiAgICAgICAgICAgIG0wW3Nib3hbdG1wID4+PiAyNF1dIF5cbiAgICAgICAgICAgIG0xW3Nib3hbdG1wID4+PiAxNiAmIDI1NV1dIF5cbiAgICAgICAgICAgIG0yW3Nib3hbdG1wID4+PiA4ICYgMjU1XV0gXlxuICAgICAgICAgICAgbTNbc2JveFt0bXAgJiAyNTVdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB3ID0gd25ldztcbiAgfVxuXG4gIHJldHVybiB3O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDE2IGJ5dGVzKSB1c2luZyBBRVMuIFRoZSB1cGRhdGUgd2lsbCBlaXRoZXJcbiAqIGVuY3J5cHQgb3IgZGVjcnlwdCB0aGUgYmxvY2suXG4gKlxuICogQHBhcmFtIHcgdGhlIGtleSBzY2hlZHVsZS5cbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgYmxvY2sgKGFuIGFycmF5IG9mIDMyLWJpdCB3b3JkcykuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSB1cGRhdGVkIG91dHB1dCBibG9jay5cbiAqIEBwYXJhbSBkZWNyeXB0IHRydWUgdG8gZGVjcnlwdCB0aGUgYmxvY2ssIGZhbHNlIHRvIGVuY3J5cHQgaXQuXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayh3LCBpbnB1dCwgb3V0cHV0LCBkZWNyeXB0KSB7XG4gIC8qXG4gIENpcGhlcihieXRlIGluWzQqTmJdLCBieXRlIG91dFs0Kk5iXSwgd29yZCB3W05iKihOcisxKV0pXG4gIGJlZ2luXG4gICAgYnl0ZSBzdGF0ZVs0LE5iXVxuICAgIHN0YXRlID0gaW5cbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBmb3Igcm91bmQgPSAxIHN0ZXAgMSB0byBOci0xXG4gICAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIE1peENvbHVtbnMoc3RhdGUpXG4gICAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tyb3VuZCpOYiwgKHJvdW5kKzEpKk5iLTFdKVxuICAgIGVuZCBmb3JcbiAgICBTdWJCeXRlcyhzdGF0ZSlcbiAgICBTaGlmdFJvd3Moc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcblxuICBJbnZDaXBoZXIoYnl0ZSBpbls0Kk5iXSwgYnl0ZSBvdXRbNCpOYl0sIHdvcmQgd1tOYiooTnIrMSldKVxuICBiZWdpblxuICAgIGJ5dGUgc3RhdGVbNCxOYl1cbiAgICBzdGF0ZSA9IGluXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgICBmb3Igcm91bmQgPSBOci0xIHN0ZXAgLTEgZG93bnRvIDFcbiAgICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICAgIEludlN1YkJ5dGVzKHN0YXRlKVxuICAgICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbcm91bmQqTmIsIChyb3VuZCsxKSpOYi0xXSlcbiAgICAgIEludk1peENvbHVtbnMoc3RhdGUpXG4gICAgZW5kIGZvclxuICAgIEludlNoaWZ0Um93cyhzdGF0ZSlcbiAgICBJbnZTdWJCeXRlcyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgICBvdXQgPSBzdGF0ZVxuICBlbmRcbiAgKi9cblxuICAvLyBFbmNyeXB0OiBBZGRSb3VuZEtleShzdGF0ZSwgd1swLCBOYi0xXSlcbiAgLy8gRGVjcnlwdDogQWRkUm91bmRLZXkoc3RhdGUsIHdbTnIqTmIsIChOcisxKSpOYi0xXSlcbiAgdmFyIE5yID0gdy5sZW5ndGggLyA0IC0gMTtcbiAgdmFyIG0wLCBtMSwgbTIsIG0zLCBzdWI7XG4gIGlmKGRlY3J5cHQpIHtcbiAgICBtMCA9IGltaXhbMF07XG4gICAgbTEgPSBpbWl4WzFdO1xuICAgIG0yID0gaW1peFsyXTtcbiAgICBtMyA9IGltaXhbM107XG4gICAgc3ViID0gaXNib3g7XG4gIH0gZWxzZSB7XG4gICAgbTAgPSBtaXhbMF07XG4gICAgbTEgPSBtaXhbMV07XG4gICAgbTIgPSBtaXhbMl07XG4gICAgbTMgPSBtaXhbM107XG4gICAgc3ViID0gc2JveDtcbiAgfVxuICB2YXIgYSwgYiwgYywgZCwgYTIsIGIyLCBjMjtcbiAgYSA9IGlucHV0WzBdIF4gd1swXTtcbiAgYiA9IGlucHV0W2RlY3J5cHQgPyAzIDogMV0gXiB3WzFdO1xuICBjID0gaW5wdXRbMl0gXiB3WzJdO1xuICBkID0gaW5wdXRbZGVjcnlwdCA/IDEgOiAzXSBeIHdbM107XG4gIHZhciBpID0gMztcblxuICAvKiBJbiBvcmRlciB0byBzaGFyZSBjb2RlIHdlIGZvbGxvdyB0aGUgZW5jcnlwdGlvbiBhbGdvcml0aG0gd2hlbiBib3RoXG4gICAgZW5jcnlwdGluZyBhbmQgZGVjcnlwdGluZy4gVG8gYWNjb3VudCBmb3IgdGhlIGNoYW5nZXMgcmVxdWlyZWQgaW4gdGhlXG4gICAgZGVjcnlwdGlvbiBhbGdvcml0aG0sIHdlIHVzZSBkaWZmZXJlbnQgbG9va3VwIHRhYmxlcyB3aGVuIGRlY3J5cHRpbmdcbiAgICBhbmQgdXNlIGEgbW9kaWZpZWQga2V5IHNjaGVkdWxlIHRvIGFjY291bnQgZm9yIHRoZSBkaWZmZXJlbmNlIGluIHRoZVxuICAgIG9yZGVyIG9mIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyByb3VuZHMuIFdlIGFsc28gZ2V0XG4gICAga2V5IHJvdW5kcyBpbiByZXZlcnNlIG9yZGVyIChyZWxhdGl2ZSB0byBlbmNyeXB0aW9uKS4gKi9cbiAgZm9yKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgTnI7ICsrcm91bmQpIHtcbiAgICAvKiBBcyBkZXNjcmliZWQgYWJvdmUsIHdlJ2xsIGJlIHVzaW5nIHRhYmxlIGxvb2t1cHMgdG8gcGVyZm9ybSB0aGVcbiAgICAgIGNvbHVtbiBtaXhpbmcuIEVhY2ggY29sdW1uIGlzIHN0b3JlZCBhcyBhIHdvcmQgaW4gdGhlIHN0YXRlICh0aGVcbiAgICAgIGFycmF5ICdpbnB1dCcgaGFzIG9uZSBjb2x1bW4gYXMgYSB3b3JkIGF0IGVhY2ggaW5kZXgpLiBJbiBvcmRlciB0b1xuICAgICAgbWl4IGEgY29sdW1uLCB3ZSBwZXJmb3JtIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyBvbiBlYWNoIHJvdyBpbiBjLFxuICAgICAgd2hpY2ggaXMgMSBieXRlIGluIGVhY2ggd29yZC4gVGhlIG5ldyBjb2x1bW4gZm9yIGMwIGlzIGMnMDpcblxuICAgICAgICAgICAgICAgbTAgICAgICBtMSAgICAgIG0yICAgICAgbTNcbiAgICAgIHIwLGMnMCA9IDIqcjAsYzAgKyAzKnIxLGMwICsgMSpyMixjMCArIDEqcjMsYzBcbiAgICAgIHIxLGMnMCA9IDEqcjAsYzAgKyAyKnIxLGMwICsgMypyMixjMCArIDEqcjMsYzBcbiAgICAgIHIyLGMnMCA9IDEqcjAsYzAgKyAxKnIxLGMwICsgMipyMixjMCArIDMqcjMsYzBcbiAgICAgIHIzLGMnMCA9IDMqcjAsYzAgKyAxKnIxLGMwICsgMSpyMixjMCArIDIqcjMsYzBcblxuICAgICAgU28gdXNpbmcgbWl4IHRhYmxlcyB3aGVyZSBjMCBpcyBhIHdvcmQgd2l0aCByMCBiZWluZyBpdHMgdXBwZXJcbiAgICAgIDggYml0cyBhbmQgcjMgYmVpbmcgaXRzIGxvd2VyIDggYml0czpcblxuICAgICAgbTBbYzAgPj4gMjRdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMipyMCwxKnIwLDEqcjAsMypyMF1cbiAgICAgIC4uLlxuICAgICAgbTNbYzAgJiAyNTVdIHdpbGwgeWllbGQgdGhpcyB3b3JkOiBbMSpyMywxKnIzLDMqcjMsMipyM11cblxuICAgICAgVGhlcmVmb3JlIHRvIG1peCB0aGUgY29sdW1ucyBpbiBlYWNoIHdvcmQgaW4gdGhlIHN0YXRlIHdlXG4gICAgICBkbyB0aGUgZm9sbG93aW5nICgmIDI1NSBvbWl0dGVkIGZvciBicmV2aXR5KTpcbiAgICAgIGMnMCxyMCA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG4gICAgICBjJzAscjEgPSBtMFtjMCA+PiAyNF0gXiBtMVtjMSA+PiAxNl0gXiBtMltjMiA+PiA4XSBeIG0zW2MzXVxuICAgICAgYycwLHIyID0gbTBbYzAgPj4gMjRdIF4gbTFbYzEgPj4gMTZdIF4gbTJbYzIgPj4gOF0gXiBtM1tjM11cbiAgICAgIGMnMCxyMyA9IG0wW2MwID4+IDI0XSBeIG0xW2MxID4+IDE2XSBeIG0yW2MyID4+IDhdIF4gbTNbYzNdXG5cbiAgICAgIEhvd2V2ZXIsIGJlZm9yZSBtaXhpbmcsIHRoZSBhbGdvcml0aG0gcmVxdWlyZXMgdXMgdG8gcGVyZm9ybVxuICAgICAgU2hpZnRSb3dzKCkuIFRoZSBTaGlmdFJvd3MoKSB0cmFuc2Zvcm1hdGlvbiBjeWNsaWNhbGx5IHNoaWZ0cyB0aGVcbiAgICAgIGxhc3QgMyByb3dzIG9mIHRoZSBzdGF0ZSBvdmVyIGRpZmZlcmVudCBvZmZzZXRzLiBUaGUgZmlyc3Qgcm93XG4gICAgICAociA9IDApIGlzIG5vdCBzaGlmdGVkLlxuXG4gICAgICBzJ19yLGMgPSBzX3IsKGMgKyBzaGlmdChyLCBOYikgbW9kIE5iXG4gICAgICBmb3IgMCA8IHIgPCA0IGFuZCAwIDw9IGMgPCBOYiBhbmRcbiAgICAgIHNoaWZ0KDEsIDQpID0gMVxuICAgICAgc2hpZnQoMiwgNCkgPSAyXG4gICAgICBzaGlmdCgzLCA0KSA9IDMuXG5cbiAgICAgIFRoaXMgY2F1c2VzIHRoZSBmaXJzdCBieXRlIGluIHIgPSAxIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAyIGJ5dGVzIGluIHIgPSAyIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3csIHRoZSBmaXJzdCAzIGJ5dGVzIGluIHIgPSAzIHRvIGJlIG1vdmVkIHRvIHRoZSBlbmQgb2ZcbiAgICAgIHRoZSByb3c6XG5cbiAgICAgIHIxOiBbYzAgYzEgYzIgYzNdID0+IFtjMSBjMiBjMyBjMF1cbiAgICAgIHIyOiBbYzAgYzEgYzIgYzNdICAgIFtjMiBjMyBjMCBjMV1cbiAgICAgIHIzOiBbYzAgYzEgYzIgYzNdICAgIFtjMyBjMCBjMSBjMl1cblxuICAgICAgV2UgY2FuIG1ha2UgdGhlc2Ugc3Vic3RpdHV0aW9ucyBpbmxpbmUgd2l0aCBvdXIgY29sdW1uIG1peGluZyB0b1xuICAgICAgZ2VuZXJhdGUgYW4gdXBkYXRlZCBzZXQgb2YgZXF1YXRpb25zIHRvIHByb2R1Y2UgZWFjaCB3b3JkIGluIHRoZVxuICAgICAgc3RhdGUgKG5vdGUgdGhlIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIHBvc2l0aW9ucyk6XG5cbiAgICAgIGMwIGMxIGMyIGMzID0+IGMwIGMxIGMyIGMzXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMSBjMiBjMyBjMCAgKGN5Y2xlZCAxIGJ5dGUpXG4gICAgICBjMCBjMSBjMiBjMyAgICBjMiBjMyBjMCBjMSAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzAgYzEgYzIgYzMgICAgYzMgYzAgYzEgYzIgIChjeWNsZWQgMyBieXRlcylcblxuICAgICAgVGhlcmVmb3JlOlxuXG4gICAgICBjJzAgPSAyKnIwLGMwICsgMypyMSxjMSArIDEqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMipyMSxjMSArIDMqcjIsYzIgKyAxKnIzLGMzXG4gICAgICBjJzAgPSAxKnIwLGMwICsgMSpyMSxjMSArIDIqcjIsYzIgKyAzKnIzLGMzXG4gICAgICBjJzAgPSAzKnIwLGMwICsgMSpyMSxjMSArIDEqcjIsYzIgKyAyKnIzLGMzXG5cbiAgICAgIGMnMSA9IDIqcjAsYzEgKyAzKnIxLGMyICsgMSpyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAyKnIxLGMyICsgMypyMixjMyArIDEqcjMsYzBcbiAgICAgIGMnMSA9IDEqcjAsYzEgKyAxKnIxLGMyICsgMipyMixjMyArIDMqcjMsYzBcbiAgICAgIGMnMSA9IDMqcjAsYzEgKyAxKnIxLGMyICsgMSpyMixjMyArIDIqcjMsYzBcblxuICAgICAgLi4uIGFuZCBzbyBmb3J0aCBmb3IgYycyIGFuZCBjJzMuIFRoZSBpbXBvcnRhbnQgZGlzdGluY3Rpb24gaXNcbiAgICAgIHRoYXQgdGhlIGNvbHVtbnMgYXJlIGN5Y2xpbmcsIHdpdGggYzAgYmVpbmcgdXNlZCB3aXRoIHRoZSBtMFxuICAgICAgbWFwIHdoZW4gY2FsY3VsYXRpbmcgYzAsIGJ1dCBjMSBiZWluZyB1c2VkIHdpdGggdGhlIG0wIG1hcCB3aGVuXG4gICAgICBjYWxjdWxhdGluZyBjMSAuLi4gYW5kIHNvIGZvcnRoLlxuXG4gICAgICBXaGVuIHBlcmZvcm1pbmcgdGhlIGludmVyc2Ugd2UgdHJhbnNmb3JtIHRoZSBtaXJyb3IgaW1hZ2UgYW5kXG4gICAgICBza2lwIHRoZSBib3R0b20gcm93LCBpbnN0ZWFkIG9mIHRoZSB0b3Agb25lLCBhbmQgbW92ZSB1cHdhcmRzOlxuXG4gICAgICBjMyBjMiBjMSBjMCA9PiBjMCBjMyBjMiBjMSAgKGN5Y2xlZCAzIGJ5dGVzKSAqc2FtZSBhcyBlbmNyeXB0aW9uXG4gICAgICBjMyBjMiBjMSBjMCAgICBjMSBjMCBjMyBjMiAgKGN5Y2xlZCAyIGJ5dGVzKVxuICAgICAgYzMgYzIgYzEgYzAgICAgYzIgYzEgYzAgYzMgIChjeWNsZWQgMSBieXRlKSAgKnNhbWUgYXMgZW5jcnlwdGlvblxuICAgICAgYzMgYzIgYzEgYzAgICAgYzMgYzIgYzEgYzBcblxuICAgICAgSWYgeW91IGNvbXBhcmUgdGhlIHJlc3VsdGluZyBtYXRyaWNlcyBmb3IgU2hpZnRSb3dzKCkrTWl4Q29sdW1ucygpXG4gICAgICBhbmQgZm9yIEludlNoaWZ0Um93cygpK0ludk1peENvbHVtbnMoKSB0aGUgMm5kIGFuZCA0dGggY29sdW1ucyBhcmVcbiAgICAgIGRpZmZlcmVudCAoaW4gZW5jcnlwdCBtb2RlIHZzLiBkZWNyeXB0IG1vZGUpLiBTbyBpbiBvcmRlciB0byB1c2VcbiAgICAgIHRoZSBzYW1lIGNvZGUgdG8gaGFuZGxlIGJvdGggZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbiwgd2Ugd2lsbFxuICAgICAgbmVlZCB0byBkbyBzb21lIG1hcHBpbmcuXG5cbiAgICAgIElmIGluIGVuY3J5cHRpb24gbW9kZSB3ZSBsZXQgYT1jMCwgYj1jMSwgYz1jMiwgZD1jMywgYW5kIHI8Tj4gYmVcbiAgICAgIGEgcm93IG51bWJlciBpbiB0aGUgc3RhdGUsIHRoZW4gdGhlIHJlc3VsdGluZyBtYXRyaXggaW4gZW5jcnlwdGlvblxuICAgICAgbW9kZSBmb3IgYXBwbHlpbmcgdGhlIGFib3ZlIHRyYW5zZm9ybWF0aW9ucyB3b3VsZCBiZTpcblxuICAgICAgcjE6IGEgYiBjIGRcbiAgICAgIHIyOiBiIGMgZCBhXG4gICAgICByMzogYyBkIGEgYlxuICAgICAgcjQ6IGQgYSBiIGNcblxuICAgICAgSWYgd2UgZGlkIHRoZSBzYW1lIGluIGRlY3J5cHRpb24gbW9kZSB3ZSB3b3VsZCBnZXQ6XG5cbiAgICAgIHIxOiBhIGQgYyBiXG4gICAgICByMjogYiBhIGQgY1xuICAgICAgcjM6IGMgYiBhIGRcbiAgICAgIHI0OiBkIGMgYiBhXG5cbiAgICAgIElmIGluc3RlYWQgd2Ugc3dhcCBkIGFuZCBiIChzZXQgYj1jMyBhbmQgZD1jMSksIHRoZW4gd2UgZ2V0OlxuXG4gICAgICByMTogYSBiIGMgZFxuICAgICAgcjI6IGQgYSBiIGNcbiAgICAgIHIzOiBjIGQgYSBiXG4gICAgICByNDogYiBjIGQgYVxuXG4gICAgICBOb3cgdGhlIDFzdCBhbmQgM3JkIHJvd3MgYXJlIHRoZSBzYW1lIGFzIHRoZSBlbmNyeXB0aW9uIG1hdHJpeC4gQWxsXG4gICAgICB3ZSBuZWVkIHRvIGRvIHRoZW4gdG8gbWFrZSB0aGUgbWFwcGluZyBleGFjdGx5IHRoZSBzYW1lIGlzIHRvIHN3YXBcbiAgICAgIHRoZSAybmQgYW5kIDR0aCByb3dzIHdoZW4gaW4gZGVjcnlwdGlvbiBtb2RlLiBUbyBkbyB0aGlzIHdpdGhvdXRcbiAgICAgIGhhdmluZyB0byBkbyBpdCBvbiBlYWNoIGl0ZXJhdGlvbiwgd2Ugc3dhcHBlZCB0aGUgMm5kIGFuZCA0dGggcm93c1xuICAgICAgaW4gdGhlIGRlY3J5cHRpb24ga2V5IHNjaGVkdWxlLiBXZSBhbHNvIGhhdmUgdG8gZG8gdGhlIHN3YXAgYWJvdmVcbiAgICAgIHdoZW4gd2UgZmlyc3QgcHVsbCBpbiB0aGUgaW5wdXQgYW5kIHdoZW4gd2Ugc2V0IHRoZSBmaW5hbCBvdXRwdXQuICovXG4gICAgYTIgPVxuICAgICAgbTBbYSA+Pj4gMjRdIF5cbiAgICAgIG0xW2IgPj4+IDE2ICYgMjU1XSBeXG4gICAgICBtMltjID4+PiA4ICYgMjU1XSBeXG4gICAgICBtM1tkICYgMjU1XSBeIHdbKytpXTtcbiAgICBiMiA9XG4gICAgICBtMFtiID4+PiAyNF0gXlxuICAgICAgbTFbYyA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2QgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2EgJiAyNTVdIF4gd1srK2ldO1xuICAgIGMyID1cbiAgICAgIG0wW2MgPj4+IDI0XSBeXG4gICAgICBtMVtkID4+PiAxNiAmIDI1NV0gXlxuICAgICAgbTJbYSA+Pj4gOCAmIDI1NV0gXlxuICAgICAgbTNbYiAmIDI1NV0gXiB3WysraV07XG4gICAgZCA9XG4gICAgICBtMFtkID4+PiAyNF0gXlxuICAgICAgbTFbYSA+Pj4gMTYgJiAyNTVdIF5cbiAgICAgIG0yW2IgPj4+IDggJiAyNTVdIF5cbiAgICAgIG0zW2MgJiAyNTVdIF4gd1srK2ldO1xuICAgIGEgPSBhMjtcbiAgICBiID0gYjI7XG4gICAgYyA9IGMyO1xuICB9XG5cbiAgLypcbiAgICBFbmNyeXB0OlxuICAgIFN1YkJ5dGVzKHN0YXRlKVxuICAgIFNoaWZ0Um93cyhzdGF0ZSlcbiAgICBBZGRSb3VuZEtleShzdGF0ZSwgd1tOcipOYiwgKE5yKzEpKk5iLTFdKVxuXG4gICAgRGVjcnlwdDpcbiAgICBJbnZTaGlmdFJvd3Moc3RhdGUpXG4gICAgSW52U3ViQnl0ZXMoc3RhdGUpXG4gICAgQWRkUm91bmRLZXkoc3RhdGUsIHdbMCwgTmItMV0pXG4gICAqL1xuICAvLyBOb3RlOiByb3dzIGFyZSBzaGlmdGVkIGlubGluZVxuICBvdXRwdXRbMF0gPVxuICAgIChzdWJbYSA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltiID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2MgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2QgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0W2RlY3J5cHQgPyAzIDogMV0gPVxuICAgIChzdWJbYiA+Pj4gMjRdIDw8IDI0KSBeXG4gICAgKHN1YltjID4+PiAxNiAmIDI1NV0gPDwgMTYpIF5cbiAgICAoc3ViW2QgPj4+IDggJiAyNTVdIDw8IDgpIF5cbiAgICAoc3ViW2EgJiAyNTVdKSBeIHdbKytpXTtcbiAgb3V0cHV0WzJdID1cbiAgICAoc3ViW2MgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbZCA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YlthID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltiICYgMjU1XSkgXiB3WysraV07XG4gIG91dHB1dFtkZWNyeXB0ID8gMSA6IDNdID1cbiAgICAoc3ViW2QgPj4+IDI0XSA8PCAyNCkgXlxuICAgIChzdWJbYSA+Pj4gMTYgJiAyNTVdIDw8IDE2KSBeXG4gICAgKHN1YltiID4+PiA4ICYgMjU1XSA8PCA4KSBeXG4gICAgKHN1YltjICYgMjU1XSkgXiB3WysraV07XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0FFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdBRVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBBRVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcywgYW4gYXJyYXkgb2YgYnl0ZXMsIGFcbiAqIGJ5dGUgYnVmZmVyLCBvciBhbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqICAgICAgICAgIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLlxuICogICAgICAgICAgZGVjcnlwdCB0cnVlIGZvciBkZWNyeXB0aW9uLCBmYWxzZSBmb3IgZW5jcnlwdGlvbi5cbiAqICAgICAgICAgIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUNpcGhlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbW9kZSA9IChvcHRpb25zLm1vZGUgfHwgJ0NCQycpLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBhbGdvcml0aG0gPSAnQUVTLScgKyBtb2RlO1xuXG4gIHZhciBjaXBoZXI7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihhbGdvcml0aG0sIG9wdGlvbnMua2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgc3RhcnQgQVBJXG4gIHZhciBzdGFydCA9IGNpcGhlci5zdGFydDtcbiAgY2lwaGVyLnN0YXJ0ID0gZnVuY3Rpb24oaXYsIG9wdGlvbnMpIHtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogc3VwcG9ydCBzZWNvbmQgYXJnIGFzIG91dHB1dCBidWZmZXJcbiAgICB2YXIgb3V0cHV0ID0gbnVsbDtcbiAgICBpZihvcHRpb25zIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKSB7XG4gICAgICBvdXRwdXQgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm91dHB1dCA9IG91dHB1dDtcbiAgICBvcHRpb25zLml2ID0gaXY7XG4gICAgc3RhcnQuY2FsbChjaXBoZXIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgQWJzdHJhY3QgU3ludGF4IE5vdGF0aW9uIE51bWJlciBPbmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIEFuIEFQSSBmb3Igc3RvcmluZyBkYXRhIHVzaW5nIHRoZSBBYnN0cmFjdCBTeW50YXggTm90YXRpb24gTnVtYmVyIE9uZVxuICogZm9ybWF0IHVzaW5nIERFUiAoRGlzdGluZ3Vpc2hlZCBFbmNvZGluZyBSdWxlcykgZW5jb2RpbmcuIFRoaXMgZW5jb2RpbmcgaXNcbiAqIGNvbW1vbmx5IHVzZWQgdG8gc3RvcmUgZGF0YSBmb3IgUEtJLCBpLmUuIFguNTA5IENlcnRpZmljYXRlcywgYW5kIHRoaXNcbiAqIGltcGxlbWVudGF0aW9uIGV4aXN0cyBmb3IgdGhhdCBwdXJwb3NlLlxuICpcbiAqIEFic3RyYWN0IFN5bnRheCBOb3RhdGlvbiBOdW1iZXIgT25lIChBU04uMSkgaXMgdXNlZCB0byBkZWZpbmUgdGhlIGFic3RyYWN0XG4gKiBzeW50YXggb2YgaW5mb3JtYXRpb24gd2l0aG91dCByZXN0cmljdGluZyB0aGUgd2F5IHRoZSBpbmZvcm1hdGlvbiBpcyBlbmNvZGVkXG4gKiBmb3IgdHJhbnNtaXNzaW9uLiBJdCBwcm92aWRlcyBhIHN0YW5kYXJkIHRoYXQgYWxsb3dzIGZvciBvcGVuIHN5c3RlbXNcbiAqIGNvbW11bmljYXRpb24uIEFTTi4xIGRlZmluZXMgdGhlIHN5bnRheCBvZiBpbmZvcm1hdGlvbiBkYXRhIGFuZCBhIG51bWJlciBvZlxuICogc2ltcGxlIGRhdGEgdHlwZXMgYXMgd2VsbCBhcyBhIG5vdGF0aW9uIGZvciBkZXNjcmliaW5nIHRoZW0gYW5kIHNwZWNpZnlpbmdcbiAqIHZhbHVlcyBmb3IgdGhlbS5cbiAqXG4gKiBUaGUgUlNBIGFsZ29yaXRobSBjcmVhdGVzIHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXlzIHRoYXQgYXJlIG9mdGVuIHN0b3JlZCBpblxuICogWC41MDkgb3IgUEtDUyNYIGZvcm1hdHMgLS0gd2hpY2ggdXNlIEFTTi4xIChlbmNvZGVkIGluIERFUiBmb3JtYXQpLiBUaGlzXG4gKiBjbGFzcyBwcm92aWRlcyB0aGUgbW9zdCBiYXNpYyBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkIHRvIHN0b3JlIGFuZCBsb2FkIERTQVxuICoga2V5cyB0aGF0IGFyZSBlbmNvZGVkIGFjY29yZGluZyB0byBBU04uMS5cbiAqXG4gKiBUaGUgbW9zdCBjb21tb24gYmluYXJ5IGVuY29kaW5ncyBmb3IgQVNOLjEgYXJlIEJFUiAoQmFzaWMgRW5jb2RpbmcgUnVsZXMpXG4gKiBhbmQgREVSIChEaXN0aW5ndWlzaGVkIEVuY29kaW5nIFJ1bGVzKS4gREVSIGlzIGp1c3QgYSBzdWJzZXQgb2YgQkVSIHRoYXRcbiAqIGhhcyBzdHJpY3RlciByZXF1aXJlbWVudHMgZm9yIGhvdyBkYXRhIG11c3QgYmUgZW5jb2RlZC5cbiAqXG4gKiBFYWNoIEFTTi4xIHN0cnVjdHVyZSBoYXMgYSB0YWcgKGEgYnl0ZSBpZGVudGlmeWluZyB0aGUgQVNOLjEgc3RydWN0dXJlIHR5cGUpXG4gKiBhbmQgYSBieXRlIGFycmF5IGZvciB0aGUgdmFsdWUgb2YgdGhpcyBBU04xIHN0cnVjdHVyZSB3aGljaCBtYXkgYmUgZGF0YSBvciBhXG4gKiBsaXN0IG9mIEFTTi4xIHN0cnVjdHVyZXMuXG4gKlxuICogRWFjaCBBU04uMSBzdHJ1Y3R1cmUgdXNpbmcgQkVSIGlzIChUYWctTGVuZ3RoLVZhbHVlKTpcbiAqXG4gKiB8IGJ5dGUgMCB8IGJ5dGVzIFggfCBieXRlcyBZIHxcbiAqIHwtLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLVxuICogfCAgdGFnICAgfCBsZW5ndGggIHwgIHZhbHVlICB8XG4gKlxuICogQVNOLjEgYWxsb3dzIGZvciB0YWdzIHRvIGJlIG9mIFwiSGlnaC10YWctbnVtYmVyIGZvcm1cIiB3aGljaCBhbGxvd3MgYSB0YWcgdG9cbiAqIGJlIHR3byBvciBtb3JlIG9jdGV0cywgYnV0IHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNsYXNzLiBBIHRhZyBpc1xuICogb25seSAxIGJ5dGUuIEJpdHMgMS01IGdpdmUgdGhlIHRhZyBudW1iZXIgKGllIHRoZSBkYXRhIHR5cGUgd2l0aGluIGFcbiAqIHBhcnRpY3VsYXIgJ2NsYXNzJyksIDYgaW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBBU04uMSB2YWx1ZSBpc1xuICogY29uc3RydWN0ZWQgZnJvbSBvdGhlciBBU04uMSB2YWx1ZXMsIGFuZCBiaXRzIDcgYW5kIDggZ2l2ZSB0aGUgJ2NsYXNzJy4gSWZcbiAqIGJpdHMgNyBhbmQgOCBhcmUgYm90aCB6ZXJvLCB0aGUgY2xhc3MgaXMgVU5JVkVSU0FMLiBJZiBvbmx5IGJpdCA3IGlzIHNldCxcbiAqIHRoZW4gdGhlIGNsYXNzIGlzIEFQUExJQ0FUSU9OLiBJZiBvbmx5IGJpdCA4IGlzIHNldCwgdGhlbiB0aGUgY2xhc3MgaXNcbiAqIENPTlRFWFRfU1BFQ0lGSUMuIElmIGJvdGggYml0cyA3IGFuZCA4IGFyZSBzZXQsIHRoZW4gdGhlIGNsYXNzIGlzIFBSSVZBVEUuXG4gKiBUaGUgdGFnIG51bWJlcnMgZm9yIHRoZSBkYXRhIHR5cGVzIGZvciB0aGUgY2xhc3MgVU5JVkVSU0FMIGFyZSBsaXN0ZWQgYmVsb3c6XG4gKlxuICogVU5JVkVSU0FMIDAgUmVzZXJ2ZWQgZm9yIHVzZSBieSB0aGUgZW5jb2RpbmcgcnVsZXNcbiAqIFVOSVZFUlNBTCAxIEJvb2xlYW4gdHlwZVxuICogVU5JVkVSU0FMIDIgSW50ZWdlciB0eXBlXG4gKiBVTklWRVJTQUwgMyBCaXRzdHJpbmcgdHlwZVxuICogVU5JVkVSU0FMIDQgT2N0ZXRzdHJpbmcgdHlwZVxuICogVU5JVkVSU0FMIDUgTnVsbCB0eXBlXG4gKiBVTklWRVJTQUwgNiBPYmplY3QgaWRlbnRpZmllciB0eXBlXG4gKiBVTklWRVJTQUwgNyBPYmplY3QgZGVzY3JpcHRvciB0eXBlXG4gKiBVTklWRVJTQUwgOCBFeHRlcm5hbCB0eXBlIGFuZCBJbnN0YW5jZS1vZiB0eXBlXG4gKiBVTklWRVJTQUwgOSBSZWFsIHR5cGVcbiAqIFVOSVZFUlNBTCAxMCBFbnVtZXJhdGVkIHR5cGVcbiAqIFVOSVZFUlNBTCAxMSBFbWJlZGRlZC1wZHYgdHlwZVxuICogVU5JVkVSU0FMIDEyIFVURjhTdHJpbmcgdHlwZVxuICogVU5JVkVSU0FMIDEzIFJlbGF0aXZlIG9iamVjdCBpZGVudGlmaWVyIHR5cGVcbiAqIFVOSVZFUlNBTCAxNC0xNSBSZXNlcnZlZCBmb3IgZnV0dXJlIGVkaXRpb25zXG4gKiBVTklWRVJTQUwgMTYgU2VxdWVuY2UgYW5kIFNlcXVlbmNlLW9mIHR5cGVzXG4gKiBVTklWRVJTQUwgMTcgU2V0IGFuZCBTZXQtb2YgdHlwZXNcbiAqIFVOSVZFUlNBTCAxOC0yMiwgMjUtMzAgQ2hhcmFjdGVyIHN0cmluZyB0eXBlc1xuICogVU5JVkVSU0FMIDIzLTI0IFRpbWUgdHlwZXNcbiAqXG4gKiBUaGUgbGVuZ3RoIG9mIGFuIEFTTi4xIHN0cnVjdHVyZSBpcyBzcGVjaWZpZWQgYWZ0ZXIgdGhlIHRhZyBpZGVudGlmaWVyLlxuICogVGhlcmUgaXMgYSBkZWZpbml0ZSBmb3JtIGFuZCBhbiBpbmRlZmluaXRlIGZvcm0uIFRoZSBpbmRlZmluaXRlIGZvcm0gbWF5XG4gKiBiZSB1c2VkIGlmIHRoZSBlbmNvZGluZyBpcyBjb25zdHJ1Y3RlZCBhbmQgbm90IGFsbCBpbW1lZGlhdGVseSBhdmFpbGFibGUuXG4gKiBUaGUgaW5kZWZpbml0ZSBmb3JtIGlzIGVuY29kZWQgdXNpbmcgYSBsZW5ndGggYnl0ZSB3aXRoIG9ubHkgdGhlIDh0aCBiaXRcbiAqIHNldC4gVGhlIGVuZCBvZiB0aGUgY29uc3RydWN0ZWQgb2JqZWN0IGlzIG1hcmtlZCB1c2luZyBlbmQtb2YtY29udGVudHNcbiAqIG9jdGV0cyAodHdvIHplcm8gYnl0ZXMpLlxuICpcbiAqIFRoZSBkZWZpbml0ZSBmb3JtIGxvb2tzIGxpa2UgdGhpczpcbiAqXG4gKiBUaGUgbGVuZ3RoIG1heSB0YWtlIHVwIDEgb3IgbW9yZSBieXRlcywgaXQgZGVwZW5kcyBvbiB0aGUgbGVuZ3RoIG9mIHRoZVxuICogdmFsdWUgb2YgdGhlIEFTTi4xIHN0cnVjdHVyZS4gREVSIGVuY29kaW5nIHJlcXVpcmVzIHRoYXQgaWYgdGhlIEFTTi4xXG4gKiBzdHJ1Y3R1cmUgaGFzIGEgdmFsdWUgdGhhdCBoYXMgYSBsZW5ndGggZ3JlYXRlciB0aGFuIDEyNywgbW9yZSB0aGFuIDEgYnl0ZVxuICogd2lsbCBiZSB1c2VkIHRvIHN0b3JlIGl0cyBsZW5ndGgsIG90aGVyd2lzZSBqdXN0IG9uZSBieXRlIHdpbGwgYmUgdXNlZC5cbiAqIFRoaXMgaXMgc3RyaWN0LlxuICpcbiAqIEluIHRoZSBjYXNlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgQVNOLjEgdmFsdWUgaXMgbGVzcyB0aGFuIDEyNywgMSBvY3RldFxuICogKGJ5dGUpIGlzIHVzZWQgdG8gc3RvcmUgdGhlIFwic2hvcnQgZm9ybVwiIGxlbmd0aC4gVGhlIDh0aCBiaXQgaGFzIGEgdmFsdWUgb2ZcbiAqIDAgaW5kaWNhdGluZyB0aGUgbGVuZ3RoIGlzIFwic2hvcnQgZm9ybVwiIGFuZCBub3QgXCJsb25nIGZvcm1cIiBhbmQgYml0cyA3LTFcbiAqIGdpdmUgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YS4gKFRoZSA4dGggYml0IGlzIHRoZSBsZWZ0LW1vc3QsIG1vc3Qgc2lnbmlmaWNhbnRcbiAqIGJpdDogYWxzbyBrbm93biBhcyBiaWcgZW5kaWFuIG9yIG5ldHdvcmsgZm9ybWF0KS5cbiAqXG4gKiBJbiB0aGUgY2FzZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIEFTTi4xIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAxMjcsIDIgdG9cbiAqIDEyNyBvY3RldHMgKGJ5dGVzKSBhcmUgdXNlZCB0byBzdG9yZSB0aGUgXCJsb25nIGZvcm1cIiBsZW5ndGguIFRoZSBmaXJzdFxuICogYnl0ZSdzIDh0aCBiaXQgaXMgc2V0IHRvIDEgdG8gaW5kaWNhdGUgdGhlIGxlbmd0aCBpcyBcImxvbmcgZm9ybS5cIiBCaXRzIDctMVxuICogZ2l2ZSB0aGUgbnVtYmVyIG9mIGFkZGl0aW9uYWwgb2N0ZXRzLiBBbGwgZm9sbG93aW5nIG9jdGV0cyBhcmUgaW4gYmFzZSAyNTZcbiAqIHdpdGggdGhlIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXQgZmlyc3QgKHR5cGljYWwgYmlnLWVuZGlhbiBiaW5hcnkgdW5zaWduZWRcbiAqIGludGVnZXIgc3RvcmFnZSkuIFNvLCBmb3IgaW5zdGFuY2UsIGlmIHRoZSBsZW5ndGggb2YgYSB2YWx1ZSB3YXMgMjU3LCB0aGVcbiAqIGZpcnN0IGJ5dGUgd291bGQgYmUgc2V0IHRvOlxuICpcbiAqIDEwMDAwMDEwID0gMTMwID0gMHg4Mi5cbiAqXG4gKiBUaGlzIGluZGljYXRlcyB0aGVyZSBhcmUgMiBvY3RldHMgKGJhc2UgMjU2KSBmb3IgdGhlIGxlbmd0aC4gVGhlIHNlY29uZCBhbmRcbiAqIHRoaXJkIGJ5dGVzICh0aGUgb2N0ZXRzIGp1c3QgbWVudGlvbmVkKSB3b3VsZCBzdG9yZSB0aGUgbGVuZ3RoIGluIGJhc2UgMjU2OlxuICpcbiAqIG9jdGV0IDI6IDAwMDAwMDAxID0gMSAqIDI1Nl4xID0gMjU2XG4gKiBvY3RldCAzOiAwMDAwMDAwMSA9IDEgKiAyNTZeMCA9IDFcbiAqIHRvdGFsID0gMjU3XG4gKlxuICogVGhlIGFsZ29yaXRobSBmb3IgY29udmVydGluZyBhIGpzIGludGVnZXIgdmFsdWUgb2YgMjU3IHRvIGJhc2UtMjU2IGlzOlxuICpcbiAqIHZhciB2YWx1ZSA9IDI1NztcbiAqIHZhciBieXRlcyA9IFtdO1xuICogYnl0ZXNbMF0gPSAodmFsdWUgPj4+IDgpICYgMHhGRjsgLy8gbW9zdCBzaWduaWZpY2FudCBieXRlIGZpcnN0XG4gKiBieXRlc1sxXSA9IHZhbHVlICYgMHhGRjsgICAgICAgIC8vIGxlYXN0IHNpZ25pZmljYW50IGJ5dGUgbGFzdFxuICpcbiAqIE9uIHRoZSBBU04uMSBVTklWRVJTQUwgT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgdHlwZTpcbiAqXG4gKiBBbiBPSUQgY2FuIGJlIHdyaXR0ZW4gbGlrZTogXCJ2YWx1ZTEudmFsdWUyLnZhbHVlMy4uLnZhbHVlTlwiXG4gKlxuICogVGhlIERFUiBlbmNvZGluZyBydWxlczpcbiAqXG4gKiBUaGUgZmlyc3QgYnl0ZSBoYXMgdGhlIHZhbHVlIDQwICogdmFsdWUxICsgdmFsdWUyLlxuICogVGhlIGZvbGxvd2luZyBieXRlcywgaWYgYW55LCBlbmNvZGUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuIEVhY2ggdmFsdWUgaXNcbiAqIGVuY29kZWQgaW4gYmFzZSAxMjgsIG1vc3Qgc2lnbmlmaWNhbnQgZGlnaXQgZmlyc3QgKGJpZyBlbmRpYW4pLCB3aXRoIGFzXG4gKiBmZXcgZGlnaXRzIGFzIHBvc3NpYmxlLCBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIGVhY2ggYnl0ZSBzZXRcbiAqIHRvIDEgZXhjZXB0IHRoZSBsYXN0IGluIGVhY2ggdmFsdWUncyBlbmNvZGluZy4gRm9yIGV4YW1wbGU6IEdpdmVuIHRoZVxuICogT0lEIFwiMS4yLjg0MC4xMTM1NDlcIiwgaXRzIERFUiBlbmNvZGluZyBpcyAocmVtZW1iZXIgZWFjaCBieXRlIGV4Y2VwdCB0aGVcbiAqIGxhc3Qgb25lIGluIGVhY2ggZW5jb2RpbmcgaXMgT1InZCB3aXRoIDB4ODApOlxuICpcbiAqIGJ5dGUgMTogNDAgKiAxICsgMiA9IDQyID0gMHgyQS5cbiAqIGJ5dGVzIDItMzogMTI4ICogNiArIDcyID0gODQwID0gNiA3MiA9IDYgNzIgPSAweDA2NDggPSAweDg2NDhcbiAqIGJ5dGVzIDQtNjogMTYzODQgKiA2ICsgMTI4ICogMTE5ICsgMTMgPSA2IDExOSAxMyA9IDB4MDY3NzBEID0gMHg4NkY3MERcbiAqXG4gKiBUaGUgZmluYWwgdmFsdWUgaXM6IDB4MkE4NjQ4ODZGNzBELlxuICogVGhlIGZ1bGwgT0lEIChpbmNsdWRpbmcgQVNOLjEgdGFnIGFuZCBsZW5ndGggb2YgNiBieXRlcykgaXM6XG4gKiAweDA2MDYyQTg2NDg4NkY3MERcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL29pZHMnKTtcblxuLyogQVNOLjEgQVBJICovXG52YXIgYXNuMSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuYXNuMSA9IGZvcmdlLmFzbjEgfHwge307XG5cbi8qKlxuICogQVNOLjEgY2xhc3Nlcy5cbiAqL1xuYXNuMS5DbGFzcyA9IHtcbiAgVU5JVkVSU0FMOiAgICAgICAgMHgwMCxcbiAgQVBQTElDQVRJT046ICAgICAgMHg0MCxcbiAgQ09OVEVYVF9TUEVDSUZJQzogMHg4MCxcbiAgUFJJVkFURTogICAgICAgICAgMHhDMFxufTtcblxuLyoqXG4gKiBBU04uMSB0eXBlcy4gTm90IGFsbCB0eXBlcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb24sIG9ubHlcbiAqIHRob3NlIG5lY2Vzc2FyeSB0byBpbXBsZW1lbnQgYSBzaW1wbGUgUEtJIGFyZSBpbXBsZW1lbnRlZC5cbiAqL1xuYXNuMS5UeXBlID0ge1xuICBOT05FOiAgICAgICAgICAgICAwLFxuICBCT09MRUFOOiAgICAgICAgICAxLFxuICBJTlRFR0VSOiAgICAgICAgICAyLFxuICBCSVRTVFJJTkc6ICAgICAgICAzLFxuICBPQ1RFVFNUUklORzogICAgICA0LFxuICBOVUxMOiAgICAgICAgICAgICA1LFxuICBPSUQ6ICAgICAgICAgICAgICA2LFxuICBPREVTQzogICAgICAgICAgICA3LFxuICBFWFRFUk5BTDogICAgICAgICA4LFxuICBSRUFMOiAgICAgICAgICAgICA5LFxuICBFTlVNRVJBVEVEOiAgICAgIDEwLFxuICBFTUJFRERFRDogICAgICAgIDExLFxuICBVVEY4OiAgICAgICAgICAgIDEyLFxuICBST0lEOiAgICAgICAgICAgIDEzLFxuICBTRVFVRU5DRTogICAgICAgIDE2LFxuICBTRVQ6ICAgICAgICAgICAgIDE3LFxuICBQUklOVEFCTEVTVFJJTkc6IDE5LFxuICBJQTVTVFJJTkc6ICAgICAgIDIyLFxuICBVVENUSU1FOiAgICAgICAgIDIzLFxuICBHRU5FUkFMSVpFRFRJTUU6IDI0LFxuICBCTVBTVFJJTkc6ICAgICAgIDMwXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhZ0NsYXNzIHRoZSB0YWcgY2xhc3MgZm9yIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0gdHlwZSB0aGUgZGF0YSB0eXBlICh0YWcgbnVtYmVyKSBmb3IgdGhlIG9iamVjdC5cbiAqIEBwYXJhbSBjb25zdHJ1Y3RlZCB0cnVlIGlmIHRoZSBhc24xIG9iamVjdCBpcyBpbiBjb25zdHJ1Y3RlZCBmb3JtLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBmb3IgdGhlIG9iamVjdCwgaWYgaXQgaXMgbm90IGNvbnN0cnVjdGVkLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYml0U3RyaW5nQ29udGVudHNdIHRoZSBwbGFpbiBCSVQgU1RSSU5HIGNvbnRlbnQgaW5jbHVkaW5nIHBhZGRpbmdcbiAqICAgICAgICAgICAgYnl0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIG9iamVjdC5cbiAqL1xuYXNuMS5jcmVhdGUgPSBmdW5jdGlvbih0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8qIEFuIGFzbjEgb2JqZWN0IGhhcyBhIHRhZ0NsYXNzLCBhIHR5cGUsIGEgY29uc3RydWN0ZWQgZmxhZywgYW5kIGFcbiAgICB2YWx1ZS4gVGhlIHZhbHVlJ3MgdHlwZSBkZXBlbmRzIG9uIHRoZSBjb25zdHJ1Y3RlZCBmbGFnLiBJZlxuICAgIGNvbnN0cnVjdGVkLCBpdCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG90aGVyIGFzbjEgb2JqZWN0cy4gSWYgbm90LFxuICAgIGl0IHdpbGwgY29udGFpbiB0aGUgQVNOLjEgdmFsdWUgYXMgYW4gYXJyYXkgb2YgYnl0ZXMgZm9ybWF0dGVkXG4gICAgYWNjb3JkaW5nIHRvIHRoZSBBU04uMSBkYXRhIHR5cGUuICovXG5cbiAgLy8gcmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdG1wLnB1c2godmFsdWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBvYmogPSB7XG4gICAgdGFnQ2xhc3M6IHRhZ0NsYXNzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29uc3RydWN0ZWQ6IGNvbnN0cnVjdGVkLFxuICAgIGNvbXBvc2VkOiBjb25zdHJ1Y3RlZCB8fCBmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xuICBpZihvcHRpb25zICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb3B0aW9ucykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICBvYmouYml0U3RyaW5nQ29udGVudHMgPSBvcHRpb25zLmJpdFN0cmluZ0NvbnRlbnRzO1xuICAgIC8vIFRPRE86IGFkZCByZWFkb25seSBmbGFnIHRvIGF2b2lkIHRoaXMgb3ZlcmhlYWRcbiAgICAvLyBzYXZlIGNvcHkgdG8gZGV0ZWN0IGNoYW5nZXNcbiAgICBvYmoub3JpZ2luYWwgPSBhc24xLmNvcHkob2JqKTtcbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgYW4gYXNuMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSBvYmplY3QuXG4gKiBAcGFyYW0gW29wdGlvbnNdIGNvcHkgb3B0aW9uczpcbiAqICAgICAgICAgIFtleGNsdWRlQml0U3RyaW5nQ29udGVudHNdIHRydWUgdG8gbm90IGNvcHkgYml0U3RyaW5nQ29udGVudHNcbiAqXG4gKiBAcmV0dXJuIHRoZSBhIGNvcHkgb2YgdGhlIGFzbjEgb2JqZWN0LlxuICovXG5hc24xLmNvcHkgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGNvcHk7XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICBjb3B5ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgY29weS5wdXNoKGFzbjEuY29weShvYmpbaV0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRPRE86IGNvcHkgYnl0ZSBidWZmZXIgaWYgaXQncyBhIGJ1ZmZlciBub3QgYSBzdHJpbmdcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29weSA9IHtcbiAgICB0YWdDbGFzczogb2JqLnRhZ0NsYXNzLFxuICAgIHR5cGU6IG9iai50eXBlLFxuICAgIGNvbnN0cnVjdGVkOiBvYmouY29uc3RydWN0ZWQsXG4gICAgY29tcG9zZWQ6IG9iai5jb21wb3NlZCxcbiAgICB2YWx1ZTogYXNuMS5jb3B5KG9iai52YWx1ZSwgb3B0aW9ucylcbiAgfTtcbiAgaWYob3B0aW9ucyAmJiAhb3B0aW9ucy5leGNsdWRlQml0U3RyaW5nQ29udGVudHMpIHtcbiAgICAvLyBUT0RPOiBjb3B5IGJ5dGUgYnVmZmVyIGlmIGl0J3MgYSBidWZmZXIgbm90IGEgc3RyaW5nXG4gICAgY29weS5iaXRTdHJpbmdDb250ZW50cyA9IG9iai5iaXRTdHJpbmdDb250ZW50cztcbiAgfVxuICByZXR1cm4gY29weTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgYXNuMSBvYmplY3RzIGZvciBlcXVhbGl0eS5cbiAqXG4gKiBOb3RlIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcnVuIGluIGNvbnN0YW50IHRpbWUuXG4gKlxuICogQHBhcmFtIG9iajEgdGhlIGZpcnN0IGFzbjEgb2JqZWN0LlxuICogQHBhcmFtIG9iajIgdGhlIHNlY29uZCBhc24xIG9iamVjdC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gY29tcGFyZSBvcHRpb25zOlxuICogICAgICAgICAgW2luY2x1ZGVCaXRTdHJpbmdDb250ZW50c10gdHJ1ZSB0byBjb21wYXJlIGJpdFN0cmluZ0NvbnRlbnRzXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBhc24xIG9iamVjdHMgYXJlIGVxdWFsLlxuICovXG5hc24xLmVxdWFscyA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KG9iajEpKSB7XG4gICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShvYmoyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZihvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iajEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKCFhc24xLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgIT09IHR5cGVvZiBvYmoyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYodHlwZW9mIG9iajEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIH1cblxuICB2YXIgZXF1YWwgPSBvYmoxLnRhZ0NsYXNzID09PSBvYmoyLnRhZ0NsYXNzICYmXG4gICAgb2JqMS50eXBlID09PSBvYmoyLnR5cGUgJiZcbiAgICBvYmoxLmNvbnN0cnVjdGVkID09PSBvYmoyLmNvbnN0cnVjdGVkICYmXG4gICAgb2JqMS5jb21wb3NlZCA9PT0gb2JqMi5jb21wb3NlZCAmJlxuICAgIGFzbjEuZXF1YWxzKG9iajEudmFsdWUsIG9iajIudmFsdWUpO1xuICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgZXF1YWwgPSBlcXVhbCAmJiAob2JqMS5iaXRTdHJpbmdDb250ZW50cyA9PT0gb2JqMi5iaXRTdHJpbmdDb250ZW50cyk7XG4gIH1cblxuICByZXR1cm4gZXF1YWw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGIgdGhlIEJFUi1lbmNvZGVkIEFTTi4xIGJ5dGUgYnVmZmVyLCBzdGFydGluZyB3aXRoIHRoZSBmaXJzdFxuICogICAgICAgICAgbGVuZ3RoIGJ5dGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbmFzbjEuZ2V0QmVyVmFsdWVMZW5ndGggPSBmdW5jdGlvbihiKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIHZhciBiMiA9IGIuZ2V0Qnl0ZSgpO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgbGVuZ3RoID0gYi5nZXRJbnQoKGIyICYgMHg3RikgPDwgMyk7XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJ5dGUgYnVmZmVyIGhhcyBlbm91Z2ggYnl0ZXMuIFRocm93cyBhbiBFcnJvciBpZiBub3QuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgbXVzdCBoYXZlLlxuICovXG5mdW5jdGlvbiBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgbikge1xuICBpZihuID4gcmVtYWluaW5nKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHBhcnNlIERFUi4nKTtcbiAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICBlcnJvci5yZW1haW5pbmcgPSByZW1haW5pbmc7XG4gICAgZXJyb3IucmVxdWVzdGVkID0gbjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGxlbmd0aCBvZiBhIEJFUi1lbmNvZGVkIEFTTi4xIHZhbHVlLlxuICpcbiAqIEluIGNhc2UgdGhlIGxlbmd0aCBpcyBub3Qgc3BlY2lmaWVkLCB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIHJlbWFpbmluZyB0aGUgYnl0ZXMgcmVtYWluaW5nIGluIHRoZSBjdXJyZW50IHBhcnNpbmcgc3RhdGUuXG4gKlxuICogQHJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBCRVItZW5jb2RlZCBBU04uMSB2YWx1ZSBvciB1bmRlZmluZWQuXG4gKi9cbnZhciBfZ2V0VmFsdWVMZW5ndGggPSBmdW5jdGlvbihieXRlcywgcmVtYWluaW5nKSB7XG4gIC8vIFRPRE86IG1vdmUgdGhpcyBmdW5jdGlvbiBhbmQgcmVsYXRlZCBERVIvQkVSIGZ1bmN0aW9ucyB0byBhIGRlci5qc1xuICAvLyBmaWxlOyBiZXR0ZXIgYWJzdHJhY3QgQVNOLjEgYXdheSBmcm9tIGRlci9iZXIuXG4gIC8vIGZyb21EZXIgYWxyZWFkeSBjaGVja2VkIHRoYXQgdGhpcyBieXRlIGV4aXN0c1xuICB2YXIgYjIgPSBieXRlcy5nZXRCeXRlKCk7XG4gIHJlbWFpbmluZy0tO1xuICBpZihiMiA9PT0gMHg4MCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBzZWUgaWYgdGhlIGxlbmd0aCBpcyBcInNob3J0IGZvcm1cIiBvciBcImxvbmcgZm9ybVwiIChiaXQgOCBzZXQpXG4gIHZhciBsZW5ndGg7XG4gIHZhciBsb25nRm9ybSA9IGIyICYgMHg4MDtcbiAgaWYoIWxvbmdGb3JtKSB7XG4gICAgLy8gbGVuZ3RoIGlzIGp1c3QgdGhlIGZpcnN0IGJ5dGVcbiAgICBsZW5ndGggPSBiMjtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBsZW5ndGggaXMgc3BlY2lmaWVkIGluIGJpdHMgNyB0aHJvdWdoIDFcbiAgICAvLyBhbmQgZWFjaCBsZW5ndGggYnl0ZSBpcyBpbiBiaWctZW5kaWFuIGJhc2UtMjU2XG4gICAgdmFyIGxvbmdGb3JtQnl0ZXMgPSBiMiAmIDB4N0Y7XG4gICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIGxvbmdGb3JtQnl0ZXMpO1xuICAgIGxlbmd0aCA9IGJ5dGVzLmdldEludChsb25nRm9ybUJ5dGVzIDw8IDMpO1xuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHdpbGwgb25seSBoYXBwZW4gZm9yIDMyIGJpdCBnZXRJbnQgd2l0aCBoaWdoIGJpdCBzZXRcbiAgaWYobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgbGVuZ3RoOiAnICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYXNuMSBvYmplY3QgZnJvbSBhIGJ5dGUgYnVmZmVyIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlIGJ1ZmZlciB0byBwYXJzZSBmcm9tLlxuICogQHBhcmFtIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgIGFsbG93IHRydW5jYXRlZCB2YWx1ZXMgKGRlZmF1bHQ6IHRydWUpLlxuICogQHBhcmFtIFtvcHRpb25zXSBvYmplY3Qgd2l0aCBvcHRpb25zIG9yIGJvb2xlYW4gc3RyaWN0IGZsYWdcbiAqICAgICAgICAgIFtzdHJpY3RdIHRydWUgdG8gYmUgc3RyaWN0IHdoZW4gY2hlY2tpbmcgdmFsdWUgbGVuZ3RocywgZmFsc2UgdG9cbiAqICAgICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZGVjb2RlQml0U3RyaW5nc10gdHJ1ZSB0byBhdHRlbXB0IHRvIGRlY29kZSB0aGUgY29udGVudCBvZlxuICogICAgICAgICAgICBCSVQgU1RSSU5HcyAobm90IE9DVEVUIFNUUklOR3MpIHVzaW5nIHN0cmljdCBtb2RlLiBOb3RlIHRoYXRcbiAqICAgICAgICAgICAgd2l0aG91dCBzY2hlbWEgc3VwcG9ydCB0byB1bmRlcnN0YW5kIHRoZSBkYXRhIGNvbnRleHQgdGhpcyBjYW5cbiAqICAgICAgICAgICAgZXJyb25lb3VzbHkgZGVjb2RlIHZhbHVlcyB0aGF0IGhhcHBlbiB0byBiZSB2YWxpZCBBU04uMS4gVGhpc1xuICogICAgICAgICAgICBmbGFnIHdpbGwgYmUgZGVwcmVjYXRlZCBvciByZW1vdmVkIGFzIHNvb24gYXMgc2NoZW1hIHN1cHBvcnQgaXNcbiAqICAgICAgICAgICAgYXZhaWxhYmxlLiAoZGVmYXVsdDogdHJ1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBwYXJzZWQgYXNuMSBvYmplY3QuXG4gKi9cbmFzbjEuZnJvbURlciA9IGZ1bmN0aW9uKGJ5dGVzLCBvcHRpb25zKSB7XG4gIGlmKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgfTtcbiAgfVxuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdDogb3B0aW9ucyxcbiAgICAgIGRlY29kZUJpdFN0cmluZ3M6IHRydWVcbiAgICB9O1xuICB9XG4gIGlmKCEoJ3N0cmljdCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgaWYoISgnZGVjb2RlQml0U3RyaW5ncycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmRlY29kZUJpdFN0cmluZ3MgPSB0cnVlO1xuICB9XG5cbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHJldHVybiBfZnJvbURlcihieXRlcywgYnl0ZXMubGVuZ3RoKCksIDAsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBwYXJzZSBhbiBhc24xIG9iamVjdCBmcm9tIGEgYnl0ZSBidWZmZXIgaW4gREVSIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyIHRvIHBhcnNlIGZyb20uXG4gKiBAcGFyYW0gcmVtYWluaW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGZvciB0aGlzIGNodW5rLlxuICogQHBhcmFtIGRlcHRoIHRoZSBjdXJyZW50IHBhcnNpbmcgZGVwdGguXG4gKiBAcGFyYW0gb3B0aW9ucyBvYmplY3Qgd2l0aCBzYW1lIG9wdGlvbnMgYXMgZnJvbURlcigpLlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBhc24xIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGgsIG9wdGlvbnMpIHtcbiAgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvbnN1bXB0aW9uIGNhbGN1bGF0aW9uc1xuICB2YXIgc3RhcnQ7XG5cbiAgLy8gbWluaW11bSBsZW5ndGggZm9yIEFTTi4xIERFUiBzdHJ1Y3R1cmUgaXMgMlxuICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBieXRlXG4gIHZhciBiMSA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgLy8gY29uc3VtZWQgb25lIGJ5dGVcbiAgcmVtYWluaW5nLS07XG5cbiAgLy8gZ2V0IHRoZSB0YWcgY2xhc3NcbiAgdmFyIHRhZ0NsYXNzID0gKGIxICYgMHhDMCk7XG5cbiAgLy8gZ2V0IHRoZSB0eXBlIChiaXRzIDEtNSlcbiAgdmFyIHR5cGUgPSBiMSAmIDB4MUY7XG5cbiAgLy8gZ2V0IHRoZSB2YXJpYWJsZSB2YWx1ZSBsZW5ndGggYW5kIGFkanVzdCByZW1haW5pbmcgYnl0ZXNcbiAgc3RhcnQgPSBieXRlcy5sZW5ndGgoKTtcbiAgdmFyIGxlbmd0aCA9IF9nZXRWYWx1ZUxlbmd0aChieXRlcywgcmVtYWluaW5nKTtcbiAgcmVtYWluaW5nIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG5cbiAgLy8gZW5zdXJlIHRoZXJlIGFyZSBlbm91Z2ggYnl0ZXMgdG8gZ2V0IHRoZSB2YWx1ZVxuICBpZihsZW5ndGggIT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICBpZihvcHRpb25zLnN0cmljdCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdUb28gZmV3IGJ5dGVzIHRvIHJlYWQgQVNOLjEgdmFsdWUuJyk7XG4gICAgICBlcnJvci5hdmFpbGFibGUgPSBieXRlcy5sZW5ndGgoKTtcbiAgICAgIGVycm9yLnJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICAgIGVycm9yLnJlcXVlc3RlZCA9IGxlbmd0aDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBOb3RlOiBiZSBsZW5pZW50IHdpdGggdHJ1bmNhdGVkIHZhbHVlcyBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfVxuXG4gIC8vIHZhbHVlIHN0b3JhZ2VcbiAgdmFyIHZhbHVlO1xuICAvLyBwb3NzaWJsZSBCSVQgU1RSSU5HIGNvbnRlbnRzIHN0b3JhZ2VcbiAgdmFyIGJpdFN0cmluZ0NvbnRlbnRzO1xuXG4gIC8vIGNvbnN0cnVjdGVkIGZsYWcgaXMgYml0IDYgKDMyID0gMHgyMCkgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGNvbnN0cnVjdGVkID0gKChiMSAmIDB4MjApID09PSAweDIwKTtcbiAgaWYoY29uc3RydWN0ZWQpIHtcbiAgICAvLyBwYXJzZSBjaGlsZCBhc24xIG9iamVjdHMgZnJvbSB0aGUgdmFsdWVcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGlmKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBhc24xIG9iamVjdCBvZiBpbmRlZmluaXRlIGxlbmd0aCwgcmVhZCB1bnRpbCBlbmQgdGFnXG4gICAgICBmb3IoOzspIHtcbiAgICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDIpO1xuICAgICAgICBpZihieXRlcy5ieXRlcygyKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwKSkge1xuICAgICAgICAgIGJ5dGVzLmdldEJ5dGVzKDIpO1xuICAgICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICAgIHZhbHVlLnB1c2goX2Zyb21EZXIoYnl0ZXMsIHJlbWFpbmluZywgZGVwdGggKyAxLCBvcHRpb25zKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSBzdGFydCAtIGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJzaW5nIGFzbjEgb2JqZWN0IG9mIGRlZmluaXRlIGxlbmd0aFxuICAgICAgd2hpbGUobGVuZ3RoID4gMCkge1xuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YWx1ZS5wdXNoKF9mcm9tRGVyKGJ5dGVzLCBsZW5ndGgsIGRlcHRoICsgMSwgb3B0aW9ucykpO1xuICAgICAgICByZW1haW5pbmcgLT0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgbGVuZ3RoIC09IHN0YXJ0IC0gYnl0ZXMubGVuZ3RoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYSBCSVQgU1RSSU5HLCBzYXZlIHRoZSBjb250ZW50cyBpbmNsdWRpbmcgcGFkZGluZ1xuICBpZih2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRhZ0NsYXNzID09PSBhc24xLkNsYXNzLlVOSVZFUlNBTCAmJlxuICAgIHR5cGUgPT09IGFzbjEuVHlwZS5CSVRTVFJJTkcpIHtcbiAgICBiaXRTdHJpbmdDb250ZW50cyA9IGJ5dGVzLmJ5dGVzKGxlbmd0aCk7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgaWYgYSBub24tY29uc3RydWN0ZWQgdmFsdWUgc2hvdWxkIGJlIGRlY29kZWQgYXMgYSBjb21wb3NlZFxuICAvLyB2YWx1ZSB0aGF0IGNvbnRhaW5zIG90aGVyIEFTTi4xIG9iamVjdHMuIEJJVCBTVFJJTkdzIChhbmQgT0NURVQgU1RSSU5HcylcbiAgLy8gY2FuIGJlIHVzZWQgdGhpcyB3YXkuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5kZWNvZGVCaXRTdHJpbmdzICYmXG4gICAgdGFnQ2xhc3MgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMICYmXG4gICAgLy8gRklYTUU6IE9DVEVUIFNUUklOR3Mgbm90IHlldCBzdXBwb3J0ZWQgaGVyZVxuICAgIC8vIC4uIG90aGVyIHBhcnRzIG9mIGZvcmdlIGV4cGVjdCB0byBkZWNvZGUgT0NURVQgU1RSSU5HcyBtYW51YWxseVxuICAgICh0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HIC8qfHwgdHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKi8pICYmXG4gICAgbGVuZ3RoID4gMSkge1xuICAgIC8vIHNhdmUgcmVhZCBwb3NpdGlvblxuICAgIHZhciBzYXZlZFJlYWQgPSBieXRlcy5yZWFkO1xuICAgIHZhciBzYXZlZFJlbWFpbmluZyA9IHJlbWFpbmluZztcbiAgICB2YXIgdW51c2VkID0gMDtcbiAgICBpZih0eXBlID09PSBhc24xLlR5cGUuQklUU1RSSU5HKSB7XG4gICAgICAvKiBUaGUgZmlyc3Qgb2N0ZXQgZ2l2ZXMgdGhlIG51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIHRoZSBsZW5ndGggb2YgdGhlXG4gICAgICAgIGJpdCBzdHJpbmcgaXMgbGVzcyB0aGFuIHRoZSBuZXh0IG11bHRpcGxlIG9mIGVpZ2h0ICh0aGlzIGlzIGNhbGxlZFxuICAgICAgICB0aGUgXCJudW1iZXIgb2YgdW51c2VkIGJpdHNcIikuXG5cbiAgICAgICAgVGhlIHNlY29uZCBhbmQgZm9sbG93aW5nIG9jdGV0cyBnaXZlIHRoZSB2YWx1ZSBvZiB0aGUgYml0IHN0cmluZ1xuICAgICAgICBjb252ZXJ0ZWQgdG8gYW4gb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgX2NoZWNrQnVmZmVyTGVuZ3RoKGJ5dGVzLCByZW1haW5pbmcsIDEpO1xuICAgICAgdW51c2VkID0gYnl0ZXMuZ2V0Qnl0ZSgpO1xuICAgICAgcmVtYWluaW5nLS07XG4gICAgfVxuICAgIC8vIGlmIGFsbCBiaXRzIGFyZSB1c2VkLCBtYXliZSB0aGUgQklUL09DVEVUIFNUUklORyBob2xkcyBBU04uMSBvYmpzXG4gICAgaWYodW51c2VkID09PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBhdHRlbXB0IHRvIHBhcnNlIGNoaWxkIGFzbjEgb2JqZWN0IGZyb20gdGhlIHZhbHVlXG4gICAgICAgIC8vIChzdG9yZWQgaW4gYXJyYXkgdG8gc2lnbmFsIGNvbXBvc2VkIHZhbHVlKVxuICAgICAgICBzdGFydCA9IGJ5dGVzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgc3ViT3B0aW9ucyA9IHtcbiAgICAgICAgICAvLyBlbmZvcmNlIHN0cmljdCBtb2RlIHRvIGF2b2lkIHBhcnNpbmcgQVNOLjEgZnJvbSBwbGFpbiBkYXRhXG4gICAgICAgICAgdmVyYm9zZTogb3B0aW9ucy52ZXJib3NlLFxuICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICBkZWNvZGVCaXRTdHJpbmdzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb21wb3NlZCA9IF9mcm9tRGVyKGJ5dGVzLCByZW1haW5pbmcsIGRlcHRoICsgMSwgc3ViT3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VkID0gc3RhcnQgLSBieXRlcy5sZW5ndGgoKTtcbiAgICAgICAgcmVtYWluaW5nIC09IHVzZWQ7XG4gICAgICAgIGlmKHR5cGUgPT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgICAgIHVzZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBkYXRhIGFsbCBkZWNvZGVkIGFuZCB0aGUgY2xhc3MgaW5kaWNhdGVzIFVOSVZFUlNBTCBvclxuICAgICAgICAvLyBDT05URVhUX1NQRUNJRklDIHRoZW4gYXNzdW1lIHdlJ3ZlIGdvdCBhbiBlbmNhcHN1bGF0ZWQgQVNOLjEgb2JqZWN0XG4gICAgICAgIHZhciB0YyA9IGNvbXBvc2VkLnRhZ0NsYXNzO1xuICAgICAgICBpZih1c2VkID09PSBsZW5ndGggJiZcbiAgICAgICAgICAodGMgPT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8IHRjID09PSBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbY29tcG9zZWRdO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJlc3RvcmUgcmVhZCBwb3NpdGlvblxuICAgICAgYnl0ZXMucmVhZCA9IHNhdmVkUmVhZDtcbiAgICAgIHJlbWFpbmluZyA9IHNhdmVkUmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIGlmKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBhc24xIG5vdCBjb25zdHJ1Y3RlZCBvciBjb21wb3NlZCwgZ2V0IHJhdyB2YWx1ZVxuICAgIC8vIFRPRE86IGRvIERFUiB0byBPSUQgY29udmVyc2lvbiBhbmQgdmljZS12ZXJzYSBpbiAudG9EZXI/XG5cbiAgICBpZihsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24tY29uc3RydWN0ZWQgQVNOLjEgb2JqZWN0IG9mIGluZGVmaW5pdGUgbGVuZ3RoLicpO1xuICAgICAgfVxuICAgICAgLy8gYmUgbGVuaWVudCBhbmQgdXNlIHJlbWFpbmluZyBzdGF0ZSBieXRlc1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cblxuICAgIGlmKHR5cGUgPT09IGFzbjEuVHlwZS5CTVBTVFJJTkcpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgICBmb3IoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMikge1xuICAgICAgICBfY2hlY2tCdWZmZXJMZW5ndGgoYnl0ZXMsIHJlbWFpbmluZywgMik7XG4gICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXMuZ2V0SW50MTYoKSk7XG4gICAgICAgIHJlbWFpbmluZyAtPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGJ5dGVzLmdldEJ5dGVzKGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlXG4gIHZhciBhc24xT3B0aW9ucyA9IGJpdFN0cmluZ0NvbnRlbnRzID09PSB1bmRlZmluZWQgPyBudWxsIDoge1xuICAgIGJpdFN0cmluZ0NvbnRlbnRzOiBiaXRTdHJpbmdDb250ZW50c1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFzbjEgb2JqZWN0XG4gIHJldHVybiBhc24xLmNyZWF0ZSh0YWdDbGFzcywgdHlwZSwgY29uc3RydWN0ZWQsIHZhbHVlLCBhc24xT3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGFzbjEgb2JqZWN0IHRvIGEgYnVmZmVyIG9mIGJ5dGVzIGluIERFUiBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGFzbjEgdGhlIGFzbjEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKlxuICogQHJldHVybiB0aGUgYnVmZmVyIG9mIGJ5dGVzLlxuICovXG5hc24xLnRvRGVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gYnVpbGQgdGhlIGZpcnN0IGJ5dGVcbiAgdmFyIGIxID0gb2JqLnRhZ0NsYXNzIHwgb2JqLnR5cGU7XG5cbiAgLy8gZm9yIHN0b3JpbmcgdGhlIEFTTi4xIHZhbHVlXG4gIHZhciB2YWx1ZSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlIEJJVCBTVFJJTkcgY29udGVudHMgaWYgYXZhaWxhYmxlIGFuZCBkYXRhIG5vdCBjaGFuZ2VkXG4gIHZhciB1c2VCaXRTdHJpbmdDb250ZW50cyA9IGZhbHNlO1xuICBpZignYml0U3RyaW5nQ29udGVudHMnIGluIG9iaikge1xuICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gdHJ1ZTtcbiAgICBpZihvYmoub3JpZ2luYWwpIHtcbiAgICAgIHVzZUJpdFN0cmluZ0NvbnRlbnRzID0gYXNuMS5lcXVhbHMob2JqLCBvYmoub3JpZ2luYWwpO1xuICAgIH1cbiAgfVxuXG4gIGlmKHVzZUJpdFN0cmluZ0NvbnRlbnRzKSB7XG4gICAgdmFsdWUucHV0Qnl0ZXMob2JqLmJpdFN0cmluZ0NvbnRlbnRzKTtcbiAgfSBlbHNlIGlmKG9iai5jb21wb3NlZCkge1xuICAgIC8vIGlmIGNvbXBvc2VkLCB1c2UgZWFjaCBjaGlsZCBhc24xIG9iamVjdCdzIERFUiBieXRlcyBhcyB2YWx1ZVxuICAgIC8vIHR1cm4gb24gNnRoIGJpdCAoMHgyMCA9IDMyKSB0byBpbmRpY2F0ZSBhc24xIGlzIGNvbnN0cnVjdGVkXG4gICAgLy8gZnJvbSBvdGhlciBhc24xIG9iamVjdHNcbiAgICBpZihvYmouY29uc3RydWN0ZWQpIHtcbiAgICAgIGIxIHw9IDB4MjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHR5cGUgaXMgYSBiaXQgc3RyaW5nLCBhZGQgdW51c2VkIGJpdHMgb2YgMHgwMFxuICAgICAgdmFsdWUucHV0Qnl0ZSgweDAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGlsZCBERVIgYnl0ZXMgdG9nZXRoZXJcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZihvYmoudmFsdWVbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZS5wdXRCdWZmZXIoYXNuMS50b0RlcihvYmoudmFsdWVbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGFzbjEudmFsdWUgZGlyZWN0bHlcbiAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJNUFNUUklORykge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZS5wdXRJbnQxNihvYmoudmFsdWUuY2hhckNvZGVBdChpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSBpbnRlZ2VyIGlzIG1pbmltYWxseS1lbmNvZGVkXG4gICAgICAvLyBUT0RPOiBzaG91bGQgYWxsIGxlYWRpbmcgYnl0ZXMgYmUgc3RyaXBwZWQgdnMganVzdCBvbmU/XG4gICAgICAvLyAuLiBleCAnMDAgMDAgMDEnID0+ICcwMSc/XG4gICAgICBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLklOVEVHRVIgJiZcbiAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgICAgICgob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDAgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDApIHx8XG4gICAgICAgIC8vIGxlYWRpbmcgMHhGRiBmb3IgbmVnYXRpdmUgaW50ZWdlclxuICAgICAgICAob2JqLnZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IDB4RkYgJiZcbiAgICAgICAgKG9iai52YWx1ZS5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgICAgICB2YWx1ZS5wdXRCeXRlcyhvYmoudmFsdWUuc3Vic3RyKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlLnB1dEJ5dGVzKG9iai52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIHRhZyBieXRlXG4gIGJ5dGVzLnB1dEJ5dGUoYjEpO1xuXG4gIC8vIHVzZSBcInNob3J0IGZvcm1cIiBlbmNvZGluZ1xuICBpZih2YWx1ZS5sZW5ndGgoKSA8PSAxMjcpIHtcbiAgICAvLyBvbmUgYnl0ZSBkZXNjcmliZXMgdGhlIGxlbmd0aFxuICAgIC8vIGJpdCA4ID0gMCBhbmQgYml0cyA3LTEgPSBsZW5ndGhcbiAgICBieXRlcy5wdXRCeXRlKHZhbHVlLmxlbmd0aCgpICYgMHg3Rik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIFwibG9uZyBmb3JtXCIgZW5jb2RpbmdcbiAgICAvLyAyIHRvIDEyNyBieXRlcyBkZXNjcmliZSB0aGUgbGVuZ3RoXG4gICAgLy8gZmlyc3QgYnl0ZTogYml0IDggPSAxIGFuZCBiaXRzIDctMSA9ICMgb2YgYWRkaXRpb25hbCBieXRlc1xuICAgIC8vIG90aGVyIGJ5dGVzOiBsZW5ndGggaW4gYmFzZSAyNTYsIGJpZy1lbmRpYW5cbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoKCk7XG4gICAgdmFyIGxlbkJ5dGVzID0gJyc7XG4gICAgZG8ge1xuICAgICAgbGVuQnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4gJiAweEZGKTtcbiAgICAgIGxlbiA9IGxlbiA+Pj4gODtcbiAgICB9IHdoaWxlKGxlbiA+IDApO1xuXG4gICAgLy8gc2V0IGZpcnN0IGJ5dGUgdG8gIyBieXRlcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggYW5kIHR1cm4gb25cbiAgICAvLyBiaXQgOCB0byBpbmRpY2F0ZSBsb25nLWZvcm0gbGVuZ3RoIGlzIHVzZWRcbiAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmxlbmd0aCB8IDB4ODApO1xuXG4gICAgLy8gY29uY2F0ZW5hdGUgbGVuZ3RoIGJ5dGVzIGluIHJldmVyc2Ugc2luY2UgdGhleSB3ZXJlIGdlbmVyYXRlZFxuICAgIC8vIGxpdHRsZSBlbmRpYW4gYW5kIHdlIG5lZWQgYmlnIGVuZGlhblxuICAgIGZvcih2YXIgaSA9IGxlbkJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBieXRlcy5wdXRCeXRlKGxlbkJ5dGVzLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbmNhdGVuYXRlIHZhbHVlIGJ5dGVzXG4gIGJ5dGVzLnB1dEJ1ZmZlcih2YWx1ZSk7XG4gIHJldHVybiBieXRlcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nIHRvIGEgYnl0ZSBidWZmZXIuIFRoZSBieXRlIGJ1ZmZlclxuICogY29udGFpbnMgb25seSB0aGUgREVSLWVuY29kZWQgdmFsdWUsIG5vdCBhbnkgdGFnIG9yIGxlbmd0aCBieXRlcy5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgZG90LXNlcGFyYXRlZCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZSBidWZmZXIuXG4gKi9cbmFzbjEub2lkVG9EZXIgPSBmdW5jdGlvbihvaWQpIHtcbiAgLy8gc3BsaXQgT0lEIGludG8gaW5kaXZpZHVhbCB2YWx1ZXNcbiAgdmFyIHZhbHVlcyA9IG9pZC5zcGxpdCgnLicpO1xuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gIC8vIGZpcnN0IGJ5dGUgaXMgNDAgKiB2YWx1ZTEgKyB2YWx1ZTJcbiAgYnl0ZXMucHV0Qnl0ZSg0MCAqIHBhcnNlSW50KHZhbHVlc1swXSwgMTApICsgcGFyc2VJbnQodmFsdWVzWzFdLCAxMCkpO1xuICAvLyBvdGhlciBieXRlcyBhcmUgZWFjaCB2YWx1ZSBpbiBiYXNlIDEyOCB3aXRoIDh0aCBiaXQgc2V0IGV4Y2VwdCBmb3JcbiAgLy8gdGhlIGxhc3QgYnl0ZSBmb3IgZWFjaCB2YWx1ZVxuICB2YXIgbGFzdCwgdmFsdWVCeXRlcywgdmFsdWUsIGI7XG4gIGZvcih2YXIgaSA9IDI7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBwcm9kdWNlIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGhvdyBtYW55XG4gICAgLy8gYnl0ZXMgaXQgd2lsbCB0YWtlIHRvIHN0b3JlIHRoZSB2YWx1ZVxuICAgIGxhc3QgPSB0cnVlO1xuICAgIHZhbHVlQnl0ZXMgPSBbXTtcbiAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlc1tpXSwgMTApO1xuICAgIGRvIHtcbiAgICAgIGIgPSB2YWx1ZSAmIDB4N0Y7XG4gICAgICB2YWx1ZSA9IHZhbHVlID4+PiA3O1xuICAgICAgLy8gaWYgdmFsdWUgaXMgbm90IGxhc3QsIHRoZW4gdHVybiBvbiA4dGggYml0XG4gICAgICBpZighbGFzdCkge1xuICAgICAgICBiIHw9IDB4ODA7XG4gICAgICB9XG4gICAgICB2YWx1ZUJ5dGVzLnB1c2goYik7XG4gICAgICBsYXN0ID0gZmFsc2U7XG4gICAgfSB3aGlsZSh2YWx1ZSA+IDApO1xuXG4gICAgLy8gYWRkIHZhbHVlIGJ5dGVzIGluIHJldmVyc2UgKG5lZWRzIHRvIGJlIGluIGJpZyBlbmRpYW4pXG4gICAgZm9yKHZhciBuID0gdmFsdWVCeXRlcy5sZW5ndGggLSAxOyBuID49IDA7IC0tbikge1xuICAgICAgYnl0ZXMucHV0Qnl0ZSh2YWx1ZUJ5dGVzW25dKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgYnl0ZSBidWZmZXIgdG8gYW4gT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLiBUaGVcbiAqIGJ5dGUgYnVmZmVyIHNob3VsZCBjb250YWluIG9ubHkgdGhlIERFUi1lbmNvZGVkIHZhbHVlLCBub3QgYW55IHRhZyBvclxuICogbGVuZ3RoIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgT0lEIGRvdC1zZXBhcmF0ZWQgc3RyaW5nLlxuICovXG5hc24xLmRlclRvT2lkID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgdmFyIG9pZDtcblxuICAvLyB3cmFwIGluIGJ1ZmZlciBpZiBuZWVkZWRcbiAgaWYodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYnl0ZXMpO1xuICB9XG5cbiAgLy8gZmlyc3QgYnl0ZSBpcyA0MCAqIHZhbHVlMSArIHZhbHVlMlxuICB2YXIgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgb2lkID0gTWF0aC5mbG9vcihiIC8gNDApICsgJy4nICsgKGIgJSA0MCk7XG5cbiAgLy8gb3RoZXIgYnl0ZXMgYXJlIGVhY2ggdmFsdWUgaW4gYmFzZSAxMjggd2l0aCA4dGggYml0IHNldCBleGNlcHQgZm9yXG4gIC8vIHRoZSBsYXN0IGJ5dGUgZm9yIGVhY2ggdmFsdWVcbiAgdmFyIHZhbHVlID0gMDtcbiAgd2hpbGUoYnl0ZXMubGVuZ3RoKCkgPiAwKSB7XG4gICAgYiA9IGJ5dGVzLmdldEJ5dGUoKTtcbiAgICB2YWx1ZSA9IHZhbHVlIDw8IDc7XG4gICAgLy8gbm90IHRoZSBsYXN0IGJ5dGUgZm9yIHRoZSB2YWx1ZVxuICAgIGlmKGIgJiAweDgwKSB7XG4gICAgICB2YWx1ZSArPSBiICYgMHg3RjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGFzdCBieXRlXG4gICAgICBvaWQgKz0gJy4nICsgKHZhbHVlICsgYik7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9pZDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVVENUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBOb3RlOiBHZW5lcmFsaXplZFRpbWUgaGFzIDQgZGlnaXRzIGZvciB0aGUgeWVhciBhbmQgaXMgdXNlZCBmb3IgWC41MDlcbiAqIGRhdGVzIHBhc3QgMjA0OS4gUGFyc2luZyB0aGF0IHN0cnVjdHVyZSBoYXNuJ3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIHV0YyB0aGUgVVRDVGltZSB2YWx1ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUuXG4gKi9cbmFzbjEudXRjVGltZVRvRGF0ZSA9IGZ1bmN0aW9uKHV0Yykge1xuICAvKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgY2FuIGJlIHVzZWQ6XG5cbiAgICBZWU1NRERoaG1tWlxuICAgIFlZTU1ERGhobW0raGgnbW0nXG4gICAgWVlNTUREaGhtbS1oaCdtbSdcbiAgICBZWU1NRERoaG1tc3NaXG4gICAgWVlNTUREaGhtbXNzK2hoJ21tJ1xuICAgIFlZTU1ERGhobW1zcy1oaCdtbSdcblxuICAgIFdoZXJlOlxuXG4gICAgWVkgaXMgdGhlIGxlYXN0IHNpZ25pZmljYW50IHR3byBkaWdpdHMgb2YgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgWiBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIEdNVCwgKyBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzXG4gICAgbGF0ZXIgdGhhbiBHTVQsIGFuZCAtIGluZGljYXRlcyB0aGF0IGxvY2FsIHRpbWUgaXMgZWFybGllciB0aGFuIEdNVFxuICAgIGhoJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBob3Vyc1xuICAgIG1tJyBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIG9mZnNldCBmcm9tIEdNVCBpbiBtaW51dGVzICovXG4gIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICAvLyBpZiBZWSA+PSA1MCB1c2UgMTl4eCwgaWYgWVkgPCA1MCB1c2UgMjB4eFxuICB2YXIgeWVhciA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMCwgMiksIDEwKTtcbiAgeWVhciA9ICh5ZWFyID49IDUwKSA/IDE5MDAgKyB5ZWFyIDogMjAwMCArIHllYXI7XG4gIHZhciBNTSA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoMiwgMiksIDEwKSAtIDE7IC8vIHVzZSAwLTExIGZvciBtb250aFxuICB2YXIgREQgPSBwYXJzZUludCh1dGMuc3Vic3RyKDQsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KHV0Yy5zdWJzdHIoNiwgMiksIDEwKTtcbiAgdmFyIG1tID0gcGFyc2VJbnQodXRjLnN1YnN0cig4LCAyKSwgMTApO1xuICB2YXIgc3MgPSAwO1xuXG4gIC8vIG5vdCBqdXN0IFlZTU1ERGhobW1aXG4gIGlmKHV0Yy5sZW5ndGggPiAxMSkge1xuICAgIC8vIGdldCBjaGFyYWN0ZXIgYWZ0ZXIgbWludXRlc1xuICAgIHZhciBjID0gdXRjLmNoYXJBdCgxMCk7XG4gICAgdmFyIGVuZCA9IDEwO1xuXG4gICAgLy8gc2VlIGlmIHNlY29uZHMgYXJlIHByZXNlbnRcbiAgICBpZihjICE9PSAnKycgJiYgYyAhPT0gJy0nKSB7XG4gICAgICAvLyBnZXQgc2Vjb25kc1xuICAgICAgc3MgPSBwYXJzZUludCh1dGMuc3Vic3RyKDEwLCAyKSwgMTApO1xuICAgICAgZW5kICs9IDI7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIGRhdGVcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBNTSwgREQpO1xuICBkYXRlLnNldFVUQ0hvdXJzKGhoLCBtbSwgc3MsIDApO1xuXG4gIGlmKGVuZCkge1xuICAgIC8vIGdldCArLy0gYWZ0ZXIgZW5kIG9mIHRpbWVcbiAgICBjID0gdXRjLmNoYXJBdChlbmQpO1xuICAgIGlmKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcbiAgICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgICAgdmFyIGhob2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyAxLCAyKSwgMTApO1xuICAgICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQodXRjLnN1YnN0cihlbmQgKyA0LCAyKSwgMTApO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAgdmFyIG9mZnNldCA9IGhob2Zmc2V0ICogNjAgKyBtbW9mZnNldDtcbiAgICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgICAgLy8gYXBwbHkgb2Zmc2V0XG4gICAgICBpZihjID09PSAnKycpIHtcbiAgICAgICAgZGF0ZS5zZXRUaW1lKCtkYXRlIC0gb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZ2VudGltZSB0aGUgR2VuZXJhbGl6ZWRUaW1lIHZhbHVlIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZGF0ZS5cbiAqL1xuYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUgPSBmdW5jdGlvbihnZW50aW1lKSB7XG4gIC8qIFRoZSBmb2xsb3dpbmcgZm9ybWF0cyBjYW4gYmUgdXNlZDpcblxuICAgIFlZWVlNTURESEhNTVNTXG4gICAgWVlZWU1NRERISE1NU1MuZmZmXG4gICAgWVlZWU1NRERISE1NU1NaXG4gICAgWVlZWU1NRERISE1NU1MuZmZmWlxuICAgIFlZWVlNTURESEhNTVNTK2hoJ21tJ1xuICAgIFlZWVlNTURESEhNTVNTLmZmZitoaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy1oaCdtbSdcbiAgICBZWVlZTU1EREhITU1TUy5mZmYtaGgnbW0nXG5cbiAgICBXaGVyZTpcblxuICAgIFlZWVkgaXMgdGhlIHllYXJcbiAgICBNTSBpcyB0aGUgbW9udGggKDAxIHRvIDEyKVxuICAgIEREIGlzIHRoZSBkYXkgKDAxIHRvIDMxKVxuICAgIGhoIGlzIHRoZSBob3VyICgwMCB0byAyMylcbiAgICBtbSBhcmUgdGhlIG1pbnV0ZXMgKDAwIHRvIDU5KVxuICAgIHNzIGFyZSB0aGUgc2Vjb25kcyAoMDAgdG8gNTkpXG4gICAgLmZmZiBpcyB0aGUgc2Vjb25kIGZyYWN0aW9uLCBhY2N1cmF0ZSB0byB0aHJlZSBkZWNpbWFsIHBsYWNlc1xuICAgIFogaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpcyBHTVQsICsgaW5kaWNhdGVzIHRoYXQgbG9jYWwgdGltZSBpc1xuICAgIGxhdGVyIHRoYW4gR01ULCBhbmQgLSBpbmRpY2F0ZXMgdGhhdCBsb2NhbCB0aW1lIGlzIGVhcmxpZXIgdGhhbiBHTVRcbiAgICBoaCcgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gaG91cnNcbiAgICBtbScgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBvZmZzZXQgZnJvbSBHTVQgaW4gbWludXRlcyAqL1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgdmFyIFlZWVkgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigwLCA0KSwgMTApO1xuICB2YXIgTU0gPSBwYXJzZUludChnZW50aW1lLnN1YnN0cig0LCAyKSwgMTApIC0gMTsgLy8gdXNlIDAtMTEgZm9yIG1vbnRoXG4gIHZhciBERCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDYsIDIpLCAxMCk7XG4gIHZhciBoaCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDgsIDIpLCAxMCk7XG4gIHZhciBtbSA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKDEwLCAyKSwgMTApO1xuICB2YXIgc3MgPSBwYXJzZUludChnZW50aW1lLnN1YnN0cigxMiwgMiksIDEwKTtcbiAgdmFyIGZmZiA9IDA7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgaXNVVEMgPSBmYWxzZTtcblxuICBpZihnZW50aW1lLmNoYXJBdChnZW50aW1lLmxlbmd0aCAtIDEpID09PSAnWicpIHtcbiAgICBpc1VUQyA9IHRydWU7XG4gIH1cblxuICB2YXIgZW5kID0gZ2VudGltZS5sZW5ndGggLSA1LCBjID0gZ2VudGltZS5jaGFyQXQoZW5kKTtcbiAgaWYoYyA9PT0gJysnIHx8IGMgPT09ICctJykge1xuICAgIC8vIGdldCBob3VycyttaW51dGVzIG9mZnNldFxuICAgIHZhciBoaG9mZnNldCA9IHBhcnNlSW50KGdlbnRpbWUuc3Vic3RyKGVuZCArIDEsIDIpLCAxMCk7XG4gICAgdmFyIG1tb2Zmc2V0ID0gcGFyc2VJbnQoZ2VudGltZS5zdWJzdHIoZW5kICsgNCwgMiksIDEwKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgb2Zmc2V0ID0gaGhvZmZzZXQgKiA2MCArIG1tb2Zmc2V0O1xuICAgIG9mZnNldCAqPSA2MDAwMDtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGlmKGMgPT09ICcrJykge1xuICAgICAgb2Zmc2V0ICo9IC0xO1xuICAgIH1cblxuICAgIGlzVVRDID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBzZWNvbmQgZnJhY3Rpb25cbiAgaWYoZ2VudGltZS5jaGFyQXQoMTQpID09PSAnLicpIHtcbiAgICBmZmYgPSBwYXJzZUZsb2F0KGdlbnRpbWUuc3Vic3RyKDE0KSwgMTApICogMTAwMDtcbiAgfVxuXG4gIGlmKGlzVVRDKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoaGgsIG1tLCBzcywgZmZmKTtcblxuICAgIC8vIGFwcGx5IG9mZnNldFxuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihZWVlZLCBNTSwgREQpO1xuICAgIGRhdGUuc2V0SG91cnMoaGgsIG1tLCBzcywgZmZmKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gYSBVVENUaW1lIHZhbHVlLlxuICpcbiAqIE5vdGU6IEdlbmVyYWxpemVkVGltZSBoYXMgNCBkaWdpdHMgZm9yIHRoZSB5ZWFyIGFuZCBpcyB1c2VkIGZvciBYLjUwOVxuICogZGF0ZXMgcGFzdCAyMDQ5LiBDb252ZXJ0aW5nIHRvIGEgR2VuZXJhbGl6ZWRUaW1lIGhhc24ndCBiZWVuXG4gKiBpbXBsZW1lbnRlZCB5ZXQuXG4gKlxuICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVVENUaW1lIHZhbHVlLlxuICovXG5hc24xLmRhdGVUb1V0Y1RpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZTU1ERGhobW1zc1pcbiAgdmFyIGZvcm1hdCA9IFtdO1xuICBmb3JtYXQucHVzaCgoJycgKyBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpLnN1YnN0cigyKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0RhdGUoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENIb3VycygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ01pbnV0ZXMoKSk7XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENTZWNvbmRzKCkpO1xuXG4gIC8vIGVuc3VyZSAyIGRpZ2l0cyBhcmUgdXNlZCBmb3IgZWFjaCBmb3JtYXQgZW50cnlcbiAgZm9yKHZhciBpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7ICsraSkge1xuICAgIGlmKGZvcm1hdFtpXS5sZW5ndGggPCAyKSB7XG4gICAgICBydmFsICs9ICcwJztcbiAgICB9XG4gICAgcnZhbCArPSBmb3JtYXRbaV07XG4gIH1cbiAgcnZhbCArPSAnWic7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGF0ZSB0byBhIEdlbmVyYWxpemVkVGltZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIEdlbmVyYWxpemVkVGltZSB2YWx1ZSBhcyBhIHN0cmluZy5cbiAqL1xuYXNuMS5kYXRlVG9HZW5lcmFsaXplZFRpbWUgPSBmdW5jdGlvbihkYXRlKSB7XG4gIC8vIFRPRE86IHZhbGlkYXRlOyBjdXJyZW50bHkgYXNzdW1lcyBwcm9wZXIgZm9ybWF0XG4gIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgdmFyIHJ2YWwgPSAnJztcblxuICAvLyBjcmVhdGUgZm9ybWF0IFlZWVlNTURESEhNTVNTWlxuICB2YXIgZm9ybWF0ID0gW107XG4gIGZvcm1hdC5wdXNoKCcnICsgZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgZm9ybWF0LnB1c2goJycgKyAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ0hvdXJzKCkpO1xuICBmb3JtYXQucHVzaCgnJyArIGRhdGUuZ2V0VVRDTWludXRlcygpKTtcbiAgZm9ybWF0LnB1c2goJycgKyBkYXRlLmdldFVUQ1NlY29uZHMoKSk7XG5cbiAgLy8gZW5zdXJlIDIgZGlnaXRzIGFyZSB1c2VkIGZvciBlYWNoIGZvcm1hdCBlbnRyeVxuICBmb3IodmFyIGkgPSAwOyBpIDwgZm9ybWF0Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYoZm9ybWF0W2ldLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGZvcm1hdFtpXTtcbiAgfVxuICBydmFsICs9ICdaJztcblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBqYXZhc2NyaXB0IGludGVnZXIgdG8gYSBERVItZW5jb2RlZCBieXRlIGJ1ZmZlciB0byBiZSB1c2VkXG4gKiBhcyB0aGUgdmFsdWUgZm9yIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlIGJ1ZmZlci5cbiAqL1xuYXNuMS5pbnRlZ2VyVG9EZXIgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgaWYoeCA+PSAtMHg4MCAmJiB4IDwgMHg4MCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCA4KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAgJiYgeCA8IDB4ODAwMCkge1xuICAgIHJldHVybiBydmFsLnB1dFNpZ25lZEludCh4LCAxNik7XG4gIH1cbiAgaWYoeCA+PSAtMHg4MDAwMDAgJiYgeCA8IDB4ODAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDI0KTtcbiAgfVxuICBpZih4ID49IC0weDgwMDAwMDAwICYmIHggPCAweDgwMDAwMDAwKSB7XG4gICAgcmV0dXJuIHJ2YWwucHV0U2lnbmVkSW50KHgsIDMyKTtcbiAgfVxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgZXJyb3IuaW50ZWdlciA9IHg7XG4gIHRocm93IGVycm9yO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIGJ5dGUgYnVmZmVyIHRvIGEgamF2YXNjcmlwdCBpbnRlZ2VyLiBUaGlzIGlzXG4gKiB0eXBpY2FsbHkgdXNlZCB0byBkZWNvZGUgdGhlIHZhbHVlIG9mIGFuIElOVEVHRVIgdHlwZS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbmFzbjEuZGVyVG9JbnRlZ2VyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgLy8gd3JhcCBpbiBidWZmZXIgaWYgbmVlZGVkXG4gIGlmKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBuID0gYnl0ZXMubGVuZ3RoKCkgKiA4O1xuICBpZihuID4gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgdG9vIGxhcmdlOyBtYXggaXMgMzItYml0cy4nKTtcbiAgfVxuICByZXR1cm4gYnl0ZXMuZ2V0U2lnbmVkSW50KG4pO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgZ2l2ZW4gQVNOLjEgb2JqZWN0IGlzIGF0IGxlYXN0IGEgc3VwZXIgc2V0IG9mIHRoZVxuICogZ2l2ZW4gQVNOLjEgc3RydWN0dXJlLiBPbmx5IHRhZyBjbGFzc2VzIGFuZCB0eXBlcyBhcmUgY2hlY2tlZC4gQW5cbiAqIG9wdGlvbmFsIG1hcCBtYXkgYWxzbyBiZSBwcm92aWRlZCB0byBjYXB0dXJlIEFTTi4xIHZhbHVlcyB3aGlsZSB0aGVcbiAqIHN0cnVjdHVyZSBpcyBjaGVja2VkLlxuICpcbiAqIFRvIGNhcHR1cmUgYW4gQVNOLjEgdmFsdWUsIHNldCBhbiBvYmplY3QgaW4gdGhlIHZhbGlkYXRvcidzICdjYXB0dXJlJ1xuICogcGFyYW1ldGVyIHRvIHRoZSBrZXkgdG8gdXNlIGluIHRoZSBjYXB0dXJlIG1hcC4gVG8gY2FwdHVyZSB0aGUgZnVsbFxuICogQVNOLjEgb2JqZWN0LCBzcGVjaWZ5ICdjYXB0dXJlQXNuMScuIFRvIGNhcHR1cmUgQklUIFNUUklORyBieXRlcywgaW5jbHVkaW5nXG4gKiB0aGUgbGVhZGluZyB1bnVzZWQgYml0cyBjb3VudGVyIGJ5dGUsIHNwZWNpZnkgJ2NhcHR1cmVCaXRTdHJpbmdDb250ZW50cycuXG4gKiBUbyBjYXB0dXJlIEJJVCBTVFJJTkcgYnl0ZXMsIHdpdGhvdXQgdGhlIGxlYWRpbmcgdW51c2VkIGJpdHMgY291bnRlciBieXRlLFxuICogc3BlY2lmeSAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlJy5cbiAqXG4gKiBPYmplY3RzIGluIHRoZSB2YWxpZGF0b3IgbWF5IHNldCBhIGZpZWxkICdvcHRpb25hbCcgdG8gdHJ1ZSB0byBpbmRpY2F0ZVxuICogdGhhdCBpdCBpc24ndCBuZWNlc3NhcnkgdG8gcGFzcyB2YWxpZGF0aW9uLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIEFTTi4xIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSB2IHRoZSBBU04uMSBzdHJ1Y3R1cmUgdmFsaWRhdG9yLlxuICogQHBhcmFtIGNhcHR1cmUgYW4gb3B0aW9uYWwgbWFwIHRvIGNhcHR1cmUgdmFsdWVzIGluLlxuICogQHBhcmFtIGVycm9ycyBhbiBvcHRpb25hbCBhcnJheSBmb3Igc3RvcmluZyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqXG4gKiBAcmV0dXJuIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZS5cbiAqL1xuYXNuMS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgdiwgY2FwdHVyZSwgZXJyb3JzKSB7XG4gIHZhciBydmFsID0gZmFsc2U7XG5cbiAgLy8gZW5zdXJlIHRhZyBjbGFzcyBhbmQgdHlwZSBhcmUgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gIGlmKChvYmoudGFnQ2xhc3MgPT09IHYudGFnQ2xhc3MgfHwgdHlwZW9mKHYudGFnQ2xhc3MpID09PSAndW5kZWZpbmVkJykgJiZcbiAgICAob2JqLnR5cGUgPT09IHYudHlwZSB8fCB0eXBlb2Yodi50eXBlKSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgLy8gZW5zdXJlIGNvbnN0cnVjdGVkIGZsYWcgaXMgdGhlIHNhbWUgaWYgc3BlY2lmaWVkXG4gICAgaWYob2JqLmNvbnN0cnVjdGVkID09PSB2LmNvbnN0cnVjdGVkIHx8XG4gICAgICB0eXBlb2Yodi5jb25zdHJ1Y3RlZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBydmFsID0gdHJ1ZTtcblxuICAgICAgLy8gaGFuZGxlIHN1YiB2YWx1ZXNcbiAgICAgIGlmKHYudmFsdWUgJiYgZm9yZ2UudXRpbC5pc0FycmF5KHYudmFsdWUpKSB7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgcnZhbCAmJiBpIDwgdi52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHJ2YWwgPSB2LnZhbHVlW2ldLm9wdGlvbmFsIHx8IGZhbHNlO1xuICAgICAgICAgIGlmKG9iai52YWx1ZVtqXSkge1xuICAgICAgICAgICAgcnZhbCA9IGFzbjEudmFsaWRhdGUob2JqLnZhbHVlW2pdLCB2LnZhbHVlW2ldLCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICB9IGVsc2UgaWYodi52YWx1ZVtpXS5vcHRpb25hbCkge1xuICAgICAgICAgICAgICBydmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIXJ2YWwgJiYgZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICAgICAgICdUYWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgdHlwZSBcIicgK1xuICAgICAgICAgICAgICB2LnR5cGUgKyAnXCIgZXhwZWN0ZWQgdmFsdWUgbGVuZ3RoIFwiJyArXG4gICAgICAgICAgICAgIHYudmFsdWUubGVuZ3RoICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgICAgICAgb2JqLnZhbHVlLmxlbmd0aCArICdcIicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihydmFsICYmIGNhcHR1cmUpIHtcbiAgICAgICAgaWYodi5jYXB0dXJlKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVdID0gb2JqLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUFzbjEpIHtcbiAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUFzbjFdID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmKHYuY2FwdHVyZUJpdFN0cmluZ0NvbnRlbnRzICYmICdiaXRTdHJpbmdDb250ZW50cycgaW4gb2JqKSB7XG4gICAgICAgICAgY2FwdHVyZVt2LmNhcHR1cmVCaXRTdHJpbmdDb250ZW50c10gPSBvYmouYml0U3RyaW5nQ29udGVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYodi5jYXB0dXJlQml0U3RyaW5nVmFsdWUgJiYgJ2JpdFN0cmluZ0NvbnRlbnRzJyBpbiBvYmopIHtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYob2JqLmJpdFN0cmluZ0NvbnRlbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGNhcHR1cmVbdi5jYXB0dXJlQml0U3RyaW5nVmFsdWVdID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBzdXBwb3J0IHVudXNlZCBiaXRzIHdpdGggZGF0YSBzaGlmdGluZ1xuICAgICAgICAgICAgdmFyIHVudXNlZCA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYodW51c2VkICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnY2FwdHVyZUJpdFN0cmluZ1ZhbHVlIG9ubHkgc3VwcG9ydGVkIGZvciB6ZXJvIHVudXNlZCBiaXRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXB0dXJlW3YuY2FwdHVyZUJpdFN0cmluZ1ZhbHVlXSA9IG9iai5iaXRTdHJpbmdDb250ZW50cy5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCBjb25zdHJ1Y3RlZCBcIicgKyB2LmNvbnN0cnVjdGVkICsgJ1wiLCBnb3QgXCInICtcbiAgICAgICAgb2JqLmNvbnN0cnVjdGVkICsgJ1wiJyk7XG4gICAgfVxuICB9IGVsc2UgaWYoZXJyb3JzKSB7XG4gICAgaWYob2JqLnRhZ0NsYXNzICE9PSB2LnRhZ0NsYXNzKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0YWcgY2xhc3MgXCInICsgdi50YWdDbGFzcyArICdcIiwgZ290IFwiJyArXG4gICAgICAgIG9iai50YWdDbGFzcyArICdcIicpO1xuICAgIH1cbiAgICBpZihvYmoudHlwZSAhPT0gdi50eXBlKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgJ1snICsgdi5uYW1lICsgJ10gJyArXG4gICAgICAgICdFeHBlY3RlZCB0eXBlIFwiJyArIHYudHlwZSArICdcIiwgZ290IFwiJyArIG9iai50eXBlICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLy8gcmVnZXggZm9yIHRlc3RpbmcgZm9yIG5vbi1sYXRpbiBjaGFyYWN0ZXJzXG52YXIgX25vbkxhdGluUmVnZXggPSAvW15cXFxcdTAwMDAtXFxcXHUwMGZmXS87XG5cbi8qKlxuICogUHJldHR5IHByaW50cyBhbiBBU04uMSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgb2JqZWN0IHRvIHdyaXRlIG91dC5cbiAqIEBwYXJhbSBsZXZlbCB0aGUgbGV2ZWwgaW4gdGhlIHRyZWUuXG4gKiBAcGFyYW0gaW5kZW50YXRpb24gdGhlIGluZGVudGF0aW9uIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdHJpbmcuXG4gKi9cbmFzbjEucHJldHR5UHJpbnQgPSBmdW5jdGlvbihvYmosIGxldmVsLCBpbmRlbnRhdGlvbikge1xuICB2YXIgcnZhbCA9ICcnO1xuXG4gIC8vIHNldCBkZWZhdWx0IGxldmVsIGFuZCBpbmRlbnRhdGlvblxuICBsZXZlbCA9IGxldmVsIHx8IDA7XG4gIGluZGVudGF0aW9uID0gaW5kZW50YXRpb24gfHwgMjtcblxuICAvLyBzdGFydCBuZXcgbGluZSBmb3IgZGVlcCBsZXZlbHNcbiAgaWYobGV2ZWwgPiAwKSB7XG4gICAgcnZhbCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbmRlbnRcbiAgdmFyIGluZGVudCA9ICcnO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGV2ZWwgKiBpbmRlbnRhdGlvbjsgKytpKSB7XG4gICAgaW5kZW50ICs9ICcgJztcbiAgfVxuXG4gIC8vIHByaW50IGNsYXNzOnR5cGVcbiAgcnZhbCArPSBpbmRlbnQgKyAnVGFnOiAnO1xuICBzd2l0Y2gob2JqLnRhZ0NsYXNzKSB7XG4gIGNhc2UgYXNuMS5DbGFzcy5VTklWRVJTQUw6XG4gICAgcnZhbCArPSAnVW5pdmVyc2FsOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5BUFBMSUNBVElPTjpcbiAgICBydmFsICs9ICdBcHBsaWNhdGlvbjonO1xuICAgIGJyZWFrO1xuICBjYXNlIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQzpcbiAgICBydmFsICs9ICdDb250ZXh0LVNwZWNpZmljOic7XG4gICAgYnJlYWs7XG4gIGNhc2UgYXNuMS5DbGFzcy5QUklWQVRFOlxuICAgIHJ2YWwgKz0gJ1ByaXZhdGU6JztcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmKG9iai50YWdDbGFzcyA9PT0gYXNuMS5DbGFzcy5VTklWRVJTQUwpIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuXG4gICAgLy8ga25vd24gdHlwZXNcbiAgICBzd2l0Y2gob2JqLnR5cGUpIHtcbiAgICBjYXNlIGFzbjEuVHlwZS5OT05FOlxuICAgICAgcnZhbCArPSAnIChOb25lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CT09MRUFOOlxuICAgICAgcnZhbCArPSAnIChCb29sZWFuKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JTlRFR0VSOlxuICAgICAgcnZhbCArPSAnIChJbnRlZ2VyKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CSVRTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJpdCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9DVEVUU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChPY3RldCBzdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk5VTEw6XG4gICAgICBydmFsICs9ICcgKE51bGwpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9JRDpcbiAgICAgIHJ2YWwgKz0gJyAoT2JqZWN0IElkZW50aWZpZXIpJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXNuMS5UeXBlLk9ERVNDOlxuICAgICAgcnZhbCArPSAnIChPYmplY3QgRGVzY3JpcHRvciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuRVhURVJOQUw6XG4gICAgICBydmFsICs9ICcgKEV4dGVybmFsIG9yIEluc3RhbmNlIG9mKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5SRUFMOlxuICAgICAgcnZhbCArPSAnIChSZWFsKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTlVNRVJBVEVEOlxuICAgICAgcnZhbCArPSAnIChFbnVtZXJhdGVkKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5FTUJFRERFRDpcbiAgICAgIHJ2YWwgKz0gJyAoRW1iZWRkZWQgUERWKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVEY4OlxuICAgICAgcnZhbCArPSAnIChVVEY4KSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5ST0lEOlxuICAgICAgcnZhbCArPSAnIChSZWxhdGl2ZSBPYmplY3QgSWRlbnRpZmllciknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuU0VRVUVOQ0U6XG4gICAgICBydmFsICs9ICcgKFNlcXVlbmNlKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5TRVQ6XG4gICAgICBydmFsICs9ICcgKFNldCknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HOlxuICAgICAgcnZhbCArPSAnIChQcmludGFibGUgU3RyaW5nKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5JQTVTdHJpbmc6XG4gICAgICBydmFsICs9ICcgKElBNVN0cmluZyAoQVNDSUkpKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5VVENUSU1FOlxuICAgICAgcnZhbCArPSAnIChVVEMgdGltZSknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FOlxuICAgICAgcnZhbCArPSAnIChHZW5lcmFsaXplZCB0aW1lKSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFzbjEuVHlwZS5CTVBTVFJJTkc6XG4gICAgICBydmFsICs9ICcgKEJNUCBTdHJpbmcpJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBydmFsICs9IG9iai50eXBlO1xuICB9XG5cbiAgcnZhbCArPSAnXFxuJztcbiAgcnZhbCArPSBpbmRlbnQgKyAnQ29uc3RydWN0ZWQ6ICcgKyBvYmouY29uc3RydWN0ZWQgKyAnXFxuJztcblxuICBpZihvYmouY29tcG9zZWQpIHtcbiAgICB2YXIgc3VidmFsdWVzID0gMDtcbiAgICB2YXIgc3ViID0gJyc7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYob2JqLnZhbHVlW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VidmFsdWVzICs9IDE7XG4gICAgICAgIHN1YiArPSBhc24xLnByZXR0eVByaW50KG9iai52YWx1ZVtpXSwgbGV2ZWwgKyAxLCBpbmRlbnRhdGlvbik7XG4gICAgICAgIGlmKChpICsgMSkgPCBvYmoudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBydmFsICs9IGluZGVudCArICdTdWIgdmFsdWVzOiAnICsgc3VidmFsdWVzICsgc3ViO1xuICB9IGVsc2Uge1xuICAgIHJ2YWwgKz0gaW5kZW50ICsgJ1ZhbHVlOiAnO1xuICAgIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuT0lEKSB7XG4gICAgICB2YXIgb2lkID0gYXNuMS5kZXJUb09pZChvYmoudmFsdWUpO1xuICAgICAgcnZhbCArPSBvaWQ7XG4gICAgICBpZihmb3JnZS5wa2kgJiYgZm9yZ2UucGtpLm9pZHMpIHtcbiAgICAgICAgaWYob2lkIGluIGZvcmdlLnBraS5vaWRzKSB7XG4gICAgICAgICAgcnZhbCArPSAnICgnICsgZm9yZ2UucGtpLm9pZHNbb2lkXSArICcpICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYob2JqLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICB0cnkge1xuICAgICAgICBydmFsICs9IGFzbjEuZGVyVG9JbnRlZ2VyKG9iai52YWx1ZSk7XG4gICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLkJJVFNUUklORykge1xuICAgICAgLy8gVE9ETzogc2hpZnQgYml0cyBhcyBuZWVkZWQgdG8gZGlzcGxheSB3aXRob3V0IHBhZGRpbmdcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSB1bnVzZWQgYml0cyBmaWVsZFxuICAgICAgICBydmFsICs9ICcweCcgKyBmb3JnZS51dGlsLmJ5dGVzVG9IZXgob2JqLnZhbHVlLnNsaWNlKDEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgKz0gJyhub25lKSc7XG4gICAgICB9XG4gICAgICAvLyBzaG93IHVudXNlZCBiaXQgY291bnRcbiAgICAgIGlmKG9iai52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB1bnVzZWQgPSBvYmoudmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYodW51c2VkID09IDEpIHtcbiAgICAgICAgICBydmFsICs9ICcgKDEgdW51c2VkIGJpdCBzaG93biknO1xuICAgICAgICB9IGVsc2UgaWYodW51c2VkID4gMSkge1xuICAgICAgICAgIHJ2YWwgKz0gJyAoJyArIHVudXNlZCArICcgdW51c2VkIGJpdHMgc2hvd24pJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgICBpZighX25vbkxhdGluUmVnZXgudGVzdChvYmoudmFsdWUpKSB7XG4gICAgICAgIHJ2YWwgKz0gJygnICsgb2JqLnZhbHVlICsgJykgJztcbiAgICAgIH1cbiAgICAgIHJ2YWwgKz0gJzB4JyArIGZvcmdlLnV0aWwuYnl0ZXNUb0hleChvYmoudmFsdWUpO1xuICAgIH0gZWxzZSBpZihvYmoudHlwZSA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHJ2YWwgKz0gZm9yZ2UudXRpbC5kZWNvZGVVdGY4KG9iai52YWx1ZSk7XG4gICAgfSBlbHNlIGlmKG9iai50eXBlID09PSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HIHx8XG4gICAgICBvYmoudHlwZSA9PT0gYXNuMS5UeXBlLklBNVN0cmluZykge1xuICAgICAgcnZhbCArPSBvYmoudmFsdWU7XG4gICAgfSBlbHNlIGlmKF9ub25MYXRpblJlZ2V4LnRlc3Qob2JqLnZhbHVlKSkge1xuICAgICAgcnZhbCArPSAnMHgnICsgZm9yZ2UudXRpbC5ieXRlc1RvSGV4KG9iai52YWx1ZSk7XG4gICAgfSBlbHNlIGlmKG9iai52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJ2YWwgKz0gJ1tudWxsXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgKz0gb2JqLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcbiIsIi8qKlxuICogQmFzZS1OL0Jhc2UtWCBlbmNvZGluZy9kZWNvZGluZyBmdW5jdGlvbnMuXG4gKlxuICogT3JpZ2luYWwgaW1wbGVtZW50YXRpb24gZnJvbSBiYXNlLXg6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2Jhc2UteFxuICpcbiAqIFdoaWNoIGlzIE1JVCBsaWNlbnNlZDpcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vLyBiYXNlTiBhbHBoYWJldCBpbmRleGVzXG52YXIgX3JldmVyc2VBbHBoYWJldHMgPSB7fTtcblxuLyoqXG4gKiBCYXNlTi1lbmNvZGVzIGEgVWludDhBcnJheSB1c2luZyB0aGUgZ2l2ZW4gYWxwaGFiZXQuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlTi1lbmNvZGVkIG91dHB1dCBzdHJpbmcuXG4gKi9cbmFwaS5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgYWxwaGFiZXQsIG1heGxpbmUpIHtcbiAgaWYodHlwZW9mIGFscGhhYmV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxwaGFiZXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG4gIGlmKG1heGxpbmUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbWF4bGluZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm1heGxpbmVcIiBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuXG4gIGlmKCEoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIC8vIGFzc3VtZSBmb3JnZSBieXRlIGJ1ZmZlclxuICAgIG91dHB1dCA9IF9lbmNvZGVXaXRoQnl0ZUJ1ZmZlcihpbnB1dCwgYWxwaGFiZXQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gICAgdmFyIGRpZ2l0cyA9IFswXTtcbiAgICBmb3IoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSBpbnB1dFtpXTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSBiYXNlO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUoY2FycnkgPiAwKSB7XG4gICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgYmFzZSk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gYmFzZSkgfCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgZm9yKGkgPSAwOyBpbnB1dFtpXSA9PT0gMCAmJiBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBvdXRwdXQgKz0gZmlyc3Q7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgZm9yKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG91dHB1dCArPSBhbHBoYWJldFtkaWdpdHNbaV1dO1xuICAgIH1cbiAgfVxuXG4gIGlmKG1heGxpbmUpIHtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcuezEsJyArIG1heGxpbmUgKyAnfScsICdnJyk7XG4gICAgb3V0cHV0ID0gb3V0cHV0Lm1hdGNoKHJlZ2V4KS5qb2luKCdcXHJcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiYXNlTi1lbmNvZGVkICh1c2luZyB0aGUgZ2l2ZW4gYWxwaGFiZXQpIHN0cmluZyB0byBhXG4gKiBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZU4tZW5jb2RlZCBpbnB1dCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheS5cbiAqL1xuYXBpLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCBhbHBoYWJldCkge1xuICBpZih0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJpbnB1dFwiIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cbiAgaWYodHlwZW9mIGFscGhhYmV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYWxwaGFiZXRcIiBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHRhYmxlID0gX3JldmVyc2VBbHBoYWJldHNbYWxwaGFiZXRdO1xuICBpZighdGFibGUpIHtcbiAgICAvLyBjb21wdXRlIHJldmVyc2UgYWxwaGFiZXRcbiAgICB0YWJsZSA9IF9yZXZlcnNlQWxwaGFiZXRzW2FscGhhYmV0XSA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgICAgdGFibGVbYWxwaGFiZXQuY2hhckNvZGVBdChpKV0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gIHZhciBiYXNlID0gYWxwaGFiZXQubGVuZ3RoO1xuICB2YXIgZmlyc3QgPSBhbHBoYWJldC5jaGFyQXQoMCk7XG4gIHZhciBieXRlcyA9IFswXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gdGFibGVbaW5wdXQuY2hhckNvZGVBdChpKV07XG4gICAgaWYodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvcih2YXIgaiA9IDAsIGNhcnJ5ID0gdmFsdWU7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiBiYXNlO1xuICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICBjYXJyeSA+Pj0gODtcbiAgICB9XG5cbiAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcbiAgICAgIGNhcnJ5ID4+PSA4O1xuICAgIH1cbiAgfVxuXG4gIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gIGZvcih2YXIgayA9IDA7IGlucHV0W2tdID09PSBmaXJzdCAmJiBrIDwgaW5wdXQubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgYnl0ZXMucHVzaCgwKTtcbiAgfVxuXG4gIGlmKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzLnJldmVyc2UoKSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKTtcbn07XG5cbmZ1bmN0aW9uIF9lbmNvZGVXaXRoQnl0ZUJ1ZmZlcihpbnB1dCwgYWxwaGFiZXQpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgYmFzZSA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgdmFyIGZpcnN0ID0gYWxwaGFiZXQuY2hhckF0KDApO1xuICB2YXIgZGlnaXRzID0gWzBdO1xuICBmb3IoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGgoKTsgKytpKSB7XG4gICAgZm9yKHZhciBqID0gMCwgY2FycnkgPSBpbnB1dC5hdChpKTsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIGJhc2U7XG4gICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICB9XG5cbiAgICB3aGlsZShjYXJyeSA+IDApIHtcbiAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgYmFzZSk7XG4gICAgICBjYXJyeSA9IChjYXJyeSAvIGJhc2UpIHwgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgZm9yKGkgPSAwOyBpbnB1dC5hdChpKSA9PT0gMCAmJiBpIDwgaW5wdXQubGVuZ3RoKCkgLSAxOyArK2kpIHtcbiAgICBvdXRwdXQgKz0gZmlyc3Q7XG4gIH1cbiAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgZm9yKGkgPSBkaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBvdXRwdXQgKz0gYWxwaGFiZXRbZGlnaXRzW2ldXTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4iLCIvKipcbiAqIENpcGhlciBiYXNlIEFQSS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlciA9IGZvcmdlLmNpcGhlciB8fCB7fTtcblxuLy8gcmVnaXN0ZXJlZCBhbGdvcml0aG1zXG5mb3JnZS5jaXBoZXIuYWxnb3JpdGhtcyA9IGZvcmdlLmNpcGhlci5hbGdvcml0aG1zIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjaXBoZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZW5jcnlwdCBkYXRhIHVzaW5nIHRoZSBnaXZlblxuICogYWxnb3JpdGhtIGFuZCBrZXkuIFRoZSBhbGdvcml0aG0gbWF5IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHZhbHVlIGZvciBhXG4gKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWxnb3JpdGhtIG9yIGl0IG1heSBiZSBnaXZlbiBhcyBhIGNpcGhlciBhbGdvcml0aG1cbiAqIEFQSSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSwgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFsZ29yaXRobSBBUElcbiAqICAgICAgICAgIG9iamVjdC5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGFcbiAqICAgICAgICAgIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiBmYWxzZVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlY2lwaGVyIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW5cbiAqIGFsZ29yaXRobSBhbmQga2V5LiBUaGUgYWxnb3JpdGhtIG1heSBiZSBwcm92aWRlZCBhcyBhIHN0cmluZyB2YWx1ZSBmb3IgYVxuICogcHJldmlvdXNseSByZWdpc3RlcmVkIGFsZ29yaXRobSBvciBpdCBtYXkgYmUgZ2l2ZW4gYXMgYSBjaXBoZXIgYWxnb3JpdGhtXG4gKiBBUEkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhbGdvcml0aG0gdGhlIGFsZ29yaXRobSB0byB1c2UsIGVpdGhlciBhIHN0cmluZyBvciBhbiBhbGdvcml0aG0gQVBJXG4gKiAgICAgICAgICBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcyBvciBhXG4gKiAgICAgICAgICBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlciA9IGZ1bmN0aW9uKGFsZ29yaXRobSwga2V5KSB7XG4gIHZhciBhcGkgPSBhbGdvcml0aG07XG4gIGlmKHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnKSB7XG4gICAgYXBpID0gZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobShhcGkpO1xuICAgIGlmKGFwaSkge1xuICAgICAgYXBpID0gYXBpKCk7XG4gICAgfVxuICB9XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICAvLyBhc3N1bWUgYmxvY2sgY2lwaGVyXG4gIHJldHVybiBuZXcgZm9yZ2UuY2lwaGVyLkJsb2NrQ2lwaGVyKHtcbiAgICBhbGdvcml0aG06IGFwaSxcbiAgICBrZXk6IGtleSxcbiAgICBkZWNyeXB0OiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gYWxnb3JpdGhtIGJ5IG5hbWUuIElmIHRoZSBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQsIHRoZVxuICogYWxnb3JpdGhtIEFQSSBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYWxnb3JpdGhtLlxuICogQHBhcmFtIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIEFQSSBvYmplY3QuXG4gKi9cbmZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUsIGFsZ29yaXRobSkge1xuICBuYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXSA9IGFsZ29yaXRobTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHJlZ2lzdGVyZWQgYWxnb3JpdGhtIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhbGdvcml0aG0sIGlmIGZvdW5kLCBudWxsIGlmIG5vdC5cbiAqL1xuZm9yZ2UuY2lwaGVyLmdldEFsZ29yaXRobSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgaWYobmFtZSBpbiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtcykge1xuICAgIHJldHVybiBmb3JnZS5jaXBoZXIuYWxnb3JpdGhtc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBCbG9ja0NpcGhlciA9IGZvcmdlLmNpcGhlci5CbG9ja0NpcGhlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobTtcbiAgdGhpcy5tb2RlID0gdGhpcy5hbGdvcml0aG0ubW9kZTtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLm1vZGUuYmxvY2tTaXplO1xuICB0aGlzLl9maW5pc2ggPSBmYWxzZTtcbiAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB0aGlzLm91dHB1dCA9IG51bGw7XG4gIHRoaXMuX29wID0gb3B0aW9ucy5kZWNyeXB0ID8gdGhpcy5tb2RlLmRlY3J5cHQgOiB0aGlzLm1vZGUuZW5jcnlwdDtcbiAgdGhpcy5fZGVjcnlwdCA9IG9wdGlvbnMuZGVjcnlwdDtcbiAgdGhpcy5hbGdvcml0aG0uaW5pdGlhbGl6ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIG9yIHJlc3RhcnRzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcywgd2hpY2hldmVyXG4gKiB3YXMgcHJldmlvdXNseSBjb25maWd1cmVkLlxuICpcbiAqIEZvciBub24tR0NNIG1vZGUsIHRoZSBJViBtYXkgYmUgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGFuIGFycmF5XG4gKiBvZiBieXRlcywgYSBieXRlIGJ1ZmZlciwgb3IgYW4gYXJyYXkgb2YgMzItYml0IGludGVnZXJzLiBJZiB0aGUgSVYgaXMgaW5cbiAqIGJ5dGVzLCB0aGVuIGl0IG11c3QgYmUgTmIgKDE2KSBieXRlcyBpbiBsZW5ndGguIElmIHRoZSBJViBpcyBnaXZlbiBpbiBhc1xuICogMzItYml0IGludGVnZXJzLCB0aGVuIGl0IG11c3QgYmUgNCBpbnRlZ2VycyBsb25nLlxuICpcbiAqIE5vdGU6IGFuIElWIGlzIG5vdCByZXF1aXJlZCBvciB1c2VkIGluIEVDQiBtb2RlLlxuICpcbiAqIEZvciBHQ00tbW9kZSwgdGhlIElWIG11c3QgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3JcbiAqIGEgYnl0ZSBidWZmZXIuIFRoZSBudW1iZXIgb2YgYnl0ZXMgc2hvdWxkIGJlIDEyICg5NiBiaXRzKSBhcyByZWNvbW1lbmRlZFxuICogYnkgTklTVCBTUC04MDAtMzhEIGJ1dCBhbm90aGVyIGxlbmd0aCBtYXkgYmUgZ2l2ZW4uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2ZcbiAqICAgICAgICAgICAgYnl0ZXMsIG51bGwgdG8gcmV1c2UgdGhlIGxhc3QgY2lwaGVyZWQgYmxvY2sgZnJvbSBhIHByZXZpb3VzXG4gKiAgICAgICAgICAgIHVwZGF0ZSgpICh0aGlzIFwicmVzaWR1ZVwiIG1ldGhvZCBpcyBmb3IgbGVnYWN5IHN1cHBvcnQgb25seSkuXG4gKiAgICAgICAgICBhZGRpdGlvbmFsRGF0YSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIGRhdGEgYXMgYSBiaW5hcnktZW5jb2RlZFxuICogICAgICAgICAgICBzdHJpbmcgb2YgYnl0ZXMsIGZvciAnR0NNJyBtb2RlLCAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICB0YWdMZW5ndGggZGVzaXJlZCBsZW5ndGggb2YgYXV0aGVudGljYXRpb24gdGFnLCBpbiBiaXRzLCBmb3JcbiAqICAgICAgICAgICAgJ0dDTScgbW9kZSAoMC0xMjgsIGRlZmF1bHQ6IDEyOCkuXG4gKiAgICAgICAgICB0YWcgdGhlIGF1dGhlbnRpY2F0aW9uIHRhZyB0byBjaGVjayBpZiBkZWNyeXB0aW5nLCBhcyBhXG4gKiAgICAgICAgICAgICBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiAgICAgICAgICBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBvcHRzID0ge307XG4gIGZvcih2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRzW2tleV0gPSBvcHRpb25zW2tleV07XG4gIH1cbiAgb3B0cy5kZWNyeXB0ID0gdGhpcy5fZGVjcnlwdDtcbiAgdGhpcy5fZmluaXNoID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5vdXRwdXQgPSBvcHRpb25zLm91dHB1dCB8fCBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLm1vZGUuc3RhcnQob3B0cyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIG5leHQgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBjaXBoZXIgbW9kZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gKi9cbkJsb2NrQ2lwaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkge1xuICAgIC8vIGlucHV0IGdpdmVuLCBzbyBlbXB0eSBpdCBpbnRvIHRoZSBpbnB1dCBidWZmZXJcbiAgICB0aGlzLl9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICB9XG5cbiAgLy8gZG8gY2lwaGVyIG9wZXJhdGlvbiB1bnRpbCBpdCBuZWVkcyBtb3JlIGlucHV0IGFuZCBub3QgZmluaXNoZWRcbiAgd2hpbGUoIXRoaXMuX29wLmNhbGwodGhpcy5tb2RlLCB0aGlzLl9pbnB1dCwgdGhpcy5vdXRwdXQsIHRoaXMuX2ZpbmlzaCkgJiZcbiAgICAhdGhpcy5fZmluaXNoKSB7fVxuXG4gIC8vIGZyZWUgY29uc3VtZWQgbWVtb3J5IGZyb20gaW5wdXQgYnVmZmVyXG4gIHRoaXMuX2lucHV0LmNvbXBhY3QoKTtcbn07XG5cbi8qKlxuICogRmluaXNoZXMgZW5jcnlwdGluZyBvciBkZWNyeXB0aW5nLlxuICpcbiAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSBpbiBDQkMgbW9kZSwgbnVsbCBmb3IgZGVmYXVsdCxcbiAqICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGZhbHNlIG9uIGVycm9yLlxuICovXG5CbG9ja0NpcGhlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ocGFkKSB7XG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHcvZGVwcmVjYXRlZCBwYWRkaW5nIEFQSVxuICAvLyBOb3RlOiB3aWxsIG92ZXJ3cml0ZSBwYWRkaW5nIGZ1bmN0aW9ucyBldmVuIGFmdGVyIGFub3RoZXIgc3RhcnQoKSBjYWxsXG4gIGlmKHBhZCAmJiAodGhpcy5tb2RlLm5hbWUgPT09ICdFQ0InIHx8IHRoaXMubW9kZS5uYW1lID09PSAnQ0JDJykpIHtcbiAgICB0aGlzLm1vZGUucGFkID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIGlucHV0LCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLm1vZGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBwYWQodGhpcy5ibG9ja1NpemUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGJ1aWxkIG9wdGlvbnMgZm9yIHBhZGRpbmcgYW5kIGFmdGVyRmluaXNoIGZ1bmN0aW9uc1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuICBvcHRpb25zLmRlY3J5cHQgPSB0aGlzLl9kZWNyeXB0O1xuXG4gIC8vIGdldCAjIG9mIGJ5dGVzIHRoYXQgd29uJ3QgZmlsbCBhIGJsb2NrXG4gIG9wdGlvbnMub3ZlcmZsb3cgPSB0aGlzLl9pbnB1dC5sZW5ndGgoKSAlIHRoaXMuYmxvY2tTaXplO1xuXG4gIGlmKCF0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS5wYWQpIHtcbiAgICBpZighdGhpcy5tb2RlLnBhZCh0aGlzLl9pbnB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBkbyBmaW5hbCB1cGRhdGVcbiAgdGhpcy5fZmluaXNoID0gdHJ1ZTtcbiAgdGhpcy51cGRhdGUoKTtcblxuICBpZih0aGlzLl9kZWNyeXB0ICYmIHRoaXMubW9kZS51bnBhZCkge1xuICAgIGlmKCF0aGlzLm1vZGUudW5wYWQodGhpcy5vdXRwdXQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYodGhpcy5tb2RlLmFmdGVyRmluaXNoKSB7XG4gICAgaWYoIXRoaXMubW9kZS5hZnRlckZpbmlzaCh0aGlzLm91dHB1dCwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKipcbiAqIFN1cHBvcnRlZCBjaXBoZXIgbW9kZXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuZm9yZ2UuY2lwaGVyID0gZm9yZ2UuY2lwaGVyIHx8IHt9O1xuXG4vLyBzdXBwb3J0ZWQgY2lwaGVyIG1vZGVzXG52YXIgbW9kZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmNpcGhlci5tb2RlcyA9IGZvcmdlLmNpcGhlci5tb2RlcyB8fCB7fTtcblxuLyoqIEVsZWN0cm9uaWMgY29kZWJvb2sgKEVDQikgKERvbid0IHVzZSB0aGlzOyBpdCdzIG5vdCBzZWN1cmUpICoqL1xuXG5tb2Rlcy5lY2IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnRUNCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge307XG5cbm1vZGVzLmVjYi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGVuY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2Rlcy5lY2IucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgLy8gdmFsdWUgb2YgdGhlIG51bWJlciBvZiBwYWQgYnl0ZXMpXG4gIHZhciBwYWRkaW5nID0gKGlucHV0Lmxlbmd0aCgpID09PSB0aGlzLmJsb2NrU2l6ZSA/XG4gICAgdGhpcy5ibG9ja1NpemUgOiAodGhpcy5ibG9ja1NpemUgLSBpbnB1dC5sZW5ndGgoKSkpO1xuICBpbnB1dC5maWxsV2l0aEJ5dGUocGFkZGluZywgcGFkZGluZyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxubW9kZXMuZWNiLnByb3RvdHlwZS51bnBhZCA9IGZ1bmN0aW9uKG91dHB1dCwgb3B0aW9ucykge1xuICAvLyBjaGVjayBmb3IgZXJyb3I6IGlucHV0IGRhdGEgbm90IGEgbXVsdGlwbGUgb2YgYmxvY2tTaXplXG4gIGlmKG9wdGlvbnMub3ZlcmZsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZW5zdXJlIHBhZGRpbmcgYnl0ZSBjb3VudCBpcyB2YWxpZFxuICB2YXIgbGVuID0gb3V0cHV0Lmxlbmd0aCgpO1xuICB2YXIgY291bnQgPSBvdXRwdXQuYXQobGVuIC0gMSk7XG4gIGlmKGNvdW50ID4gKHRoaXMuYmxvY2tTaXplIDw8IDIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICBvdXRwdXQudHJ1bmNhdGUoY291bnQpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKiBDaXBoZXItYmxvY2sgQ2hhaW5pbmcgKENCQykgKiovXG5cbm1vZGVzLmNiYyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDQkMnO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9pbnRzKTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8vIE5vdGU6IGxlZ2FjeSBzdXBwb3J0IGZvciB1c2luZyBJViByZXNpZHVlIChoYXMgc2VjdXJpdHkgZmxhd3MpXG4gIC8vIGlmIElWIGlzIG51bGwsIHJldXNlIGJsb2NrIGZyb20gcHJldmlvdXMgcHJvY2Vzc2luZ1xuICBpZihvcHRpb25zLml2ID09PSBudWxsKSB7XG4gICAgLy8gbXVzdCBoYXZlIGEgcHJldmlvdXMgYmxvY2tcbiAgICBpZighdGhpcy5fcHJldikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5faXYgPSB0aGlzLl9wcmV2LnNsaWNlKDApO1xuICB9IGVsc2UgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYXZlIElWIGFzIFwicHJldmlvdXNcIiBibG9ja1xuICAgIHRoaXMuX2l2ID0gdHJhbnNmb3JtSVYob3B0aW9ucy5pdik7XG4gICAgdGhpcy5fcHJldiA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB9XG59O1xuXG5tb2Rlcy5jYmMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgLy8gQ0JDIFhPUidzIElWIChvciBwcmV2aW91cyBibG9jaykgd2l0aCBwbGFpbnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wcmV2W2ldIF4gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0LCBzYXZlIHByZXZpb3VzIGJsb2NrXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9vdXRCbG9jaztcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBkZWNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmRlY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dCwgc2F2ZSBwcmV2aW91cyBjaXBoZXJlZCBibG9ja1xuICAvLyBDQkMgWE9SJ3MgSVYgKG9yIHByZXZpb3VzIGJsb2NrKSB3aXRoIGNpcGhlcnRleHRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9wcmV2W2ldIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG4gIHRoaXMuX3ByZXYgPSB0aGlzLl9pbkJsb2NrLnNsaWNlKDApO1xufTtcblxubW9kZXMuY2JjLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICAvLyBhZGQgUEtDUyM3IHBhZGRpbmcgdG8gYmxvY2sgKGVhY2ggcGFkIGJ5dGUgaXMgdGhlXG4gIC8vIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcGFkIGJ5dGVzKVxuICB2YXIgcGFkZGluZyA9IChpbnB1dC5sZW5ndGgoKSA9PT0gdGhpcy5ibG9ja1NpemUgP1xuICAgIHRoaXMuYmxvY2tTaXplIDogKHRoaXMuYmxvY2tTaXplIC0gaW5wdXQubGVuZ3RoKCkpKTtcbiAgaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZGVzLmNiYy5wcm90b3R5cGUudW5wYWQgPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgLy8gY2hlY2sgZm9yIGVycm9yOiBpbnB1dCBkYXRhIG5vdCBhIG11bHRpcGxlIG9mIGJsb2NrU2l6ZVxuICBpZihvcHRpb25zLm92ZXJmbG93ID4gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgdmFyIGxlbiA9IG91dHB1dC5sZW5ndGgoKTtcbiAgdmFyIGNvdW50ID0gb3V0cHV0LmF0KGxlbiAtIDEpO1xuICBpZihjb3VudCA+ICh0aGlzLmJsb2NrU2l6ZSA8PCAyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHRyaW0gb2ZmIHBhZGRpbmcgYnl0ZXNcbiAgb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiogQ2lwaGVyIGZlZWRiYWNrIChDRkIpICoqL1xuXG5tb2Rlcy5jZmIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5hbWUgPSAnQ0ZCJztcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5faW50cyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG51bGw7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaGFuZGxlIGZ1bGwgYmxvY2tcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID09PSAwICYmIGlucHV0TGVuZ3RoID49IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgLy8gWE9SIGlucHV0IHdpdGggb3V0cHV0LCB3cml0ZSBpbnB1dCBhcyBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX2luQmxvY2tbaV0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICB2YXIgcGFydGlhbEJ5dGVzID0gKHRoaXMuYmxvY2tTaXplIC0gaW5wdXRMZW5ndGgpICUgdGhpcy5ibG9ja1NpemU7XG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgfVxuXG4gIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgcGFydGlhbCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbEJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldO1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQucHV0SW50MzIodGhpcy5fcGFydGlhbEJsb2NrW2ldKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlclxuICAgIGlucHV0LnJlYWQgLT0gdGhpcy5ibG9ja1NpemU7XG4gIH0gZWxzZSB7XG4gICAgLy8gYmxvY2sgY29tcGxldGUsIHVwZGF0ZSBpbnB1dCBibG9ja1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9wYXJ0aWFsQmxvY2tbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gc2tpcCBhbnkgcHJldmlvdXMgcGFydGlhbCBieXRlc1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyh0aGlzLl9wYXJ0aWFsQnl0ZXMpO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICBpbnB1dExlbmd0aCAtIHRoaXMuX3BhcnRpYWxCeXRlcykpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY2ZiLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZGVjcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENGQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCwgd3JpdGUgaW5wdXQgYXMgb3V0cHV0XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5faW5CbG9ja1tpXSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXQsIHdyaXRlIGlucHV0IGFzIHBhcnRpYWwgb3V0cHV0XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQuY2xlYXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMuX3BhcnRpYWxCbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMih0aGlzLl9wYXJ0aWFsQmxvY2tbaV0gXiB0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cblxuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgLy8gYmxvY2sgc3RpbGwgaW5jb21wbGV0ZSwgcmVzdG9yZSBpbnB1dCBidWZmZXJcbiAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICB9IGVsc2Uge1xuICAgIC8vIGJsb2NrIGNvbXBsZXRlLCB1cGRhdGUgaW5wdXQgYmxvY2tcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICB0aGlzLl9pbkJsb2NrW2ldID0gdGhpcy5fcGFydGlhbEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbi8qKiBPdXRwdXQgZmVlZGJhY2sgKE9GQikgKiovXG5cbm1vZGVzLm9mYiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdPRkInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMub2ZiLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKE9GQiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dCBhbmQgdXBkYXRlIG5leHQgaW5wdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIoaW5wdXQuZ2V0SW50MzIoKSBeIHRoaXMuX291dEJsb2NrW2ldKTtcbiAgICAgIHRoaXMuX2luQmxvY2tbaV0gPSB0aGlzLl9vdXRCbG9ja1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHBhcnRpYWwgYmxvY2tcbiAgdmFyIHBhcnRpYWxCeXRlcyA9ICh0aGlzLmJsb2NrU2l6ZSAtIGlucHV0TGVuZ3RoKSAlIHRoaXMuYmxvY2tTaXplO1xuICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgcGFydGlhbEJ5dGVzID0gdGhpcy5ibG9ja1NpemUgLSBwYXJ0aWFsQnl0ZXM7XG4gIH1cblxuICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgdGhpcy5fcGFydGlhbE91dHB1dC5jbGVhcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG5cbiAgaWYocGFydGlhbEJ5dGVzID4gMCkge1xuICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBibG9jayBjb21wbGV0ZSwgdXBkYXRlIGlucHV0IGJsb2NrXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5faW5CbG9ja1tpXSA9IHRoaXMuX291dEJsb2NrW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgaWYodGhpcy5fcGFydGlhbEJ5dGVzID4gMCkge1xuICAgIHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXModGhpcy5fcGFydGlhbEJ5dGVzKTtcbiAgfVxuXG4gIGlmKHBhcnRpYWxCeXRlcyA+IDAgJiYgIWZpbmlzaCkge1xuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gcGFydGlhbEJ5dGVzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgb3V0cHV0LnB1dEJ5dGVzKHRoaXMuX3BhcnRpYWxPdXRwdXQuZ2V0Qnl0ZXMoXG4gICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbn07XG5cbm1vZGVzLm9mYi5wcm90b3R5cGUuZGVjcnlwdCA9IG1vZGVzLm9mYi5wcm90b3R5cGUuZW5jcnlwdDtcblxuLyoqIENvdW50ZXIgKENUUikgKiovXG5cbm1vZGVzLmN0ciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9ICdDVFInO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IG9wdGlvbnMuYmxvY2tTaXplIHx8IDE2O1xuICB0aGlzLl9pbnRzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbnVsbDtcbiAgdGhpcy5fb3V0QmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX3BhcnRpYWxPdXRwdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgaWYoISgnaXYnIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElWIHBhcmFtZXRlci4nKTtcbiAgfVxuICAvLyB1c2UgSVYgYXMgZmlyc3QgaW5wdXRcbiAgdGhpcy5faXYgPSB0cmFuc2Zvcm1JVihvcHRpb25zLml2KTtcbiAgdGhpcy5faW5CbG9jayA9IHRoaXMuX2l2LnNsaWNlKDApO1xuICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIC8vIG5vdCBlbm91Z2ggaW5wdXQgdG8gZW5jcnlwdFxuICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgoKTtcbiAgaWYoaW5wdXRMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGVuY3J5cHQgYmxvY2sgKENUUiBhbHdheXMgdXNlcyBlbmNyeXB0aW9uIG1vZGUpXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIGhhbmRsZSBmdWxsIGJsb2NrXG4gIGlmKHRoaXMuX3BhcnRpYWxCeXRlcyA9PT0gMCAmJiBpbnB1dExlbmd0aCA+PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgIC8vIFhPUiBpbnB1dCB3aXRoIG91dHB1dFxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRzOyArK2kpIHtcbiAgICAgIG91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA+IDApIHtcbiAgICAgIC8vIGJsb2NrIHN0aWxsIGluY29tcGxldGUsIHJlc3RvcmUgaW5wdXQgYnVmZmVyXG4gICAgICBpbnB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgICAgcGFydGlhbEJ5dGVzIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSBwYXJ0aWFsQnl0ZXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvdXRwdXQucHV0Qnl0ZXModGhpcy5fcGFydGlhbE91dHB1dC5nZXRCeXRlcyhcbiAgICAgIGlucHV0TGVuZ3RoIC0gdGhpcy5fcGFydGlhbEJ5dGVzKSk7XG4gICAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcbiAgfVxuXG4gIC8vIGJsb2NrIGNvbXBsZXRlLCBpbmNyZW1lbnQgY291bnRlciAoaW5wdXQgYmxvY2spXG4gIGluYzMyKHRoaXMuX2luQmxvY2spO1xufTtcblxubW9kZXMuY3RyLnByb3RvdHlwZS5kZWNyeXB0ID0gbW9kZXMuY3RyLnByb3RvdHlwZS5lbmNyeXB0O1xuXG4vKiogR2Fsb2lzL0NvdW50ZXIgTW9kZSAoR0NNKSAqKi9cblxubW9kZXMuZ2NtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gJ0dDTSc7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2ludHMgPSB0aGlzLmJsb2NrU2l6ZSAvIDQ7XG4gIHRoaXMuX2luQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2ludHMpO1xuICB0aGlzLl9wYXJ0aWFsT3V0cHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5fcGFydGlhbEJ5dGVzID0gMDtcblxuICAvLyBSIGlzIGFjdHVhbGx5IHRoaXMgdmFsdWUgY29uY2F0ZW5hdGVkIHdpdGggMTIwIG1vcmUgemVybyBiaXRzLCBidXRcbiAgLy8gd2Ugb25seSBYT1IgYWdhaW5zdCBSIHNvIHRoZSBvdGhlciB6ZXJvcyBoYXZlIG5vIGVmZmVjdCAtLSB3ZSBqdXN0XG4gIC8vIGFwcGx5IHRoaXMgdmFsdWUgdG8gdGhlIGZpcnN0IGludGVnZXIgaW4gYSBibG9ja1xuICB0aGlzLl9SID0gMHhFMTAwMDAwMDtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmKCEoJ2l2JyBpbiBvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJViBwYXJhbWV0ZXIuJyk7XG4gIH1cbiAgLy8gZW5zdXJlIElWIGlzIGEgYnl0ZSBidWZmZXJcbiAgdmFyIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5pdik7XG5cbiAgLy8gbm8gY2lwaGVyZWQgZGF0YSBwcm9jZXNzZWQgeWV0XG4gIHRoaXMuX2NpcGhlckxlbmd0aCA9IDA7XG5cbiAgLy8gZGVmYXVsdCBhZGRpdGlvbmFsIGRhdGEgaXMgbm9uZVxuICB2YXIgYWRkaXRpb25hbERhdGE7XG4gIGlmKCdhZGRpdGlvbmFsRGF0YScgaW4gb3B0aW9ucykge1xuICAgIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgYWRkaXRpb25hbERhdGEgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0YWcgbGVuZ3RoIGlzIDEyOCBiaXRzXG4gIGlmKCd0YWdMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSBvcHRpb25zLnRhZ0xlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWdMZW5ndGggPSAxMjg7XG4gIH1cblxuICAvLyBpZiB0YWcgaXMgZ2l2ZW4sIGVuc3VyZSB0YWcgbWF0Y2hlcyB0YWcgbGVuZ3RoXG4gIHRoaXMuX3RhZyA9IG51bGw7XG4gIGlmKG9wdGlvbnMuZGVjcnlwdCkge1xuICAgIC8vIHNhdmUgdGFnIHRvIGNoZWNrIGxhdGVyXG4gICAgdGhpcy5fdGFnID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIob3B0aW9ucy50YWcpLmdldEJ5dGVzKCk7XG4gICAgaWYodGhpcy5fdGFnLmxlbmd0aCAhPT0gKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIHRhZyBkb2VzIG5vdCBtYXRjaCB0YWcgbGVuZ3RoLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSB0bXAgc3RvcmFnZSBmb3IgaGFzaCBjYWxjdWxhdGlvblxuICB0aGlzLl9oYXNoQmxvY2sgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG5cbiAgLy8gbm8gdGFnIGdlbmVyYXRlZCB5ZXRcbiAgdGhpcy50YWcgPSBudWxsO1xuXG4gIC8vIGdlbmVyYXRlIGhhc2ggc3Via2V5XG4gIC8vIChhcHBseSBibG9jayBjaXBoZXIgdG8gXCJ6ZXJvXCIgYmxvY2spXG4gIHRoaXMuX2hhc2hTdWJrZXkgPSBuZXcgQXJyYXkodGhpcy5faW50cyk7XG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQoWzAsIDAsIDAsIDBdLCB0aGlzLl9oYXNoU3Via2V5KTtcblxuICAvLyBnZW5lcmF0ZSB0YWJsZSBNXG4gIC8vIHVzZSA0LWJpdCB0YWJsZXMgKDMyIGNvbXBvbmVudCBkZWNvbXBvc2l0aW9uIG9mIGEgMTYgYnl0ZSB2YWx1ZSlcbiAgLy8gOC1iaXQgdGFibGVzIHRha2UgbW9yZSBzcGFjZSBhbmQgYXJlIGtub3duIHRvIGhhdmUgc2VjdXJpdHlcbiAgLy8gdnVsbmVyYWJpbGl0aWVzIChpbiBuYXRpdmUgaW1wbGVtZW50YXRpb25zKVxuICB0aGlzLmNvbXBvbmVudEJpdHMgPSA0O1xuICB0aGlzLl9tID0gdGhpcy5nZW5lcmF0ZUhhc2hUYWJsZSh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLmNvbXBvbmVudEJpdHMpO1xuXG4gIC8vIE5vdGU6IHN1cHBvcnQgSVYgbGVuZ3RoIGRpZmZlcmVudCBmcm9tIDk2IGJpdHM/IChvbmx5IHN1cHBvcnRpbmdcbiAgLy8gOTYgYml0cyBpcyByZWNvbW1lbmRlZCBieSBOSVNUIFNQLTgwMC0zOEQpXG4gIC8vIGdlbmVyYXRlIEpfMFxuICB2YXIgaXZMZW5ndGggPSBpdi5sZW5ndGgoKTtcbiAgaWYoaXZMZW5ndGggPT09IDEyKSB7XG4gICAgLy8gOTYtYml0IElWXG4gICAgdGhpcy5fajAgPSBbaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgaXYuZ2V0SW50MzIoKSwgMV07XG4gIH0gZWxzZSB7XG4gICAgLy8gSVYgaXMgTk9UIDk2LWJpdHNcbiAgICB0aGlzLl9qMCA9IFswLCAwLCAwLCAwXTtcbiAgICB3aGlsZShpdi5sZW5ndGgoKSA+IDApIHtcbiAgICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgICAgdGhpcy5faGFzaFN1YmtleSwgdGhpcy5fajAsXG4gICAgICAgIFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXSk7XG4gICAgfVxuICAgIHRoaXMuX2owID0gdGhpcy5naGFzaChcbiAgICAgIHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX2owLCBbMCwgMF0uY29uY2F0KGZyb202NFRvMzIoaXZMZW5ndGggKiA4KSkpO1xuICB9XG5cbiAgLy8gZ2VuZXJhdGUgSUNCIChpbml0aWFsIGNvdW50ZXIgYmxvY2spXG4gIHRoaXMuX2luQmxvY2sgPSB0aGlzLl9qMC5zbGljZSgwKTtcbiAgaW5jMzIodGhpcy5faW5CbG9jayk7XG4gIHRoaXMuX3BhcnRpYWxCeXRlcyA9IDA7XG5cbiAgLy8gY29uc3VtZSBhdXRoZW50aWNhdGlvbiBkYXRhXG4gIGFkZGl0aW9uYWxEYXRhID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoYWRkaXRpb25hbERhdGEpO1xuICAvLyBzYXZlIGFkZGl0aW9uYWwgZGF0YSBsZW5ndGggYXMgYSBCRSA2NC1iaXQgbnVtYmVyXG4gIHRoaXMuX2FEYXRhTGVuZ3RoID0gZnJvbTY0VG8zMihhZGRpdGlvbmFsRGF0YS5sZW5ndGgoKSAqIDgpO1xuICAvLyBwYWQgYWRkaXRpb25hbCBkYXRhIHRvIDEyOCBiaXQgKDE2IGJ5dGUpIGJsb2NrIHNpemVcbiAgdmFyIG92ZXJmbG93ID0gYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgaWYob3ZlcmZsb3cpIHtcbiAgICBhZGRpdGlvbmFsRGF0YS5maWxsV2l0aEJ5dGUoMCwgdGhpcy5ibG9ja1NpemUgLSBvdmVyZmxvdyk7XG4gIH1cbiAgdGhpcy5fcyA9IFswLCAwLCAwLCAwXTtcbiAgd2hpbGUoYWRkaXRpb25hbERhdGEubGVuZ3RoKCkgPiAwKSB7XG4gICAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgW1xuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKSxcbiAgICAgIGFkZGl0aW9uYWxEYXRhLmdldEludDMyKCksXG4gICAgICBhZGRpdGlvbmFsRGF0YS5nZXRJbnQzMigpLFxuICAgICAgYWRkaXRpb25hbERhdGEuZ2V0SW50MzIoKVxuICAgIF0pO1xuICB9XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgLy8gbm90IGVub3VnaCBpbnB1dCB0byBlbmNyeXB0XG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCgpO1xuICBpZihpbnB1dExlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyBoYW5kbGUgZnVsbCBibG9ja1xuICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPT09IDAgJiYgaW5wdXRMZW5ndGggPj0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0gXj0gaW5wdXQuZ2V0SW50MzIoKSk7XG4gICAgfVxuICAgIHRoaXMuX2NpcGhlckxlbmd0aCArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoYW5kbGUgcGFydGlhbCBibG9ja1xuICAgIHZhciBwYXJ0aWFsQnl0ZXMgPSAodGhpcy5ibG9ja1NpemUgLSBpbnB1dExlbmd0aCkgJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICBpZihwYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICBwYXJ0aWFsQnl0ZXMgPSB0aGlzLmJsb2NrU2l6ZSAtIHBhcnRpYWxCeXRlcztcbiAgICB9XG5cbiAgICAvLyBYT1IgaW5wdXQgd2l0aCBvdXRwdXRcbiAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmNsZWFyKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5wdXRJbnQzMihpbnB1dC5nZXRJbnQzMigpIF4gdGhpcy5fb3V0QmxvY2tbaV0pO1xuICAgIH1cblxuICAgIGlmKHBhcnRpYWxCeXRlcyA8PSAwIHx8IGZpbmlzaCkge1xuICAgICAgLy8gaGFuZGxlIG92ZXJmbG93IHByaW9yIHRvIGhhc2hpbmdcbiAgICAgIGlmKGZpbmlzaCkge1xuICAgICAgICAvLyBnZXQgYmxvY2sgb3ZlcmZsb3dcbiAgICAgICAgdmFyIG92ZXJmbG93ID0gaW5wdXRMZW5ndGggJSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IG92ZXJmbG93O1xuICAgICAgICAvLyB0cnVuY2F0ZSBmb3IgaGFzaCBmdW5jdGlvblxuICAgICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LnRydW5jYXRlKHRoaXMuYmxvY2tTaXplIC0gb3ZlcmZsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2lwaGVyTGVuZ3RoICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgb3V0cHV0IGJsb2NrIGZvciBoYXNoaW5nXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faW50czsgKytpKSB7XG4gICAgICAgIHRoaXMuX291dEJsb2NrW2ldID0gdGhpcy5fcGFydGlhbE91dHB1dC5nZXRJbnQzMigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGFydGlhbE91dHB1dC5yZWFkIC09IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cblxuICAgIC8vIHNraXAgYW55IHByZXZpb3VzIHBhcnRpYWwgYnl0ZXNcbiAgICBpZih0aGlzLl9wYXJ0aWFsQnl0ZXMgPiAwKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKHRoaXMuX3BhcnRpYWxCeXRlcyk7XG4gICAgfVxuXG4gICAgaWYocGFydGlhbEJ5dGVzID4gMCAmJiAhZmluaXNoKSB7XG4gICAgICAvLyBibG9jayBzdGlsbCBpbmNvbXBsZXRlLCByZXN0b3JlIGlucHV0IGJ1ZmZlciwgZ2V0IHBhcnRpYWwgb3V0cHV0LFxuICAgICAgLy8gYW5kIHJldHVybiBlYXJseVxuICAgICAgaW5wdXQucmVhZCAtPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgICBwYXJ0aWFsQnl0ZXMgLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxCeXRlcyA9IHBhcnRpYWxCeXRlcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXRCeXRlcyh0aGlzLl9wYXJ0aWFsT3V0cHV0LmdldEJ5dGVzKFxuICAgICAgaW5wdXRMZW5ndGggLSB0aGlzLl9wYXJ0aWFsQnl0ZXMpKTtcbiAgICB0aGlzLl9wYXJ0aWFsQnl0ZXMgPSAwO1xuICB9XG5cbiAgLy8gdXBkYXRlIGhhc2ggYmxvY2sgU1xuICB0aGlzLl9zID0gdGhpcy5naGFzaCh0aGlzLl9oYXNoU3Via2V5LCB0aGlzLl9zLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICAvLyBub3QgZW5vdWdoIGlucHV0IHRvIGRlY3J5cHRcbiAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoKCk7XG4gIGlmKGlucHV0TGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXRMZW5ndGggPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9jayAoR0NNIGFsd2F5cyB1c2VzIGVuY3J5cHRpb24gbW9kZSlcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gaW5jcmVtZW50IGNvdW50ZXIgKGlucHV0IGJsb2NrKVxuICBpbmMzMih0aGlzLl9pbkJsb2NrKTtcblxuICAvLyB1cGRhdGUgaGFzaCBibG9jayBTXG4gIHRoaXMuX2hhc2hCbG9ja1swXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1sxXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1syXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX2hhc2hCbG9ja1szXSA9IGlucHV0LmdldEludDMyKCk7XG4gIHRoaXMuX3MgPSB0aGlzLmdoYXNoKHRoaXMuX2hhc2hTdWJrZXksIHRoaXMuX3MsIHRoaXMuX2hhc2hCbG9jayk7XG5cbiAgLy8gWE9SIGhhc2ggaW5wdXQgd2l0aCBvdXRwdXRcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSBeIHRoaXMuX2hhc2hCbG9ja1tpXSk7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgY2lwaGVyIGRhdGEgbGVuZ3RoXG4gIGlmKGlucHV0TGVuZ3RoIDwgdGhpcy5ibG9ja1NpemUpIHtcbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gaW5wdXRMZW5ndGggJSB0aGlzLmJsb2NrU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jaXBoZXJMZW5ndGggKz0gdGhpcy5ibG9ja1NpemU7XG4gIH1cbn07XG5cbm1vZGVzLmdjbS5wcm90b3R5cGUuYWZ0ZXJGaW5pc2ggPSBmdW5jdGlvbihvdXRwdXQsIG9wdGlvbnMpIHtcbiAgdmFyIHJ2YWwgPSB0cnVlO1xuXG4gIC8vIGhhbmRsZSBvdmVyZmxvd1xuICBpZihvcHRpb25zLmRlY3J5cHQgJiYgb3B0aW9ucy5vdmVyZmxvdykge1xuICAgIG91dHB1dC50cnVuY2F0ZSh0aGlzLmJsb2NrU2l6ZSAtIG9wdGlvbnMub3ZlcmZsb3cpO1xuICB9XG5cbiAgLy8gaGFuZGxlIGF1dGhlbnRpY2F0aW9uIHRhZ1xuICB0aGlzLnRhZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gY29uY2F0ZW5hdGUgYWRkaXRpb25hbCBkYXRhIGxlbmd0aCB3aXRoIGNpcGhlciBsZW5ndGhcbiAgdmFyIGxlbmd0aHMgPSB0aGlzLl9hRGF0YUxlbmd0aC5jb25jYXQoZnJvbTY0VG8zMih0aGlzLl9jaXBoZXJMZW5ndGggKiA4KSk7XG5cbiAgLy8gaW5jbHVkZSBsZW5ndGhzIGluIGhhc2hcbiAgdGhpcy5fcyA9IHRoaXMuZ2hhc2godGhpcy5faGFzaFN1YmtleSwgdGhpcy5fcywgbGVuZ3Rocyk7XG5cbiAgLy8gZG8gR0NUUihKXzAsIFMpXG4gIHZhciB0YWcgPSBbXTtcbiAgdGhpcy5jaXBoZXIuZW5jcnlwdCh0aGlzLl9qMCwgdGFnKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2ludHM7ICsraSkge1xuICAgIHRoaXMudGFnLnB1dEludDMyKHRoaXMuX3NbaV0gXiB0YWdbaV0pO1xuICB9XG5cbiAgLy8gdHJpbSB0YWcgdG8gbGVuZ3RoXG4gIHRoaXMudGFnLnRydW5jYXRlKHRoaXMudGFnLmxlbmd0aCgpICUgKHRoaXMuX3RhZ0xlbmd0aCAvIDgpKTtcblxuICAvLyBjaGVjayBhdXRoZW50aWNhdGlvbiB0YWdcbiAgaWYob3B0aW9ucy5kZWNyeXB0ICYmIHRoaXMudGFnLmJ5dGVzKCkgIT09IHRoaXMuX3RhZykge1xuICAgIHJ2YWwgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTZWUgTklTVCBTUC04MDAtMzhEIDYuMyAoQWxnb3JpdGhtIDEpLiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIEdhbG9pc1xuICogZmllbGQgbXVsdGlwbGljYXRpb24uIFRoZSBmaWVsZCwgR0YoMl4xMjgpLCBpcyBkZWZpbmVkIGJ5IHRoZSBwb2x5bm9taWFsOlxuICpcbiAqIHheMTI4ICsgeF43ICsgeF4yICsgeCArIDFcbiAqXG4gKiBXaGljaCBpcyByZXByZXNlbnRlZCBpbiBsaXR0bGUtZW5kaWFuIGJpbmFyeSBmb3JtIGFzOiAxMTEwMDAwMSAoMHhlMSkuIFdoZW5cbiAqIHRoZSB2YWx1ZSBvZiBhIGNvZWZmaWNpZW50IGlzIDEsIGEgYml0IGlzIHNldC4gVGhlIHZhbHVlIFIsIGlzIHRoZVxuICogY29uY2F0ZW5hdGlvbiBvZiB0aGlzIHZhbHVlIGFuZCAxMjAgemVybyBiaXRzLCB5aWVsZGluZyBhIDEyOC1iaXQgdmFsdWVcbiAqIHdoaWNoIG1hdGNoZXMgdGhlIGJsb2NrIHNpemUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIG11bHRpcGx5IHR3byBlbGVtZW50cyAodmVjdG9ycyBvZiBieXRlcyksIFggYW5kIFksIGluXG4gKiB0aGUgZmllbGQgR0YoMl4xMjgpLiBUaGUgcmVzdWx0IGlzIGluaXRpYWxpemVkIHRvIHplcm8uIEZvciBlYWNoIGJpdCBvZlxuICogWCAob3V0IG9mIDEyOCksIHhfaSwgaWYgeF9pIGlzIHNldCwgdGhlbiB0aGUgcmVzdWx0IGlzIG11bHRpcGxpZWQgKFhPUidkKVxuICogYnkgdGhlIGN1cnJlbnQgdmFsdWUgb2YgWS4gRm9yIGVhY2ggYml0LCB0aGUgdmFsdWUgb2YgWSB3aWxsIGJlIHJhaXNlZCBieVxuICogYSBwb3dlciBvZiB4IChtdWx0aXBsaWVkIGJ5IHRoZSBwb2x5bm9taWFsIHgpLiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieVxuICogc2hpZnRpbmcgWSBvbmNlIHRvIHRoZSByaWdodC4gSWYgdGhlIGN1cnJlbnQgdmFsdWUgb2YgWSwgcHJpb3IgdG8gYmVpbmdcbiAqIG11bHRpcGxpZWQgYnkgeCwgaGFzIDAgYXMgaXRzIExTQiwgdGhlbiBpdCBpcyBhIDEyN3RoIGRlZ3JlZSBwb2x5bm9taWFsLlxuICogT3RoZXJ3aXNlLCB3ZSBtdXN0IGRpdmlkZSBieSBSIGFmdGVyIHNoaWZ0aW5nIHRvIGZpbmQgdGhlIHJlbWFpbmRlci5cbiAqXG4gKiBAcGFyYW0geCB0aGUgZmlyc3QgYmxvY2sgdG8gbXVsdGlwbHkgYnkgdGhlIHNlY29uZC5cbiAqIEBwYXJhbSB5IHRoZSBzZWNvbmQgYmxvY2sgdG8gbXVsdGlwbHkgYnkgdGhlIGZpcnN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGJsb2NrIHJlc3VsdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB6X2kgPSBbMCwgMCwgMCwgMF07XG4gIHZhciB2X2kgPSB5LnNsaWNlKDApO1xuXG4gIC8vIGNhbGN1bGF0ZSBaXzEyOCAoYmxvY2sgaGFzIDEyOCBiaXRzKVxuICBmb3IodmFyIGkgPSAwOyBpIDwgMTI4OyArK2kpIHtcbiAgICAvLyBpZiB4X2kgaXMgMCwgWl97aSsxfSA9IFpfaSAodW5jaGFuZ2VkKVxuICAgIC8vIGVsc2UgWl97aSsxfSA9IFpfaSBeIFZfaVxuICAgIC8vIGdldCB4X2kgYnkgZmluZGluZyAzMi1iaXQgaW50IHBvc2l0aW9uLCB0aGVuIGxlZnQgc2hpZnQgMSBieSByZW1haW5kZXJcbiAgICB2YXIgeF9pID0geFsoaSAvIDMyKSB8IDBdICYgKDEgPDwgKDMxIC0gaSAlIDMyKSk7XG4gICAgaWYoeF9pKSB7XG4gICAgICB6X2lbMF0gXj0gdl9pWzBdO1xuICAgICAgel9pWzFdIF49IHZfaVsxXTtcbiAgICAgIHpfaVsyXSBePSB2X2lbMl07XG4gICAgICB6X2lbM10gXj0gdl9pWzNdO1xuICAgIH1cblxuICAgIC8vIGlmIExTQihWX2kpIGlzIDEsIFZfaSA9IFZfaSA+PiAxXG4gICAgLy8gZWxzZSBWX2kgPSAoVl9pID4+IDEpIF4gUlxuICAgIHRoaXMucG93KHZfaSwgdl9pKTtcbiAgfVxuXG4gIHJldHVybiB6X2k7XG59O1xuXG5tb2Rlcy5nY20ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKHgsIG91dCkge1xuICAvLyBpZiBMU0IoeCkgaXMgMSwgeCA9IHggPj4+IDFcbiAgLy8gZWxzZSB4ID0gKHggPj4+IDEpIF4gUlxuICB2YXIgbHNiID0geFszXSAmIDE7XG5cbiAgLy8gYWx3YXlzIGRvIHggPj4+IDE6XG4gIC8vIHN0YXJ0aW5nIHdpdGggdGhlIHJpZ2h0bW9zdCBpbnRlZ2VyLCBzaGlmdCBlYWNoIGludGVnZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9uZSBiaXQsIHB1bGxpbmcgaW4gdGhlIGJpdCBmcm9tIHRoZSBpbnRlZ2VyIHRvIHRoZSBsZWZ0IGFzIGl0cyB0b3BcbiAgLy8gbW9zdCBiaXQgKGRvIHRoaXMgZm9yIHRoZSBsYXN0IDMgaW50ZWdlcnMpXG4gIGZvcih2YXIgaSA9IDM7IGkgPiAwOyAtLWkpIHtcbiAgICBvdXRbaV0gPSAoeFtpXSA+Pj4gMSkgfCAoKHhbaSAtIDFdICYgMSkgPDwgMzEpO1xuICB9XG4gIC8vIHNoaWZ0IHRoZSBmaXJzdCBpbnRlZ2VyIG5vcm1hbGx5XG4gIG91dFswXSA9IHhbMF0gPj4+IDE7XG5cbiAgLy8gaWYgbHNiIHdhcyBub3Qgc2V0LCB0aGVuIHBvbHlub21pYWwgaGFkIGEgZGVncmVlIG9mIDEyNyBhbmQgZG9lc24ndFxuICAvLyBuZWVkIHRvIGRpdmlkZWQ7IG90aGVyd2lzZSwgWE9SIHdpdGggUiB0byBmaW5kIHRoZSByZW1haW5kZXI7IHdlIG9ubHlcbiAgLy8gbmVlZCB0byBYT1IgdGhlIGZpcnN0IGludGVnZXIgc2luY2UgUiB0ZWNobmljYWxseSBlbmRzIHcvMTIwIHplcm8gYml0c1xuICBpZihsc2IpIHtcbiAgICBvdXRbMF0gXj0gdGhpcy5fUjtcbiAgfVxufTtcblxubW9kZXMuZ2NtLnByb3RvdHlwZS50YWJsZU11bHRpcGx5ID0gZnVuY3Rpb24oeCkge1xuICAvLyBhc3N1bWVzIDQtYml0IHRhYmxlcyBhcmUgdXNlZFxuICB2YXIgeiA9IFswLCAwLCAwLCAwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGkgLyA4KSB8IDA7XG4gICAgdmFyIHhfaSA9ICh4W2lkeF0gPj4+ICgoNyAtIChpICUgOCkpICogNCkpICYgMHhGO1xuICAgIHZhciBhaCA9IHRoaXMuX21baV1beF9pXTtcbiAgICB6WzBdIF49IGFoWzBdO1xuICAgIHpbMV0gXj0gYWhbMV07XG4gICAgelsyXSBePSBhaFsyXTtcbiAgICB6WzNdIF49IGFoWzNdO1xuICB9XG4gIHJldHVybiB6O1xufTtcblxuLyoqXG4gKiBBIGNvbnRpbnVpbmcgdmVyc2lvbiBvZiB0aGUgR0hBU0ggYWxnb3JpdGhtIHRoYXQgb3BlcmF0ZXMgb24gYSBzaW5nbGVcbiAqIGJsb2NrLiBUaGUgaGFzaCBibG9jaywgbGFzdCBoYXNoIHZhbHVlIChZbSkgYW5kIHRoZSBuZXcgYmxvY2sgdG8gaGFzaFxuICogYXJlIGdpdmVuLlxuICpcbiAqIEBwYXJhbSBoIHRoZSBoYXNoIGJsb2NrLlxuICogQHBhcmFtIHkgdGhlIHByZXZpb3VzIHZhbHVlIGZvciBZbSwgdXNlIFswLCAwLCAwLCAwXSBmb3IgYSBuZXcgaGFzaC5cbiAqIEBwYXJhbSB4IHRoZSBibG9jayB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4gdGhlIGhhc2hlZCB2YWx1ZSAoWW0pLlxuICovXG5tb2Rlcy5nY20ucHJvdG90eXBlLmdoYXNoID0gZnVuY3Rpb24oaCwgeSwgeCkge1xuICB5WzBdIF49IHhbMF07XG4gIHlbMV0gXj0geFsxXTtcbiAgeVsyXSBePSB4WzJdO1xuICB5WzNdIF49IHhbM107XG4gIHJldHVybiB0aGlzLnRhYmxlTXVsdGlwbHkoeSk7XG4gIC8vcmV0dXJuIHRoaXMubXVsdGlwbHkoeSwgaCk7XG59O1xuXG4vKipcbiAqIFByZWNvbXB1dGVzIGEgdGFibGUgZm9yIG11bHRpcGx5aW5nIGFnYWluc3QgdGhlIGhhc2ggc3Via2V5LiBUaGlzXG4gKiBtZWNoYW5pc20gcHJvdmlkZXMgYSBzdWJzdGFudGlhbCBzcGVlZCBpbmNyZWFzZSBvdmVyIG11bHRpcGxpY2F0aW9uXG4gKiBwZXJmb3JtZWQgd2l0aG91dCBhIHRhYmxlLiBUaGUgdGFibGUtYmFzZWQgbXVsdGlwbGljYXRpb24gdGhpcyB0YWJsZSBpc1xuICogZm9yIHNvbHZlcyBYICogSCBieSBtdWx0aXBseWluZyBlYWNoIGNvbXBvbmVudCBvZiBYIGJ5IEggYW5kIHRoZW5cbiAqIGNvbXBvc2luZyB0aGUgcmVzdWx0cyB0b2dldGhlciB1c2luZyBYT1IuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0YWJsZXMgd2l0aCBkaWZmZXJlbnQgYml0IHNpemVzXG4gKiBmb3IgdGhlIGNvbXBvbmVudHMsIGhvd2V2ZXIsIHRoaXMgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGVyZSBhcmVcbiAqIDMyIGNvbXBvbmVudHMgb2YgWCAod2hpY2ggaXMgYSAxNiBieXRlIHZlY3RvciksIHRoZXJlZm9yZSBlYWNoIGNvbXBvbmVudFxuICogdGFrZXMgNC1iaXRzIChzbyB0aGUgdGFibGUgaXMgY29uc3RydWN0ZWQgd2l0aCBiaXRzPTQpLlxuICpcbiAqIEBwYXJhbSBoIHRoZSBoYXNoIHN1YmtleS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZSBmb3IgYSBjb21wb25lbnQuXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUuZ2VuZXJhdGVIYXNoVGFibGUgPSBmdW5jdGlvbihoLCBiaXRzKSB7XG4gIC8vIFRPRE86IFRoZXJlIGFyZSBmdXJ0aGVyIG9wdGltaXphdGlvbnMgdGhhdCB3b3VsZCB1c2Ugb25seSB0aGVcbiAgLy8gZmlyc3QgdGFibGUgTV8wIChvciBzb21lIHZhcmlhbnQpIGFsb25nIHdpdGggYSByZW1haW5kZXIgdGFibGU7XG4gIC8vIHRoaXMgY2FuIGJlIGV4cGxvcmVkIGluIHRoZSBmdXR1cmVcbiAgdmFyIG11bHRpcGxpZXIgPSA4IC8gYml0cztcbiAgdmFyIHBlckludCA9IDQgKiBtdWx0aXBsaWVyO1xuICB2YXIgc2l6ZSA9IDE2ICogbXVsdGlwbGllcjtcbiAgdmFyIG0gPSBuZXcgQXJyYXkoc2l6ZSk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICB2YXIgdG1wID0gWzAsIDAsIDAsIDBdO1xuICAgIHZhciBpZHggPSAoaSAvIHBlckludCkgfCAwO1xuICAgIHZhciBzaGZ0ID0gKChwZXJJbnQgLSAxIC0gKGkgJSBwZXJJbnQpKSAqIGJpdHMpO1xuICAgIHRtcFtpZHhdID0gKDEgPDwgKGJpdHMgLSAxKSkgPDwgc2hmdDtcbiAgICBtW2ldID0gdGhpcy5nZW5lcmF0ZVN1Ykhhc2hUYWJsZSh0aGlzLm11bHRpcGx5KHRtcCwgaCksIGJpdHMpO1xuICB9XG4gIHJldHVybiBtO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0YWJsZSBmb3IgbXVsdGlwbHlpbmcgYWdhaW5zdCB0aGUgaGFzaCBzdWJrZXkgZm9yIG9uZVxuICogcGFydGljdWxhciBjb21wb25lbnQgKG91dCBvZiBhbGwgcG9zc2libGUgY29tcG9uZW50IHZhbHVlcykuXG4gKlxuICogQHBhcmFtIG1pZCB0aGUgcHJlLW11bHRpcGxpZWQgdmFsdWUgZm9yIHRoZSBtaWRkbGUga2V5IG9mIHRoZSB0YWJsZS5cbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZSBmb3IgYSBjb21wb25lbnQuXG4gKi9cbm1vZGVzLmdjbS5wcm90b3R5cGUuZ2VuZXJhdGVTdWJIYXNoVGFibGUgPSBmdW5jdGlvbihtaWQsIGJpdHMpIHtcbiAgLy8gY29tcHV0ZSB0aGUgdGFibGUgcXVpY2tseSBieSBtaW5pbWl6aW5nIHRoZSBudW1iZXIgb2ZcbiAgLy8gUE9XIG9wZXJhdGlvbnMgLS0gdGhleSBvbmx5IG5lZWQgdG8gYmUgcGVyZm9ybWVkIGZvciBwb3dlcnMgb2YgMixcbiAgLy8gYWxsIG90aGVyIGVudHJpZXMgY2FuIGJlIGNvbXBvc2VkIGZyb20gdGhvc2UgcG93ZXJzIHVzaW5nIFhPUlxuICB2YXIgc2l6ZSA9IDEgPDwgYml0cztcbiAgdmFyIGhhbGYgPSBzaXplID4+PiAxO1xuICB2YXIgbSA9IG5ldyBBcnJheShzaXplKTtcbiAgbVtoYWxmXSA9IG1pZC5zbGljZSgwKTtcbiAgdmFyIGkgPSBoYWxmID4+PiAxO1xuICB3aGlsZShpID4gMCkge1xuICAgIC8vIHJhaXNlIG0wWzIgKiBpXSBhbmQgc3RvcmUgaW4gbTBbaV1cbiAgICB0aGlzLnBvdyhtWzIgKiBpXSwgbVtpXSA9IFtdKTtcbiAgICBpID4+PSAxO1xuICB9XG4gIGkgPSAyO1xuICB3aGlsZShpIDwgaGFsZikge1xuICAgIGZvcih2YXIgaiA9IDE7IGogPCBpOyArK2opIHtcbiAgICAgIHZhciBtX2kgPSBtW2ldO1xuICAgICAgdmFyIG1faiA9IG1bal07XG4gICAgICBtW2kgKyBqXSA9IFtcbiAgICAgICAgbV9pWzBdIF4gbV9qWzBdLFxuICAgICAgICBtX2lbMV0gXiBtX2pbMV0sXG4gICAgICAgIG1faVsyXSBeIG1falsyXSxcbiAgICAgICAgbV9pWzNdIF4gbV9qWzNdXG4gICAgICBdO1xuICAgIH1cbiAgICBpICo9IDI7XG4gIH1cbiAgbVswXSA9IFswLCAwLCAwLCAwXTtcbiAgLyogTm90ZTogV2UgY291bGQgYXZvaWQgc3RvcmluZyB0aGVzZSBieSBkb2luZyBjb21wb3NpdGlvbiBkdXJpbmcgbXVsdGlwbHlcbiAgY2FsY3VsYXRlIHRvcCBoYWxmIHVzaW5nIGNvbXBvc2l0aW9uIGJ5IHNwZWVkIGlzIHByZWZlcnJlZC4gKi9cbiAgZm9yKGkgPSBoYWxmICsgMTsgaSA8IHNpemU7ICsraSkge1xuICAgIHZhciBjID0gbVtpIF4gaGFsZl07XG4gICAgbVtpXSA9IFttaWRbMF0gXiBjWzBdLCBtaWRbMV0gXiBjWzFdLCBtaWRbMl0gXiBjWzJdLCBtaWRbM10gXiBjWzNdXTtcbiAgfVxuICByZXR1cm4gbTtcbn07XG5cbi8qKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1JVihpdikge1xuICBpZih0eXBlb2YgaXYgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gY29udmVydCBpdiBzdHJpbmcgaW50byBieXRlIGJ1ZmZlclxuICAgIGl2ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoaXYpO1xuICB9XG5cbiAgaWYoZm9yZ2UudXRpbC5pc0FycmF5KGl2KSAmJiBpdi5sZW5ndGggPiA0KSB7XG4gICAgLy8gY29udmVydCBpdiBieXRlIGFycmF5IGludG8gYnl0ZSBidWZmZXJcbiAgICB2YXIgdG1wID0gaXY7XG4gICAgaXYgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyArK2kpIHtcbiAgICAgIGl2LnB1dEJ5dGUodG1wW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheShpdikpIHtcbiAgICAvLyBjb252ZXJ0IGl2IGJ5dGUgYnVmZmVyIGludG8gMzItYml0IGludGVnZXIgYXJyYXlcbiAgICBpdiA9IFtpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpLCBpdi5nZXRJbnQzMigpXTtcbiAgfVxuXG4gIHJldHVybiBpdjtcbn1cblxuZnVuY3Rpb24gaW5jMzIoYmxvY2spIHtcbiAgLy8gaW5jcmVtZW50IGxhc3QgMzIgYml0cyBvZiBibG9jayBvbmx5XG4gIGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdID0gKGJsb2NrW2Jsb2NrLmxlbmd0aCAtIDFdICsgMSkgJiAweEZGRkZGRkZGO1xufVxuXG5mdW5jdGlvbiBmcm9tNjRUbzMyKG51bSkge1xuICAvLyBjb252ZXJ0IDY0LWJpdCBudW1iZXIgdG8gdHdvIEJFIEludDMyc1xuICByZXR1cm4gWyhudW0gLyAweDEwMDAwMDAwMCkgfCAwLCBudW0gJiAweEZGRkZGRkZGXTtcbn1cbiIsIi8qKlxuICogREVTIChEYXRhIEVuY3J5cHRpb24gU3RhbmRhcmQpIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gc3VwcG9ydHMgREVTIGFzIHdlbGwgYXMgM0RFUy1FREUgaW4gRUNCIGFuZCBDQkMgbW9kZS5cbiAqIEl0IGlzIGJhc2VkIG9uIHRoZSBCU0QtbGljZW5zZWQgaW1wbGVtZW50YXRpb24gYnkgUGF1bCBUZXJvOlxuICpcbiAqIFBhdWwgVGVybywgSnVseSAyMDAxXG4gKiBodHRwOi8vd3d3LnRlcm8uY28udWsvZGVzL1xuICpcbiAqIE9wdGltaXNlZCBmb3IgcGVyZm9ybWFuY2Ugd2l0aCBsYXJnZSBibG9ja3MgYnlcbiAqIE1pY2hhZWwgSGF5d29ydGgsIE5vdmVtYmVyIDIwMDFcbiAqIGh0dHA6Ly93d3cubmV0ZGVhbGluZy5jb21cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFNcbiAqIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKVxuICogSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1RcbiAqIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVlcbiAqIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0ZcbiAqIFNVQ0ggREFNQUdFLlxuICpcbiAqIEBhdXRob3IgU3RlZmFuIFNpZWdsXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9jaXBoZXInKTtcbnJlcXVpcmUoJy4vY2lwaGVyTW9kZXMnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKiBERVMgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLmRlcyA9IGZvcmdlLmRlcyB8fCB7fTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IGZhbHNlLFxuICAgIG1vZGU6IG1vZGUgfHwgKGl2ID09PSBudWxsID8gJ0VDQicgOiAnQ0JDJylcbiAgfSk7XG4gIGNpcGhlci5zdGFydChpdik7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZTpcbiAqXG4gKiB2YXIgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZUNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBlbmNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiBmYWxzZSxcbiAgICBtb2RlOiBtb2RlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2U6XG4gKlxuICogdmFyIGRlY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqIGRlY2lwaGVyLnN0YXJ0KHtpdjogaXZ9KTtcbiAqXG4gKiBDcmVhdGVzIGFuIERFUyBjaXBoZXIgb2JqZWN0IHRvIGRlY3J5cHQgZGF0YSB1c2luZyB0aGUgZ2l2ZW4gc3ltbWV0cmljIGtleS5cbiAqIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlciBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBiaW5hcnktZW5jb2RlZCBzdHJpbmdzIG9mIGJ5dGVzIG9yXG4gKiBieXRlIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UgKDY0IG9yIDE5MiBiaXRzKS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycgaWYgSVYgaXNcbiAqICAgICAgICAgIGdpdmVuLCAnRUNCJyBpZiBudWxsKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQsIG1vZGUpIHtcbiAgdmFyIGNpcGhlciA9IF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogb3V0cHV0LFxuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgbW9kZTogbW9kZSB8fCAoaXYgPT09IG51bGwgPyAnRUNCJyA6ICdDQkMnKVxuICB9KTtcbiAgY2lwaGVyLnN0YXJ0KGl2KTtcbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIHZhciBkZWNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcignREVTLTxtb2RlPicsIGtleSk7XG4gKlxuICogQ3JlYXRlcyBhbiBERVMgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgdXNpbmcgdGhlIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogQHBhcmFtIG1vZGUgdGhlIGNpcGhlciBtb2RlIHRvIHVzZSAoZGVmYXVsdDogJ0NCQycpLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIG1vZGUpIHtcbiAgcmV0dXJuIF9jcmVhdGVDaXBoZXIoe1xuICAgIGtleToga2V5LFxuICAgIG91dHB1dDogbnVsbCxcbiAgICBkZWNyeXB0OiB0cnVlLFxuICAgIG1vZGU6IG1vZGVcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgREVTIGNpcGhlciBhbGdvcml0aG0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0uXG4gKiBAcGFyYW0gbW9kZSB0aGUgbW9kZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIERFUyBhbGdvcml0aG0gb2JqZWN0LlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtID0gZnVuY3Rpb24obmFtZSwgbW9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYubmFtZSA9IG5hbWU7XG4gIHNlbGYubW9kZSA9IG5ldyBtb2RlKHtcbiAgICBibG9ja1NpemU6IDgsXG4gICAgY2lwaGVyOiB7XG4gICAgICBlbmNyeXB0OiBmdW5jdGlvbihpbkJsb2NrLCBvdXRCbG9jaykge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZUJsb2NrKHNlbGYuX2tleXMsIGluQmxvY2ssIG91dEJsb2NrLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogZnVuY3Rpb24oaW5CbG9jaywgb3V0QmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF91cGRhdGVCbG9jayhzZWxmLl9rZXlzLCBpbkJsb2NrLCBvdXRCbG9jaywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgc2VsZi5faW5pdCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIERFUyBhbGdvcml0aG0gYnkgZXhwYW5kaW5nIGl0cyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBrZXkgdG8gdXNlIHdpdGggdGhpcyBhbGdvcml0aG0uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgaWYgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgZm9yIGRlY3J5cHRpb24sXG4gKiAgICAgICAgICAgIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICovXG5mb3JnZS5kZXMuQWxnb3JpdGhtLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZih0aGlzLl9pbml0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKG9wdGlvbnMua2V5KTtcbiAgaWYodGhpcy5uYW1lLmluZGV4T2YoJzNERVMnKSA9PT0gMCkge1xuICAgIGlmKGtleS5sZW5ndGgoKSAhPT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUcmlwbGUtREVTIGtleSBzaXplOiAnICsga2V5Lmxlbmd0aCgpICogOCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZG8ga2V5IGV4cGFuc2lvbiB0byAxNiBvciA0OCBzdWJrZXlzIChzaW5nbGUgb3IgdHJpcGxlIERFUylcbiAgdGhpcy5fa2V5cyA9IF9jcmVhdGVLZXlzKGtleSk7XG4gIHRoaXMuX2luaXQgPSB0cnVlO1xufTtcblxuLyoqIFJlZ2lzdGVyIERFUyBhbGdvcml0aG1zICoqL1xuXG5yZWdpc3RlckFsZ29yaXRobSgnREVTLUVDQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5lY2IpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCdERVMtQ0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmNmYik7XG5yZWdpc3RlckFsZ29yaXRobSgnREVTLU9GQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5vZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJ0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtRUNCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLmVjYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DQkMnLCBmb3JnZS5jaXBoZXIubW9kZXMuY2JjKTtcbnJlZ2lzdGVyQWxnb3JpdGhtKCczREVTLUNGQicsIGZvcmdlLmNpcGhlci5tb2Rlcy5jZmIpO1xucmVnaXN0ZXJBbGdvcml0aG0oJzNERVMtT0ZCJywgZm9yZ2UuY2lwaGVyLm1vZGVzLm9mYik7XG5yZWdpc3RlckFsZ29yaXRobSgnM0RFUy1DVFInLCBmb3JnZS5jaXBoZXIubW9kZXMuY3RyKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgbW9kZSkge1xuICB2YXIgZmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuZGVzLkFsZ29yaXRobShuYW1lLCBtb2RlKTtcbiAgfTtcbiAgZm9yZ2UuY2lwaGVyLnJlZ2lzdGVyQWxnb3JpdGhtKG5hbWUsIGZhY3RvcnkpO1xufVxuXG4vKiogREVTIGltcGxlbWVudGF0aW9uICoqL1xuXG52YXIgc3BmdW5jdGlvbjEgPSBbMHgxMDEwNDAwLDAsMHgxMDAwMCwweDEwMTA0MDQsMHgxMDEwMDA0LDB4MTA0MDQsMHg0LDB4MTAwMDAsMHg0MDAsMHgxMDEwNDAwLDB4MTAxMDQwNCwweDQwMCwweDEwMDA0MDQsMHgxMDEwMDA0LDB4MTAwMDAwMCwweDQsMHg0MDQsMHgxMDAwNDAwLDB4MTAwMDQwMCwweDEwNDAwLDB4MTA0MDAsMHgxMDEwMDAwLDB4MTAxMDAwMCwweDEwMDA0MDQsMHgxMDAwNCwweDEwMDAwMDQsMHgxMDAwMDA0LDB4MTAwMDQsMCwweDQwNCwweDEwNDA0LDB4MTAwMDAwMCwweDEwMDAwLDB4MTAxMDQwNCwweDQsMHgxMDEwMDAwLDB4MTAxMDQwMCwweDEwMDAwMDAsMHgxMDAwMDAwLDB4NDAwLDB4MTAxMDAwNCwweDEwMDAwLDB4MTA0MDAsMHgxMDAwMDA0LDB4NDAwLDB4NCwweDEwMDA0MDQsMHgxMDQwNCwweDEwMTA0MDQsMHgxMDAwNCwweDEwMTAwMDAsMHgxMDAwNDA0LDB4MTAwMDAwNCwweDQwNCwweDEwNDA0LDB4MTAxMDQwMCwweDQwNCwweDEwMDA0MDAsMHgxMDAwNDAwLDAsMHgxMDAwNCwweDEwNDAwLDAsMHgxMDEwMDA0XTtcbnZhciBzcGZ1bmN0aW9uMiA9IFstMHg3ZmVmN2ZlMCwtMHg3ZmZmODAwMCwweDgwMDAsMHgxMDgwMjAsMHgxMDAwMDAsMHgyMCwtMHg3ZmVmZmZlMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwtMHg3ZmVmN2ZlMCwtMHg3ZmVmODAwMCwtMHg4MDAwMDAwMCwtMHg3ZmZmODAwMCwweDEwMDAwMCwweDIwLC0weDdmZWZmZmUwLDB4MTA4MDAwLDB4MTAwMDIwLC0weDdmZmY3ZmUwLDAsLTB4ODAwMDAwMDAsMHg4MDAwLDB4MTA4MDIwLC0weDdmZjAwMDAwLDB4MTAwMDIwLC0weDdmZmZmZmUwLDAsMHgxMDgwMDAsMHg4MDIwLC0weDdmZWY4MDAwLC0weDdmZjAwMDAwLDB4ODAyMCwwLDB4MTA4MDIwLC0weDdmZWZmZmUwLDB4MTAwMDAwLC0weDdmZmY3ZmUwLC0weDdmZjAwMDAwLC0weDdmZWY4MDAwLDB4ODAwMCwtMHg3ZmYwMDAwMCwtMHg3ZmZmODAwMCwweDIwLC0weDdmZWY3ZmUwLDB4MTA4MDIwLDB4MjAsMHg4MDAwLC0weDgwMDAwMDAwLDB4ODAyMCwtMHg3ZmVmODAwMCwweDEwMDAwMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwtMHg3ZmZmN2ZlMCwtMHg3ZmZmZmZlMCwweDEwMDAyMCwweDEwODAwMCwwLC0weDdmZmY4MDAwLDB4ODAyMCwtMHg4MDAwMDAwMCwtMHg3ZmVmZmZlMCwtMHg3ZmVmN2ZlMCwweDEwODAwMF07XG52YXIgc3BmdW5jdGlvbjMgPSBbMHgyMDgsMHg4MDIwMjAwLDAsMHg4MDIwMDA4LDB4ODAwMDIwMCwwLDB4MjAyMDgsMHg4MDAwMjAwLDB4MjAwMDgsMHg4MDAwMDA4LDB4ODAwMDAwOCwweDIwMDAwLDB4ODAyMDIwOCwweDIwMDA4LDB4ODAyMDAwMCwweDIwOCwweDgwMDAwMDAsMHg4LDB4ODAyMDIwMCwweDIwMCwweDIwMjAwLDB4ODAyMDAwMCwweDgwMjAwMDgsMHgyMDIwOCwweDgwMDAyMDgsMHgyMDIwMCwweDIwMDAwLDB4ODAwMDIwOCwweDgsMHg4MDIwMjA4LDB4MjAwLDB4ODAwMDAwMCwweDgwMjAyMDAsMHg4MDAwMDAwLDB4MjAwMDgsMHgyMDgsMHgyMDAwMCwweDgwMjAyMDAsMHg4MDAwMjAwLDAsMHgyMDAsMHgyMDAwOCwweDgwMjAyMDgsMHg4MDAwMjAwLDB4ODAwMDAwOCwweDIwMCwwLDB4ODAyMDAwOCwweDgwMDAyMDgsMHgyMDAwMCwweDgwMDAwMDAsMHg4MDIwMjA4LDB4OCwweDIwMjA4LDB4MjAyMDAsMHg4MDAwMDA4LDB4ODAyMDAwMCwweDgwMDAyMDgsMHgyMDgsMHg4MDIwMDAwLDB4MjAyMDgsMHg4LDB4ODAyMDAwOCwweDIwMjAwXTtcbnZhciBzcGZ1bmN0aW9uNCA9IFsweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODAsMHg4MDAwODEsMHg4MDAwMDEsMHgyMDAxLDAsMHg4MDIwMDAsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDB4ODAwMDgwLDB4ODAwMDAxLDB4MSwweDIwMDAsMHg4MDAwMDAsMHg4MDIwMDEsMHg4MCwweDgwMDAwMCwweDIwMDEsMHgyMDgwLDB4ODAwMDgxLDB4MSwweDIwODAsMHg4MDAwODAsMHgyMDAwLDB4ODAyMDgwLDB4ODAyMDgxLDB4ODEsMHg4MDAwODAsMHg4MDAwMDEsMHg4MDIwMDAsMHg4MDIwODEsMHg4MSwwLDAsMHg4MDIwMDAsMHgyMDgwLDB4ODAwMDgwLDB4ODAwMDgxLDB4MSwweDgwMjAwMSwweDIwODEsMHgyMDgxLDB4ODAsMHg4MDIwODEsMHg4MSwweDEsMHgyMDAwLDB4ODAwMDAxLDB4MjAwMSwweDgwMjA4MCwweDgwMDA4MSwweDIwMDEsMHgyMDgwLDB4ODAwMDAwLDB4ODAyMDAxLDB4ODAsMHg4MDAwMDAsMHgyMDAwLDB4ODAyMDgwXTtcbnZhciBzcGZ1bmN0aW9uNSA9IFsweDEwMCwweDIwODAxMDAsMHgyMDgwMDAwLDB4NDIwMDAxMDAsMHg4MDAwMCwweDEwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQwMDgwMTAwLDB4ODAwMDAsMHgyMDAwMTAwLDB4NDAwODAxMDAsMHg0MjAwMDEwMCwweDQyMDgwMDAwLDB4ODAxMDAsMHg0MDAwMDAwMCwweDIwMDAwMDAsMHg0MDA4MDAwMCwweDQwMDgwMDAwLDAsMHg0MDAwMDEwMCwweDQyMDgwMTAwLDB4NDIwODAxMDAsMHgyMDAwMTAwLDB4NDIwODAwMDAsMHg0MDAwMDEwMCwwLDB4NDIwMDAwMDAsMHgyMDgwMTAwLDB4MjAwMDAwMCwweDQyMDAwMDAwLDB4ODAxMDAsMHg4MDAwMCwweDQyMDAwMTAwLDB4MTAwLDB4MjAwMDAwMCwweDQwMDAwMDAwLDB4MjA4MDAwMCwweDQyMDAwMTAwLDB4NDAwODAxMDAsMHgyMDAwMTAwLDB4NDAwMDAwMDAsMHg0MjA4MDAwMCwweDIwODAxMDAsMHg0MDA4MDEwMCwweDEwMCwweDIwMDAwMDAsMHg0MjA4MDAwMCwweDQyMDgwMTAwLDB4ODAxMDAsMHg0MjAwMDAwMCwweDQyMDgwMTAwLDB4MjA4MDAwMCwwLDB4NDAwODAwMDAsMHg0MjAwMDAwMCwweDgwMTAwLDB4MjAwMDEwMCwweDQwMDAwMTAwLDB4ODAwMDAsMCwweDQwMDgwMDAwLDB4MjA4MDEwMCwweDQwMDAwMTAwXTtcbnZhciBzcGZ1bmN0aW9uNiA9IFsweDIwMDAwMDEwLDB4MjA0MDAwMDAsMHg0MDAwLDB4MjA0MDQwMTAsMHgyMDQwMDAwMCwweDEwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDQwNDAxMCwweDQwMDAwMCwweDIwMDAwMDEwLDB4NDAwMDEwLDB4MjAwMDQwMDAsMHgyMDAwMDAwMCwweDQwMTAsMCwweDQwMDAxMCwweDIwMDA0MDEwLDB4NDAwMCwweDQwNDAwMCwweDIwMDA0MDEwLDB4MTAsMHgyMDQwMDAxMCwweDIwNDAwMDEwLDAsMHg0MDQwMTAsMHgyMDQwNDAwMCwweDQwMTAsMHg0MDQwMDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4MjAwMDQwMDAsMHgxMCwweDIwNDAwMDEwLDB4NDA0MDAwLDB4MjA0MDQwMTAsMHg0MDAwMDAsMHg0MDEwLDB4MjAwMDAwMTAsMHg0MDAwMDAsMHgyMDAwNDAwMCwweDIwMDAwMDAwLDB4NDAxMCwweDIwMDAwMDEwLDB4MjA0MDQwMTAsMHg0MDQwMDAsMHgyMDQwMDAwMCwweDQwNDAxMCwweDIwNDA0MDAwLDAsMHgyMDQwMDAxMCwweDEwLDB4NDAwMCwweDIwNDAwMDAwLDB4NDA0MDEwLDB4NDAwMCwweDQwMDAxMCwweDIwMDA0MDEwLDAsMHgyMDQwNDAwMCwweDIwMDAwMDAwLDB4NDAwMDEwLDB4MjAwMDQwMTBdO1xudmFyIHNwZnVuY3Rpb243ID0gWzB4MjAwMDAwLDB4NDIwMDAwMiwweDQwMDA4MDIsMCwweDgwMCwweDQwMDA4MDIsMHgyMDA4MDIsMHg0MjAwODAwLDB4NDIwMDgwMiwweDIwMDAwMCwwLDB4NDAwMDAwMiwweDIsMHg0MDAwMDAwLDB4NDIwMDAwMiwweDgwMiwweDQwMDA4MDAsMHgyMDA4MDIsMHgyMDAwMDIsMHg0MDAwODAwLDB4NDAwMDAwMiwweDQyMDAwMDAsMHg0MjAwODAwLDB4MjAwMDAyLDB4NDIwMDAwMCwweDgwMCwweDgwMiwweDQyMDA4MDIsMHgyMDA4MDAsMHgyLDB4NDAwMDAwMCwweDIwMDgwMCwweDQwMDAwMDAsMHgyMDA4MDAsMHgyMDAwMDAsMHg0MDAwODAyLDB4NDAwMDgwMiwweDQyMDAwMDIsMHg0MjAwMDAyLDB4MiwweDIwMDAwMiwweDQwMDAwMDAsMHg0MDAwODAwLDB4MjAwMDAwLDB4NDIwMDgwMCwweDgwMiwweDIwMDgwMiwweDQyMDA4MDAsMHg4MDIsMHg0MDAwMDAyLDB4NDIwMDgwMiwweDQyMDAwMDAsMHgyMDA4MDAsMCwweDIsMHg0MjAwODAyLDAsMHgyMDA4MDIsMHg0MjAwMDAwLDB4ODAwLDB4NDAwMDAwMiwweDQwMDA4MDAsMHg4MDAsMHgyMDAwMDJdO1xudmFyIHNwZnVuY3Rpb244ID0gWzB4MTAwMDEwNDAsMHgxMDAwLDB4NDAwMDAsMHgxMDA0MTA0MCwweDEwMDAwMDAwLDB4MTAwMDEwNDAsMHg0MCwweDEwMDAwMDAwLDB4NDAwNDAsMHgxMDA0MDAwMCwweDEwMDQxMDQwLDB4NDEwMDAsMHgxMDA0MTAwMCwweDQxMDQwLDB4MTAwMCwweDQwLDB4MTAwNDAwMDAsMHgxMDAwMDA0MCwweDEwMDAxMDAwLDB4MTA0MCwweDQxMDAwLDB4NDAwNDAsMHgxMDA0MDA0MCwweDEwMDQxMDAwLDB4MTA0MCwwLDAsMHgxMDA0MDA0MCwweDEwMDAwMDQwLDB4MTAwMDEwMDAsMHg0MTA0MCwweDQwMDAwLDB4NDEwNDAsMHg0MDAwMCwweDEwMDQxMDAwLDB4MTAwMCwweDQwLDB4MTAwNDAwNDAsMHgxMDAwLDB4NDEwNDAsMHgxMDAwMTAwMCwweDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDQwMDQwLDB4MTAwMDAwMDAsMHg0MDAwMCwweDEwMDAxMDQwLDAsMHgxMDA0MTA0MCwweDQwMDQwLDB4MTAwMDAwNDAsMHgxMDA0MDAwMCwweDEwMDAxMDAwLDB4MTAwMDEwNDAsMCwweDEwMDQxMDQwLDB4NDEwMDAsMHg0MTAwMCwweDEwNDAsMHgxMDQwLDB4NDAwNDAsMHgxMDAwMDAwMCwweDEwMDQxMDAwXTtcblxuLyoqXG4gKiBDcmVhdGUgbmVjZXNzYXJ5IHN1YiBrZXlzLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIDY0LWJpdCBvciAxOTItYml0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBrZXlzLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlS2V5cyhrZXkpIHtcbiAgdmFyIHBjMmJ5dGVzMCAgPSBbMCwweDQsMHgyMDAwMDAwMCwweDIwMDAwMDA0LDB4MTAwMDAsMHgxMDAwNCwweDIwMDEwMDAwLDB4MjAwMTAwMDQsMHgyMDAsMHgyMDQsMHgyMDAwMDIwMCwweDIwMDAwMjA0LDB4MTAyMDAsMHgxMDIwNCwweDIwMDEwMjAwLDB4MjAwMTAyMDRdLFxuICAgICAgcGMyYnl0ZXMxICA9IFswLDB4MSwweDEwMDAwMCwweDEwMDAwMSwweDQwMDAwMDAsMHg0MDAwMDAxLDB4NDEwMDAwMCwweDQxMDAwMDEsMHgxMDAsMHgxMDEsMHgxMDAxMDAsMHgxMDAxMDEsMHg0MDAwMTAwLDB4NDAwMDEwMSwweDQxMDAxMDAsMHg0MTAwMTAxXSxcbiAgICAgIHBjMmJ5dGVzMiAgPSBbMCwweDgsMHg4MDAsMHg4MDgsMHgxMDAwMDAwLDB4MTAwMDAwOCwweDEwMDA4MDAsMHgxMDAwODA4LDAsMHg4LDB4ODAwLDB4ODA4LDB4MTAwMDAwMCwweDEwMDAwMDgsMHgxMDAwODAwLDB4MTAwMDgwOF0sXG4gICAgICBwYzJieXRlczMgID0gWzAsMHgyMDAwMDAsMHg4MDAwMDAwLDB4ODIwMDAwMCwweDIwMDAsMHgyMDIwMDAsMHg4MDAyMDAwLDB4ODIwMjAwMCwweDIwMDAwLDB4MjIwMDAwLDB4ODAyMDAwMCwweDgyMjAwMDAsMHgyMjAwMCwweDIyMjAwMCwweDgwMjIwMDAsMHg4MjIyMDAwXSxcbiAgICAgIHBjMmJ5dGVzNCAgPSBbMCwweDQwMDAwLDB4MTAsMHg0MDAxMCwwLDB4NDAwMDAsMHgxMCwweDQwMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwLDB4MTAwMCwweDQxMDAwLDB4MTAxMCwweDQxMDEwXSxcbiAgICAgIHBjMmJ5dGVzNSAgPSBbMCwweDQwMCwweDIwLDB4NDIwLDAsMHg0MDAsMHgyMCwweDQyMCwweDIwMDAwMDAsMHgyMDAwNDAwLDB4MjAwMDAyMCwweDIwMDA0MjAsMHgyMDAwMDAwLDB4MjAwMDQwMCwweDIwMDAwMjAsMHgyMDAwNDIwXSxcbiAgICAgIHBjMmJ5dGVzNiAgPSBbMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDIsMCwweDEwMDAwMDAwLDB4ODAwMDAsMHgxMDA4MDAwMCwweDIsMHgxMDAwMDAwMiwweDgwMDAyLDB4MTAwODAwMDJdLFxuICAgICAgcGMyYnl0ZXM3ICA9IFswLDB4MTAwMDAsMHg4MDAsMHgxMDgwMCwweDIwMDAwMDAwLDB4MjAwMTAwMDAsMHgyMDAwMDgwMCwweDIwMDEwODAwLDB4MjAwMDAsMHgzMDAwMCwweDIwODAwLDB4MzA4MDAsMHgyMDAyMDAwMCwweDIwMDMwMDAwLDB4MjAwMjA4MDAsMHgyMDAzMDgwMF0sXG4gICAgICBwYzJieXRlczggID0gWzAsMHg0MDAwMCwwLDB4NDAwMDAsMHgyLDB4NDAwMDIsMHgyLDB4NDAwMDIsMHgyMDAwMDAwLDB4MjA0MDAwMCwweDIwMDAwMDAsMHgyMDQwMDAwLDB4MjAwMDAwMiwweDIwNDAwMDIsMHgyMDAwMDAyLDB4MjA0MDAwMl0sXG4gICAgICBwYzJieXRlczkgID0gWzAsMHgxMDAwMDAwMCwweDgsMHgxMDAwMDAwOCwwLDB4MTAwMDAwMDAsMHg4LDB4MTAwMDAwMDgsMHg0MDAsMHgxMDAwMDQwMCwweDQwOCwweDEwMDAwNDA4LDB4NDAwLDB4MTAwMDA0MDAsMHg0MDgsMHgxMDAwMDQwOF0sXG4gICAgICBwYzJieXRlczEwID0gWzAsMHgyMCwwLDB4MjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgxMDAwMDAsMHgxMDAwMjAsMHgyMDAwLDB4MjAyMCwweDIwMDAsMHgyMDIwLDB4MTAyMDAwLDB4MTAyMDIwLDB4MTAyMDAwLDB4MTAyMDIwXSxcbiAgICAgIHBjMmJ5dGVzMTEgPSBbMCwweDEwMDAwMDAsMHgyMDAsMHgxMDAwMjAwLDB4MjAwMDAwLDB4MTIwMDAwMCwweDIwMDIwMCwweDEyMDAyMDAsMHg0MDAwMDAwLDB4NTAwMDAwMCwweDQwMDAyMDAsMHg1MDAwMjAwLDB4NDIwMDAwMCwweDUyMDAwMDAsMHg0MjAwMjAwLDB4NTIwMDIwMF0sXG4gICAgICBwYzJieXRlczEyID0gWzAsMHgxMDAwLDB4ODAwMDAwMCwweDgwMDEwMDAsMHg4MDAwMCwweDgxMDAwLDB4ODA4MDAwMCwweDgwODEwMDAsMHgxMCwweDEwMTAsMHg4MDAwMDEwLDB4ODAwMTAxMCwweDgwMDEwLDB4ODEwMTAsMHg4MDgwMDEwLDB4ODA4MTAxMF0sXG4gICAgICBwYzJieXRlczEzID0gWzAsMHg0LDB4MTAwLDB4MTA0LDAsMHg0LDB4MTAwLDB4MTA0LDB4MSwweDUsMHgxMDEsMHgxMDUsMHgxLDB4NSwweDEwMSwweDEwNV07XG5cbiAgLy8gaG93IG1hbnkgaXRlcmF0aW9ucyAoMSBmb3IgZGVzLCAzIGZvciB0cmlwbGUgZGVzKVxuICAvLyBjaGFuZ2VkIGJ5IFBhdWwgMTYvNi8yMDA3IHRvIHVzZSBUcmlwbGUgREVTIGZvciA5KyBieXRlIGtleXNcbiAgdmFyIGl0ZXJhdGlvbnMgPSBrZXkubGVuZ3RoKCkgPiA4ID8gMyA6IDE7XG5cbiAgLy8gc3RvcmVzIHRoZSByZXR1cm4ga2V5c1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIC8vIG5vdyBkZWZpbmUgdGhlIGxlZnQgc2hpZnRzIHdoaWNoIG5lZWQgdG8gYmUgZG9uZVxuICB2YXIgc2hpZnRzID0gWzAsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDBdO1xuXG4gIHZhciBuID0gMCwgdG1wO1xuICBmb3IodmFyIGogPSAwOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG4gICAgdmFyIGxlZnQgPSBrZXkuZ2V0SW50MzIoKTtcbiAgICB2YXIgcmlnaHQgPSBrZXkuZ2V0SW50MzIoKTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gNCkgXiByaWdodCkgJiAweDBmMGYwZjBmO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMikgXiByaWdodCkgJiAweDMzMzMzMzMzO1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMik7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiAtMTYpIF4gbGVmdCkgJiAweDAwMDBmZmZmO1xuICAgIGxlZnQgXj0gdG1wO1xuICAgIHJpZ2h0IF49ICh0bXAgPDwgLTE2KTtcblxuICAgIHRtcCA9ICgobGVmdCA+Pj4gMSkgXiByaWdodCkgJiAweDU1NTU1NTU1O1xuICAgIHJpZ2h0IF49IHRtcDtcbiAgICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgICBsZWZ0IF49IHRtcDtcbiAgICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gICAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gICAgcmlnaHQgXj0gdG1wO1xuICAgIGxlZnQgXj0gKHRtcCA8PCAxKTtcblxuICAgIC8vIHJpZ2h0IG5lZWRzIHRvIGJlIHNoaWZ0ZWQgYW5kIE9SJ2Qgd2l0aCBsYXN0IGZvdXIgYml0cyBvZiBsZWZ0XG4gICAgdG1wID0gKGxlZnQgPDwgOCkgfCAoKHJpZ2h0ID4+PiAyMCkgJiAweDAwMDAwMGYwKTtcblxuICAgIC8vIGxlZnQgbmVlZHMgdG8gYmUgcHV0IHVwc2lkZSBkb3duXG4gICAgbGVmdCA9ICgocmlnaHQgPDwgMjQpIHwgKChyaWdodCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAoKHJpZ2h0ID4+PiA4KSAmIDB4ZmYwMCkgfCAoKHJpZ2h0ID4+PiAyNCkgJiAweGYwKSk7XG4gICAgcmlnaHQgPSB0bXA7XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGVzZSBzaGlmdHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IGtleXNcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2hpZnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvL3NoaWZ0IHRoZSBrZXlzIGVpdGhlciBvbmUgb3IgdHdvIGJpdHMgdG8gdGhlIGxlZnRcbiAgICAgIGlmKHNoaWZ0c1tpXSkge1xuICAgICAgICBsZWZ0ID0gKGxlZnQgPDwgMikgfCAobGVmdCA+Pj4gMjYpO1xuICAgICAgICByaWdodCA9IChyaWdodCA8PCAyKSB8IChyaWdodCA+Pj4gMjYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IChsZWZ0IDw8IDEpIHwgKGxlZnQgPj4+IDI3KTtcbiAgICAgICAgcmlnaHQgPSAocmlnaHQgPDwgMSkgfCAocmlnaHQgPj4+IDI3KTtcbiAgICAgIH1cbiAgICAgIGxlZnQgJj0gLTB4ZjtcbiAgICAgIHJpZ2h0ICY9IC0weGY7XG5cbiAgICAgIC8vIG5vdyBhcHBseSBQQy0yLCBpbiBzdWNoIGEgd2F5IHRoYXQgRSBpcyBlYXNpZXIgd2hlbiBlbmNyeXB0aW5nIG9yXG4gICAgICAvLyBkZWNyeXB0aW5nIHRoaXMgY29udmVyc2lvbiB3aWxsIGxvb2sgbGlrZSBQQy0yIGV4Y2VwdCBvbmx5IHRoZSBsYXN0IDZcbiAgICAgIC8vIGJpdHMgb2YgZWFjaCBieXRlIGFyZSB1c2VkIHJhdGhlciB0aGFuIDQ4IGNvbnNlY3V0aXZlIGJpdHMgYW5kIHRoZVxuICAgICAgLy8gb3JkZXIgb2YgbGluZXMgd2lsbCBiZSBhY2NvcmRpbmcgdG8gaG93IHRoZSBTIHNlbGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICAgICAgLy8gYmUgYXBwbGllZDogUzIsIFM0LCBTNiwgUzgsIFMxLCBTMywgUzUsIFM3XG4gICAgICB2YXIgbGVmdHRtcCA9IChcbiAgICAgICAgcGMyYnl0ZXMwW2xlZnQgPj4+IDI4XSB8IHBjMmJ5dGVzMVsobGVmdCA+Pj4gMjQpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzMlsobGVmdCA+Pj4gMjApICYgMHhmXSB8IHBjMmJ5dGVzM1sobGVmdCA+Pj4gMTYpICYgMHhmXSB8XG4gICAgICAgIHBjMmJ5dGVzNFsobGVmdCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzNVsobGVmdCA+Pj4gOCkgJiAweGZdIHxcbiAgICAgICAgcGMyYnl0ZXM2WyhsZWZ0ID4+PiA0KSAmIDB4Zl0pO1xuICAgICAgdmFyIHJpZ2h0dG1wID0gKFxuICAgICAgICBwYzJieXRlczdbcmlnaHQgPj4+IDI4XSB8IHBjMmJ5dGVzOFsocmlnaHQgPj4+IDI0KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczlbKHJpZ2h0ID4+PiAyMCkgJiAweGZdIHwgcGMyYnl0ZXMxMFsocmlnaHQgPj4+IDE2KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczExWyhyaWdodCA+Pj4gMTIpICYgMHhmXSB8IHBjMmJ5dGVzMTJbKHJpZ2h0ID4+PiA4KSAmIDB4Zl0gfFxuICAgICAgICBwYzJieXRlczEzWyhyaWdodCA+Pj4gNCkgJiAweGZdKTtcbiAgICAgIHRtcCA9ICgocmlnaHR0bXAgPj4+IDE2KSBeIGxlZnR0bXApICYgMHgwMDAwZmZmZjtcbiAgICAgIGtleXNbbisrXSA9IGxlZnR0bXAgXiB0bXA7XG4gICAgICBrZXlzW24rK10gPSByaWdodHRtcCBeICh0bXAgPDwgMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYmxvY2sgKDEgYnl0ZSkgdXNpbmcgREVTLiBUaGUgdXBkYXRlIHdpbGwgZWl0aGVyXG4gKiBlbmNyeXB0IG9yIGRlY3J5cHQgdGhlIGJsb2NrLlxuICpcbiAqIEBwYXJhbSBrZXlzIHRoZSBleHBhbmRlZCBrZXlzLlxuICogQHBhcmFtIGlucHV0IHRoZSBpbnB1dCBibG9jayAoYW4gYXJyYXkgb2YgMzItYml0IHdvcmRzKS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIHVwZGF0ZWQgb3V0cHV0IGJsb2NrLlxuICogQHBhcmFtIGRlY3J5cHQgdHJ1ZSB0byBkZWNyeXB0IHRoZSBibG9jaywgZmFsc2UgdG8gZW5jcnlwdCBpdC5cbiAqL1xuZnVuY3Rpb24gX3VwZGF0ZUJsb2NrKGtleXMsIGlucHV0LCBvdXRwdXQsIGRlY3J5cHQpIHtcbiAgLy8gc2V0IHVwIGxvb3BzIGZvciBzaW5nbGUgb3IgdHJpcGxlIERFU1xuICB2YXIgaXRlcmF0aW9ucyA9IGtleXMubGVuZ3RoID09PSAzMiA/IDMgOiA5O1xuICB2YXIgbG9vcGluZztcbiAgaWYoaXRlcmF0aW9ucyA9PT0gMykge1xuICAgIGxvb3BpbmcgPSBkZWNyeXB0ID8gWzMwLCAtMiwgLTJdIDogWzAsIDMyLCAyXTtcbiAgfSBlbHNlIHtcbiAgICBsb29waW5nID0gKGRlY3J5cHQgP1xuICAgICAgWzk0LCA2MiwgLTIsIDMyLCA2NCwgMiwgMzAsIC0yLCAtMl0gOlxuICAgICAgWzAsIDMyLCAyLCA2MiwgMzAsIC0yLCA2NCwgOTYsIDJdKTtcbiAgfVxuXG4gIHZhciB0bXA7XG5cbiAgdmFyIGxlZnQgPSBpbnB1dFswXTtcbiAgdmFyIHJpZ2h0ID0gaW5wdXRbMV07XG5cbiAgLy8gZmlyc3QgZWFjaCA2NCBiaXQgY2h1bmsgb2YgdGhlIG1lc3NhZ2UgbXVzdCBiZSBwZXJtdXRlZCBhY2NvcmRpbmcgdG8gSVBcbiAgdG1wID0gKChsZWZ0ID4+PiA0KSBeIHJpZ2h0KSAmIDB4MGYwZjBmMGY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDQpO1xuXG4gIHRtcCA9ICgobGVmdCA+Pj4gMTYpIF4gcmlnaHQpICYgMHgwMDAwZmZmZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMTYpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKHJpZ2h0ID4+PiA4KSBeIGxlZnQpICYgMHgwMGZmMDBmZjtcbiAgbGVmdCBePSB0bXA7XG4gIHJpZ2h0IF49ICh0bXAgPDwgOCk7XG5cbiAgdG1wID0gKChsZWZ0ID4+PiAxKSBeIHJpZ2h0KSAmIDB4NTU1NTU1NTU7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDEpO1xuXG4gIC8vIHJvdGF0ZSBsZWZ0IDEgYml0XG4gIGxlZnQgPSAoKGxlZnQgPDwgMSkgfCAobGVmdCA+Pj4gMzEpKTtcbiAgcmlnaHQgPSAoKHJpZ2h0IDw8IDEpIHwgKHJpZ2h0ID4+PiAzMSkpO1xuXG4gIGZvcih2YXIgaiA9IDA7IGogPCBpdGVyYXRpb25zOyBqICs9IDMpIHtcbiAgICB2YXIgZW5kbG9vcCA9IGxvb3BpbmdbaiArIDFdO1xuICAgIHZhciBsb29waW5jID0gbG9vcGluZ1tqICsgMl07XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBhbmQgcGVyZm9ybSB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uXG4gICAgZm9yKHZhciBpID0gbG9vcGluZ1tqXTsgaSAhPSBlbmRsb29wOyBpICs9IGxvb3BpbmMpIHtcbiAgICAgIHZhciByaWdodDEgPSByaWdodCBeIGtleXNbaV07XG4gICAgICB2YXIgcmlnaHQyID0gKChyaWdodCA+Pj4gNCkgfCAocmlnaHQgPDwgMjgpKSBeIGtleXNbaSArIDFdO1xuXG4gICAgICAvLyBwYXNzaW5nIHRoZXNlIGJ5dGVzIHRocm91Z2ggdGhlIFMgc2VsZWN0aW9uIGZ1bmN0aW9uc1xuICAgICAgdG1wID0gbGVmdDtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gdG1wIF4gKFxuICAgICAgICBzcGZ1bmN0aW9uMlsocmlnaHQxID4+PiAyNCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb240WyhyaWdodDEgPj4+IDE2KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjZbKHJpZ2h0MSA+Pj4gIDgpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uOFtyaWdodDEgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb24xWyhyaWdodDIgPj4+IDI0KSAmIDB4M2ZdIHxcbiAgICAgICAgc3BmdW5jdGlvbjNbKHJpZ2h0MiA+Pj4gMTYpICYgMHgzZl0gfFxuICAgICAgICBzcGZ1bmN0aW9uNVsocmlnaHQyID4+PiAgOCkgJiAweDNmXSB8XG4gICAgICAgIHNwZnVuY3Rpb243W3JpZ2h0MiAmIDB4M2ZdKTtcbiAgICB9XG4gICAgLy8gdW5yZXZlcnNlIGxlZnQgYW5kIHJpZ2h0XG4gICAgdG1wID0gbGVmdDtcbiAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgcmlnaHQgPSB0bXA7XG4gIH1cblxuICAvLyByb3RhdGUgcmlnaHQgMSBiaXRcbiAgbGVmdCA9ICgobGVmdCA+Pj4gMSkgfCAobGVmdCA8PCAzMSkpO1xuICByaWdodCA9ICgocmlnaHQgPj4+IDEpIHwgKHJpZ2h0IDw8IDMxKSk7XG5cbiAgLy8gbm93IHBlcmZvcm0gSVAtMSwgd2hpY2ggaXMgSVAgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICB0bXAgPSAoKGxlZnQgPj4+IDEpIF4gcmlnaHQpICYgMHg1NTU1NTU1NTtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgMSk7XG5cbiAgdG1wID0gKChyaWdodCA+Pj4gOCkgXiBsZWZ0KSAmIDB4MDBmZjAwZmY7XG4gIGxlZnQgXj0gdG1wO1xuICByaWdodCBePSAodG1wIDw8IDgpO1xuXG4gIHRtcCA9ICgocmlnaHQgPj4+IDIpIF4gbGVmdCkgJiAweDMzMzMzMzMzO1xuICBsZWZ0IF49IHRtcDtcbiAgcmlnaHQgXj0gKHRtcCA8PCAyKTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDE2KSBeIHJpZ2h0KSAmIDB4MDAwMGZmZmY7XG4gIHJpZ2h0IF49IHRtcDtcbiAgbGVmdCBePSAodG1wIDw8IDE2KTtcblxuICB0bXAgPSAoKGxlZnQgPj4+IDQpIF4gcmlnaHQpICYgMHgwZjBmMGYwZjtcbiAgcmlnaHQgXj0gdG1wO1xuICBsZWZ0IF49ICh0bXAgPDwgNCk7XG5cbiAgb3V0cHV0WzBdID0gbGVmdDtcbiAgb3V0cHV0WzFdID0gcmlnaHQ7XG59XG5cbi8qKlxuICogRGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlOlxuICpcbiAqIGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoJ0RFUy08bW9kZT4nLCBrZXkpO1xuICogZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKCdERVMtPG1vZGU+Jywga2V5KTtcbiAqXG4gKiBDcmVhdGVzIGEgZGVwcmVjYXRlZCBERVMgY2lwaGVyIG9iamVjdC4gVGhpcyBvYmplY3QncyBtb2RlIHdpbGwgZGVmYXVsdCB0b1xuICogQ0JDIChjaXBoZXItYmxvY2stY2hhaW5pbmcpLlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoNjQgb3IgMTkyIGJpdHMpLlxuICogICAgICAgICAgb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8uXG4gKiAgICAgICAgICBkZWNyeXB0IHRydWUgZm9yIGRlY3J5cHRpb24sIGZhbHNlIGZvciBlbmNyeXB0aW9uLlxuICogICAgICAgICAgbW9kZSB0aGUgY2lwaGVyIG1vZGUgdG8gdXNlIChkZWZhdWx0OiAnQ0JDJykuXG4gKlxuICogQHJldHVybiB0aGUgY2lwaGVyLlxuICovXG5mdW5jdGlvbiBfY3JlYXRlQ2lwaGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBtb2RlID0gKG9wdGlvbnMubW9kZSB8fCAnQ0JDJykudG9VcHBlckNhc2UoKTtcbiAgdmFyIGFsZ29yaXRobSA9ICdERVMtJyArIG1vZGU7XG5cbiAgdmFyIGNpcGhlcjtcbiAgaWYob3B0aW9ucy5kZWNyeXB0KSB7XG4gICAgY2lwaGVyID0gZm9yZ2UuY2lwaGVyLmNyZWF0ZURlY2lwaGVyKGFsZ29yaXRobSwgb3B0aW9ucy5rZXkpO1xuICB9IGVsc2Uge1xuICAgIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoYWxnb3JpdGhtLCBvcHRpb25zLmtleSk7XG4gIH1cblxuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdGFydCBBUElcbiAgdmFyIHN0YXJ0ID0gY2lwaGVyLnN0YXJ0O1xuICBjaXBoZXIuc3RhcnQgPSBmdW5jdGlvbihpdiwgb3B0aW9ucykge1xuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBzdXBwb3J0IHNlY29uZCBhcmcgYXMgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciBvdXRwdXQgPSBudWxsO1xuICAgIGlmKG9wdGlvbnMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVCdWZmZXIpIHtcbiAgICAgIG91dHB1dCA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdGlvbnMuaXYgPSBpdjtcbiAgICBzdGFydC5jYWxsKGNpcGhlciwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn1cbiIsIi8qKlxuICogTm9kZS5qcyBtb2R1bGUgZm9yIEZvcmdlLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxNiBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnM6IHtcbiAgICB1c2VQdXJlSmF2YVNjcmlwdDogZmFsc2VcbiAgfVxufTtcbiIsIi8qKlxuICogSGFzaC1iYXNlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgaW1wbGVtZW50YXRpb24uIFJlcXVpcmVzIGEgbWVzc2FnZVxuICogZGlnZXN0IG9iamVjdCB0aGF0IGNhbiBiZSBvYnRhaW5lZCwgZm9yIGV4YW1wbGUsIGZyb20gZm9yZ2UubWQuc2hhMSBvclxuICogZm9yZ2UubWQubWQ1LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qIEhNQUMgQVBJICovXG52YXIgaG1hYyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UuaG1hYyA9IGZvcmdlLmhtYWMgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBITUFDIG9iamVjdCB0aGF0IHVzZXMgdGhlIGdpdmVuIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGFuIEhNQUMgb2JqZWN0LlxuICovXG5obWFjLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB0aGUgaG1hYyBrZXkgdG8gdXNlXG4gIHZhciBfa2V5ID0gbnVsbDtcblxuICAvLyB0aGUgbWVzc2FnZSBkaWdlc3QgdG8gdXNlXG4gIHZhciBfbWQgPSBudWxsO1xuXG4gIC8vIHRoZSBpbm5lciBwYWRkaW5nXG4gIHZhciBfaXBhZGRpbmcgPSBudWxsO1xuXG4gIC8vIHRoZSBvdXRlciBwYWRkaW5nXG4gIHZhciBfb3BhZGRpbmcgPSBudWxsO1xuXG4gIC8vIGhtYWMgY29udGV4dFxuICB2YXIgY3R4ID0ge307XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgSE1BQyB3aXRoIHRoZSBnaXZlbiBrZXkgYW5kIG1lc3NhZ2UgZGlnZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgbnVsbCB0byByZXVzZSB0aGUgcHJldmlvdXMgb25lLFxuICAgKiAgICAgICAgICAgYSBzdHJpbmcgdG8gdXNlIGJ1aWx0aW4gJ3NoYTEnLCAnbWQ1JywgJ3NoYTI1NicuXG4gICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1c2UgYXMgYSBzdHJpbmcsIGFycmF5IG9mIGJ5dGVzLCBieXRlIGJ1ZmZlcixcbiAgICogICAgICAgICAgIG9yIG51bGwgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGtleS5cbiAgICovXG4gIGN0eC5zdGFydCA9IGZ1bmN0aW9uKG1kLCBrZXkpIHtcbiAgICBpZihtZCAhPT0gbnVsbCkge1xuICAgICAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBjcmVhdGUgYnVpbHRpbiBtZXNzYWdlIGRpZ2VzdFxuICAgICAgICBtZCA9IG1kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKG1kIGluIGZvcmdlLm1kLmFsZ29yaXRobXMpIHtcbiAgICAgICAgICBfbWQgPSBmb3JnZS5tZC5hbGdvcml0aG1zW21kXS5jcmVhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG0gXCInICsgbWQgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RvcmUgbWVzc2FnZSBkaWdlc3RcbiAgICAgICAgX21kID0gbWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoa2V5ID09PSBudWxsKSB7XG4gICAgICAvLyByZXVzZSBwcmV2aW91cyBrZXlcbiAgICAgIGtleSA9IF9rZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIGludG8gYnl0ZSBidWZmZXJcbiAgICAgICAga2V5ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoa2V5KTtcbiAgICAgIH0gZWxzZSBpZihmb3JnZS51dGlsLmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvLyBjb252ZXJ0IGJ5dGUgYXJyYXkgaW50byBieXRlIGJ1ZmZlclxuICAgICAgICB2YXIgdG1wID0ga2V5O1xuICAgICAgICBrZXkgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5LnB1dEJ5dGUodG1wW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiBrZXkgaXMgbG9uZ2VyIHRoYW4gYmxvY2tzaXplLCBoYXNoIGl0XG4gICAgICB2YXIga2V5bGVuID0ga2V5Lmxlbmd0aCgpO1xuICAgICAgaWYoa2V5bGVuID4gX21kLmJsb2NrTGVuZ3RoKSB7XG4gICAgICAgIF9tZC5zdGFydCgpO1xuICAgICAgICBfbWQudXBkYXRlKGtleS5ieXRlcygpKTtcbiAgICAgICAga2V5ID0gX21kLmRpZ2VzdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBtaXgga2V5IGludG8gaW5uZXIgYW5kIG91dGVyIHBhZGRpbmdcbiAgICAgIC8vIGlwYWRkaW5nID0gWzB4MzYgKiBibG9ja3NpemVdIF4ga2V5XG4gICAgICAvLyBvcGFkZGluZyA9IFsweDVDICogYmxvY2tzaXplXSBeIGtleVxuICAgICAgX2lwYWRkaW5nID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9vcGFkZGluZyA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBrZXlsZW4gPSBrZXkubGVuZ3RoKCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwga2V5bGVuOyArK2kpIHtcbiAgICAgICAgdmFyIHRtcCA9IGtleS5hdChpKTtcbiAgICAgICAgX2lwYWRkaW5nLnB1dEJ5dGUoMHgzNiBeIHRtcCk7XG4gICAgICAgIF9vcGFkZGluZy5wdXRCeXRlKDB4NUMgXiB0bXApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBrZXkgaXMgc2hvcnRlciB0aGFuIGJsb2Nrc2l6ZSwgYWRkIGFkZGl0aW9uYWwgcGFkZGluZ1xuICAgICAgaWYoa2V5bGVuIDwgX21kLmJsb2NrTGVuZ3RoKSB7XG4gICAgICAgIHZhciB0bXAgPSBfbWQuYmxvY2tMZW5ndGggLSBrZXlsZW47XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXA7ICsraSkge1xuICAgICAgICAgIF9pcGFkZGluZy5wdXRCeXRlKDB4MzYpO1xuICAgICAgICAgIF9vcGFkZGluZy5wdXRCeXRlKDB4NUMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfa2V5ID0ga2V5O1xuICAgICAgX2lwYWRkaW5nID0gX2lwYWRkaW5nLmJ5dGVzKCk7XG4gICAgICBfb3BhZGRpbmcgPSBfb3BhZGRpbmcuYnl0ZXMoKTtcbiAgICB9XG5cbiAgICAvLyBkaWdlc3QgaXMgZG9uZSBsaWtlIHNvOiBoYXNoKG9wYWRkaW5nIHwgaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpKVxuXG4gICAgLy8gcHJlcGFyZSB0byBkbyBpbm5lciBoYXNoXG4gICAgLy8gaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpXG4gICAgX21kLnN0YXJ0KCk7XG4gICAgX21kLnVwZGF0ZShfaXBhZGRpbmcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBITUFDIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gdXBkYXRlIHdpdGguXG4gICAqL1xuICBjdHgudXBkYXRlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICBfbWQudXBkYXRlKGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIE1lc3NhZ2UgQXV0aGVudGljYXRpb24gQ29kZSAoTUFDKS5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIGN0eC5nZXRNYWMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBkaWdlc3QgaXMgZG9uZSBsaWtlIHNvOiBoYXNoKG9wYWRkaW5nIHwgaGFzaChpcGFkZGluZyB8IG1lc3NhZ2UpKVxuICAgIC8vIGhlcmUgd2UgZG8gdGhlIG91dGVyIGhhc2hpbmdcbiAgICB2YXIgaW5uZXIgPSBfbWQuZGlnZXN0KCkuYnl0ZXMoKTtcbiAgICBfbWQuc3RhcnQoKTtcbiAgICBfbWQudXBkYXRlKF9vcGFkZGluZyk7XG4gICAgX21kLnVwZGF0ZShpbm5lcik7XG4gICAgcmV0dXJuIF9tZC5kaWdlc3QoKTtcbiAgfTtcbiAgLy8gYWxpYXMgZm9yIGdldE1hY1xuICBjdHguZGlnZXN0ID0gY3R4LmdldE1hYztcblxuICByZXR1cm4gY3R4O1xufTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAwNSAgVG9tIFd1XG4vLyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIFwiTElDRU5TRVwiIGZvciBkZXRhaWxzLlxuXG4vLyBCYXNpYyBKYXZhU2NyaXB0IEJOIGxpYnJhcnkgLSBzdWJzZXQgdXNlZnVsIGZvciBSU0EgZW5jcnlwdGlvbi5cblxuLypcbkxpY2Vuc2luZyAoTElDRU5TRSlcbi0tLS0tLS0tLS0tLS0tLS0tLS1cblxuVGhpcyBzb2Z0d2FyZSBpcyBjb3ZlcmVkIHVuZGVyIHRoZSBmb2xsb3dpbmcgY29weXJpZ2h0OlxuKi9cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDMtMjAwNSAgVG9tIFd1XG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTLUlTXCIgQU5EIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTLCBJTVBMSUVEIE9SIE9USEVSV0lTRSwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiwgQU5ZXG4gKiBXQVJSQU5UWSBPRiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4gKlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVE9NIFdVIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIElOQ0lERU5UQUwsXG4gKiBJTkRJUkVDVCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT0YgQU5ZIEtJTkQsIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVJcbiAqIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgT1IgTk9UIEFEVklTRUQgT0ZcbiAqIFRIRSBQT1NTSUJJTElUWSBPRiBEQU1BR0UsIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgQVJJU0lORyBPVVRcbiAqIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4gKlxuICogSW4gYWRkaXRpb24sIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGFwcGxpZXM6XG4gKlxuICogQWxsIHJlZGlzdHJpYnV0aW9ucyBtdXN0IHJldGFpbiBhbiBpbnRhY3QgY29weSBvZiB0aGlzIGNvcHlyaWdodCBub3RpY2VcbiAqIGFuZCBkaXNjbGFpbWVyLlxuICovXG4vKlxuQWRkcmVzcyBhbGwgcXVlc3Rpb25zIHJlZ2FyZGluZyB0aGlzIGxpY2Vuc2UgdG86XG5cbiAgVG9tIFd1XG4gIHRqd0Bjcy5TdGFuZm9yZC5FRFVcbiovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UuanNibiA9IGZvcmdlLmpzYm4gfHwge307XG5cbi8vIEJpdHMgcGVyIGRpZ2l0XG52YXIgZGJpdHM7XG5cbi8vIEphdmFTY3JpcHQgZW5naW5lIGFuYWx5c2lzXG52YXIgY2FuYXJ5ID0gMHhkZWFkYmVlZmNhZmU7XG52YXIgal9sbSA9ICgoY2FuYXJ5JjB4ZmZmZmZmKT09MHhlZmNhZmUpO1xuXG4vLyAocHVibGljKSBDb25zdHJ1Y3RvclxuZnVuY3Rpb24gQmlnSW50ZWdlcihhLGIsYykge1xuICB0aGlzLmRhdGEgPSBbXTtcbiAgaWYoYSAhPSBudWxsKVxuICAgIGlmKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHRoaXMuZnJvbU51bWJlcihhLGIsYyk7XG4gICAgZWxzZSBpZihiID09IG51bGwgJiYgXCJzdHJpbmdcIiAhPSB0eXBlb2YgYSkgdGhpcy5mcm9tU3RyaW5nKGEsMjU2KTtcbiAgICBlbHNlIHRoaXMuZnJvbVN0cmluZyhhLGIpO1xufVxuZm9yZ2UuanNibi5CaWdJbnRlZ2VyID0gQmlnSW50ZWdlcjtcblxuLy8gcmV0dXJuIG5ldywgdW5zZXQgQmlnSW50ZWdlclxuZnVuY3Rpb24gbmJpKCkgeyByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7IH1cblxuLy8gYW06IENvbXB1dGUgd19qICs9ICh4KnRoaXNfaSksIHByb3BhZ2F0ZSBjYXJyaWVzLFxuLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuLy8gYyA8IDMqZHZhbHVlLCB4IDwgMipkdmFsdWUsIHRoaXNfaSA8IGR2YWx1ZVxuLy8gV2UgbmVlZCB0byBzZWxlY3QgdGhlIGZhc3Rlc3Qgb25lIHRoYXQgd29ya3MgaW4gdGhpcyBlbnZpcm9ubWVudC5cblxuLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxuLy8gbWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDI2IGJlY2F1c2Vcbi8vIG1heCBpbnRlcm5hbCB2YWx1ZSA9IDIqZHZhbHVlXjItMipkdmFsdWUgKDwgMl41MylcbmZ1bmN0aW9uIGFtMShpLHgsdyxqLGMsbikge1xuICB3aGlsZSgtLW4gPj0gMCkge1xuICAgIHZhciB2ID0geCp0aGlzLmRhdGFbaSsrXSt3LmRhdGFbal0rYztcbiAgICBjID0gTWF0aC5mbG9vcih2LzB4NDAwMDAwMCk7XG4gICAgdy5kYXRhW2orK10gPSB2JjB4M2ZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cbi8vIGFtMiBhdm9pZHMgYSBiaWcgbXVsdC1hbmQtZXh0cmFjdCBjb21wbGV0ZWx5LlxuLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbi8vIG9uIHZhbHVlcyB1cCB0byAyKmhkdmFsdWVeMi1oZHZhbHVlLTEgKDwgMl4zMSlcbmZ1bmN0aW9uIGFtMihpLHgsdyxqLGMsbikge1xuICB2YXIgeGwgPSB4JjB4N2ZmZiwgeGggPSB4Pj4xNTtcbiAgd2hpbGUoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtpXSYweDdmZmY7XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbaSsrXT4+MTU7XG4gICAgdmFyIG0gPSB4aCpsK2gqeGw7XG4gICAgbCA9IHhsKmwrKChtJjB4N2ZmZik8PDE1KSt3LmRhdGFbal0rKGMmMHgzZmZmZmZmZik7XG4gICAgYyA9IChsPj4+MzApKyhtPj4+MTUpK3hoKmgrKGM+Pj4zMCk7XG4gICAgdy5kYXRhW2orK10gPSBsJjB4M2ZmZmZmZmY7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG4vLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcbi8vIGJyb3dzZXJzIHNsb3cgZG93biB3aGVuIGRlYWxpbmcgd2l0aCAzMi1iaXQgbnVtYmVycy5cbmZ1bmN0aW9uIGFtMyhpLHgsdyxqLGMsbikge1xuICB2YXIgeGwgPSB4JjB4M2ZmZiwgeGggPSB4Pj4xNDtcbiAgd2hpbGUoLS1uID49IDApIHtcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtpXSYweDNmZmY7XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbaSsrXT4+MTQ7XG4gICAgdmFyIG0gPSB4aCpsK2gqeGw7XG4gICAgbCA9IHhsKmwrKChtJjB4M2ZmZik8PDE0KSt3LmRhdGFbal0rYztcbiAgICBjID0gKGw+PjI4KSsobT4+MTQpK3hoKmg7XG4gICAgdy5kYXRhW2orK10gPSBsJjB4ZmZmZmZmZjtcbiAgfVxuICByZXR1cm4gYztcbn1cblxuLy8gbm9kZS5qcyAobm8gYnJvd3NlcilcbmlmKHR5cGVvZihuYXZpZ2F0b3IpID09PSAndW5kZWZpbmVkJylcbntcbiAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0zO1xuICAgZGJpdHMgPSAyODtcbn0gZWxzZSBpZihqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiKSkge1xuICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMjtcbiAgZGJpdHMgPSAzMDtcbn0gZWxzZSBpZihqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpKSB7XG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0xO1xuICBkYml0cyA9IDI2O1xufSBlbHNlIHsgLy8gTW96aWxsYS9OZXRzY2FwZSBzZWVtcyB0byBwcmVmZXIgYW0zXG4gIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0zO1xuICBkYml0cyA9IDI4O1xufVxuXG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5EQiA9IGRiaXRzO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRE0gPSAoKDE8PGRiaXRzKS0xKTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLkRWID0gKDE8PGRiaXRzKTtcblxudmFyIEJJX0ZQID0gNTI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5GViA9IE1hdGgucG93KDIsQklfRlApO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuRjEgPSBCSV9GUC1kYml0cztcbkJpZ0ludGVnZXIucHJvdG90eXBlLkYyID0gMipkYml0cy1CSV9GUDtcblxuLy8gRGlnaXQgY29udmVyc2lvbnNcbnZhciBCSV9STSA9IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG52YXIgQklfUkMgPSBuZXcgQXJyYXkoKTtcbnZhciBycix2djtcbnJyID0gXCIwXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDA7IHZ2IDw9IDk7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG5yciA9IFwiYVwiLmNoYXJDb2RlQXQoMCk7XG5mb3IodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcbnJyID0gXCJBXCIuY2hhckNvZGVBdCgwKTtcbmZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xuXG5mdW5jdGlvbiBpbnQyY2hhcihuKSB7IHJldHVybiBCSV9STS5jaGFyQXQobik7IH1cbmZ1bmN0aW9uIGludEF0KHMsaSkge1xuICB2YXIgYyA9IEJJX1JDW3MuY2hhckNvZGVBdChpKV07XG4gIHJldHVybiAoYz09bnVsbCk/LTE6Yztcbn1cblxuLy8gKHByb3RlY3RlZCkgY29weSB0aGlzIHRvIHJcbmZ1bmN0aW9uIGJucENvcHlUbyhyKSB7XG4gIGZvcih2YXIgaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgci5kYXRhW2ldID0gdGhpcy5kYXRhW2ldO1xuICByLnQgPSB0aGlzLnQ7XG4gIHIucyA9IHRoaXMucztcbn1cblxuLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG5mdW5jdGlvbiBibnBGcm9tSW50KHgpIHtcbiAgdGhpcy50ID0gMTtcbiAgdGhpcy5zID0gKHg8MCk/LTE6MDtcbiAgaWYoeCA+IDApIHRoaXMuZGF0YVswXSA9IHg7XG4gIGVsc2UgaWYoeCA8IC0xKSB0aGlzLmRhdGFbMF0gPSB4K3RoaXMuRFY7XG4gIGVsc2UgdGhpcy50ID0gMDtcbn1cblxuLy8gcmV0dXJuIGJpZ2ludCBpbml0aWFsaXplZCB0byB2YWx1ZVxuZnVuY3Rpb24gbmJ2KGkpIHsgdmFyIHIgPSBuYmkoKTsgci5mcm9tSW50KGkpOyByZXR1cm4gcjsgfVxuXG4vLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBzdHJpbmcgYW5kIHJhZGl4XG5mdW5jdGlvbiBibnBGcm9tU3RyaW5nKHMsYikge1xuICB2YXIgaztcbiAgaWYoYiA9PSAxNikgayA9IDQ7XG4gIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgZWxzZSBpZihiID09IDI1NikgayA9IDg7IC8vIGJ5dGUgYXJyYXlcbiAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICBlbHNlIGlmKGIgPT0gMzIpIGsgPSA1O1xuICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gIGVsc2UgeyB0aGlzLmZyb21SYWRpeChzLGIpOyByZXR1cm47IH1cbiAgdGhpcy50ID0gMDtcbiAgdGhpcy5zID0gMDtcbiAgdmFyIGkgPSBzLmxlbmd0aCwgbWkgPSBmYWxzZSwgc2ggPSAwO1xuICB3aGlsZSgtLWkgPj0gMCkge1xuICAgIHZhciB4ID0gKGs9PTgpP3NbaV0mMHhmZjppbnRBdChzLGkpO1xuICAgIGlmKHggPCAwKSB7XG4gICAgICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIikgbWkgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1pID0gZmFsc2U7XG4gICAgaWYoc2ggPT0gMClcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQrK10gPSB4O1xuICAgIGVsc2UgaWYoc2grayA+IHRoaXMuREIpIHtcbiAgICAgIHRoaXMuZGF0YVt0aGlzLnQtMV0gfD0gKHgmKCgxPDwodGhpcy5EQi1zaCkpLTEpKTw8c2g7XG4gICAgICB0aGlzLmRhdGFbdGhpcy50KytdID0gKHg+Pih0aGlzLkRCLXNoKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmRhdGFbdGhpcy50LTFdIHw9IHg8PHNoO1xuICAgIHNoICs9IGs7XG4gICAgaWYoc2ggPj0gdGhpcy5EQikgc2ggLT0gdGhpcy5EQjtcbiAgfVxuICBpZihrID09IDggJiYgKHNbMF0mMHg4MCkgIT0gMCkge1xuICAgIHRoaXMucyA9IC0xO1xuICAgIGlmKHNoID4gMCkgdGhpcy5kYXRhW3RoaXMudC0xXSB8PSAoKDE8PCh0aGlzLkRCLXNoKSktMSk8PHNoO1xuICB9XG4gIHRoaXMuY2xhbXAoKTtcbiAgaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xufVxuXG4vLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbmZ1bmN0aW9uIGJucENsYW1wKCkge1xuICB2YXIgYyA9IHRoaXMucyZ0aGlzLkRNO1xuICB3aGlsZSh0aGlzLnQgPiAwICYmIHRoaXMuZGF0YVt0aGlzLnQtMV0gPT0gYykgLS10aGlzLnQ7XG59XG5cbi8vIChwdWJsaWMpIHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gZ2l2ZW4gcmFkaXhcbmZ1bmN0aW9uIGJuVG9TdHJpbmcoYikge1xuICBpZih0aGlzLnMgPCAwKSByZXR1cm4gXCItXCIrdGhpcy5uZWdhdGUoKS50b1N0cmluZyhiKTtcbiAgdmFyIGs7XG4gIGlmKGIgPT0gMTYpIGsgPSA0O1xuICBlbHNlIGlmKGIgPT0gOCkgayA9IDM7XG4gIGVsc2UgaWYoYiA9PSAyKSBrID0gMTtcbiAgZWxzZSBpZihiID09IDMyKSBrID0gNTtcbiAgZWxzZSBpZihiID09IDQpIGsgPSAyO1xuICBlbHNlIHJldHVybiB0aGlzLnRvUmFkaXgoYik7XG4gIHZhciBrbSA9ICgxPDxrKS0xLCBkLCBtID0gZmFsc2UsIHIgPSBcIlwiLCBpID0gdGhpcy50O1xuICB2YXIgcCA9IHRoaXMuREItKGkqdGhpcy5EQiklaztcbiAgaWYoaS0tID4gMCkge1xuICAgIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpcy5kYXRhW2ldPj5wKSA+IDApIHsgbSA9IHRydWU7IHIgPSBpbnQyY2hhcihkKTsgfVxuICAgIHdoaWxlKGkgPj0gMCkge1xuICAgICAgaWYocCA8IGspIHtcbiAgICAgICAgZCA9ICh0aGlzLmRhdGFbaV0mKCgxPDxwKS0xKSk8PChrLXApO1xuICAgICAgICBkIHw9IHRoaXMuZGF0YVstLWldPj4ocCs9dGhpcy5EQi1rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSAodGhpcy5kYXRhW2ldPj4ocC09aykpJmttO1xuICAgICAgICBpZihwIDw9IDApIHsgcCArPSB0aGlzLkRCOyAtLWk7IH1cbiAgICAgIH1cbiAgICAgIGlmKGQgPiAwKSBtID0gdHJ1ZTtcbiAgICAgIGlmKG0pIHIgKz0gaW50MmNoYXIoZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtP3I6XCIwXCI7XG59XG5cbi8vIChwdWJsaWMpIC10aGlzXG5mdW5jdGlvbiBibk5lZ2F0ZSgpIHsgdmFyIHIgPSBuYmkoKTsgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHRoaXMscik7IHJldHVybiByOyB9XG5cbi8vIChwdWJsaWMpIHx0aGlzfFxuZnVuY3Rpb24gYm5BYnMoKSB7IHJldHVybiAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpczsgfVxuXG4vLyAocHVibGljKSByZXR1cm4gKyBpZiB0aGlzID4gYSwgLSBpZiB0aGlzIDwgYSwgMCBpZiBlcXVhbFxuZnVuY3Rpb24gYm5Db21wYXJlVG8oYSkge1xuICB2YXIgciA9IHRoaXMucy1hLnM7XG4gIGlmKHIgIT0gMCkgcmV0dXJuIHI7XG4gIHZhciBpID0gdGhpcy50O1xuICByID0gaS1hLnQ7XG4gIGlmKHIgIT0gMCkgcmV0dXJuICh0aGlzLnM8MCk/LXI6cjtcbiAgd2hpbGUoLS1pID49IDApIGlmKChyPXRoaXMuZGF0YVtpXS1hLmRhdGFbaV0pICE9IDApIHJldHVybiByO1xuICByZXR1cm4gMDtcbn1cblxuLy8gcmV0dXJucyBiaXQgbGVuZ3RoIG9mIHRoZSBpbnRlZ2VyIHhcbmZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgdmFyIHIgPSAxLCB0O1xuICBpZigodD14Pj4+MTYpICE9IDApIHsgeCA9IHQ7IHIgKz0gMTY7IH1cbiAgaWYoKHQ9eD4+OCkgIT0gMCkgeyB4ID0gdDsgciArPSA4OyB9XG4gIGlmKCh0PXg+PjQpICE9IDApIHsgeCA9IHQ7IHIgKz0gNDsgfVxuICBpZigodD14Pj4yKSAhPSAwKSB7IHggPSB0OyByICs9IDI7IH1cbiAgaWYoKHQ9eD4+MSkgIT0gMCkgeyB4ID0gdDsgciArPSAxOyB9XG4gIHJldHVybiByO1xufVxuXG4vLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG5mdW5jdGlvbiBibkJpdExlbmd0aCgpIHtcbiAgaWYodGhpcy50IDw9IDApIHJldHVybiAwO1xuICByZXR1cm4gdGhpcy5EQioodGhpcy50LTEpK25iaXRzKHRoaXMuZGF0YVt0aGlzLnQtMV1eKHRoaXMucyZ0aGlzLkRNKSk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcbmZ1bmN0aW9uIGJucERMU2hpZnRUbyhuLHIpIHtcbiAgdmFyIGk7XG4gIGZvcihpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaStuXSA9IHRoaXMuZGF0YVtpXTtcbiAgZm9yKGkgPSBuLTE7IGkgPj0gMDsgLS1pKSByLmRhdGFbaV0gPSAwO1xuICByLnQgPSB0aGlzLnQrbjtcbiAgci5zID0gdGhpcy5zO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuKkRCXG5mdW5jdGlvbiBibnBEUlNoaWZ0VG8obixyKSB7XG4gIGZvcih2YXIgaSA9IG47IGkgPCB0aGlzLnQ7ICsraSkgci5kYXRhW2ktbl0gPSB0aGlzLmRhdGFbaV07XG4gIHIudCA9IE1hdGgubWF4KHRoaXMudC1uLDApO1xuICByLnMgPSB0aGlzLnM7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG5cbmZ1bmN0aW9uIGJucExTaGlmdFRvKG4scikge1xuICB2YXIgYnMgPSBuJXRoaXMuREI7XG4gIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICB2YXIgYm0gPSAoMTw8Y2JzKS0xO1xuICB2YXIgZHMgPSBNYXRoLmZsb29yKG4vdGhpcy5EQiksIGMgPSAodGhpcy5zPDxicykmdGhpcy5ETSwgaTtcbiAgZm9yKGkgPSB0aGlzLnQtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICByLmRhdGFbaStkcysxXSA9ICh0aGlzLmRhdGFbaV0+PmNicyl8YztcbiAgICBjID0gKHRoaXMuZGF0YVtpXSZibSk8PGJzO1xuICB9XG4gIGZvcihpID0gZHMtMTsgaSA+PSAwOyAtLWkpIHIuZGF0YVtpXSA9IDA7XG4gIHIuZGF0YVtkc10gPSBjO1xuICByLnQgPSB0aGlzLnQrZHMrMTtcbiAgci5zID0gdGhpcy5zO1xuICByLmNsYW1wKCk7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG5cbmZ1bmN0aW9uIGJucFJTaGlmdFRvKG4scikge1xuICByLnMgPSB0aGlzLnM7XG4gIHZhciBkcyA9IE1hdGguZmxvb3Iobi90aGlzLkRCKTtcbiAgaWYoZHMgPj0gdGhpcy50KSB7IHIudCA9IDA7IHJldHVybjsgfVxuICB2YXIgYnMgPSBuJXRoaXMuREI7XG4gIHZhciBjYnMgPSB0aGlzLkRCLWJzO1xuICB2YXIgYm0gPSAoMTw8YnMpLTE7XG4gIHIuZGF0YVswXSA9IHRoaXMuZGF0YVtkc10+PmJzO1xuICBmb3IodmFyIGkgPSBkcysxOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICByLmRhdGFbaS1kcy0xXSB8PSAodGhpcy5kYXRhW2ldJmJtKTw8Y2JzO1xuICAgIHIuZGF0YVtpLWRzXSA9IHRoaXMuZGF0YVtpXT4+YnM7XG4gIH1cbiAgaWYoYnMgPiAwKSByLmRhdGFbdGhpcy50LWRzLTFdIHw9ICh0aGlzLnMmYm0pPDxjYnM7XG4gIHIudCA9IHRoaXMudC1kcztcbiAgci5jbGFtcCgpO1xufVxuXG4vLyAocHJvdGVjdGVkKSByID0gdGhpcyAtIGFcbmZ1bmN0aW9uIGJucFN1YlRvKGEscikge1xuICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gIHdoaWxlKGkgPCBtKSB7XG4gICAgYyArPSB0aGlzLmRhdGFbaV0tYS5kYXRhW2ldO1xuICAgIHIuZGF0YVtpKytdID0gYyZ0aGlzLkRNO1xuICAgIGMgPj49IHRoaXMuREI7XG4gIH1cbiAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgYyAtPSBhLnM7XG4gICAgd2hpbGUoaSA8IHRoaXMudCkge1xuICAgICAgYyArPSB0aGlzLmRhdGFbaV07XG4gICAgICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgIGMgPj49IHRoaXMuREI7XG4gICAgfVxuICAgIGMgKz0gdGhpcy5zO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gdGhpcy5zO1xuICAgIHdoaWxlKGkgPCBhLnQpIHtcbiAgICAgIGMgLT0gYS5kYXRhW2ldO1xuICAgICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICAgICBjID4+PSB0aGlzLkRCO1xuICAgIH1cbiAgICBjIC09IGEucztcbiAgfVxuICByLnMgPSAoYzwwKT8tMTowO1xuICBpZihjIDwgLTEpIHIuZGF0YVtpKytdID0gdGhpcy5EVitjO1xuICBlbHNlIGlmKGMgPiAwKSByLmRhdGFbaSsrXSA9IGM7XG4gIHIudCA9IGk7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlUbyhhLHIpIHtcbiAgdmFyIHggPSB0aGlzLmFicygpLCB5ID0gYS5hYnMoKTtcbiAgdmFyIGkgPSB4LnQ7XG4gIHIudCA9IGkreS50O1xuICB3aGlsZSgtLWkgPj0gMCkgci5kYXRhW2ldID0gMDtcbiAgZm9yKGkgPSAwOyBpIDwgeS50OyArK2kpIHIuZGF0YVtpK3gudF0gPSB4LmFtKDAseS5kYXRhW2ldLHIsaSwwLHgudCk7XG4gIHIucyA9IDA7XG4gIHIuY2xhbXAoKTtcbiAgaWYodGhpcy5zICE9IGEucykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG59XG5cbi8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuZnVuY3Rpb24gYm5wU3F1YXJlVG8ocikge1xuICB2YXIgeCA9IHRoaXMuYWJzKCk7XG4gIHZhciBpID0gci50ID0gMip4LnQ7XG4gIHdoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuICBmb3IoaSA9IDA7IGkgPCB4LnQtMTsgKytpKSB7XG4gICAgdmFyIGMgPSB4LmFtKGkseC5kYXRhW2ldLHIsMippLDAsMSk7XG4gICAgaWYoKHIuZGF0YVtpK3gudF0rPXguYW0oaSsxLDIqeC5kYXRhW2ldLHIsMippKzEsYyx4LnQtaS0xKSkgPj0geC5EVikge1xuICAgICAgci5kYXRhW2kreC50XSAtPSB4LkRWO1xuICAgICAgci5kYXRhW2kreC50KzFdID0gMTtcbiAgICB9XG4gIH1cbiAgaWYoci50ID4gMCkgci5kYXRhW3IudC0xXSArPSB4LmFtKGkseC5kYXRhW2ldLHIsMippLDAsMSk7XG4gIHIucyA9IDA7XG4gIHIuY2xhbXAoKTtcbn1cblxuLy8gKHByb3RlY3RlZCkgZGl2aWRlIHRoaXMgYnkgbSwgcXVvdGllbnQgYW5kIHJlbWFpbmRlciB0byBxLCByIChIQUMgMTQuMjApXG4vLyByICE9IHEsIHRoaXMgIT0gbS4gIHEgb3IgciBtYXkgYmUgbnVsbC5cbmZ1bmN0aW9uIGJucERpdlJlbVRvKG0scSxyKSB7XG4gIHZhciBwbSA9IG0uYWJzKCk7XG4gIGlmKHBtLnQgPD0gMCkgcmV0dXJuO1xuICB2YXIgcHQgPSB0aGlzLmFicygpO1xuICBpZihwdC50IDwgcG0udCkge1xuICAgIGlmKHEgIT0gbnVsbCkgcS5mcm9tSW50KDApO1xuICAgIGlmKHIgIT0gbnVsbCkgdGhpcy5jb3B5VG8ocik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmKHIgPT0gbnVsbCkgciA9IG5iaSgpO1xuICB2YXIgeSA9IG5iaSgpLCB0cyA9IHRoaXMucywgbXMgPSBtLnM7XG4gIHZhciBuc2ggPSB0aGlzLkRCLW5iaXRzKHBtLmRhdGFbcG0udC0xXSk7XHQvLyBub3JtYWxpemUgbW9kdWx1c1xuICBpZihuc2ggPiAwKSB7IHBtLmxTaGlmdFRvKG5zaCx5KTsgcHQubFNoaWZ0VG8obnNoLHIpOyB9IGVsc2UgeyBwbS5jb3B5VG8oeSk7IHB0LmNvcHlUbyhyKTsgfVxuICB2YXIgeXMgPSB5LnQ7XG4gIHZhciB5MCA9IHkuZGF0YVt5cy0xXTtcbiAgaWYoeTAgPT0gMCkgcmV0dXJuO1xuICB2YXIgeXQgPSB5MCooMTw8dGhpcy5GMSkrKCh5cz4xKT95LmRhdGFbeXMtMl0+PnRoaXMuRjI6MCk7XG4gIHZhciBkMSA9IHRoaXMuRlYveXQsIGQyID0gKDE8PHRoaXMuRjEpL3l0LCBlID0gMTw8dGhpcy5GMjtcbiAgdmFyIGkgPSByLnQsIGogPSBpLXlzLCB0ID0gKHE9PW51bGwpP25iaSgpOnE7XG4gIHkuZGxTaGlmdFRvKGosdCk7XG4gIGlmKHIuY29tcGFyZVRvKHQpID49IDApIHtcbiAgICByLmRhdGFbci50KytdID0gMTtcbiAgICByLnN1YlRvKHQscik7XG4gIH1cbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKHlzLHQpO1xuICB0LnN1YlRvKHkseSk7XHQvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICB3aGlsZSh5LnQgPCB5cykgeS5kYXRhW3kudCsrXSA9IDA7XG4gIHdoaWxlKC0taiA+PSAwKSB7XG4gICAgLy8gRXN0aW1hdGUgcXVvdGllbnQgZGlnaXRcbiAgICB2YXIgcWQgPSAoci5kYXRhWy0taV09PXkwKT90aGlzLkRNOk1hdGguZmxvb3Ioci5kYXRhW2ldKmQxKyhyLmRhdGFbaS0xXStlKSpkMik7XG4gICAgaWYoKHIuZGF0YVtpXSs9eS5hbSgwLHFkLHIsaiwwLHlzKSkgPCBxZCkge1x0Ly8gVHJ5IGl0IG91dFxuICAgICAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgICAgIHIuc3ViVG8odCxyKTtcbiAgICAgIHdoaWxlKHIuZGF0YVtpXSA8IC0tcWQpIHIuc3ViVG8odCxyKTtcbiAgICB9XG4gIH1cbiAgaWYocSAhPSBudWxsKSB7XG4gICAgci5kclNoaWZ0VG8oeXMscSk7XG4gICAgaWYodHMgIT0gbXMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhxLHEpO1xuICB9XG4gIHIudCA9IHlzO1xuICByLmNsYW1wKCk7XG4gIGlmKG5zaCA+IDApIHIuclNoaWZ0VG8obnNoLHIpO1x0Ly8gRGVub3JtYWxpemUgcmVtYWluZGVyXG4gIGlmKHRzIDwgMCkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG59XG5cbi8vIChwdWJsaWMpIHRoaXMgbW9kIGFcbmZ1bmN0aW9uIGJuTW9kKGEpIHtcbiAgdmFyIHIgPSBuYmkoKTtcbiAgdGhpcy5hYnMoKS5kaXZSZW1UbyhhLG51bGwscik7XG4gIGlmKHRoaXMucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIGEuc3ViVG8ocixyKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxuZnVuY3Rpb24gQ2xhc3NpYyhtKSB7IHRoaXMubSA9IG07IH1cbmZ1bmN0aW9uIGNDb252ZXJ0KHgpIHtcbiAgaWYoeC5zIDwgMCB8fCB4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICBlbHNlIHJldHVybiB4O1xufVxuZnVuY3Rpb24gY1JldmVydCh4KSB7IHJldHVybiB4OyB9XG5mdW5jdGlvbiBjUmVkdWNlKHgpIHsgeC5kaXZSZW1Ubyh0aGlzLm0sbnVsbCx4KTsgfVxuZnVuY3Rpb24gY011bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuZnVuY3Rpb24gY1NxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5DbGFzc2ljLnByb3RvdHlwZS5jb252ZXJ0ID0gY0NvbnZlcnQ7XG5DbGFzc2ljLnByb3RvdHlwZS5yZXZlcnQgPSBjUmV2ZXJ0O1xuQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcbkNsYXNzaWMucHJvdG90eXBlLm11bFRvID0gY011bFRvO1xuQ2xhc3NpYy5wcm90b3R5cGUuc3FyVG8gPSBjU3FyVG87XG5cbi8vIChwcm90ZWN0ZWQpIHJldHVybiBcIi0xL3RoaXMgJSAyXkRCXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXG4vLyBqdXN0aWZpY2F0aW9uOlxuLy8gICAgICAgICB4eSA9PSAxIChtb2QgbSlcbi8vICAgICAgICAgeHkgPSAgMStrbVxuLy8gICB4eSgyLXh5KSA9ICgxK2ttKSgxLWttKVxuLy8geFt5KDIteHkpXSA9IDEta14ybV4yXG4vLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXG4vLyBpZiB5IGlzIDEveCBtb2QgbSwgdGhlbiB5KDIteHkpIGlzIDEveCBtb2QgbV4yXG4vLyBzaG91bGQgcmVkdWNlIHggYW5kIHkoMi14eSkgYnkgbV4yIGF0IGVhY2ggc3RlcCB0byBrZWVwIHNpemUgYm91bmRlZC5cbi8vIEpTIG11bHRpcGx5IFwib3ZlcmZsb3dzXCIgZGlmZmVyZW50bHkgZnJvbSBDL0MrKywgc28gY2FyZSBpcyBuZWVkZWQgaGVyZS5cbmZ1bmN0aW9uIGJucEludkRpZ2l0KCkge1xuICBpZih0aGlzLnQgPCAxKSByZXR1cm4gMDtcbiAgdmFyIHggPSB0aGlzLmRhdGFbMF07XG4gIGlmKCh4JjEpID09IDApIHJldHVybiAwO1xuICB2YXIgeSA9IHgmMztcdFx0Ly8geSA9PSAxL3ggbW9kIDJeMlxuICB5ID0gKHkqKDItKHgmMHhmKSp5KSkmMHhmO1x0Ly8geSA9PSAxL3ggbW9kIDJeNFxuICB5ID0gKHkqKDItKHgmMHhmZikqeSkpJjB4ZmY7XHQvLyB5ID09IDEveCBtb2QgMl44XG4gIHkgPSAoeSooMi0oKCh4JjB4ZmZmZikqeSkmMHhmZmZmKSkpJjB4ZmZmZjtcdC8vIHkgPT0gMS94IG1vZCAyXjE2XG4gIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseTtcbiAgLy8gYXNzdW1lcyAxNiA8IERCIDw9IDMyIGFuZCBhc3N1bWVzIGFiaWxpdHkgdG8gaGFuZGxlIDQ4LWJpdCBpbnRzXG4gIHkgPSAoeSooMi14KnkldGhpcy5EVikpJXRoaXMuRFY7XHRcdC8vIHkgPT0gMS94IG1vZCAyXmRiaXRzXG4gIC8vIHdlIHJlYWxseSB3YW50IHRoZSBuZWdhdGl2ZSBpbnZlcnNlLCBhbmQgLURWIDwgeSA8IERWXG4gIHJldHVybiAoeT4wKT90aGlzLkRWLXk6LXk7XG59XG5cbi8vIE1vbnRnb21lcnkgcmVkdWN0aW9uXG5mdW5jdGlvbiBNb250Z29tZXJ5KG0pIHtcbiAgdGhpcy5tID0gbTtcbiAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKTtcbiAgdGhpcy5tcGwgPSB0aGlzLm1wJjB4N2ZmZjtcbiAgdGhpcy5tcGggPSB0aGlzLm1wPj4xNTtcbiAgdGhpcy51bSA9ICgxPDwobS5EQi0xNSkpLTE7XG4gIHRoaXMubXQyID0gMiptLnQ7XG59XG5cbi8vIHhSIG1vZCBtXG5mdW5jdGlvbiBtb250Q29udmVydCh4KSB7XG4gIHZhciByID0gbmJpKCk7XG4gIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LHIpO1xuICByLmRpdlJlbVRvKHRoaXMubSxudWxsLHIpO1xuICBpZih4LnMgPCAwICYmIHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuWkVSTykgPiAwKSB0aGlzLm0uc3ViVG8ocixyKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIHgvUiBtb2QgbVxuZnVuY3Rpb24gbW9udFJldmVydCh4KSB7XG4gIHZhciByID0gbmJpKCk7XG4gIHguY29weVRvKHIpO1xuICB0aGlzLnJlZHVjZShyKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIHggPSB4L1IgbW9kIG0gKEhBQyAxNC4zMilcbmZ1bmN0aW9uIG1vbnRSZWR1Y2UoeCkge1xuICB3aGlsZSh4LnQgPD0gdGhpcy5tdDIpXHQvLyBwYWQgeCBzbyBhbSBoYXMgZW5vdWdoIHJvb20gbGF0ZXJcbiAgICB4LmRhdGFbeC50KytdID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubS50OyArK2kpIHtcbiAgICAvLyBmYXN0ZXIgd2F5IG9mIGNhbGN1bGF0aW5nIHUwID0geC5kYXRhW2ldKm1wIG1vZCBEVlxuICAgIHZhciBqID0geC5kYXRhW2ldJjB4N2ZmZjtcbiAgICB2YXIgdTAgPSAoaip0aGlzLm1wbCsoKChqKnRoaXMubXBoKyh4LmRhdGFbaV0+PjE1KSp0aGlzLm1wbCkmdGhpcy51bSk8PDE1KSkmeC5ETTtcbiAgICAvLyB1c2UgYW0gdG8gY29tYmluZSB0aGUgbXVsdGlwbHktc2hpZnQtYWRkIGludG8gb25lIGNhbGxcbiAgICBqID0gaSt0aGlzLm0udDtcbiAgICB4LmRhdGFbal0gKz0gdGhpcy5tLmFtKDAsdTAseCxpLDAsdGhpcy5tLnQpO1xuICAgIC8vIHByb3BhZ2F0ZSBjYXJyeVxuICAgIHdoaWxlKHguZGF0YVtqXSA+PSB4LkRWKSB7IHguZGF0YVtqXSAtPSB4LkRWOyB4LmRhdGFbKytqXSsrOyB9XG4gIH1cbiAgeC5jbGFtcCgpO1xuICB4LmRyU2hpZnRUbyh0aGlzLm0udCx4KTtcbiAgaWYoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbn1cblxuLy8gciA9IFwieF4yL1IgbW9kIG1cIjsgeCAhPSByXG5mdW5jdGlvbiBtb250U3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbi8vIHIgPSBcInh5L1IgbW9kIG1cIjsgeCx5ICE9IHJcbmZ1bmN0aW9uIG1vbnRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuTW9udGdvbWVyeS5wcm90b3R5cGUuY29udmVydCA9IG1vbnRDb252ZXJ0O1xuTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcbk1vbnRnb21lcnkucHJvdG90eXBlLnJlZHVjZSA9IG1vbnRSZWR1Y2U7XG5Nb250Z29tZXJ5LnByb3RvdHlwZS5tdWxUbyA9IG1vbnRNdWxUbztcbk1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvO1xuXG4vLyAocHJvdGVjdGVkKSB0cnVlIGlmZiB0aGlzIGlzIGV2ZW5cbmZ1bmN0aW9uIGJucElzRXZlbigpIHsgcmV0dXJuICgodGhpcy50PjApPyh0aGlzLmRhdGFbMF0mMSk6dGhpcy5zKSA9PSAwOyB9XG5cbi8vIChwcm90ZWN0ZWQpIHRoaXNeZSwgZSA8IDJeMzIsIGRvaW5nIHNxciBhbmQgbXVsIHdpdGggXCJyXCIgKEhBQyAxNC43OSlcbmZ1bmN0aW9uIGJucEV4cChlLHopIHtcbiAgaWYoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHJldHVybiBCaWdJbnRlZ2VyLk9ORTtcbiAgdmFyIHIgPSBuYmkoKSwgcjIgPSBuYmkoKSwgZyA9IHouY29udmVydCh0aGlzKSwgaSA9IG5iaXRzKGUpLTE7XG4gIGcuY29weVRvKHIpO1xuICB3aGlsZSgtLWkgPj0gMCkge1xuICAgIHouc3FyVG8ocixyMik7XG4gICAgaWYoKGUmKDE8PGkpKSA+IDApIHoubXVsVG8ocjIsZyxyKTtcbiAgICBlbHNlIHsgdmFyIHQgPSByOyByID0gcjI7IHIyID0gdDsgfVxuICB9XG4gIHJldHVybiB6LnJldmVydChyKTtcbn1cblxuLy8gKHB1YmxpYykgdGhpc15lICUgbSwgMCA8PSBlIDwgMl4zMlxuZnVuY3Rpb24gYm5Nb2RQb3dJbnQoZSxtKSB7XG4gIHZhciB6O1xuICBpZihlIDwgMjU2IHx8IG0uaXNFdmVuKCkpIHogPSBuZXcgQ2xhc3NpYyhtKTsgZWxzZSB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG4gIHJldHVybiB0aGlzLmV4cChlLHopO1xufVxuXG4vLyBwcm90ZWN0ZWRcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNvcHlUbyA9IGJucENvcHlUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBibnBGcm9tSW50O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGJucEZyb21TdHJpbmc7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jbGFtcCA9IGJucENsYW1wO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZHJTaGlmdFRvID0gYm5wRFJTaGlmdFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubFNoaWZ0VG8gPSBibnBMU2hpZnRUbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJUbyA9IGJucFN1YlRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlUbyA9IGJucE11bHRpcGx5VG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGJucFNxdWFyZVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2UmVtVG8gPSBibnBEaXZSZW1UbztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmludkRpZ2l0ID0gYm5wSW52RGlnaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5leHAgPSBibnBFeHA7XG5cbi8vIHB1YmxpY1xuQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBiblRvU3RyaW5nO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gYm5OZWdhdGU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnMgPSBibkFicztcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGJuQ29tcGFyZVRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoID0gYm5CaXRMZW5ndGg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBibk1vZDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGJuTW9kUG93SW50O1xuXG4vLyBcImNvbnN0YW50c1wiXG5CaWdJbnRlZ2VyLlpFUk8gPSBuYnYoMCk7XG5CaWdJbnRlZ2VyLk9ORSA9IG5idigxKTtcblxuLy8ganNibjIgbGliXG5cbi8vQ29weXJpZ2h0IChjKSAyMDA1LTIwMDkgIFRvbSBXdVxuLy9BbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9TZWUgXCJMSUNFTlNFXCIgZm9yIGRldGFpbHMgKFNlZSBqc2JuLmpzIGZvciBMSUNFTlNFKS5cblxuLy9FeHRlbmRlZCBKYXZhU2NyaXB0IEJOIGZ1bmN0aW9ucywgcmVxdWlyZWQgZm9yIFJTQSBwcml2YXRlIG9wcy5cblxuLy9WZXJzaW9uIDEuMTogbmV3IEJpZ0ludGVnZXIoXCIwXCIsIDEwKSByZXR1cm5zIFwicHJvcGVyXCIgemVyb1xuXG4vLyhwdWJsaWMpXG5mdW5jdGlvbiBibkNsb25lKCkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmNvcHlUbyhyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgaW50ZWdlclxuZnVuY3Rpb24gYm5JbnRWYWx1ZSgpIHtcbmlmKHRoaXMucyA8IDApIHtcbiBpZih0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXMuZGF0YVswXS10aGlzLkRWO1xuIGVsc2UgaWYodGhpcy50ID09IDApIHJldHVybiAtMTtcbn0gZWxzZSBpZih0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXMuZGF0YVswXTtcbmVsc2UgaWYodGhpcy50ID09IDApIHJldHVybiAwO1xuLy8gYXNzdW1lcyAxNiA8IERCIDwgMzJcbnJldHVybiAoKHRoaXMuZGF0YVsxXSYoKDE8PCgzMi10aGlzLkRCKSktMSkpPDx0aGlzLkRCKXx0aGlzLmRhdGFbMF07XG59XG5cbi8vKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbmZ1bmN0aW9uIGJuQnl0ZVZhbHVlKCkgeyByZXR1cm4gKHRoaXMudD09MCk/dGhpcy5zOih0aGlzLmRhdGFbMF08PDI0KT4+MjQ7IH1cblxuLy8ocHVibGljKSByZXR1cm4gdmFsdWUgYXMgc2hvcnQgKGFzc3VtZXMgREI+PTE2KVxuZnVuY3Rpb24gYm5TaG9ydFZhbHVlKCkgeyByZXR1cm4gKHRoaXMudD09MCk/dGhpcy5zOih0aGlzLmRhdGFbMF08PDE2KT4+MTY7IH1cblxuLy8ocHJvdGVjdGVkKSByZXR1cm4geCBzLnQuIHJeeCA8IERWXG5mdW5jdGlvbiBibnBDaHVua1NpemUocikgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMip0aGlzLkRCL01hdGgubG9nKHIpKTsgfVxuXG4vLyhwdWJsaWMpIDAgaWYgdGhpcyA9PSAwLCAxIGlmIHRoaXMgPiAwXG5mdW5jdGlvbiBiblNpZ051bSgpIHtcbmlmKHRoaXMucyA8IDApIHJldHVybiAtMTtcbmVsc2UgaWYodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXMuZGF0YVswXSA8PSAwKSkgcmV0dXJuIDA7XG5lbHNlIHJldHVybiAxO1xufVxuXG4vLyhwcm90ZWN0ZWQpIGNvbnZlcnQgdG8gcmFkaXggc3RyaW5nXG5mdW5jdGlvbiBibnBUb1JhZGl4KGIpIHtcbmlmKGIgPT0gbnVsbCkgYiA9IDEwO1xuaWYodGhpcy5zaWdudW0oKSA9PSAwIHx8IGIgPCAyIHx8IGIgPiAzNikgcmV0dXJuIFwiMFwiO1xudmFyIGNzID0gdGhpcy5jaHVua1NpemUoYik7XG52YXIgYSA9IE1hdGgucG93KGIsY3MpO1xudmFyIGQgPSBuYnYoYSksIHkgPSBuYmkoKSwgeiA9IG5iaSgpLCByID0gXCJcIjtcbnRoaXMuZGl2UmVtVG8oZCx5LHopO1xud2hpbGUoeS5zaWdudW0oKSA+IDApIHtcbiByID0gKGErei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkgKyByO1xuIHkuZGl2UmVtVG8oZCx5LHopO1xufVxucmV0dXJuIHouaW50VmFsdWUoKS50b1N0cmluZyhiKSArIHI7XG59XG5cbi8vKHByb3RlY3RlZCkgY29udmVydCBmcm9tIHJhZGl4IHN0cmluZ1xuZnVuY3Rpb24gYm5wRnJvbVJhZGl4KHMsYikge1xudGhpcy5mcm9tSW50KDApO1xuaWYoYiA9PSBudWxsKSBiID0gMTA7XG52YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbnZhciBkID0gTWF0aC5wb3coYixjcyksIG1pID0gZmFsc2UsIGogPSAwLCB3ID0gMDtcbmZvcih2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gdmFyIHggPSBpbnRBdChzLGkpO1xuIGlmKHggPCAwKSB7XG4gICBpZihzLmNoYXJBdChpKSA9PSBcIi1cIiAmJiB0aGlzLnNpZ251bSgpID09IDApIG1pID0gdHJ1ZTtcbiAgIGNvbnRpbnVlO1xuIH1cbiB3ID0gYip3K3g7XG4gaWYoKytqID49IGNzKSB7XG4gICB0aGlzLmRNdWx0aXBseShkKTtcbiAgIHRoaXMuZEFkZE9mZnNldCh3LDApO1xuICAgaiA9IDA7XG4gICB3ID0gMDtcbiB9XG59XG5pZihqID4gMCkge1xuIHRoaXMuZE11bHRpcGx5KE1hdGgucG93KGIsaikpO1xuIHRoaXMuZEFkZE9mZnNldCh3LDApO1xufVxuaWYobWkpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyh0aGlzLHRoaXMpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIGFsdGVybmF0ZSBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gYm5wRnJvbU51bWJlcihhLGIsYykge1xuaWYoXCJudW1iZXJcIiA9PSB0eXBlb2YgYikge1xuIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuIGlmKGEgPCAyKSB0aGlzLmZyb21JbnQoMSk7XG4gZWxzZSB7XG4gICB0aGlzLmZyb21OdW1iZXIoYSxjKTtcbiAgIGlmKCF0aGlzLnRlc3RCaXQoYS0xKSkgIC8vIGZvcmNlIE1TQiBzZXRcbiAgICAgdGhpcy5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGEtMSksb3Bfb3IsdGhpcyk7XG4gICBpZih0aGlzLmlzRXZlbigpKSB0aGlzLmRBZGRPZmZzZXQoMSwwKTsgLy8gZm9yY2Ugb2RkXG4gICB3aGlsZSghdGhpcy5pc1Byb2JhYmxlUHJpbWUoYikpIHtcbiAgICAgdGhpcy5kQWRkT2Zmc2V0KDIsMCk7XG4gICAgIGlmKHRoaXMuYml0TGVuZ3RoKCkgPiBhKSB0aGlzLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLHRoaXMpO1xuICAgfVxuIH1cbn0gZWxzZSB7XG4gLy8gbmV3IEJpZ0ludGVnZXIoaW50LFJORylcbiB2YXIgeCA9IG5ldyBBcnJheSgpLCB0ID0gYSY3O1xuIHgubGVuZ3RoID0gKGE+PjMpKzE7XG4gYi5uZXh0Qnl0ZXMoeCk7XG4gaWYodCA+IDApIHhbMF0gJj0gKCgxPDx0KS0xKTsgZWxzZSB4WzBdID0gMDtcbiB0aGlzLmZyb21TdHJpbmcoeCwyNTYpO1xufVxufVxuXG4vLyhwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcbmZ1bmN0aW9uIGJuVG9CeXRlQXJyYXkoKSB7XG52YXIgaSA9IHRoaXMudCwgciA9IG5ldyBBcnJheSgpO1xuclswXSA9IHRoaXMucztcbnZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSU4LCBkLCBrID0gMDtcbmlmKGktLSA+IDApIHtcbiBpZihwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXMuZGF0YVtpXT4+cCkgIT0gKHRoaXMucyZ0aGlzLkRNKT4+cClcbiAgIHJbaysrXSA9IGR8KHRoaXMuczw8KHRoaXMuREItcCkpO1xuIHdoaWxlKGkgPj0gMCkge1xuICAgaWYocCA8IDgpIHtcbiAgICAgZCA9ICh0aGlzLmRhdGFbaV0mKCgxPDxwKS0xKSk8PCg4LXApO1xuICAgICBkIHw9IHRoaXMuZGF0YVstLWldPj4ocCs9dGhpcy5EQi04KTtcbiAgIH0gZWxzZSB7XG4gICAgIGQgPSAodGhpcy5kYXRhW2ldPj4ocC09OCkpJjB4ZmY7XG4gICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgfVxuICAgaWYoKGQmMHg4MCkgIT0gMCkgZCB8PSAtMjU2O1xuICAgaWYoayA9PSAwICYmICh0aGlzLnMmMHg4MCkgIT0gKGQmMHg4MCkpICsraztcbiAgIGlmKGsgPiAwIHx8IGQgIT0gdGhpcy5zKSByW2srK10gPSBkO1xuIH1cbn1cbnJldHVybiByO1xufVxuXG5mdW5jdGlvbiBibkVxdWFscyhhKSB7IHJldHVybih0aGlzLmNvbXBhcmVUbyhhKT09MCk7IH1cbmZ1bmN0aW9uIGJuTWluKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPDApP3RoaXM6YTsgfVxuZnVuY3Rpb24gYm5NYXgoYSkgeyByZXR1cm4odGhpcy5jb21wYXJlVG8oYSk+MCk/dGhpczphOyB9XG5cbi8vKHByb3RlY3RlZCkgciA9IHRoaXMgb3AgYSAoYml0d2lzZSlcbmZ1bmN0aW9uIGJucEJpdHdpc2VUbyhhLG9wLHIpIHtcbnZhciBpLCBmLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG5mb3IoaSA9IDA7IGkgPCBtOyArK2kpIHIuZGF0YVtpXSA9IG9wKHRoaXMuZGF0YVtpXSxhLmRhdGFbaV0pO1xuaWYoYS50IDwgdGhpcy50KSB7XG4gZiA9IGEucyZ0aGlzLkRNO1xuIGZvcihpID0gbTsgaSA8IHRoaXMudDsgKytpKSByLmRhdGFbaV0gPSBvcCh0aGlzLmRhdGFbaV0sZik7XG4gci50ID0gdGhpcy50O1xufSBlbHNlIHtcbiBmID0gdGhpcy5zJnRoaXMuRE07XG4gZm9yKGkgPSBtOyBpIDwgYS50OyArK2kpIHIuZGF0YVtpXSA9IG9wKGYsYS5kYXRhW2ldKTtcbiByLnQgPSBhLnQ7XG59XG5yLnMgPSBvcCh0aGlzLnMsYS5zKTtcbnIuY2xhbXAoKTtcbn1cblxuLy8ocHVibGljKSB0aGlzICYgYVxuZnVuY3Rpb24gb3BfYW5kKHgseSkgeyByZXR1cm4geCZ5OyB9XG5mdW5jdGlvbiBibkFuZChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3BfYW5kLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgfCBhXG5mdW5jdGlvbiBvcF9vcih4LHkpIHsgcmV0dXJuIHh8eTsgfVxuZnVuY3Rpb24gYm5PcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3Bfb3Iscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgdGhpcyBeIGFcbmZ1bmN0aW9uIG9wX3hvcih4LHkpIHsgcmV0dXJuIHheeTsgfVxuZnVuY3Rpb24gYm5Yb3IoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX3hvcixyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzICYgfmFcbmZ1bmN0aW9uIG9wX2FuZG5vdCh4LHkpIHsgcmV0dXJuIHgmfnk7IH1cbmZ1bmN0aW9uIGJuQW5kTm90KGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmRub3Qscik7IHJldHVybiByOyB9XG5cbi8vKHB1YmxpYykgfnRoaXNcbmZ1bmN0aW9uIGJuTm90KCkge1xudmFyIHIgPSBuYmkoKTtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgci5kYXRhW2ldID0gdGhpcy5ETSZ+dGhpcy5kYXRhW2ldO1xuci50ID0gdGhpcy50O1xuci5zID0gfnRoaXMucztcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgPDwgblxuZnVuY3Rpb24gYm5TaGlmdExlZnQobikge1xudmFyIHIgPSBuYmkoKTtcbmlmKG4gPCAwKSB0aGlzLnJTaGlmdFRvKC1uLHIpOyBlbHNlIHRoaXMubFNoaWZ0VG8obixyKTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgPj4gblxuZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pIHtcbnZhciByID0gbmJpKCk7XG5pZihuIDwgMCkgdGhpcy5sU2hpZnRUbygtbixyKTsgZWxzZSB0aGlzLnJTaGlmdFRvKG4scik7XG5yZXR1cm4gcjtcbn1cblxuLy9yZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG5mdW5jdGlvbiBsYml0KHgpIHtcbmlmKHggPT0gMCkgcmV0dXJuIC0xO1xudmFyIHIgPSAwO1xuaWYoKHgmMHhmZmZmKSA9PSAwKSB7IHggPj49IDE2OyByICs9IDE2OyB9XG5pZigoeCYweGZmKSA9PSAwKSB7IHggPj49IDg7IHIgKz0gODsgfVxuaWYoKHgmMHhmKSA9PSAwKSB7IHggPj49IDQ7IHIgKz0gNDsgfVxuaWYoKHgmMykgPT0gMCkgeyB4ID4+PSAyOyByICs9IDI7IH1cbmlmKCh4JjEpID09IDApICsrcjtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHJldHVybnMgaW5kZXggb2YgbG93ZXN0IDEtYml0IChvciAtMSBpZiBub25lKVxuZnVuY3Rpb24gYm5HZXRMb3dlc3RTZXRCaXQoKSB7XG5mb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpXG4gaWYodGhpcy5kYXRhW2ldICE9IDApIHJldHVybiBpKnRoaXMuREIrbGJpdCh0aGlzLmRhdGFbaV0pO1xuaWYodGhpcy5zIDwgMCkgcmV0dXJuIHRoaXMudCp0aGlzLkRCO1xucmV0dXJuIC0xO1xufVxuXG4vL3JldHVybiBudW1iZXIgb2YgMSBiaXRzIGluIHhcbmZ1bmN0aW9uIGNiaXQoeCkge1xudmFyIHIgPSAwO1xud2hpbGUoeCAhPSAwKSB7IHggJj0geC0xOyArK3I7IH1cbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHJldHVybiBudW1iZXIgb2Ygc2V0IGJpdHNcbmZ1bmN0aW9uIGJuQml0Q291bnQoKSB7XG52YXIgciA9IDAsIHggPSB0aGlzLnMmdGhpcy5ETTtcbmZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSkgciArPSBjYml0KHRoaXMuZGF0YVtpXV54KTtcbnJldHVybiByO1xufVxuXG4vLyhwdWJsaWMpIHRydWUgaWZmIG50aCBiaXQgaXMgc2V0XG5mdW5jdGlvbiBiblRlc3RCaXQobikge1xudmFyIGogPSBNYXRoLmZsb29yKG4vdGhpcy5EQik7XG5pZihqID49IHRoaXMudCkgcmV0dXJuKHRoaXMucyE9MCk7XG5yZXR1cm4oKHRoaXMuZGF0YVtqXSYoMTw8KG4ldGhpcy5EQikpKSE9MCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyBvcCAoMTw8bilcbmZ1bmN0aW9uIGJucENoYW5nZUJpdChuLG9wKSB7XG52YXIgciA9IEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChuKTtcbnRoaXMuYml0d2lzZVRvKHIsb3Ascik7XG5yZXR1cm4gcjtcbn1cblxuLy8ocHVibGljKSB0aGlzIHwgKDE8PG4pXG5mdW5jdGlvbiBiblNldEJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX29yKTsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJiB+KDE8PG4pXG5mdW5jdGlvbiBibkNsZWFyQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfYW5kbm90KTsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgXiAoMTw8bilcbmZ1bmN0aW9uIGJuRmxpcEJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX3hvcik7IH1cblxuLy8ocHJvdGVjdGVkKSByID0gdGhpcyArIGFcbmZ1bmN0aW9uIGJucEFkZFRvKGEscikge1xudmFyIGkgPSAwLCBjID0gMCwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xud2hpbGUoaSA8IG0pIHtcbiBjICs9IHRoaXMuZGF0YVtpXSthLmRhdGFbaV07XG4gci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gYyA+Pj0gdGhpcy5EQjtcbn1cbmlmKGEudCA8IHRoaXMudCkge1xuIGMgKz0gYS5zO1xuIHdoaWxlKGkgPCB0aGlzLnQpIHtcbiAgIGMgKz0gdGhpcy5kYXRhW2ldO1xuICAgci5kYXRhW2krK10gPSBjJnRoaXMuRE07XG4gICBjID4+PSB0aGlzLkRCO1xuIH1cbiBjICs9IHRoaXMucztcbn0gZWxzZSB7XG4gYyArPSB0aGlzLnM7XG4gd2hpbGUoaSA8IGEudCkge1xuICAgYyArPSBhLmRhdGFbaV07XG4gICByLmRhdGFbaSsrXSA9IGMmdGhpcy5ETTtcbiAgIGMgPj49IHRoaXMuREI7XG4gfVxuIGMgKz0gYS5zO1xufVxuci5zID0gKGM8MCk/LTE6MDtcbmlmKGMgPiAwKSByLmRhdGFbaSsrXSA9IGM7XG5lbHNlIGlmKGMgPCAtMSkgci5kYXRhW2krK10gPSB0aGlzLkRWK2M7XG5yLnQgPSBpO1xuci5jbGFtcCgpO1xufVxuXG4vLyhwdWJsaWMpIHRoaXMgKyBhXG5mdW5jdGlvbiBibkFkZChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYWRkVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzIC0gYVxuZnVuY3Rpb24gYm5TdWJ0cmFjdChhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuc3ViVG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuLy8ocHVibGljKSB0aGlzICogYVxuZnVuY3Rpb24gYm5NdWx0aXBseShhKSB7IHZhciByID0gbmJpKCk7IHRoaXMubXVsdGlwbHlUbyhhLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgLyBhXG5mdW5jdGlvbiBibkRpdmlkZShhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuZGl2UmVtVG8oYSxyLG51bGwpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIHRoaXMgJSBhXG5mdW5jdGlvbiBiblJlbWFpbmRlcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuZGl2UmVtVG8oYSxudWxsLHIpOyByZXR1cm4gcjsgfVxuXG4vLyhwdWJsaWMpIFt0aGlzL2EsdGhpcyVhXVxuZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSkge1xudmFyIHEgPSBuYmkoKSwgciA9IG5iaSgpO1xudGhpcy5kaXZSZW1UbyhhLHEscik7XG5yZXR1cm4gbmV3IEFycmF5KHEscik7XG59XG5cbi8vKHByb3RlY3RlZCkgdGhpcyAqPSBuLCB0aGlzID49IDAsIDEgPCBuIDwgRFZcbmZ1bmN0aW9uIGJucERNdWx0aXBseShuKSB7XG50aGlzLmRhdGFbdGhpcy50XSA9IHRoaXMuYW0oMCxuLTEsdGhpcywwLDAsdGhpcy50KTtcbisrdGhpcy50O1xudGhpcy5jbGFtcCgpO1xufVxuXG4vLyhwcm90ZWN0ZWQpIHRoaXMgKz0gbiA8PCB3IHdvcmRzLCB0aGlzID49IDBcbmZ1bmN0aW9uIGJucERBZGRPZmZzZXQobix3KSB7XG5pZihuID09IDApIHJldHVybjtcbndoaWxlKHRoaXMudCA8PSB3KSB0aGlzLmRhdGFbdGhpcy50KytdID0gMDtcbnRoaXMuZGF0YVt3XSArPSBuO1xud2hpbGUodGhpcy5kYXRhW3ddID49IHRoaXMuRFYpIHtcbiB0aGlzLmRhdGFbd10gLT0gdGhpcy5EVjtcbiBpZigrK3cgPj0gdGhpcy50KSB0aGlzLmRhdGFbdGhpcy50KytdID0gMDtcbiArK3RoaXMuZGF0YVt3XTtcbn1cbn1cblxuLy9BIFwibnVsbFwiIHJlZHVjZXJcbmZ1bmN0aW9uIE51bGxFeHAoKSB7fVxuZnVuY3Rpb24gbk5vcCh4KSB7IHJldHVybiB4OyB9XG5mdW5jdGlvbiBuTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IH1cbmZ1bmN0aW9uIG5TcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgfVxuXG5OdWxsRXhwLnByb3RvdHlwZS5jb252ZXJ0ID0gbk5vcDtcbk51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG5OdWxsRXhwLnByb3RvdHlwZS5tdWxUbyA9IG5NdWxUbztcbk51bGxFeHAucHJvdG90eXBlLnNxclRvID0gblNxclRvO1xuXG4vLyhwdWJsaWMpIHRoaXNeZVxuZnVuY3Rpb24gYm5Qb3coZSkgeyByZXR1cm4gdGhpcy5leHAoZSxuZXcgTnVsbEV4cCgpKTsgfVxuXG4vLyhwcm90ZWN0ZWQpIHIgPSBsb3dlciBuIHdvcmRzIG9mIFwidGhpcyAqIGFcIiwgYS50IDw9IG5cbi8vXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlMb3dlclRvKGEsbixyKSB7XG52YXIgaSA9IE1hdGgubWluKHRoaXMudCthLnQsbik7XG5yLnMgPSAwOyAvLyBhc3N1bWVzIGEsdGhpcyA+PSAwXG5yLnQgPSBpO1xud2hpbGUoaSA+IDApIHIuZGF0YVstLWldID0gMDtcbnZhciBqO1xuZm9yKGogPSByLnQtdGhpcy50OyBpIDwgajsgKytpKSByLmRhdGFbaSt0aGlzLnRdID0gdGhpcy5hbSgwLGEuZGF0YVtpXSxyLGksMCx0aGlzLnQpO1xuZm9yKGogPSBNYXRoLm1pbihhLnQsbik7IGkgPCBqOyArK2kpIHRoaXMuYW0oMCxhLmRhdGFbaV0scixpLDAsbi1pKTtcbnIuY2xhbXAoKTtcbn1cblxuLy8ocHJvdGVjdGVkKSByID0gXCJ0aGlzICogYVwiIHdpdGhvdXQgbG93ZXIgbiB3b3JkcywgbiA+IDBcbi8vXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuZnVuY3Rpb24gYm5wTXVsdGlwbHlVcHBlclRvKGEsbixyKSB7XG4tLW47XG52YXIgaSA9IHIudCA9IHRoaXMudCthLnQtbjtcbnIucyA9IDA7IC8vIGFzc3VtZXMgYSx0aGlzID49IDBcbndoaWxlKC0taSA+PSAwKSByLmRhdGFbaV0gPSAwO1xuZm9yKGkgPSBNYXRoLm1heChuLXRoaXMudCwwKTsgaSA8IGEudDsgKytpKVxuIHIuZGF0YVt0aGlzLnQraS1uXSA9IHRoaXMuYW0obi1pLGEuZGF0YVtpXSxyLDAsMCx0aGlzLnQraS1uKTtcbnIuY2xhbXAoKTtcbnIuZHJTaGlmdFRvKDEscik7XG59XG5cbi8vQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxuZnVuY3Rpb24gQmFycmV0dChtKSB7XG4vLyBzZXR1cCBCYXJyZXR0XG50aGlzLnIyID0gbmJpKCk7XG50aGlzLnEzID0gbmJpKCk7XG5CaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiptLnQsdGhpcy5yMik7XG50aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSk7XG50aGlzLm0gPSBtO1xufVxuXG5mdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KSB7XG5pZih4LnMgPCAwIHx8IHgudCA+IDIqdGhpcy5tLnQpIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuZWxzZSBpZih4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkgcmV0dXJuIHg7XG5lbHNlIHsgdmFyIHIgPSBuYmkoKTsgeC5jb3B5VG8ocik7IHRoaXMucmVkdWNlKHIpOyByZXR1cm4gcjsgfVxufVxuXG5mdW5jdGlvbiBiYXJyZXR0UmV2ZXJ0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy94ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KSB7XG54LmRyU2hpZnRUbyh0aGlzLm0udC0xLHRoaXMucjIpO1xuaWYoeC50ID4gdGhpcy5tLnQrMSkgeyB4LnQgPSB0aGlzLm0udCsxOyB4LmNsYW1wKCk7IH1cbnRoaXMubXUubXVsdGlwbHlVcHBlclRvKHRoaXMucjIsdGhpcy5tLnQrMSx0aGlzLnEzKTtcbnRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMyx0aGlzLm0udCsxLHRoaXMucjIpO1xud2hpbGUoeC5jb21wYXJlVG8odGhpcy5yMikgPCAwKSB4LmRBZGRPZmZzZXQoMSx0aGlzLm0udCsxKTtcbnguc3ViVG8odGhpcy5yMix4KTtcbndoaWxlKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG59XG5cbi8vciA9IHheMiBtb2QgbTsgeCAhPSByXG5mdW5jdGlvbiBiYXJyZXR0U3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbi8vciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcbkJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2U7XG5CYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbkJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuXG4vLyhwdWJsaWMpIHRoaXNeZSAlIG0gKEhBQyAxNC44NSlcbmZ1bmN0aW9uIGJuTW9kUG93KGUsbSkge1xudmFyIGkgPSBlLmJpdExlbmd0aCgpLCBrLCByID0gbmJ2KDEpLCB6O1xuaWYoaSA8PSAwKSByZXR1cm4gcjtcbmVsc2UgaWYoaSA8IDE4KSBrID0gMTtcbmVsc2UgaWYoaSA8IDQ4KSBrID0gMztcbmVsc2UgaWYoaSA8IDE0NCkgayA9IDQ7XG5lbHNlIGlmKGkgPCA3NjgpIGsgPSA1O1xuZWxzZSBrID0gNjtcbmlmKGkgPCA4KVxuIHogPSBuZXcgQ2xhc3NpYyhtKTtcbmVsc2UgaWYobS5pc0V2ZW4oKSlcbiB6ID0gbmV3IEJhcnJldHQobSk7XG5lbHNlXG4geiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuXG4vLyBwcmVjb21wdXRhdGlvblxudmFyIGcgPSBuZXcgQXJyYXkoKSwgbiA9IDMsIGsxID0gay0xLCBrbSA9ICgxPDxrKS0xO1xuZ1sxXSA9IHouY29udmVydCh0aGlzKTtcbmlmKGsgPiAxKSB7XG4gdmFyIGcyID0gbmJpKCk7XG4gei5zcXJUbyhnWzFdLGcyKTtcbiB3aGlsZShuIDw9IGttKSB7XG4gICBnW25dID0gbmJpKCk7XG4gICB6Lm11bFRvKGcyLGdbbi0yXSxnW25dKTtcbiAgIG4gKz0gMjtcbiB9XG59XG5cbnZhciBqID0gZS50LTEsIHcsIGlzMSA9IHRydWUsIHIyID0gbmJpKCksIHQ7XG5pID0gbmJpdHMoZS5kYXRhW2pdKS0xO1xud2hpbGUoaiA+PSAwKSB7XG4gaWYoaSA+PSBrMSkgdyA9IChlLmRhdGFbal0+PihpLWsxKSkma207XG4gZWxzZSB7XG4gICB3ID0gKGUuZGF0YVtqXSYoKDE8PChpKzEpKS0xKSk8PChrMS1pKTtcbiAgIGlmKGogPiAwKSB3IHw9IGUuZGF0YVtqLTFdPj4odGhpcy5EQitpLWsxKTtcbiB9XG5cbiBuID0gaztcbiB3aGlsZSgodyYxKSA9PSAwKSB7IHcgPj49IDE7IC0tbjsgfVxuIGlmKChpIC09IG4pIDwgMCkgeyBpICs9IHRoaXMuREI7IC0tajsgfVxuIGlmKGlzMSkgeyAgLy8gcmV0ID09IDEsIGRvbid0IGJvdGhlciBzcXVhcmluZyBvciBtdWx0aXBseWluZyBpdFxuICAgZ1t3XS5jb3B5VG8ocik7XG4gICBpczEgPSBmYWxzZTtcbiB9IGVsc2Uge1xuICAgd2hpbGUobiA+IDEpIHsgei5zcXJUbyhyLHIyKTsgei5zcXJUbyhyMixyKTsgbiAtPSAyOyB9XG4gICBpZihuID4gMCkgei5zcXJUbyhyLHIyKTsgZWxzZSB7IHQgPSByOyByID0gcjI7IHIyID0gdDsgfVxuICAgei5tdWxUbyhyMixnW3ddLHIpO1xuIH1cblxuIHdoaWxlKGogPj0gMCAmJiAoZS5kYXRhW2pdJigxPDxpKSkgPT0gMCkge1xuICAgei5zcXJUbyhyLHIyKTsgdCA9IHI7IHIgPSByMjsgcjIgPSB0O1xuICAgaWYoLS1pIDwgMCkgeyBpID0gdGhpcy5EQi0xOyAtLWo7IH1cbiB9XG59XG5yZXR1cm4gei5yZXZlcnQocik7XG59XG5cbi8vKHB1YmxpYykgZ2NkKHRoaXMsYSkgKEhBQyAxNC41NClcbmZ1bmN0aW9uIGJuR0NEKGEpIHtcbnZhciB4ID0gKHRoaXMuczwwKT90aGlzLm5lZ2F0ZSgpOnRoaXMuY2xvbmUoKTtcbnZhciB5ID0gKGEuczwwKT9hLm5lZ2F0ZSgpOmEuY2xvbmUoKTtcbmlmKHguY29tcGFyZVRvKHkpIDwgMCkgeyB2YXIgdCA9IHg7IHggPSB5OyB5ID0gdDsgfVxudmFyIGkgPSB4LmdldExvd2VzdFNldEJpdCgpLCBnID0geS5nZXRMb3dlc3RTZXRCaXQoKTtcbmlmKGcgPCAwKSByZXR1cm4geDtcbmlmKGkgPCBnKSBnID0gaTtcbmlmKGcgPiAwKSB7XG4geC5yU2hpZnRUbyhnLHgpO1xuIHkuclNoaWZ0VG8oZyx5KTtcbn1cbndoaWxlKHguc2lnbnVtKCkgPiAwKSB7XG4gaWYoKGkgPSB4LmdldExvd2VzdFNldEJpdCgpKSA+IDApIHguclNoaWZ0VG8oaSx4KTtcbiBpZigoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeS5yU2hpZnRUbyhpLHkpO1xuIGlmKHguY29tcGFyZVRvKHkpID49IDApIHtcbiAgIHguc3ViVG8oeSx4KTtcbiAgIHguclNoaWZ0VG8oMSx4KTtcbiB9IGVsc2Uge1xuICAgeS5zdWJUbyh4LHkpO1xuICAgeS5yU2hpZnRUbygxLHkpO1xuIH1cbn1cbmlmKGcgPiAwKSB5LmxTaGlmdFRvKGcseSk7XG5yZXR1cm4geTtcbn1cblxuLy8ocHJvdGVjdGVkKSB0aGlzICUgbiwgbiA8IDJeMjZcbmZ1bmN0aW9uIGJucE1vZEludChuKSB7XG5pZihuIDw9IDApIHJldHVybiAwO1xudmFyIGQgPSB0aGlzLkRWJW4sIHIgPSAodGhpcy5zPDApP24tMTowO1xuaWYodGhpcy50ID4gMClcbiBpZihkID09IDApIHIgPSB0aGlzLmRhdGFbMF0lbjtcbiBlbHNlIGZvcih2YXIgaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgciA9IChkKnIrdGhpcy5kYXRhW2ldKSVuO1xucmV0dXJuIHI7XG59XG5cbi8vKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuZnVuY3Rpb24gYm5Nb2RJbnZlcnNlKG0pIHtcbnZhciBhYyA9IG0uaXNFdmVuKCk7XG5pZigodGhpcy5pc0V2ZW4oKSAmJiBhYykgfHwgbS5zaWdudW0oKSA9PSAwKSByZXR1cm4gQmlnSW50ZWdlci5aRVJPO1xudmFyIHUgPSBtLmNsb25lKCksIHYgPSB0aGlzLmNsb25lKCk7XG52YXIgYSA9IG5idigxKSwgYiA9IG5idigwKSwgYyA9IG5idigwKSwgZCA9IG5idigxKTtcbndoaWxlKHUuc2lnbnVtKCkgIT0gMCkge1xuIHdoaWxlKHUuaXNFdmVuKCkpIHtcbiAgIHUuclNoaWZ0VG8oMSx1KTtcbiAgIGlmKGFjKSB7XG4gICAgIGlmKCFhLmlzRXZlbigpIHx8ICFiLmlzRXZlbigpKSB7IGEuYWRkVG8odGhpcyxhKTsgYi5zdWJUbyhtLGIpOyB9XG4gICAgIGEuclNoaWZ0VG8oMSxhKTtcbiAgIH0gZWxzZSBpZighYi5pc0V2ZW4oKSkgYi5zdWJUbyhtLGIpO1xuICAgYi5yU2hpZnRUbygxLGIpO1xuIH1cbiB3aGlsZSh2LmlzRXZlbigpKSB7XG4gICB2LnJTaGlmdFRvKDEsdik7XG4gICBpZihhYykge1xuICAgICBpZighYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkgeyBjLmFkZFRvKHRoaXMsYyk7IGQuc3ViVG8obSxkKTsgfVxuICAgICBjLnJTaGlmdFRvKDEsYyk7XG4gICB9IGVsc2UgaWYoIWQuaXNFdmVuKCkpIGQuc3ViVG8obSxkKTtcbiAgIGQuclNoaWZ0VG8oMSxkKTtcbiB9XG4gaWYodS5jb21wYXJlVG8odikgPj0gMCkge1xuICAgdS5zdWJUbyh2LHUpO1xuICAgaWYoYWMpIGEuc3ViVG8oYyxhKTtcbiAgIGIuc3ViVG8oZCxiKTtcbiB9IGVsc2Uge1xuICAgdi5zdWJUbyh1LHYpO1xuICAgaWYoYWMpIGMuc3ViVG8oYSxjKTtcbiAgIGQuc3ViVG8oYixkKTtcbiB9XG59XG5pZih2LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbmlmKGQuY29tcGFyZVRvKG0pID49IDApIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuaWYoZC5zaWdudW0oKSA8IDApIGQuYWRkVG8obSxkKTsgZWxzZSByZXR1cm4gZDtcbmlmKGQuc2lnbnVtKCkgPCAwKSByZXR1cm4gZC5hZGQobSk7IGVsc2UgcmV0dXJuIGQ7XG59XG5cbnZhciBsb3dwcmltZXMgPSBbMiwzLDUsNywxMSwxMywxNywxOSwyMywyOSwzMSwzNyw0MSw0Myw0Nyw1Myw1OSw2MSw2Nyw3MSw3Myw3OSw4Myw4OSw5NywxMDEsMTAzLDEwNywxMDksMTEzLDEyNywxMzEsMTM3LDEzOSwxNDksMTUxLDE1NywxNjMsMTY3LDE3MywxNzksMTgxLDE5MSwxOTMsMTk3LDE5OSwyMTEsMjIzLDIyNywyMjksMjMzLDIzOSwyNDEsMjUxLDI1NywyNjMsMjY5LDI3MSwyNzcsMjgxLDI4MywyOTMsMzA3LDMxMSwzMTMsMzE3LDMzMSwzMzcsMzQ3LDM0OSwzNTMsMzU5LDM2NywzNzMsMzc5LDM4MywzODksMzk3LDQwMSw0MDksNDE5LDQyMSw0MzEsNDMzLDQzOSw0NDMsNDQ5LDQ1Nyw0NjEsNDYzLDQ2Nyw0NzksNDg3LDQ5MSw0OTksNTAzLDUwOV07XG52YXIgbHBsaW0gPSAoMTw8MjYpL2xvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoLTFdO1xuXG4vLyhwdWJsaWMpIHRlc3QgcHJpbWFsaXR5IHdpdGggY2VydGFpbnR5ID49IDEtLjVedFxuZnVuY3Rpb24gYm5Jc1Byb2JhYmxlUHJpbWUodCkge1xudmFyIGksIHggPSB0aGlzLmFicygpO1xuaWYoeC50ID09IDEgJiYgeC5kYXRhWzBdIDw9IGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoLTFdKSB7XG4gZm9yKGkgPSAwOyBpIDwgbG93cHJpbWVzLmxlbmd0aDsgKytpKVxuICAgaWYoeC5kYXRhWzBdID09IGxvd3ByaW1lc1tpXSkgcmV0dXJuIHRydWU7XG4gcmV0dXJuIGZhbHNlO1xufVxuaWYoeC5pc0V2ZW4oKSkgcmV0dXJuIGZhbHNlO1xuaSA9IDE7XG53aGlsZShpIDwgbG93cHJpbWVzLmxlbmd0aCkge1xuIHZhciBtID0gbG93cHJpbWVzW2ldLCBqID0gaSsxO1xuIHdoaWxlKGogPCBsb3dwcmltZXMubGVuZ3RoICYmIG0gPCBscGxpbSkgbSAqPSBsb3dwcmltZXNbaisrXTtcbiBtID0geC5tb2RJbnQobSk7XG4gd2hpbGUoaSA8IGopIGlmKG0lbG93cHJpbWVzW2krK10gPT0gMCkgcmV0dXJuIGZhbHNlO1xufVxucmV0dXJuIHgubWlsbGVyUmFiaW4odCk7XG59XG5cbi8vKHByb3RlY3RlZCkgdHJ1ZSBpZiBwcm9iYWJseSBwcmltZSAoSEFDIDQuMjQsIE1pbGxlci1SYWJpbilcbmZ1bmN0aW9uIGJucE1pbGxlclJhYmluKHQpIHtcbnZhciBuMSA9IHRoaXMuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xudmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKTtcbmlmKGsgPD0gMCkgcmV0dXJuIGZhbHNlO1xudmFyIHIgPSBuMS5zaGlmdFJpZ2h0KGspO1xudmFyIHBybmcgPSBibkdldFBybmcoKTtcbnZhciBhO1xuZm9yKHZhciBpID0gMDsgaSA8IHQ7ICsraSkge1xuIC8vIHNlbGVjdCB3aXRuZXNzICdhJyBhdCByYW5kb20gZnJvbSBiZXR3ZWVuIDEgYW5kIG4xXG4gZG8ge1xuICAgYSA9IG5ldyBCaWdJbnRlZ2VyKHRoaXMuYml0TGVuZ3RoKCksIHBybmcpO1xuIH1cbiB3aGlsZShhLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPD0gMCB8fCBhLmNvbXBhcmVUbyhuMSkgPj0gMCk7XG4gdmFyIHkgPSBhLm1vZFBvdyhyLHRoaXMpO1xuIGlmKHkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSAhPSAwICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICB2YXIgaiA9IDE7XG4gICB3aGlsZShqKysgPCBrICYmIHkuY29tcGFyZVRvKG4xKSAhPSAwKSB7XG4gICAgIHkgPSB5Lm1vZFBvd0ludCgyLHRoaXMpO1xuICAgICBpZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgfVxuICAgaWYoeS5jb21wYXJlVG8objEpICE9IDApIHJldHVybiBmYWxzZTtcbiB9XG59XG5yZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ2V0IHBzZXVkbyByYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuZnVuY3Rpb24gYm5HZXRQcm5nKCkge1xuICAvLyBjcmVhdGUgcHJuZyB3aXRoIGFwaSB0aGF0IG1hdGNoZXMgQmlnSW50ZWdlciBzZWN1cmUgcmFuZG9tXG4gIHJldHVybiB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHhbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy9wcm90ZWN0ZWRcbkJpZ0ludGVnZXIucHJvdG90eXBlLmNodW5rU2l6ZSA9IGJucENodW5rU2l6ZTtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnRvUmFkaXggPSBibnBUb1JhZGl4O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbU51bWJlciA9IGJucEZyb21OdW1iZXI7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXR3aXNlVG8gPSBibnBCaXR3aXNlVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGRUbyA9IGJucEFkZFRvO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZE11bHRpcGx5ID0gYm5wRE11bHRpcGx5O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseUxvd2VyVG8gPSBibnBNdWx0aXBseUxvd2VyVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVVwcGVyVG8gPSBibnBNdWx0aXBseVVwcGVyVG87XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5taWxsZXJSYWJpbiA9IGJucE1pbGxlclJhYmluO1xuXG4vL3B1YmxpY1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY2xvbmUgPSBibkNsb25lO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBibkludFZhbHVlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaG9ydFZhbHVlID0gYm5TaG9ydFZhbHVlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2lnbnVtID0gYm5TaWdOdW07XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXk7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHMgPSBibkVxdWFscztcbkJpZ0ludGVnZXIucHJvdG90eXBlLm1pbiA9IGJuTWluO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubWF4ID0gYm5NYXg7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5hbmQgPSBibkFuZDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gYm5PcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGJuWG9yO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kTm90ID0gYm5BbmROb3Q7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBibk5vdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGJuU2hpZnRSaWdodDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmdldExvd2VzdFNldEJpdCA9IGJuR2V0TG93ZXN0U2V0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBibkJpdENvdW50O1xuQmlnSW50ZWdlci5wcm90b3R5cGUudGVzdEJpdCA9IGJuVGVzdEJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLnNldEJpdCA9IGJuU2V0Qml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuY2xlYXJCaXQgPSBibkNsZWFyQml0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZmxpcEJpdCA9IGJuRmxpcEJpdDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmFkZCA9IGJuQWRkO1xuQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBiblN1YnRyYWN0O1xuQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBibk11bHRpcGx5O1xuQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gYm5EaXZpZGU7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBiblJlbWFpbmRlcjtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZUFuZFJlbWFpbmRlciA9IGJuRGl2aWRlQW5kUmVtYWluZGVyO1xuQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gYm5Nb2RQb3c7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlID0gYm5Nb2RJbnZlcnNlO1xuQmlnSW50ZWdlci5wcm90b3R5cGUucG93ID0gYm5Qb3c7XG5CaWdJbnRlZ2VyLnByb3RvdHlwZS5nY2QgPSBibkdDRDtcbkJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGJuSXNQcm9iYWJsZVByaW1lO1xuXG4vL0JpZ0ludGVnZXIgaW50ZXJmYWNlcyBub3QgaW1wbGVtZW50ZWQgaW4ganNibjpcblxuLy9CaWdJbnRlZ2VyKGludCBzaWdudW0sIGJ5dGVbXSBtYWduaXR1ZGUpXG4vL2RvdWJsZSBkb3VibGVWYWx1ZSgpXG4vL2Zsb2F0IGZsb2F0VmFsdWUoKVxuLy9pbnQgaGFzaENvZGUoKVxuLy9sb25nIGxvbmdWYWx1ZSgpXG4vL3N0YXRpYyBCaWdJbnRlZ2VyIHZhbHVlT2YobG9uZyB2YWwpXG4iLCIvKipcbiAqIE5vZGUuanMgbW9kdWxlIGZvciBGb3JnZSBtZXNzYWdlIGRpZ2VzdHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5tZCA9IGZvcmdlLm1kIHx8IHt9O1xuZm9yZ2UubWQuYWxnb3JpdGhtcyA9IGZvcmdlLm1kLmFsZ29yaXRobXMgfHwge307XG4iLCIvKipcbiAqIE1lc3NhZ2UgRGlnZXN0IEFsZ29yaXRobSA1IHdpdGggMTI4LWJpdCBkaWdlc3QgKE1ENSkgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIG1kNSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UubWQ1ID0gZm9yZ2UubWQ1IHx8IHt9O1xuZm9yZ2UubWQubWQ1ID0gZm9yZ2UubWQuYWxnb3JpdGhtcy5tZDUgPSBtZDU7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBNRDUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gYSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKi9cbm1kNS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gZG8gaW5pdGlhbGl6YXRpb24gYXMgbmVjZXNzYXJ5XG4gIGlmKCFfaW5pdGlhbGl6ZWQpIHtcbiAgICBfaW5pdCgpO1xuICB9XG5cbiAgLy8gTUQ1IHN0YXRlIGNvbnRhaW5zIGZvdXIgMzItYml0IGludGVnZXJzXG4gIHZhciBfc3RhdGUgPSBudWxsO1xuXG4gIC8vIGlucHV0IGJ1ZmZlclxuICB2YXIgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcblxuICAvLyB1c2VkIGZvciB3b3JkIHN0b3JhZ2VcbiAgdmFyIF93ID0gbmV3IEFycmF5KDE2KTtcblxuICAvLyBtZXNzYWdlIGRpZ2VzdCBvYmplY3RcbiAgdmFyIG1kID0ge1xuICAgIGFsZ29yaXRobTogJ21kNScsXG4gICAgYmxvY2tMZW5ndGg6IDY0LFxuICAgIGRpZ2VzdExlbmd0aDogMTYsXG4gICAgLy8gNTYtYml0IGxlbmd0aCBvZiBtZXNzYWdlIHNvIGZhciAoZG9lcyBub3QgaW5jbHVkaW5nIHBhZGRpbmcpXG4gICAgbWVzc2FnZUxlbmd0aDogMCxcbiAgICAvLyB0cnVlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgZnVsbE1lc3NhZ2VMZW5ndGg6IG51bGwsXG4gICAgLy8gc2l6ZSBvZiBtZXNzYWdlIGxlbmd0aCBpbiBieXRlc1xuICAgIG1lc3NhZ2VMZW5ndGhTaXplOiA4XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgZGlnZXN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHRoaXMgZGlnZXN0IG9iamVjdC5cbiAgICovXG4gIG1kLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gdXAgdG8gNTYtYml0IG1lc3NhZ2UgbGVuZ3RoIGZvciBjb252ZW5pZW5jZVxuICAgIG1kLm1lc3NhZ2VMZW5ndGggPSAwO1xuXG4gICAgLy8gZnVsbCBtZXNzYWdlIGxlbmd0aCAoc2V0IG1kLm1lc3NhZ2VMZW5ndGg2NCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkpXG4gICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGggPSBtZC5tZXNzYWdlTGVuZ3RoNjQgPSBbXTtcbiAgICB2YXIgaW50MzJzID0gbWQubWVzc2FnZUxlbmd0aFNpemUgLyA0O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbnQzMnM7ICsraSkge1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGgucHVzaCgwKTtcbiAgICB9XG4gICAgX2lucHV0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBfc3RhdGUgPSB7XG4gICAgICBoMDogMHg2NzQ1MjMwMSxcbiAgICAgIGgxOiAweEVGQ0RBQjg5LFxuICAgICAgaDI6IDB4OThCQURDRkUsXG4gICAgICBoMzogMHgxMDMyNTQ3NlxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9IChsZW5bMV0gLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgTUQ1IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnlcbiAgICB2YXIgYml0cywgY2FycnkgPSAwO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gKiA4ICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IChiaXRzIC8gMHgxMDAwMDAwMDApID4+PiAwO1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMkxlKGJpdHMgPj4+IDApO1xuICAgIH1cblxuICAgIHZhciBzMiA9IHtcbiAgICAgIGgwOiBfc3RhdGUuaDAsXG4gICAgICBoMTogX3N0YXRlLmgxLFxuICAgICAgaDI6IF9zdGF0ZS5oMixcbiAgICAgIGgzOiBfc3RhdGUuaDNcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMkxlKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyTGUoczIuaDEpO1xuICAgIHJ2YWwucHV0SW50MzJMZShzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMkxlKHMyLmgzKTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBwYWRkaW5nLCBjb25zdGFudCB0YWJsZXMgZm9yIGNhbGN1bGF0aW5nIG1kNVxudmFyIF9wYWRkaW5nID0gbnVsbDtcbnZhciBfZyA9IG51bGw7XG52YXIgX3IgPSBudWxsO1xudmFyIF9rID0gbnVsbDtcbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gZyB2YWx1ZXNcbiAgX2cgPSBbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxLCA2LCAxMSwgMCwgNSwgMTAsIDE1LCA0LCA5LCAxNCwgMywgOCwgMTMsIDIsIDcsIDEyLFxuICAgIDUsIDgsIDExLCAxNCwgMSwgNCwgNywgMTAsIDEzLCAwLCAzLCA2LCA5LCAxMiwgMTUsIDIsXG4gICAgMCwgNywgMTQsIDUsIDEyLCAzLCAxMCwgMSwgOCwgMTUsIDYsIDEzLCA0LCAxMSwgMiwgOV07XG5cbiAgLy8gcm91bmRzIHRhYmxlXG4gIF9yID0gW1xuICAgIDcsIDEyLCAxNywgMjIsICA3LCAxMiwgMTcsIDIyLCAgNywgMTIsIDE3LCAyMiwgIDcsIDEyLCAxNywgMjIsXG4gICAgNSwgIDksIDE0LCAyMCwgIDUsICA5LCAxNCwgMjAsICA1LCAgOSwgMTQsIDIwLCAgNSwgIDksIDE0LCAyMCxcbiAgICA0LCAxMSwgMTYsIDIzLCAgNCwgMTEsIDE2LCAyMywgIDQsIDExLCAxNiwgMjMsICA0LCAxMSwgMTYsIDIzLFxuICAgIDYsIDEwLCAxNSwgMjEsICA2LCAxMCwgMTUsIDIxLCAgNiwgMTAsIDE1LCAyMSwgIDYsIDEwLCAxNSwgMjFdO1xuXG4gIC8vIGdldCB0aGUgcmVzdWx0IG9mIGFicyhzaW4oaSArIDEpKSBhcyBhIDMyLWJpdCBpbnRlZ2VyXG4gIF9rID0gbmV3IEFycmF5KDY0KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICBfa1tpXSA9IE1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKTtcbiAgfVxuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYW4gTUQ1IHN0YXRlIHdpdGggdGhlIGdpdmVuIGJ5dGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzIHRoZSBNRDUgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGYsIHIsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG5cbiAgICAvLyByb3VuZCAxXG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyTGUoKTtcbiAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgIHQgPSAoYSArIGYgKyBfa1tpXSArIHdbaV0pO1xuICAgICAgciA9IF9yW2ldO1xuICAgICAgYSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiArPSAodCA8PCByKSB8ICh0ID4+PiAoMzIgLSByKSk7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgZiA9IGMgXiAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9IChhICsgZiArIF9rW2ldICsgd1tfZ1tpXV0pO1xuICAgICAgciA9IF9yW2ldO1xuICAgICAgYSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiArPSAodCA8PCByKSB8ICh0ID4+PiAoMzIgLSByKSk7XG4gICAgfVxuICAgIC8vIHJvdW5kIDNcbiAgICBmb3IoOyBpIDwgNDg7ICsraSkge1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoYSArIGYgKyBfa1tpXSArIHdbX2dbaV1dKTtcbiAgICAgIHIgPSBfcltpXTtcbiAgICAgIGEgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gYjtcbiAgICAgIGIgKz0gKHQgPDwgcikgfCAodCA+Pj4gKDMyIC0gcikpO1xuICAgIH1cbiAgICAvLyByb3VuZCA0XG4gICAgZm9yKDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIGYgPSBjIF4gKGIgfCB+ZCk7XG4gICAgICB0ID0gKGEgKyBmICsgX2tbaV0gKyB3W19nW2ldXSk7XG4gICAgICByID0gX3JbaV07XG4gICAgICBhID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGI7XG4gICAgICBiICs9ICh0IDw8IHIpIHwgKHQgPj4+ICgzMiAtIHIpKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgaGFzaCBzdGF0ZVxuICAgIHMuaDAgPSAocy5oMCArIGEpIHwgMDtcbiAgICBzLmgxID0gKHMuaDEgKyBiKSB8IDA7XG4gICAgcy5oMiA9IChzLmgyICsgYykgfCAwO1xuICAgIHMuaDMgPSAocy5oMyArIGQpIHwgMDtcblxuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIiwiLyoqXG4gKiBOb2RlLmpzIG1vZHVsZSBmb3IgRm9yZ2UgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAyMDEyIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWdmMScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZiA9IGZvcmdlLm1nZiB8fCB7fTtcbmZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMTtcbiIsIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBtYXNrIGdlbmVyYXRpb24gZnVuY3Rpb24gTUdGMS5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuZm9yZ2UubWdmID0gZm9yZ2UubWdmIHx8IHt9O1xudmFyIG1nZjEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLm1nZi5tZ2YxID0gZm9yZ2UubWdmMSA9IGZvcmdlLm1nZjEgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIE1HRjEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IEFQSSB0byB1c2UgKGVnOiBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpKS5cbiAqXG4gKiBAcmV0dXJuIGEgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIG9iamVjdC5cbiAqL1xubWdmMS5jcmVhdGUgPSBmdW5jdGlvbihtZCkge1xuICB2YXIgbWdmID0ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG1hc2sgb2Ygc3BlY2lmaWVkIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIFRoZSBzZWVkIGZvciBtYXNrIGdlbmVyYXRpb24uXG4gICAgICogQHBhcmFtIG1hc2tMZW4gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGdlbmVyYXRlZCBtYXNrLlxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihzZWVkLCBtYXNrTGVuKSB7XG4gICAgICAvKiAyLiBMZXQgVCBiZSB0aGUgZW1wdHkgb2N0ZXQgc3RyaW5nLiAqL1xuICAgICAgdmFyIHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG5cbiAgICAgIC8qIDMuIEZvciBjb3VudGVyIGZyb20gMCB0byBjZWlsKG1hc2tMZW4gLyBoTGVuKSwgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgICAgIHZhciBsZW4gPSBNYXRoLmNlaWwobWFza0xlbiAvIG1kLmRpZ2VzdExlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLyogYS4gQ29udmVydCBjb3VudGVyIHRvIGFuIG9jdGV0IHN0cmluZyBDIG9mIGxlbmd0aCA0IG9jdGV0cyAqL1xuICAgICAgICB2YXIgYyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICAgICAgYy5wdXRJbnQzMihpKTtcblxuICAgICAgICAvKiBiLiBDb25jYXRlbmF0ZSB0aGUgaGFzaCBvZiB0aGUgc2VlZCBtZ2ZTZWVkIGFuZCBDIHRvIHRoZSBvY3RldFxuICAgICAgICAgKiBzdHJpbmcgVDogKi9cbiAgICAgICAgbWQuc3RhcnQoKTtcbiAgICAgICAgbWQudXBkYXRlKHNlZWQgKyBjLmdldEJ5dGVzKCkpO1xuICAgICAgICB0LnB1dEJ1ZmZlcihtZC5kaWdlc3QoKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIE91dHB1dCB0aGUgbGVhZGluZyBtYXNrTGVuIG9jdGV0cyBvZiBUIGFzIHRoZSBvY3RldCBzdHJpbmcgbWFzay4gKi9cbiAgICAgIHQudHJ1bmNhdGUodC5sZW5ndGgoKSAtIG1hc2tMZW4pO1xuICAgICAgcmV0dXJuIHQuZ2V0Qnl0ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1nZjtcbn07XG4iLCIvKipcbiAqIE9iamVjdCBJRHMgZm9yIEFTTi4xLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xuXG5mb3JnZS5wa2kgPSBmb3JnZS5wa2kgfHwge307XG52YXIgb2lkcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLm9pZHMgPSBmb3JnZS5vaWRzID0gZm9yZ2Uub2lkcyB8fCB7fTtcblxuLy8gc2V0IGlkIHRvIG5hbWUgbWFwcGluZyBhbmQgbmFtZSB0byBpZCBtYXBwaW5nXG5mdW5jdGlvbiBfSU4oaWQsIG5hbWUpIHtcbiAgb2lkc1tpZF0gPSBuYW1lO1xuICBvaWRzW25hbWVdID0gaWQ7XG59XG4vLyBzZXQgaWQgdG8gbmFtZSBtYXBwaW5nIG9ubHlcbmZ1bmN0aW9uIF9JXyhpZCwgbmFtZSkge1xuICBvaWRzW2lkXSA9IG5hbWU7XG59XG5cbi8vIGFsZ29yaXRobSBPSURzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xJywgJ3JzYUVuY3J5cHRpb24nKTtcbi8vIE5vdGU6IG1kMiAmIG1kNCBub3QgaW1wbGVtZW50ZWRcbi8vX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMicsICdtZDJXaXRoUlNBRW5jcnlwdGlvbicpO1xuLy9fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4zJywgJ21kNFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS40JywgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS41JywgJ3NoYTFXaXRoUlNBRW5jcnlwdGlvbicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuNycsICdSU0FFUy1PQUVQJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS44JywgJ21nZjEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjknLCAncFNwZWNpZmllZCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTAnLCAnUlNBU1NBLVBTUycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEuMTEnLCAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xLjEyJywgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMS4xMycsICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbicpO1xuXG5fSU4oJzEuMi44NDAuMTAwNDAuNC4zJywgJ2RzYS13aXRoLXNoYTEnKTtcblxuX0lOKCcxLjMuMTQuMy4yLjcnLCAnZGVzQ0JDJyk7XG5cbl9JTignMS4zLjE0LjMuMi4yNicsICdzaGExJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnLCAnc2hhMjU2Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjInLCAnc2hhMzg0Jyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4yLjMnLCAnc2hhNTEyJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuNScsICdtZDUnKTtcblxuLy8gcGtjcyM3IGNvbnRlbnQgdHlwZXNcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjEnLCAnZGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuMicsICdzaWduZWREYXRhJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuNy4zJywgJ2VudmVsb3BlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjQnLCAnc2lnbmVkQW5kRW52ZWxvcGVkRGF0YScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjcuNScsICdkaWdlc3RlZERhdGEnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS43LjYnLCAnZW5jcnlwdGVkRGF0YScpO1xuXG4vLyBwa2NzIzkgb2lkc1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMScsICdlbWFpbEFkZHJlc3MnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjInLCAndW5zdHJ1Y3R1cmVkTmFtZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMycsICdjb250ZW50VHlwZScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuNCcsICdtZXNzYWdlRGlnZXN0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS41JywgJ3NpZ25pbmdUaW1lJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS42JywgJ2NvdW50ZXJTaWduYXR1cmUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjcnLCAnY2hhbGxlbmdlUGFzc3dvcmQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjgnLCAndW5zdHJ1Y3R1cmVkQWRkcmVzcycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjkuMTQnLCAnZXh0ZW5zaW9uUmVxdWVzdCcpO1xuXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuOS4yMCcsICdmcmllbmRseU5hbWUnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIxJywgJ2xvY2FsS2V5SWQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS45LjIyLjEnLCAneDUwOUNlcnRpZmljYXRlJyk7XG5cbi8vIHBrY3MjMTIgc2FmZSBiYWdzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4xJywgJ2tleUJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuMicsICdwa2NzOFNocm91ZGVkS2V5QmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS4zJywgJ2NlcnRCYWcnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xMC4xLjQnLCAnY3JsQmFnJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMTAuMS41JywgJ3NlY3JldEJhZycpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEwLjEuNicsICdzYWZlQ29udGVudHNCYWcnKTtcblxuLy8gcGFzc3dvcmQtYmFzZWQtZW5jcnlwdGlvbiBmb3IgcGtjcyMxMlxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTMnLCAncGtjczVQQkVTMicpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjUuMTInLCAncGtjczVQQktERjInKTtcblxuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMScsICdwYmVXaXRoU0hBQW5kMTI4Qml0UkM0Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS4yJywgJ3BiZVdpdGhTSEFBbmQ0MEJpdFJDNCcpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4xLjEyLjEuMycsICdwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjEuMTIuMS40JywgJ3BiZVdpdGhTSEFBbmQyLUtleVRyaXBsZURFUy1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjUnLCAncGJlV2l0aFNIQUFuZDEyOEJpdFJDMi1DQkMnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMS4xMi4xLjYnLCAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQycpO1xuXG4vLyBobWFjIE9JRHNcbl9JTignMS4yLjg0MC4xMTM1NDkuMi43JywgJ2htYWNXaXRoU0hBMScpO1xuX0lOKCcxLjIuODQwLjExMzU0OS4yLjgnLCAnaG1hY1dpdGhTSEEyMjQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi45JywgJ2htYWNXaXRoU0hBMjU2Jyk7XG5fSU4oJzEuMi44NDAuMTEzNTQ5LjIuMTAnLCAnaG1hY1dpdGhTSEEzODQnKTtcbl9JTignMS4yLjg0MC4xMTM1NDkuMi4xMScsICdobWFjV2l0aFNIQTUxMicpO1xuXG4vLyBzeW1tZXRyaWMga2V5IGFsZ29yaXRobSBvaWRzXG5fSU4oJzEuMi44NDAuMTEzNTQ5LjMuNycsICdkZXMtRURFMy1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuMicsICdhZXMxMjgtQ0JDJyk7XG5fSU4oJzIuMTYuODQwLjEuMTAxLjMuNC4xLjIyJywgJ2FlczE5Mi1DQkMnKTtcbl9JTignMi4xNi44NDAuMS4xMDEuMy40LjEuNDInLCAnYWVzMjU2LUNCQycpO1xuXG4vLyBjZXJ0aWZpY2F0ZSBpc3N1ZXIvc3ViamVjdCBPSURzXG5fSU4oJzIuNS40LjMnLCAnY29tbW9uTmFtZScpO1xuX0lOKCcyLjUuNC41JywgJ3NlcmlhbE5hbWUnKTtcbl9JTignMi41LjQuNicsICdjb3VudHJ5TmFtZScpO1xuX0lOKCcyLjUuNC43JywgJ2xvY2FsaXR5TmFtZScpO1xuX0lOKCcyLjUuNC44JywgJ3N0YXRlT3JQcm92aW5jZU5hbWUnKTtcbl9JTignMi41LjQuMTAnLCAnb3JnYW5pemF0aW9uTmFtZScpO1xuX0lOKCcyLjUuNC4xMScsICdvcmdhbml6YXRpb25hbFVuaXROYW1lJyk7XG5fSU4oJzIuNS40LjEzJywgJ2Rlc2NyaXB0aW9uJyk7XG5cbi8vIFguNTA5IGV4dGVuc2lvbiBPSURzXG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMScsICduc0NlcnRUeXBlJyk7XG5fSU4oJzIuMTYuODQwLjEuMTEzNzMwLjEuMTMnLCAnbnNDb21tZW50Jyk7IC8vIGRlcHJlY2F0ZWQgaW4gdGhlb3J5OyBzdGlsbCB3aWRlbHkgdXNlZFxuX0lfKCcyLjUuMjkuMScsICdhdXRob3JpdHlLZXlJZGVudGlmaWVyJyk7IC8vIGRlcHJlY2F0ZWQsIHVzZSAuMzVcbl9JXygnMi41LjI5LjInLCAna2V5QXR0cmlidXRlcycpOyAvLyBvYnNvbGV0ZSB1c2UgLjM3IG9yIC4xNVxuX0lfKCcyLjUuMjkuMycsICdjZXJ0aWZpY2F0ZVBvbGljaWVzJyk7IC8vIGRlcHJlY2F0ZWQsIHVzZSAuMzJcbl9JXygnMi41LjI5LjQnLCAna2V5VXNhZ2VSZXN0cmljdGlvbicpOyAvLyBvYnNvbGV0ZSB1c2UgLjM3IG9yIC4xNVxuX0lfKCcyLjUuMjkuNScsICdwb2xpY3lNYXBwaW5nJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zM1xuX0lfKCcyLjUuMjkuNicsICdzdWJ0cmVlc0NvbnN0cmFpbnQnKTsgLy8gb2Jzb2xldGUgdXNlIC4zMFxuX0lfKCcyLjUuMjkuNycsICdzdWJqZWN0QWx0TmFtZScpOyAvLyBkZXByZWNhdGVkIHVzZSAuMTdcbl9JXygnMi41LjI5LjgnLCAnaXNzdWVyQWx0TmFtZScpOyAvLyBkZXByZWNhdGVkIHVzZSAuMThcbl9JXygnMi41LjI5LjknLCAnc3ViamVjdERpcmVjdG9yeUF0dHJpYnV0ZXMnKTtcbl9JXygnMi41LjI5LjEwJywgJ2Jhc2ljQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE5XG5fSV8oJzIuNS4yOS4xMScsICduYW1lQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjMwXG5fSV8oJzIuNS4yOS4xMicsICdwb2xpY3lDb25zdHJhaW50cycpOyAvLyBkZXByZWNhdGVkIHVzZSAuMzZcbl9JXygnMi41LjI5LjEzJywgJ2Jhc2ljQ29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjE5XG5fSU4oJzIuNS4yOS4xNCcsICdzdWJqZWN0S2V5SWRlbnRpZmllcicpO1xuX0lOKCcyLjUuMjkuMTUnLCAna2V5VXNhZ2UnKTtcbl9JXygnMi41LjI5LjE2JywgJ3ByaXZhdGVLZXlVc2FnZVBlcmlvZCcpO1xuX0lOKCcyLjUuMjkuMTcnLCAnc3ViamVjdEFsdE5hbWUnKTtcbl9JTignMi41LjI5LjE4JywgJ2lzc3VlckFsdE5hbWUnKTtcbl9JTignMi41LjI5LjE5JywgJ2Jhc2ljQ29uc3RyYWludHMnKTtcbl9JXygnMi41LjI5LjIwJywgJ2NSTE51bWJlcicpO1xuX0lfKCcyLjUuMjkuMjEnLCAnY1JMUmVhc29uJyk7XG5fSV8oJzIuNS4yOS4yMicsICdleHBpcmF0aW9uRGF0ZScpO1xuX0lfKCcyLjUuMjkuMjMnLCAnaW5zdHJ1Y3Rpb25Db2RlJyk7XG5fSV8oJzIuNS4yOS4yNCcsICdpbnZhbGlkaXR5RGF0ZScpO1xuX0lfKCcyLjUuMjkuMjUnLCAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4zMVxuX0lfKCcyLjUuMjkuMjYnLCAnaXNzdWluZ0Rpc3RyaWJ1dGlvblBvaW50Jyk7IC8vIGRlcHJlY2F0ZWQgdXNlIC4yOFxuX0lfKCcyLjUuMjkuMjcnLCAnZGVsdGFDUkxJbmRpY2F0b3InKTtcbl9JXygnMi41LjI5LjI4JywgJ2lzc3VpbmdEaXN0cmlidXRpb25Qb2ludCcpO1xuX0lfKCcyLjUuMjkuMjknLCAnY2VydGlmaWNhdGVJc3N1ZXInKTtcbl9JXygnMi41LjI5LjMwJywgJ25hbWVDb25zdHJhaW50cycpO1xuX0lOKCcyLjUuMjkuMzEnLCAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJyk7XG5fSU4oJzIuNS4yOS4zMicsICdjZXJ0aWZpY2F0ZVBvbGljaWVzJyk7XG5fSV8oJzIuNS4yOS4zMycsICdwb2xpY3lNYXBwaW5ncycpO1xuX0lfKCcyLjUuMjkuMzQnLCAncG9saWN5Q29uc3RyYWludHMnKTsgLy8gZGVwcmVjYXRlZCB1c2UgLjM2XG5fSU4oJzIuNS4yOS4zNScsICdhdXRob3JpdHlLZXlJZGVudGlmaWVyJyk7XG5fSV8oJzIuNS4yOS4zNicsICdwb2xpY3lDb25zdHJhaW50cycpO1xuX0lOKCcyLjUuMjkuMzcnLCAnZXh0S2V5VXNhZ2UnKTtcbl9JXygnMi41LjI5LjQ2JywgJ2ZyZXNoZXN0Q1JMJyk7XG5fSV8oJzIuNS4yOS41NCcsICdpbmhpYml0QW55UG9saWN5Jyk7XG5cbi8vIGV4dEtleVVzYWdlIHB1cnBvc2VzXG5fSU4oJzEuMy42LjEuNC4xLjExMTI5LjIuNC4yJywgJ3RpbWVzdGFtcExpc3QnKTtcbl9JTignMS4zLjYuMS41LjUuNy4xLjEnLCAnYXV0aG9yaXR5SW5mb0FjY2VzcycpO1xuX0lOKCcxLjMuNi4xLjUuNS43LjMuMScsICdzZXJ2ZXJBdXRoJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy4yJywgJ2NsaWVudEF1dGgnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjMnLCAnY29kZVNpZ25pbmcnKTtcbl9JTignMS4zLjYuMS41LjUuNy4zLjQnLCAnZW1haWxQcm90ZWN0aW9uJyk7XG5fSU4oJzEuMy42LjEuNS41LjcuMy44JywgJ3RpbWVTdGFtcGluZycpO1xuIiwiLyoqXG4gKiBQYXNzd29yZC1iYXNlZCBlbmNyeXB0aW9uIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICogQGF1dGhvciBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBBbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbzpcbiAqXG4gKiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBlbmNyeXB0aW9uQWxnb3JpdGhtICBFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGF0YSAgICAgICAgRW5jcnlwdGVkRGF0YSB9XG4gKlxuICogRW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBPQ1RFVCBTVFJJTkdcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hZXMnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi9kZXMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wYmtkZjInKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9yYzInKTtcbnJlcXVpcmUoJy4vcnNhJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxuaWYodHlwZW9mIEJpZ0ludGVnZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyO1xufVxuXG4vLyBzaG9ydGN1dCBmb3IgYXNuLjEgQVBJXG52YXIgYXNuMSA9IGZvcmdlLmFzbjE7XG5cbi8qIFBhc3N3b3JkLWJhc2VkIGVuY3J5cHRpb24gaW1wbGVtZW50YXRpb24uICovXG52YXIgcGtpID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBwa2kucGJlID0gZm9yZ2UucGJlID0gZm9yZ2UucGJlIHx8IHt9O1xudmFyIG9pZHMgPSBwa2kub2lkcztcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHcvYWxnb3JpdGhtIHBhcmFtc1xudmFyIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZFByaXZhdGVLZXlJbmZvLmVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdlbmNyeXB0aW9uT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRpb25QYXJhbXMnXG4gICAgfV1cbiAgfSwge1xuICAgIC8vIGVuY3J5cHRlZERhdGFcbiAgICBuYW1lOiAnRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uZW5jcnlwdGVkRGF0YScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2VuY3J5cHRlZERhdGEnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgUEJFUzJBbGdvcml0aG1zIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgdy9QQktERjIgKyBBRVMgZW5jcnlwdGlvbiBzY2hlbWVzXG52YXIgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmtleURlcml2YXRpb25GdW5jJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5rZXlEZXJpdmF0aW9uRnVuYy5vaWQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdrZGZPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMuc2FsdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdrZGZTYWx0J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5pdGVyYXRpb25Db3VudCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ2tkZkl0ZXJhdGlvbkNvdW50J1xuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLnBhcmFtcy5rZXlMZW5ndGgnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiAna2V5TGVuZ3RoJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBwcmZcbiAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ1BCRVMyQWxnb3JpdGhtcy5wYXJhbXMucHJmLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdwcmZPaWQnXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnUEJFUzJBbGdvcml0aG1zLmVuY3J5cHRpb25TY2hlbWUub2lkJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jT2lkJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQQkVTMkFsZ29yaXRobXMuZW5jcnlwdGlvblNjaGVtZS5pdicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jSXYnXG4gICAgfV1cbiAgfV1cbn07XG5cbnZhciBwa2NzMTJQYmVQYXJhbXNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncGtjcy0xMlBiZVBhcmFtcy5zYWx0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2FsdCdcbiAgfSwge1xuICAgIG5hbWU6ICdwa2NzLTEyUGJlUGFyYW1zLml0ZXJhdGlvbnMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2l0ZXJhdGlvbnMnXG4gIH1dXG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGEgQVNOLjEgUHJpdmF0ZUtleUluZm8gb2JqZWN0LCBwcm9kdWNpbmcgYW4gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKlxuICogUEJFUzJBbGdvcml0aG1zIEFMR09SSVRITS1JREVOVElGSUVSIDo6PVxuICogICB7IHtQQkVTMi1wYXJhbXMgSURFTlRJRklFRCBCWSBpZC1QQkVTMn0sIC4uLn1cbiAqXG4gKiBpZC1QQkVTMiBPQkpFQ1QgSURFTlRJRklFUiA6Oj0ge3BrY3MtNSAxM31cbiAqXG4gKiBQQkVTMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAga2V5RGVyaXZhdGlvbkZ1bmMgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCRVMyLUtERnN9fSxcbiAqICAgZW5jcnlwdGlvblNjaGVtZSBBbGdvcml0aG1JZGVudGlmaWVyIHt7UEJFUzItRW5jc319XG4gKiB9XG4gKlxuICogUEJFUzItS0RGcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj1cbiAqICAgeyB7UEJLREYyLXBhcmFtcyBJREVOVElGSUVEIEJZIGlkLVBCS0RGMn0sIC4uLiB9XG4gKlxuICogUEJFUzItRW5jcyBBTEdPUklUSE0tSURFTlRJRklFUiA6Oj0geyAuLi4gfVxuICpcbiAqIFBCS0RGMi1wYXJhbXMgOjo9IFNFUVVFTkNFIHtcbiAqICAgc2FsdCBDSE9JQ0Uge1xuICogICAgIHNwZWNpZmllZCBPQ1RFVCBTVFJJTkcsXG4gKiAgICAgb3RoZXJTb3VyY2UgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1TYWx0U291cmNlc319XG4gKiAgIH0sXG4gKiAgIGl0ZXJhdGlvbkNvdW50IElOVEVHRVIgKDEuLk1BWCksXG4gKiAgIGtleUxlbmd0aCBJTlRFR0VSICgxLi5NQVgpIE9QVElPTkFMLFxuICogICBwcmYgQWxnb3JpdGhtSWRlbnRpZmllciB7e1BCS0RGMi1QUkZzfX0gREVGQVVMVCBhbGdpZC1obWFjV2l0aFNIQTFcbiAqIH1cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHByZkFsZ29yaXRobSB0aGUgUFJGIG1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdzaGExJywgJ3NoYTIyNCcsICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicpXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8gPSBmdW5jdGlvbihvYmosIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIG9wdGlvbnMucHJmQWxnb3JpdGhtID0gb3B0aW9ucy5wcmZBbGdvcml0aG0gfHwgJ3NoYTEnO1xuXG4gIC8vIGdlbmVyYXRlIFBCRSBwYXJhbXNcbiAgdmFyIHNhbHQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKG9wdGlvbnMuc2FsdFNpemUpO1xuICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICB2YXIgY291bnRCeXRlcyA9IGFzbjEuaW50ZWdlclRvRGVyKGNvdW50KTtcbiAgdmFyIGRrTGVuO1xuICB2YXIgZW5jcnlwdGlvbkFsZ29yaXRobTtcbiAgdmFyIGVuY3J5cHRlZERhdGE7XG4gIGlmKG9wdGlvbnMuYWxnb3JpdGhtLmluZGV4T2YoJ2FlcycpID09PSAwIHx8IG9wdGlvbnMuYWxnb3JpdGhtID09PSAnZGVzJykge1xuICAgIC8vIGRvIFBCRVMyXG4gICAgdmFyIGl2TGVuLCBlbmNPaWQsIGNpcGhlckZuO1xuICAgIHN3aXRjaChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ2FlczEyOCc6XG4gICAgICBka0xlbiA9IDE2O1xuICAgICAgaXZMZW4gPSAxNjtcbiAgICAgIGVuY09pZCA9IG9pZHNbJ2FlczEyOC1DQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZXMxOTInOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGl2TGVuID0gMTY7XG4gICAgICBlbmNPaWQgPSBvaWRzWydhZXMxOTItQ0JDJ107XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWVzMjU2JzpcbiAgICAgIGRrTGVuID0gMzI7XG4gICAgICBpdkxlbiA9IDE2O1xuICAgICAgZW5jT2lkID0gb2lkc1snYWVzMjU2LUNCQyddO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rlcyc6XG4gICAgICBka0xlbiA9IDg7XG4gICAgICBpdkxlbiA9IDg7XG4gICAgICBlbmNPaWQgPSBvaWRzWydkZXNDQkMnXTtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCBwcml2YXRlIGtleS4gVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobS4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICAgIHZhciBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGgnICsgb3B0aW9ucy5wcmZBbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICB2YXIgbWQgPSBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcblxuICAgIC8vIGVuY3J5cHQgcHJpdmF0ZSBrZXkgdXNpbmcgcGJlIFNIQS0xIGFuZCBBRVMvREVTXG4gICAgdmFyIGRrID0gZm9yZ2UucGtjczUucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBjb3VudCwgZGtMZW4sIG1kKTtcbiAgICB2YXIgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKGl2TGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShhc24xLnRvRGVyKG9iaikpO1xuICAgIGNpcGhlci5maW5pc2goKTtcbiAgICBlbmNyeXB0ZWREYXRhID0gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xuXG4gICAgLy8gZ2V0IFBCS0RGMi1wYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gY3JlYXRlUGJrZGYyUGFyYW1zKHNhbHQsIGNvdW50Qnl0ZXMsIGRrTGVuLCBwcmZBbGdvcml0aG0pO1xuXG4gICAgZW5jcnlwdGlvbkFsZ29yaXRobSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJFUzInXSkuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGtleURlcml2YXRpb25GdW5jXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICBhc24xLm9pZFRvRGVyKG9pZHNbJ3BrY3M1UEJLREYyJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgICAgIC8vIFBCS0RGMi1wYXJhbXNcbiAgICAgICAgICBwYXJhbXNcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGVuY3J5cHRpb25TY2hlbWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEub2lkVG9EZXIoZW5jT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBpdlxuICAgICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGl2KVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnM2RlcycpIHtcbiAgICAvLyBEbyBQS0NTMTIgUEJFXG4gICAgZGtMZW4gPSAyNDtcblxuICAgIHZhciBzYWx0Qnl0ZXMgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKHNhbHQpO1xuICAgIHZhciBkayA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHRCeXRlcywgMSwgY291bnQsIGRrTGVuKTtcbiAgICB2YXIgaXYgPSBwa2kucGJlLmdlbmVyYXRlUGtjczEyS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIDIsIGNvdW50LCBka0xlbik7XG4gICAgdmFyIGNpcGhlciA9IGZvcmdlLmRlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGRrKTtcbiAgICBjaXBoZXIuc3RhcnQoaXYpO1xuICAgIGNpcGhlci51cGRhdGUoYXNuMS50b0RlcihvYmopKTtcbiAgICBjaXBoZXIuZmluaXNoKCk7XG4gICAgZW5jcnlwdGVkRGF0YSA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcblxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0gPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0RlcihvaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ10pLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGtjcy0xMlBiZVBhcmFtc1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBzYWx0XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLCBzYWx0KSxcbiAgICAgICAgLy8gaXRlcmF0aW9uIGNvdW50XG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgICAgY291bnRCeXRlcy5nZXRCeXRlcygpKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHByaXZhdGUga2V5LiBVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gZW5jcnlwdGlvbkFsZ29yaXRobVxuICAgIGVuY3J5cHRpb25BbGdvcml0aG0sXG4gICAgLy8gZW5jcnlwdGVkRGF0YVxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGVuY3J5cHRlZERhdGEpXG4gIF0pO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYSBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgUHJpdmF0ZUtleUluZm8gb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvID0gZnVuY3Rpb24ob2JqLCBwYXNzd29yZCkge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZ2V0IFBCRSBwYXJhbXNcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIGVuY3J5cHRlZFByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnQVNOLjEgb2JqZWN0IGlzIG5vdCBhIHN1cHBvcnRlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuZW5jcnlwdGlvbk9pZCk7XG4gIHZhciBjaXBoZXIgPSBwa2kucGJlLmdldENpcGhlcihvaWQsIGNhcHR1cmUuZW5jcnlwdGlvblBhcmFtcywgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5lbmNyeXB0ZWREYXRhKTtcblxuICBjaXBoZXIudXBkYXRlKGVuY3J5cHRlZCk7XG4gIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgIHJ2YWwgPSBhc24xLmZyb21EZXIoY2lwaGVyLm91dHB1dCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBlcGtpIHRoZSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgZW5jcnlwdGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oZXBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0VOQ1JZUFRFRCBQUklWQVRFIEtFWScsXG4gICAgYm9keTogYXNuMS50b0RlcihlcGtpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQRU0tZW5jb2RlZCBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbyB0byBBU04uMSBmb3JtYXQuIERlY3J5cHRpb25cbiAqIGlzIG5vdCBwZXJmb3JtZWQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gaW4gUEVNLWZvcm1hdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLmVuY3J5cHRlZFByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdFTkNSWVBURUQgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBoZWFkZXIgdHlwZSBpcyBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgcmV0dXJuIGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIEVuY3J5cHRzIGFuIFJTQSBwcml2YXRlIGtleS4gQnkgZGVmYXVsdCwgdGhlIGtleSB3aWxsIGJlIHdyYXBwZWQgaW5cbiAqIGEgUHJpdmF0ZUtleUluZm8gYW5kIGVuY3J5cHRlZCB0byBwcm9kdWNlIGEgUEtDUyM4IEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLlxuICogVGhpcyBpcyB0aGUgc3RhbmRhcmQsIHByZWZlcnJlZCB3YXkgdG8gZW5jcnlwdCBhIHByaXZhdGUga2V5LlxuICpcbiAqIFRvIHByb2R1Y2UgYSBub24tc3RhbmRhcmQgUEVNLWVuY3J5cHRlZCBwcml2YXRlIGtleSB0aGF0IHVzZXMgZW5jYXBzdWxhdGVkXG4gKiBoZWFkZXJzIHRvIGluZGljYXRlIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSAob2xkLXN0eWxlIG5vbi1QS0NTIzggT3BlblNTTFxuICogcHJpdmF0ZSBrZXkgZW5jcnlwdGlvbiksIHNldCB0aGUgJ2xlZ2FjeScgb3B0aW9uIHRvIHRydWUuIE5vdGU6IFVzaW5nIHRoaXNcbiAqIG9wdGlvbiB3aWxsIGNhdXNlIHRoZSBpdGVyYXRpb24gY291bnQgdG8gYmUgZm9yY2VkIHRvIDEuXG4gKlxuICogTm90ZTogVGhlICdkZXMnIGFsZ29yaXRobSBpcyBzdXBwb3J0ZWQsIGJ1dCBpdCBpcyBub3QgY29uc2lkZXJlZCB0byBiZVxuICogc2VjdXJlIGJlY2F1c2UgaXQgb25seSB1c2VzIGEgc2luZ2xlIDU2LWJpdCBrZXkuIElmIHBvc3NpYmxlLCBpdCBpcyBoaWdobHlcbiAqIHJlY29tbWVuZGVkIHRoYXQgYSBkaWZmZXJlbnQgYWxnb3JpdGhtIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgUlNBIGtleSB0byBlbmNyeXB0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byB1c2UuXG4gKiBAcGFyYW0gb3B0aW9uczpcbiAqICAgICAgICAgIGFsZ29yaXRobTogdGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtIHRvIHVzZVxuICogICAgICAgICAgICAoJ2FlczEyOCcsICdhZXMxOTInLCAnYWVzMjU2JywgJzNkZXMnLCAnZGVzJykuXG4gKiAgICAgICAgICBjb3VudDogdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZTogdGhlIHNhbHQgc2l6ZSB0byB1c2UuXG4gKiAgICAgICAgICBsZWdhY3k6IG91dHB1dCBhbiBvbGQgbm9uLVBLQ1MjOCBQRU0tZW5jcnlwdGVkK2VuY2Fwc3VsYXRlZFxuICogICAgICAgICAgICBoZWFkZXJzIChERUstSW5mbykgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWVuY29kZWQgQVNOLjEgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8uXG4gKi9cbnBraS5lbmNyeXB0UnNhUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKHJzYUtleSwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcbiAgLy8gc3RhbmRhcmQgUEtDUyM4XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZighb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAvLyBlbmNyeXB0IFByaXZhdGVLZXlJbmZvXG4gICAgdmFyIHJ2YWwgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSk7XG4gICAgcnZhbCA9IHBraS5lbmNyeXB0UHJpdmF0ZUtleUluZm8ocnZhbCwgcGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwa2kuZW5jcnlwdGVkUHJpdmF0ZUtleVRvUGVtKHJ2YWwpO1xuICB9XG5cbiAgLy8gbGVnYWN5IG5vbi1QS0NTIzhcbiAgdmFyIGFsZ29yaXRobTtcbiAgdmFyIGl2O1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2FlczEyOCc6XG4gICAgYWxnb3JpdGhtID0gJ0FFUy0xMjgtQ0JDJztcbiAgICBka0xlbiA9IDE2O1xuICAgIGl2ID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzU3luYygxNik7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnYWVzMTkyJzpcbiAgICBhbGdvcml0aG0gPSAnQUVTLTE5Mi1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDE2KTtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMyNTYnOlxuICAgIGFsZ29yaXRobSA9ICdBRVMtMjU2LUNCQyc7XG4gICAgZGtMZW4gPSAzMjtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoMTYpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJzNkZXMnOlxuICAgIGFsZ29yaXRobSA9ICdERVMtRURFMy1DQkMnO1xuICAgIGRrTGVuID0gMjQ7XG4gICAgaXYgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXNTeW5jKDgpO1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZUVuY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlcyc6XG4gICAgYWxnb3JpdGhtID0gJ0RFUy1DQkMnO1xuICAgIGRrTGVuID0gODtcbiAgICBpdiA9IGZvcmdlLnJhbmRvbS5nZXRCeXRlc1N5bmMoOCk7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRW5jcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBlbmNyeXB0IFJTQSBwcml2YXRlIGtleTsgdW5zdXBwb3J0ZWQgJyArXG4gICAgICAnZW5jcnlwdGlvbiBhbGdvcml0aG0gXCInICsgb3B0aW9ucy5hbGdvcml0aG0gKyAnXCIuJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG07XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBlbmNyeXB0IHByaXZhdGUga2V5IHVzaW5nIE9wZW5TU0wgbGVnYWN5IGtleSBkZXJpdmF0aW9uXG4gIHZhciBkayA9IGZvcmdlLnBiZS5vcGVuc3NsRGVyaXZlQnl0ZXMocGFzc3dvcmQsIGl2LnN1YnN0cigwLCA4KSwgZGtMZW4pO1xuICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICBjaXBoZXIuc3RhcnQoaXYpO1xuICBjaXBoZXIudXBkYXRlKGFzbjEudG9EZXIocGtpLnByaXZhdGVLZXlUb0FzbjEocnNhS2V5KSkpO1xuICBjaXBoZXIuZmluaXNoKCk7XG5cbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBwcm9jVHlwZToge1xuICAgICAgdmVyc2lvbjogJzQnLFxuICAgICAgdHlwZTogJ0VOQ1JZUFRFRCdcbiAgICB9LFxuICAgIGRla0luZm86IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgcGFyYW1ldGVyczogZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGl2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSxcbiAgICBib2R5OiBjaXBoZXIub3V0cHV0LmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnKTtcbn07XG5cbi8qKlxuICogRGVjcnlwdHMgYW4gUlNBIHByaXZhdGUga2V5LlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgRW5jcnlwdGVkUHJpdmF0ZUtleUluZm8gdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIFJTQSBrZXkgb24gc3VjY2VzcywgbnVsbCBvbiBmYWlsdXJlLlxuICovXG5wa2kuZGVjcnlwdFJzYVByaXZhdGVLZXkgPSBmdW5jdGlvbihwZW0sIHBhc3N3b3JkKSB7XG4gIHZhciBydmFsID0gbnVsbDtcblxuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuXG4gIGlmKG1zZy50eXBlICE9PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJyAmJlxuICAgIG1zZy50eXBlICE9PSAnUFJJVkFURSBLRVknICYmXG4gICAgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNIGhlYWRlciB0eXBlICcgK1xuICAgICAgJ2lzIG5vdCBcIkVOQ1JZUFRFRCBQUklWQVRFIEtFWVwiLCBcIlBSSVZBVEUgS0VZXCIsIG9yIFwiUlNBIFBSSVZBVEUgS0VZXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHZhciBka0xlbjtcbiAgICB2YXIgY2lwaGVyRm47XG4gICAgc3dpdGNoKG1zZy5kZWtJbmZvLmFsZ29yaXRobSkge1xuICAgIGNhc2UgJ0RFUy1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0RFUy1FREUzLUNCQyc6XG4gICAgICBka0xlbiA9IDI0O1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5kZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0FFUy0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnQUVTLTE5Mi1DQkMnOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBRVMtMjU2LUNCQyc6XG4gICAgICBka0xlbiA9IDMyO1xuICAgICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi00MC1DQkMnOlxuICAgICAgZGtMZW4gPSA1O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi02NC1DQkMnOlxuICAgICAgZGtMZW4gPSA4O1xuICAgICAgY2lwaGVyRm4gPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNjQpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1JDMi0xMjgtQ0JDJzpcbiAgICAgIGRrTGVuID0gMTY7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZWNyeXB0IHByaXZhdGUga2V5OyB1bnN1cHBvcnRlZCAnICtcbiAgICAgICAgJ2VuY3J5cHRpb24gYWxnb3JpdGhtIFwiJyArIG1zZy5kZWtJbmZvLmFsZ29yaXRobSArICdcIi4nKTtcbiAgICAgIGVycm9yLmFsZ29yaXRobSA9IG1zZy5kZWtJbmZvLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHVzZSBPcGVuU1NMIGxlZ2FjeSBrZXkgZGVyaXZhdGlvblxuICAgIHZhciBpdiA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB2YXIgZGsgPSBmb3JnZS5wYmUub3BlbnNzbERlcml2ZUJ5dGVzKHBhc3N3b3JkLCBpdi5zdWJzdHIoMCwgOCksIGRrTGVuKTtcbiAgICB2YXIgY2lwaGVyID0gY2lwaGVyRm4oZGspO1xuICAgIGNpcGhlci5zdGFydChpdik7XG4gICAgY2lwaGVyLnVwZGF0ZShmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSkpO1xuICAgIGlmKGNpcGhlci5maW5pc2goKSkge1xuICAgICAgcnZhbCA9IGNpcGhlci5vdXRwdXQuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJ2YWwgPSBtc2cuYm9keTtcbiAgfVxuXG4gIGlmKG1zZy50eXBlID09PSAnRU5DUllQVEVEIFBSSVZBVEUgS0VZJykge1xuICAgIHJ2YWwgPSBwa2kuZGVjcnlwdFByaXZhdGVLZXlJbmZvKGFzbjEuZnJvbURlcihydmFsKSwgcGFzc3dvcmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlY3J5cHRpb24gYWxyZWFkeSBwZXJmb3JtZWQgYWJvdmVcbiAgICBydmFsID0gYXNuMS5mcm9tRGVyKHJ2YWwpO1xuICB9XG5cbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIHJ2YWwgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKHJ2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIERlcml2ZXMgYSBQS0NTIzEyIGtleS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IG1hdGVyaWFsIGZyb20sIG51bGwgb3JcbiAqICAgICAgICAgIHVuZGVmaW5lZCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBzYWx0IHRoZSBzYWx0LCBhcyBhIEJ5dGVCdWZmZXIsIHRvIHVzZS5cbiAqIEBwYXJhbSBpZCB0aGUgUEtDUyMxMiBJRCBieXRlICgxID0ga2V5IG1hdGVyaWFsLCAyID0gSVYsIDMgPSBNQUMpLlxuICogQHBhcmFtIGl0ZXIgdGhlIGl0ZXJhdGlvbiBjb3VudC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZGVyaXZlIGZyb20gdGhlIHBhc3N3b3JkLlxuICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCB0byB1c2UsIGRlZmF1bHRzIHRvIFNIQS0xLlxuICpcbiAqIEByZXR1cm4gYSBCeXRlQnVmZmVyIHdpdGggdGhlIGJ5dGVzIGRlcml2ZWQgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKi9cbnBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkgPSBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgaWQsIGl0ZXIsIG4sIG1kKSB7XG4gIHZhciBqLCBsO1xuXG4gIGlmKHR5cGVvZiBtZCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWQgPT09IG51bGwpIHtcbiAgICBpZighKCdzaGExJyBpbiBmb3JnZS5tZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzaGExXCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuXG4gIHZhciB1ID0gbWQuZGlnZXN0TGVuZ3RoO1xuICB2YXIgdiA9IG1kLmJsb2NrTGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuXG4gIC8qIENvbnZlcnQgcGFzc3dvcmQgdG8gVW5pY29kZSBieXRlIGJ1ZmZlciArIHRyYWlsaW5nIDAtYnl0ZS4gKi9cbiAgdmFyIHBhc3NCdWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIGlmKHBhc3N3b3JkICE9PSBudWxsICYmIHBhc3N3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IobCA9IDA7IGwgPCBwYXNzd29yZC5sZW5ndGg7IGwrKykge1xuICAgICAgcGFzc0J1Zi5wdXRJbnQxNihwYXNzd29yZC5jaGFyQ29kZUF0KGwpKTtcbiAgICB9XG4gICAgcGFzc0J1Zi5wdXRJbnQxNigwKTtcbiAgfVxuXG4gIC8qIExlbmd0aCBvZiBzYWx0IGFuZCBwYXNzd29yZCBpbiBCWVRFUy4gKi9cbiAgdmFyIHAgPSBwYXNzQnVmLmxlbmd0aCgpO1xuICB2YXIgcyA9IHNhbHQubGVuZ3RoKCk7XG5cbiAgLyogMS4gQ29uc3RydWN0IGEgc3RyaW5nLCBEICh0aGUgXCJkaXZlcnNpZmllclwiKSwgYnkgY29uY2F0ZW5hdGluZ1xuICAgICAgICB2IGNvcGllcyBvZiBJRC4gKi9cbiAgdmFyIEQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gIEQuZmlsbFdpdGhCeXRlKGlkLCB2KTtcblxuICAvKiAyLiBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgdGhlIHNhbHQgdG9nZXRoZXIgdG8gY3JlYXRlIGEgc3RyaW5nIFMgb2YgbGVuZ3RoXG4gICAgICAgIHYgKiBjZWlsKHMgLyB2KSBieXRlcyAodGhlIGZpbmFsIGNvcHkgb2YgdGhlIHNhbHQgbWF5IGJlIHRydW5hY3RlZFxuICAgICAgICB0byBjcmVhdGUgUykuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgc2FsdCBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNvIGlzIFMuICovXG4gIHZhciBTbGVuID0gdiAqIE1hdGguY2VpbChzIC8gdik7XG4gIHZhciBTID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICBmb3IobCA9IDA7IGwgPCBTbGVuOyBsKyspIHtcbiAgICBTLnB1dEJ5dGUoc2FsdC5hdChsICUgcykpO1xuICB9XG5cbiAgLyogMy4gQ29uY2F0ZW5hdGUgY29waWVzIG9mIHRoZSBwYXNzd29yZCB0b2dldGhlciB0byBjcmVhdGUgYSBzdHJpbmcgUCBvZlxuICAgICAgICBsZW5ndGggdiAqIGNlaWwocCAvIHYpIGJ5dGVzICh0aGUgZmluYWwgY29weSBvZiB0aGUgcGFzc3dvcmQgbWF5IGJlXG4gICAgICAgIHRydW5jYXRlZCB0byBjcmVhdGUgUCkuXG4gICAgICAgIE5vdGUgdGhhdCBpZiB0aGUgcGFzc3dvcmQgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzbyBpcyBQLiAqL1xuICB2YXIgUGxlbiA9IHYgKiBNYXRoLmNlaWwocCAvIHYpO1xuICB2YXIgUCA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgZm9yKGwgPSAwOyBsIDwgUGxlbjsgbCsrKSB7XG4gICAgUC5wdXRCeXRlKHBhc3NCdWYuYXQobCAlIHApKTtcbiAgfVxuXG4gIC8qIDQuIFNldCBJPVN8fFAgdG8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgUyBhbmQgUC4gKi9cbiAgdmFyIEkgPSBTO1xuICBJLnB1dEJ1ZmZlcihQKTtcblxuICAvKiA1LiBTZXQgYz1jZWlsKG4gLyB1KS4gKi9cbiAgdmFyIGMgPSBNYXRoLmNlaWwobiAvIHUpO1xuXG4gIC8qIDYuIEZvciBpPTEsIDIsIC4uLiwgYywgZG8gdGhlIGZvbGxvd2luZzogKi9cbiAgZm9yKHZhciBpID0gMTsgaSA8PSBjOyBpKyspIHtcbiAgICAvKiBhKSBTZXQgQWk9SF5yKER8fEkpLiAobC5lLiB0aGUgcnRoIGhhc2ggb2YgRHx8SSwgSChIKEgoLi4uSChEfHxJKSkpKSAqL1xuICAgIHZhciBidWYgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgYnVmLnB1dEJ5dGVzKEQuYnl0ZXMoKSk7XG4gICAgYnVmLnB1dEJ5dGVzKEkuYnl0ZXMoKSk7XG4gICAgZm9yKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgaXRlcjsgcm91bmQrKykge1xuICAgICAgbWQuc3RhcnQoKTtcbiAgICAgIG1kLnVwZGF0ZShidWYuZ2V0Qnl0ZXMoKSk7XG4gICAgICBidWYgPSBtZC5kaWdlc3QoKTtcbiAgICB9XG5cbiAgICAvKiBiKSBDb25jYXRlbmF0ZSBjb3BpZXMgb2YgQWkgdG8gY3JlYXRlIGEgc3RyaW5nIEIgb2YgbGVuZ3RoIHYgYnl0ZXMgKHRoZVxuICAgICAgICAgIGZpbmFsIGNvcHkgb2YgQWkgbWF5IGJlIHRydW5jYXRlZCB0byBjcmVhdGUgQikuICovXG4gICAgdmFyIEIgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKCk7XG4gICAgZm9yKGwgPSAwOyBsIDwgdjsgbCsrKSB7XG4gICAgICBCLnB1dEJ5dGUoYnVmLmF0KGwgJSB1KSk7XG4gICAgfVxuXG4gICAgLyogYykgVHJlYXRpbmcgSSBhcyBhIGNvbmNhdGVuYXRpb24gSTAsIEkxLCAuLi4sIElrLTEgb2Ygdi1ieXRlIGJsb2NrcyxcbiAgICAgICAgICB3aGVyZSBrPWNlaWwocyAvIHYpICsgY2VpbChwIC8gdiksIG1vZGlmeSBJIGJ5IHNldHRpbmdcbiAgICAgICAgICBJaj0oSWorQisxKSBtb2QgMnYgZm9yIGVhY2ggai4gICovXG4gICAgdmFyIGsgPSBNYXRoLmNlaWwocyAvIHYpICsgTWF0aC5jZWlsKHAgLyB2KTtcbiAgICB2YXIgSW5ldyA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoKTtcbiAgICBmb3IoaiA9IDA7IGogPCBrOyBqKyspIHtcbiAgICAgIHZhciBjaHVuayA9IG5ldyBmb3JnZS51dGlsLkJ5dGVCdWZmZXIoSS5nZXRCeXRlcyh2KSk7XG4gICAgICB2YXIgeCA9IDB4MWZmO1xuICAgICAgZm9yKGwgPSBCLmxlbmd0aCgpIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgeCA9IHggPj4gODtcbiAgICAgICAgeCArPSBCLmF0KGwpICsgY2h1bmsuYXQobCk7XG4gICAgICAgIGNodW5rLnNldEF0KGwsIHggJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIEluZXcucHV0QnVmZmVyKGNodW5rKTtcbiAgICB9XG4gICAgSSA9IEluZXc7XG5cbiAgICAvKiBBZGQgQWkgdG8gQS4gKi9cbiAgICByZXN1bHQucHV0QnVmZmVyKGJ1Zik7XG4gIH1cblxuICByZXN1bHQudHJ1bmNhdGUocmVzdWx0Lmxlbmd0aCgpIC0gbik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gb2lkIHRoZSBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBwYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXIgPSBmdW5jdGlvbihvaWQsIHBhcmFtcywgcGFzc3dvcmQpIHtcbiAgc3dpdGNoKG9pZCkge1xuICBjYXNlIHBraS5vaWRzWydwa2NzNVBCRVMyJ106XG4gICAgcmV0dXJuIHBraS5wYmUuZ2V0Q2lwaGVyRm9yUEJFUzIob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBjYXNlIHBraS5vaWRzWydwYmVXaXRoU0hBQW5kMy1LZXlUcmlwbGVERVMtQ0JDJ106XG4gIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICByZXR1cm4gcGtpLnBiZS5nZXRDaXBoZXJGb3JQS0NTMTJQQkUob2lkLCBwYXJhbXMsIHBhc3N3b3JkKTtcblxuICBkZWZhdWx0OlxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgZW5jcnlwdGVkIFBCRSBkYXRhIGJsb2NrLiBVbnN1cHBvcnRlZCBPSUQuJyk7XG4gICAgZXJyb3Iub2lkID0gb2lkO1xuICAgIGVycm9yLnN1cHBvcnRlZE9pZHMgPSBbXG4gICAgICAncGtjczVQQkVTMicsXG4gICAgICAncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQycsXG4gICAgICAncGJld2l0aFNIQUFuZDQwQml0UkMyLUNCQydcbiAgICBdO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBuZXcgRm9yZ2UgY2lwaGVyIG9iamVjdCBpbnN0YW5jZSBhY2NvcmRpbmcgdG8gUEJFUzIgcGFyYW1zIGJsb2NrLlxuICpcbiAqIFRoZSByZXR1cm5lZCBjaXBoZXIgaW5zdGFuY2UgaXMgYWxyZWFkeSBzdGFydGVkIHVzaW5nIHRoZSBJVlxuICogZnJvbSBQQkVTMiBwYXJhbWV0ZXIgYmxvY2suXG4gKlxuICogQHBhcmFtIG9pZCB0aGUgUEtDUyM1IFBCS0RGMiBPSUQgKGluIHN0cmluZyBub3RhdGlvbikuXG4gKiBAcGFyYW0gcGFyYW1zIHRoZSBBU04uMSBQQkVTMi1wYXJhbXMgb2JqZWN0LlxuICogQHBhcmFtIHBhc3N3b3JkIHRoZSBwYXNzd29yZCB0byBkZWNyeXB0IHdpdGguXG4gKlxuICogQHJldHVybiBuZXcgY2lwaGVyIG9iamVjdCBpbnN0YW5jZS5cbiAqL1xucGtpLnBiZS5nZXRDaXBoZXJGb3JQQkVTMiA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgUEJFUzJBbGdvcml0aG1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNoZWNrIG9pZHNcbiAgb2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmtkZk9pZCk7XG4gIGlmKG9pZCAhPT0gcGtpLm9pZHNbJ3BrY3M1UEJLREYyJ10pIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIGVuY3J5cHRlZCBwcml2YXRlIGtleS4gJyArXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gT0lELicpO1xuICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICBlcnJvci5zdXBwb3J0ZWRPaWRzID0gWydwa2NzNVBCS0RGMiddO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNPaWQpO1xuICBpZihvaWQgIT09IHBraS5vaWRzWydhZXMxMjgtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMxOTItQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydhZXMyNTYtQ0JDJ10gJiZcbiAgICBvaWQgIT09IHBraS5vaWRzWydkZXMtRURFMy1DQkMnXSAmJlxuICAgIG9pZCAhPT0gcGtpLm9pZHNbJ2Rlc0NCQyddKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXkuICcgK1xuICAgICAgJ1Vuc3VwcG9ydGVkIGVuY3J5cHRpb24gc2NoZW1lIE9JRC4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgZXJyb3Iuc3VwcG9ydGVkT2lkcyA9IFtcbiAgICAgICdhZXMxMjgtQ0JDJywgJ2FlczE5Mi1DQkMnLCAnYWVzMjU2LUNCQycsICdkZXMtRURFMy1DQkMnLCAnZGVzQ0JDJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBzZXQgUEJFIHBhcmFtc1xuICB2YXIgc2FsdCA9IGNhcHR1cmUua2RmU2FsdDtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5rZGZJdGVyYXRpb25Db3VudCk7XG4gIGNvdW50ID0gY291bnQuZ2V0SW50KGNvdW50Lmxlbmd0aCgpIDw8IDMpO1xuICB2YXIgZGtMZW47XG4gIHZhciBjaXBoZXJGbjtcbiAgc3dpdGNoKHBraS5vaWRzW29pZF0pIHtcbiAgY2FzZSAnYWVzMTI4LUNCQyc6XG4gICAgZGtMZW4gPSAxNjtcbiAgICBjaXBoZXJGbiA9IGZvcmdlLmFlcy5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyO1xuICAgIGJyZWFrO1xuICBjYXNlICdhZXMxOTItQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuYWVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2FlczI1Ni1DQkMnOlxuICAgIGRrTGVuID0gMzI7XG4gICAgY2lwaGVyRm4gPSBmb3JnZS5hZXMuY3JlYXRlRGVjcnlwdGlvbkNpcGhlcjtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVzLUVERTMtQ0JDJzpcbiAgICBka0xlbiA9IDI0O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rlc0NCQyc6XG4gICAgZGtMZW4gPSA4O1xuICAgIGNpcGhlckZuID0gZm9yZ2UuZGVzLmNyZWF0ZURlY3J5cHRpb25DaXBoZXI7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBnZXQgUFJGIG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBtZCA9IHByZk9pZFRvTWVzc2FnZURpZ2VzdChjYXB0dXJlLnByZk9pZCk7XG5cbiAgLy8gZGVjcnlwdCBwcml2YXRlIGtleSB1c2luZyBwYmUgd2l0aCBjaG9zZW4gUFJGIGFuZCBBRVMvREVTXG4gIHZhciBkayA9IGZvcmdlLnBrY3M1LnBia2RmMihwYXNzd29yZCwgc2FsdCwgY291bnQsIGRrTGVuLCBtZCk7XG4gIHZhciBpdiA9IGNhcHR1cmUuZW5jSXY7XG4gIHZhciBjaXBoZXIgPSBjaXBoZXJGbihkayk7XG4gIGNpcGhlci5zdGFydChpdik7XG5cbiAgcmV0dXJuIGNpcGhlcjtcbn07XG5cbi8qKlxuICogR2V0IG5ldyBGb3JnZSBjaXBoZXIgb2JqZWN0IGluc3RhbmNlIGZvciBQS0NTIzEyIFBCRS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgY2lwaGVyIGluc3RhbmNlIGlzIGFscmVhZHkgc3RhcnRlZCB1c2luZyB0aGUga2V5ICYgSVZcbiAqIGRlcml2ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcGFzc3dvcmQgYW5kIFBLQ1MjMTIgUEJFIHNhbHQuXG4gKlxuICogQHBhcmFtIG9pZCBUaGUgUEtDUyMxMiBQQkUgT0lEIChpbiBzdHJpbmcgbm90YXRpb24pLlxuICogQHBhcmFtIHBhcmFtcyBUaGUgQVNOLjEgUEtDUyMxMiBQQkUtcGFyYW1zIG9iamVjdC5cbiAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoLlxuICpcbiAqIEByZXR1cm4gdGhlIG5ldyBjaXBoZXIgb2JqZWN0IGluc3RhbmNlLlxuICovXG5wa2kucGJlLmdldENpcGhlckZvclBLQ1MxMlBCRSA9IGZ1bmN0aW9uKG9pZCwgcGFyYW1zLCBwYXNzd29yZCkge1xuICAvLyBnZXQgUEJFIHBhcmFtc1xuICB2YXIgY2FwdHVyZSA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmKCFhc24xLnZhbGlkYXRlKHBhcmFtcywgcGtjczEyUGJlUGFyYW1zVmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwYXNzd29yZC1iYXNlZC1lbmNyeXB0aW9uIGFsZ29yaXRobSAnICtcbiAgICAgICdwYXJhbWV0ZXJzLiBBU04uMSBvYmplY3QgaXMgbm90IGEgc3VwcG9ydGVkIEVuY3J5cHRlZFByaXZhdGVLZXlJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBzYWx0ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5zYWx0KTtcbiAgdmFyIGNvdW50ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5pdGVyYXRpb25zKTtcbiAgY291bnQgPSBjb3VudC5nZXRJbnQoY291bnQubGVuZ3RoKCkgPDwgMyk7XG5cbiAgdmFyIGRrTGVuLCBkSXZMZW4sIGNpcGhlckZuO1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBwa2kub2lkc1sncGJlV2l0aFNIQUFuZDMtS2V5VHJpcGxlREVTLUNCQyddOlxuICAgICAgZGtMZW4gPSAyNDtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZvcmdlLmRlcy5zdGFydERlY3J5cHRpbmc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGtpLm9pZHNbJ3BiZXdpdGhTSEFBbmQ0MEJpdFJDMi1DQkMnXTpcbiAgICAgIGRrTGVuID0gNTtcbiAgICAgIGRJdkxlbiA9IDg7XG4gICAgICBjaXBoZXJGbiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcbiAgICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVEZWNyeXB0aW9uQ2lwaGVyKGtleSwgNDApO1xuICAgICAgICBjaXBoZXIuc3RhcnQoaXYsIG51bGwpO1xuICAgICAgICByZXR1cm4gY2lwaGVyO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyAjMTIgUEJFIGRhdGEgYmxvY2suIFVuc3VwcG9ydGVkIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IG9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgLy8gZ2V0IFBSRiBtZXNzYWdlIGRpZ2VzdFxuICB2YXIgbWQgPSBwcmZPaWRUb01lc3NhZ2VEaWdlc3QoY2FwdHVyZS5wcmZPaWQpO1xuICB2YXIga2V5ID0gcGtpLnBiZS5nZW5lcmF0ZVBrY3MxMktleShwYXNzd29yZCwgc2FsdCwgMSwgY291bnQsIGRrTGVuLCBtZCk7XG4gIG1kLnN0YXJ0KCk7XG4gIHZhciBpdiA9IHBraS5wYmUuZ2VuZXJhdGVQa2NzMTJLZXkocGFzc3dvcmQsIHNhbHQsIDIsIGNvdW50LCBkSXZMZW4sIG1kKTtcblxuICByZXR1cm4gY2lwaGVyRm4oa2V5LCBpdik7XG59O1xuXG4vKipcbiAqIE9wZW5TU0wncyBsZWdhY3kga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gKlxuICogU2VlOiBodHRwOi8vd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIGRlcml2ZSB0aGUga2V5IGZyb20uXG4gKiBAcGFyYW0gc2FsdCB0aGUgc2FsdCB0byB1c2UsIG51bGwgZm9yIG5vbmUuXG4gKiBAcGFyYW0gZGtMZW4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgZm9yIHRoZSBkZXJpdmVkIGtleS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW21kXSBhbiBvcHRpb25hbCBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLlxuICovXG5wa2kucGJlLm9wZW5zc2xEZXJpdmVCeXRlcyA9IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBka0xlbiwgbWQpIHtcbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIGlmKCEoJ21kNScgaW4gZm9yZ2UubWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWQ1XCIgaGFzaCBhbGdvcml0aG0gdW5hdmFpbGFibGUuJyk7XG4gICAgfVxuICAgIG1kID0gZm9yZ2UubWQubWQ1LmNyZWF0ZSgpO1xuICB9XG4gIGlmKHNhbHQgPT09IG51bGwpIHtcbiAgICBzYWx0ID0gJyc7XG4gIH1cbiAgdmFyIGRpZ2VzdHMgPSBbaGFzaChtZCwgcGFzc3dvcmQgKyBzYWx0KV07XG4gIGZvcih2YXIgbGVuZ3RoID0gMTYsIGkgPSAxOyBsZW5ndGggPCBka0xlbjsgKytpLCBsZW5ndGggKz0gMTYpIHtcbiAgICBkaWdlc3RzLnB1c2goaGFzaChtZCwgZGlnZXN0c1tpIC0gMV0gKyBwYXNzd29yZCArIHNhbHQpKTtcbiAgfVxuICByZXR1cm4gZGlnZXN0cy5qb2luKCcnKS5zdWJzdHIoMCwgZGtMZW4pO1xufTtcblxuZnVuY3Rpb24gaGFzaChtZCwgYnl0ZXMpIHtcbiAgcmV0dXJuIG1kLnN0YXJ0KCkudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKS5nZXRCeXRlcygpO1xufVxuXG5mdW5jdGlvbiBwcmZPaWRUb01lc3NhZ2VEaWdlc3QocHJmT2lkKSB7XG4gIC8vIGdldCBQUkYgYWxnb3JpdGhtLCBkZWZhdWx0IHRvIFNIQS0xXG4gIHZhciBwcmZBbGdvcml0aG07XG4gIGlmKCFwcmZPaWQpIHtcbiAgICBwcmZBbGdvcml0aG0gPSAnaG1hY1dpdGhTSEExJztcbiAgfSBlbHNlIHtcbiAgICBwcmZBbGdvcml0aG0gPSBwa2kub2lkc1thc24xLmRlclRvT2lkKHByZk9pZCldO1xuICAgIGlmKCFwcmZBbGdvcml0aG0pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUFJGIE9JRC4nKTtcbiAgICAgIGVycm9yLm9pZCA9IHByZk9pZDtcbiAgICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICAgJ2htYWNXaXRoU0hBMScsICdobWFjV2l0aFNIQTIyNCcsICdobWFjV2l0aFNIQTI1NicsICdobWFjV2l0aFNIQTM4NCcsXG4gICAgICAgICdobWFjV2l0aFNIQTUxMiddO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcmZBbGdvcml0aG1Ub01lc3NhZ2VEaWdlc3QocHJmQWxnb3JpdGhtKTtcbn1cblxuZnVuY3Rpb24gcHJmQWxnb3JpdGhtVG9NZXNzYWdlRGlnZXN0KHByZkFsZ29yaXRobSkge1xuICB2YXIgZmFjdG9yeSA9IGZvcmdlLm1kO1xuICBzd2l0Y2gocHJmQWxnb3JpdGhtKSB7XG4gIGNhc2UgJ2htYWNXaXRoU0hBMjI0JzpcbiAgICBmYWN0b3J5ID0gZm9yZ2UubWQuc2hhNTEyO1xuICBjYXNlICdobWFjV2l0aFNIQTEnOlxuICBjYXNlICdobWFjV2l0aFNIQTI1Nic6XG4gIGNhc2UgJ2htYWNXaXRoU0hBMzg0JzpcbiAgY2FzZSAnaG1hY1dpdGhTSEE1MTInOlxuICAgIHByZkFsZ29yaXRobSA9IHByZkFsZ29yaXRobS5zdWJzdHIoOCkudG9Mb3dlckNhc2UoKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBSRiBhbGdvcml0aG0uJyk7XG4gICAgZXJyb3IuYWxnb3JpdGhtID0gcHJmQWxnb3JpdGhtO1xuICAgIGVycm9yLnN1cHBvcnRlZCA9IFtcbiAgICAgICdobWFjV2l0aFNIQTEnLCAnaG1hY1dpdGhTSEEyMjQnLCAnaG1hY1dpdGhTSEEyNTYnLCAnaG1hY1dpdGhTSEEzODQnLFxuICAgICAgJ2htYWNXaXRoU0hBNTEyJ107XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYoIWZhY3RvcnkgfHwgIShwcmZBbGdvcml0aG0gaW4gZmFjdG9yeSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGFzaCBhbGdvcml0aG06ICcgKyBwcmZBbGdvcml0aG0pO1xuICB9XG4gIHJldHVybiBmYWN0b3J5W3ByZkFsZ29yaXRobV0uY3JlYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBia2RmMlBhcmFtcyhzYWx0LCBjb3VudEJ5dGVzLCBka0xlbiwgcHJmQWxnb3JpdGhtKSB7XG4gIHZhciBwYXJhbXMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gc2FsdFxuICAgIGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHNhbHQpLFxuICAgIC8vIGl0ZXJhdGlvbiBjb3VudFxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBjb3VudEJ5dGVzLmdldEJ5dGVzKCkpXG4gIF0pO1xuICAvLyB3aGVuIFBSRiBhbGdvcml0aG0gaXMgbm90IFNIQS0xIGRlZmF1bHQsIGFkZCBrZXkgbGVuZ3RoIGFuZCBQUkYgYWxnb3JpdGhtXG4gIGlmKHByZkFsZ29yaXRobSAhPT0gJ2htYWNXaXRoU0hBMScpIHtcbiAgICBwYXJhbXMudmFsdWUucHVzaChcbiAgICAgIC8vIGtleSBsZW5ndGhcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhka0xlbi50b1N0cmluZygxNikpKSxcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzW3ByZkFsZ29yaXRobV0pLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBwYXJhbWV0ZXJzIChudWxsKVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgIF0pKTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuIiwiLyoqXG4gKiBQYXNzd29yZC1CYXNlZCBLZXktRGVyaXZhdGlvbiBGdW5jdGlvbiAjMiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTZWUgUkZDIDI4OTggZm9yIGRldGFpbHMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2htYWMnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgcGtjczUgPSBmb3JnZS5wa2NzNSA9IGZvcmdlLnBrY3M1IHx8IHt9O1xuXG52YXIgY3J5cHRvO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0gcCB0aGUgcGFzc3dvcmQgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gcyB0aGUgc2FsdCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqIEBwYXJhbSBjIHRoZSBpdGVyYXRpb24gY291bnQsIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAqIEBwYXJhbSBka0xlbiB0aGUgaW50ZW5kZWQgbGVuZ3RoLCBpbiBieXRlcywgb2YgdGhlIGRlcml2ZWQga2V5LFxuICogICAgICAgICAgKG1heDogMl4zMiAtIDEpICogaGFzaCBsZW5ndGggb2YgdGhlIFBSRi5cbiAqIEBwYXJhbSBbbWRdIHRoZSBtZXNzYWdlIGRpZ2VzdCAob3IgYWxnb3JpdGhtIGlkZW50aWZpZXIgYXMgYSBzdHJpbmcpIHRvIHVzZVxuICogICAgICAgICAgaW4gdGhlIFBSRiwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwga2V5KV0gcHJlc2VuY2UgdHJpZ2dlcnMgYXN5bmNocm9ub3VzIHZlcnNpb24sIGNhbGxlZFxuICogICAgICAgICAgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZXJpdmVkIGtleSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMsIGZvciB0aGVcbiAqICAgICAgICAgICBzeW5jaHJvbm91cyB2ZXJzaW9uIChpZiBubyBjYWxsYmFjayBpcyBzcGVjaWZpZWQpLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBia2RmMiA9IHBrY3M1LnBia2RmMiA9IGZ1bmN0aW9uKFxuICBwLCBzLCBjLCBka0xlbiwgbWQsIGNhbGxiYWNrKSB7XG4gIGlmKHR5cGVvZiBtZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbWQ7XG4gICAgbWQgPSBudWxsO1xuICB9XG5cbiAgLy8gdXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpZiBwb3NzaWJsZSBhbmQgbm90IGRpc2FibGVkLCBub3RlIHRoYXRcbiAgLy8gc29tZSBub2RlIHZlcnNpb25zIG9ubHkgc3VwcG9ydCBTSEEtMSwgb3RoZXJzIGFsbG93IGRpZ2VzdCB0byBiZSBjaGFuZ2VkXG4gIGlmKGZvcmdlLnV0aWwuaXNOb2RlanMgJiYgIWZvcmdlLm9wdGlvbnMudXNlUHVyZUphdmFTY3JpcHQgJiZcbiAgICBjcnlwdG8ucGJrZGYyICYmIChtZCA9PT0gbnVsbCB8fCB0eXBlb2YgbWQgIT09ICdvYmplY3QnKSAmJlxuICAgIChjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPiA0IHx8ICghbWQgfHwgbWQgPT09ICdzaGExJykpKSB7XG4gICAgaWYodHlwZW9mIG1kICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gZGVmYXVsdCBwcmYgdG8gU0hBLTFcbiAgICAgIG1kID0gJ3NoYTEnO1xuICAgIH1cbiAgICBwID0gQnVmZmVyLmZyb20ocCwgJ2JpbmFyeScpO1xuICAgIHMgPSBCdWZmZXIuZnJvbShzLCAnYmluYXJ5Jyk7XG4gICAgaWYoIWNhbGxiYWNrKSB7XG4gICAgICBpZihjcnlwdG8ucGJrZGYyU3luYy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjJTeW5jKHAsIHMsIGMsIGRrTGVuKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3J5cHRvLnBia2RmMlN5bmMocCwgcywgYywgZGtMZW4sIG1kKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuICAgIGlmKGNyeXB0by5wYmtkZjJTeW5jLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5wYmtkZjIocCwgcywgYywgZGtMZW4sIGZ1bmN0aW9uKGVyciwga2V5KSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcnlwdG8ucGJrZGYyKHAsIHMsIGMsIGRrTGVuLCBtZCwgZnVuY3Rpb24oZXJyLCBrZXkpIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIGtleS50b1N0cmluZygnYmluYXJ5JykpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYodHlwZW9mIG1kID09PSAndW5kZWZpbmVkJyB8fCBtZCA9PT0gbnVsbCkge1xuICAgIC8vIGRlZmF1bHQgcHJmIHRvIFNIQS0xXG4gICAgbWQgPSAnc2hhMSc7XG4gIH1cbiAgaWYodHlwZW9mIG1kID09PSAnc3RyaW5nJykge1xuICAgIGlmKCEobWQgaW4gZm9yZ2UubWQuYWxnb3JpdGhtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBoYXNoIGFsZ29yaXRobTogJyArIG1kKTtcbiAgICB9XG4gICAgbWQgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gIH1cblxuICB2YXIgaExlbiA9IG1kLmRpZ2VzdExlbmd0aDtcblxuICAvKiAxLiBJZiBka0xlbiA+ICgyXjMyIC0gMSkgKiBoTGVuLCBvdXRwdXQgXCJkZXJpdmVkIGtleSB0b28gbG9uZ1wiIGFuZFxuICAgIHN0b3AuICovXG4gIGlmKGRrTGVuID4gKDB4RkZGRkZGRkYgKiBoTGVuKSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Rlcml2ZWQga2V5IGlzIHRvbyBsb25nLicpO1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgLyogMi4gTGV0IGxlbiBiZSB0aGUgbnVtYmVyIG9mIGhMZW4tb2N0ZXQgYmxvY2tzIGluIHRoZSBkZXJpdmVkIGtleSxcbiAgICByb3VuZGluZyB1cCwgYW5kIGxldCByIGJlIHRoZSBudW1iZXIgb2Ygb2N0ZXRzIGluIHRoZSBsYXN0XG4gICAgYmxvY2s6XG5cbiAgICBsZW4gPSBDRUlMKGRrTGVuIC8gaExlbiksXG4gICAgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbi4gKi9cbiAgdmFyIGxlbiA9IE1hdGguY2VpbChka0xlbiAvIGhMZW4pO1xuICB2YXIgciA9IGRrTGVuIC0gKGxlbiAtIDEpICogaExlbjtcblxuICAvKiAzLiBGb3IgZWFjaCBibG9jayBvZiB0aGUgZGVyaXZlZCBrZXkgYXBwbHkgdGhlIGZ1bmN0aW9uIEYgZGVmaW5lZFxuICAgIGJlbG93IHRvIHRoZSBwYXNzd29yZCBQLCB0aGUgc2FsdCBTLCB0aGUgaXRlcmF0aW9uIGNvdW50IGMsIGFuZFxuICAgIHRoZSBibG9jayBpbmRleCB0byBjb21wdXRlIHRoZSBibG9jazpcblxuICAgIFRfMSA9IEYoUCwgUywgYywgMSksXG4gICAgVF8yID0gRihQLCBTLCBjLCAyKSxcbiAgICAuLi5cbiAgICBUX2xlbiA9IEYoUCwgUywgYywgbGVuKSxcblxuICAgIHdoZXJlIHRoZSBmdW5jdGlvbiBGIGlzIGRlZmluZWQgYXMgdGhlIGV4Y2x1c2l2ZS1vciBzdW0gb2YgdGhlXG4gICAgZmlyc3QgYyBpdGVyYXRlcyBvZiB0aGUgdW5kZXJseWluZyBwc2V1ZG9yYW5kb20gZnVuY3Rpb24gUFJGXG4gICAgYXBwbGllZCB0byB0aGUgcGFzc3dvcmQgUCBhbmQgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHNhbHQgU1xuICAgIGFuZCB0aGUgYmxvY2sgaW5kZXggaTpcblxuICAgIEYoUCwgUywgYywgaSkgPSB1XzEgWE9SIHVfMiBYT1IgLi4uIFhPUiB1X2NcblxuICAgIHdoZXJlXG5cbiAgICB1XzEgPSBQUkYoUCwgUyB8fCBJTlQoaSkpLFxuICAgIHVfMiA9IFBSRihQLCB1XzEpLFxuICAgIC4uLlxuICAgIHVfYyA9IFBSRihQLCB1X3tjLTF9KS5cblxuICAgIEhlcmUsIElOVChpKSBpcyBhIGZvdXItb2N0ZXQgZW5jb2Rpbmcgb2YgdGhlIGludGVnZXIgaSwgbW9zdFxuICAgIHNpZ25pZmljYW50IG9jdGV0IGZpcnN0LiAqL1xuICB2YXIgcHJmID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgcHJmLnN0YXJ0KG1kLCBwKTtcbiAgdmFyIGRrID0gJyc7XG4gIHZhciB4b3IsIHVfYywgdV9jMTtcblxuICAvLyBzeW5jIHZlcnNpb25cbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8PSBsZW47ICsraSkge1xuICAgICAgLy8gUFJGKFAsIFMgfHwgSU5UKGkpKSAoZmlyc3QgaXRlcmF0aW9uKVxuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZShzKTtcbiAgICAgIHByZi51cGRhdGUoZm9yZ2UudXRpbC5pbnQzMlRvQnl0ZXMoaSkpO1xuICAgICAgeG9yID0gdV9jMSA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgICBmb3IodmFyIGogPSAyOyBqIDw9IGM7ICsraikge1xuICAgICAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgICAgIHByZi51cGRhdGUodV9jMSk7XG4gICAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgICAvLyBGKHAsIHMsIGMsIGkpXG4gICAgICAgIHhvciA9IGZvcmdlLnV0aWwueG9yQnl0ZXMoeG9yLCB1X2MsIGhMZW4pO1xuICAgICAgICB1X2MxID0gdV9jO1xuICAgICAgfVxuXG4gICAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgICAgcHJvZHVjZSBhIGRlcml2ZWQga2V5IERLOlxuXG4gICAgICAgIERLID0gVF8xIHx8IFRfMiB8fCAgLi4uICB8fCBUX2xlbjwwLi5yLTE+ICovXG4gICAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuICAgIH1cbiAgICAvKiA1LiBPdXRwdXQgdGhlIGRlcml2ZWQga2V5IERLLiAqL1xuICAgIHJldHVybiBkaztcbiAgfVxuXG4gIC8vIGFzeW5jIHZlcnNpb25cbiAgdmFyIGkgPSAxLCBqO1xuICBmdW5jdGlvbiBvdXRlcigpIHtcbiAgICBpZihpID4gbGVuKSB7XG4gICAgICAvLyBkb25lXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGspO1xuICAgIH1cblxuICAgIC8vIFBSRihQLCBTIHx8IElOVChpKSkgKGZpcnN0IGl0ZXJhdGlvbilcbiAgICBwcmYuc3RhcnQobnVsbCwgbnVsbCk7XG4gICAgcHJmLnVwZGF0ZShzKTtcbiAgICBwcmYudXBkYXRlKGZvcmdlLnV0aWwuaW50MzJUb0J5dGVzKGkpKTtcbiAgICB4b3IgPSB1X2MxID0gcHJmLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBQUkYoUCwgdV97Yy0xfSkgKG90aGVyIGl0ZXJhdGlvbnMpXG4gICAgaiA9IDI7XG4gICAgaW5uZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlubmVyKCkge1xuICAgIGlmKGogPD0gYykge1xuICAgICAgcHJmLnN0YXJ0KG51bGwsIG51bGwpO1xuICAgICAgcHJmLnVwZGF0ZSh1X2MxKTtcbiAgICAgIHVfYyA9IHByZi5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICAgICAgLy8gRihwLCBzLCBjLCBpKVxuICAgICAgeG9yID0gZm9yZ2UudXRpbC54b3JCeXRlcyh4b3IsIHVfYywgaExlbik7XG4gICAgICB1X2MxID0gdV9jO1xuICAgICAgKytqO1xuICAgICAgcmV0dXJuIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGlubmVyKTtcbiAgICB9XG5cbiAgICAvKiA0LiBDb25jYXRlbmF0ZSB0aGUgYmxvY2tzIGFuZCBleHRyYWN0IHRoZSBmaXJzdCBka0xlbiBvY3RldHMgdG9cbiAgICAgIHByb2R1Y2UgYSBkZXJpdmVkIGtleSBESzpcblxuICAgICAgREsgPSBUXzEgfHwgVF8yIHx8ICAuLi4gIHx8IFRfbGVuPDAuLnItMT4gKi9cbiAgICBkayArPSAoaSA8IGxlbikgPyB4b3IgOiB4b3Iuc3Vic3RyKDAsIHIpO1xuXG4gICAgKytpO1xuICAgIG91dGVyKCk7XG4gIH1cblxuICBvdXRlcigpO1xufTtcbiIsIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBiYXNpYyBQRU0gKFByaXZhY3kgRW5oYW5jZWQgTWFpbCkgYWxnb3JpdGhtcy5cbiAqXG4gKiBTZWU6IFJGQyAxNDIxLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqXG4gKiBBIEZvcmdlIFBFTSBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqIHR5cGU6IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgbWVzc2FnZSAoZWc6IFwiUlNBIFBSSVZBVEUgS0VZXCIpLlxuICpcbiAqIHByb2NUeXBlOiBpZGVudGlmaWVzIHRoZSB0eXBlIG9mIHByb2Nlc3NpbmcgcGVyZm9ybWVkIG9uIHRoZSBtZXNzYWdlLFxuICogICBpdCBoYXMgdHdvIHN1YmZpZWxkczogdmVyc2lvbiBhbmQgdHlwZSwgZWc6IDQsRU5DUllQVEVELlxuICpcbiAqIGNvbnRlbnREb21haW46IGlkZW50aWZpZXMgdGhlIHR5cGUgb2YgY29udGVudCBpbiB0aGUgbWVzc2FnZSwgdHlwaWNhbGx5XG4gKiAgIG9ubHkgdXNlcyB0aGUgdmFsdWU6IFwiUkZDODIyXCIuXG4gKlxuICogZGVrSW5mbzogaWRlbnRpZmllcyB0aGUgbWVzc2FnZSBlbmNyeXB0aW9uIGFsZ29yaXRobSBhbmQgbW9kZSBhbmQgaW5jbHVkZXNcbiAqICAgYW55IHBhcmFtZXRlcnMgZm9yIHRoZSBhbGdvcml0aG0sIGl0IGhhcyB0d28gc3ViZmllbGRzOiBhbGdvcml0aG0gYW5kXG4gKiAgIHBhcmFtZXRlcnMsIGVnOiBERVMtQ0JDLEY4MTQzRURFNTk2MEM1OTcuXG4gKlxuICogaGVhZGVyczogY29udGFpbnMgYWxsIG90aGVyIFBFTSBlbmNhcHN1bGF0ZWQgaGVhZGVycyAtLSB3aGVyZSBvcmRlciBpc1xuICogICBzaWduaWZpY2FudCAoZm9yIHBhaXJpbmcgZGF0YSBsaWtlIHJlY2lwaWVudCBJRCArIGtleSBpbmZvKS5cbiAqXG4gKiBib2R5OiB0aGUgYmluYXJ5LWVuY29kZWQgYm9keS5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBwZW0gQVBJXG52YXIgcGVtID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wZW0gPSBmb3JnZS5wZW0gfHwge307XG5cbi8qKlxuICogRW5jb2RlcyAoc2VyaWFsaXplcykgdGhlIGdpdmVuIFBFTSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyB0aGUgUEVNIG1lc3NhZ2Ugb2JqZWN0IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSBmb3IgdGhlIGJvZHksIChkZWZhdWx0OiA2NCkuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbnBlbS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBydmFsID0gJy0tLS0tQkVHSU4gJyArIG1zZy50eXBlICsgJy0tLS0tXFxyXFxuJztcblxuICAvLyBlbmNvZGUgc3BlY2lhbCBoZWFkZXJzXG4gIHZhciBoZWFkZXI7XG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIGhlYWRlciA9IHtcbiAgICAgIG5hbWU6ICdQcm9jLVR5cGUnLFxuICAgICAgdmFsdWVzOiBbU3RyaW5nKG1zZy5wcm9jVHlwZS52ZXJzaW9uKSwgbXNnLnByb2NUeXBlLnR5cGVdXG4gICAgfTtcbiAgICBydmFsICs9IGZvbGRIZWFkZXIoaGVhZGVyKTtcbiAgfVxuICBpZihtc2cuY29udGVudERvbWFpbikge1xuICAgIGhlYWRlciA9IHtuYW1lOiAnQ29udGVudC1Eb21haW4nLCB2YWx1ZXM6IFttc2cuY29udGVudERvbWFpbl19O1xuICAgIHJ2YWwgKz0gZm9sZEhlYWRlcihoZWFkZXIpO1xuICB9XG4gIGlmKG1zZy5kZWtJbmZvKSB7XG4gICAgaGVhZGVyID0ge25hbWU6ICdERUstSW5mbycsIHZhbHVlczogW21zZy5kZWtJbmZvLmFsZ29yaXRobV19O1xuICAgIGlmKG1zZy5kZWtJbmZvLnBhcmFtZXRlcnMpIHtcbiAgICAgIGhlYWRlci52YWx1ZXMucHVzaChtc2cuZGVrSW5mby5wYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcnZhbCArPSBmb2xkSGVhZGVyKGhlYWRlcik7XG4gIH1cblxuICBpZihtc2cuaGVhZGVycykge1xuICAgIC8vIGVuY29kZSBhbGwgb3RoZXIgaGVhZGVyc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtc2cuaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgcnZhbCArPSBmb2xkSGVhZGVyKG1zZy5oZWFkZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyB0ZXJtaW5hdGUgaGVhZGVyXG4gIGlmKG1zZy5wcm9jVHlwZSkge1xuICAgIHJ2YWwgKz0gJ1xcclxcbic7XG4gIH1cblxuICAvLyBhZGQgYm9keVxuICBydmFsICs9IGZvcmdlLnV0aWwuZW5jb2RlNjQobXNnLmJvZHksIG9wdGlvbnMubWF4bGluZSB8fCA2NCkgKyAnXFxyXFxuJztcblxuICBydmFsICs9ICctLS0tLUVORCAnICsgbXNnLnR5cGUgKyAnLS0tLS1cXHJcXG4nO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyAoZGVzZXJpYWxpemVzKSBhbGwgUEVNIG1lc3NhZ2VzIGZvdW5kIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgUEVNLWZvcm1hdHRlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTSBtZXNzYWdlIG9iamVjdHMgaW4gYW4gYXJyYXkuXG4gKi9cbnBlbS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHJ2YWwgPSBbXTtcblxuICAvLyBzcGxpdCBzdHJpbmcgaW50byBQRU0gbWVzc2FnZXMgKGJlIGxlbmllbnQgdy9FT0Ygb24gQkVHSU4gbGluZSlcbiAgdmFyIHJNZXNzYWdlID0gL1xccyotLS0tLUJFR0lOIChbQS1aMC05LSBdKyktLS0tLVxccj9cXG4/KFtcXHgyMS1cXHg3ZVxcc10rPyg/Olxccj9cXG5cXHI/XFxuKSk/KFs6QS1aYS16MC05K1xcLz1cXHNdKz8pLS0tLS1FTkQgXFwxLS0tLS0vZztcbiAgdmFyIHJIZWFkZXIgPSAvKFtcXHgyMS1cXHg3ZV0rKTpcXHMqKFtcXHgyMS1cXHg3ZVxcc146XSspLztcbiAgdmFyIHJDUkxGID0gL1xccj9cXG4vO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlKHRydWUpIHtcbiAgICBtYXRjaCA9IHJNZXNzYWdlLmV4ZWMoc3RyKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBtc2cgPSB7XG4gICAgICB0eXBlOiBtYXRjaFsxXSxcbiAgICAgIHByb2NUeXBlOiBudWxsLFxuICAgICAgY29udGVudERvbWFpbjogbnVsbCxcbiAgICAgIGRla0luZm86IG51bGwsXG4gICAgICBoZWFkZXJzOiBbXSxcbiAgICAgIGJvZHk6IGZvcmdlLnV0aWwuZGVjb2RlNjQobWF0Y2hbM10pXG4gICAgfTtcbiAgICBydmFsLnB1c2gobXNnKTtcblxuICAgIC8vIG5vIGhlYWRlcnNcbiAgICBpZighbWF0Y2hbMl0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGhlYWRlcnNcbiAgICB2YXIgbGluZXMgPSBtYXRjaFsyXS5zcGxpdChyQ1JMRik7XG4gICAgdmFyIGxpID0gMDtcbiAgICB3aGlsZShtYXRjaCAmJiBsaSA8IGxpbmVzLmxlbmd0aCkge1xuICAgICAgLy8gZ2V0IGxpbmUsIHRyaW0gYW55IHJocyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcblxuICAgICAgLy8gUkZDMjgyMiB1bmZvbGQgYW55IGZvbGxvd2luZyBmb2xkZWQgbGluZXNcbiAgICAgIGZvcih2YXIgbmwgPSBsaSArIDE7IG5sIDwgbGluZXMubGVuZ3RoOyArK25sKSB7XG4gICAgICAgIHZhciBuZXh0ID0gbGluZXNbbmxdO1xuICAgICAgICBpZighL1xccy8udGVzdChuZXh0WzBdKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgKz0gbmV4dDtcbiAgICAgICAgbGkgPSBubDtcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgaGVhZGVyXG4gICAgICBtYXRjaCA9IGxpbmUubWF0Y2gockhlYWRlcik7XG4gICAgICBpZihtYXRjaCkge1xuICAgICAgICB2YXIgaGVhZGVyID0ge25hbWU6IG1hdGNoWzFdLCB2YWx1ZXM6IFtdfTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG1hdGNoWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IHZhbHVlcy5sZW5ndGg7ICsrdmkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsdWVzLnB1c2gobHRyaW0odmFsdWVzW3ZpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvYy1UeXBlIG11c3QgYmUgdGhlIGZpcnN0IGhlYWRlclxuICAgICAgICBpZighbXNnLnByb2NUeXBlKSB7XG4gICAgICAgICAgaWYoaGVhZGVyLm5hbWUgIT09ICdQcm9jLVR5cGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICdlbmNhcHN1bGF0ZWQgaGVhZGVyIG11c3QgYmUgXCJQcm9jLVR5cGVcIi4nKTtcbiAgICAgICAgICB9IGVsc2UgaWYoaGVhZGVyLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQRU0gZm9ybWF0dGVkIG1lc3NhZ2UuIFRoZSBcIlByb2MtVHlwZVwiICcgK1xuICAgICAgICAgICAgICAnaGVhZGVyIG11c3QgaGF2ZSB0d28gc3ViZmllbGRzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cucHJvY1R5cGUgPSB7dmVyc2lvbjogdmFsdWVzWzBdLCB0eXBlOiB2YWx1ZXNbMV19O1xuICAgICAgICB9IGVsc2UgaWYoIW1zZy5jb250ZW50RG9tYWluICYmIGhlYWRlci5uYW1lID09PSAnQ29udGVudC1Eb21haW4nKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbC1jYXNlIENvbnRlbnQtRG9tYWluXG4gICAgICAgICAgbXNnLmNvbnRlbnREb21haW4gPSB2YWx1ZXNbMF0gfHwgJyc7XG4gICAgICAgIH0gZWxzZSBpZighbXNnLmRla0luZm8gJiYgaGVhZGVyLm5hbWUgPT09ICdERUstSW5mbycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsLWNhc2UgREVLLUluZm9cbiAgICAgICAgICBpZihoZWFkZXIudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBFTSBmb3JtYXR0ZWQgbWVzc2FnZS4gVGhlIFwiREVLLUluZm9cIiAnICtcbiAgICAgICAgICAgICAgJ2hlYWRlciBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHN1YmZpZWxkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtc2cuZGVrSW5mbyA9IHthbGdvcml0aG06IHZhbHVlc1swXSwgcGFyYW1ldGVyczogdmFsdWVzWzFdIHx8IG51bGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1zZy5oZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICArK2xpO1xuICAgIH1cblxuICAgIGlmKG1zZy5wcm9jVHlwZSA9PT0gJ0VOQ1JZUFRFRCcgJiYgIW1zZy5kZWtJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLiBUaGUgXCJERUstSW5mb1wiICcgK1xuICAgICAgICAnaGVhZGVyIG11c3QgYmUgcHJlc2VudCBpZiBcIlByb2MtVHlwZVwiIGlzIFwiRU5DUllQVEVEXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYocnZhbC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUEVNIGZvcm1hdHRlZCBtZXNzYWdlLicpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5mdW5jdGlvbiBmb2xkSGVhZGVyKGhlYWRlcikge1xuICB2YXIgcnZhbCA9IGhlYWRlci5uYW1lICsgJzogJztcblxuICAvLyBlbnN1cmUgdmFsdWVzIHdpdGggQ1JMRiBhcmUgZm9sZGVkXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGluc2VydFNwYWNlID0gZnVuY3Rpb24obWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICcgJyArICQxO1xuICB9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaGVhZGVyLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlcy5wdXNoKGhlYWRlci52YWx1ZXNbaV0ucmVwbGFjZSgvXihcXFMrXFxyXFxuKS8sIGluc2VydFNwYWNlKSk7XG4gIH1cbiAgcnZhbCArPSB2YWx1ZXMuam9pbignLCcpICsgJ1xcclxcbic7XG5cbiAgLy8gZG8gZm9sZGluZ1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIGNhbmRpZGF0ZSA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgcnZhbC5sZW5ndGg7ICsraSwgKytsZW5ndGgpIHtcbiAgICBpZihsZW5ndGggPiA2NSAmJiBjYW5kaWRhdGUgIT09IC0xKSB7XG4gICAgICB2YXIgaW5zZXJ0ID0gcnZhbFtjYW5kaWRhdGVdO1xuICAgICAgaWYoaW5zZXJ0ID09PSAnLCcpIHtcbiAgICAgICAgKytjYW5kaWRhdGU7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICsgJ1xcclxcbiAnICsgcnZhbC5zdWJzdHIoY2FuZGlkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLnN1YnN0cigwLCBjYW5kaWRhdGUpICtcbiAgICAgICAgICAnXFxyXFxuJyArIGluc2VydCArIHJ2YWwuc3Vic3RyKGNhbmRpZGF0ZSArIDEpO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gKGkgLSBjYW5kaWRhdGUgLSAxKTtcbiAgICAgIGNhbmRpZGF0ZSA9IC0xO1xuICAgICAgKytpO1xuICAgIH0gZWxzZSBpZihydmFsW2ldID09PSAnICcgfHwgcnZhbFtpXSA9PT0gJ1xcdCcgfHwgcnZhbFtpXSA9PT0gJywnKSB7XG4gICAgICBjYW5kaWRhdGUgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBsdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbn1cbiIsIi8qKlxuICogUGFydGlhbCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEgdjIuMjogUlNBLU9FQVBcbiAqXG4gKiBNb2RpZmllZCBidXQgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBNSVQgYW5kIEJTRCBsaWNlbnNlZCBjb2RlOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ranVyL2pzandzL2Jsb2IvbWFzdGVyL3JzYS5qczpcbiAqXG4gKiBUaGUgJ2pzandzJyhKU09OIFdlYiBTaWduYXR1cmUgSmF2YVNjcmlwdCBMaWJyYXJ5KSBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIEtlbmppIFVydXNoaW1hXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBodHRwOi8vd2VicnNhLmN2cy5zb3VyY2Vmb3JnZS5uZXQvdmlld3ZjL3dlYnJzYS9DbGllbnQvUlNBRVMtT0FFUC5qcz9jb250ZW50LXR5cGU9dGV4dCUyRnBsYWluOlxuICpcbiAqIFJTQUVTLU9BRVAuanNcbiAqICRJZDogUlNBRVMtT0FFUC5qcyx2IDEuMS4xLjEgMjAwMy8wMy8xOSAxNTozNzoyMCBlbGxpc3ByaXRjaGFyZCBFeHAgJFxuICogSmF2YVNjcmlwdCBJbXBsZW1lbnRhdGlvbiBvZiBQS0NTICMxIHYyLjEgUlNBIENSWVBUT0dSQVBIWSBTVEFOREFSRCAoUlNBIExhYm9yYXRvcmllcywgSnVuZSAxNCwgMjAwMilcbiAqIENvcHlyaWdodCAoQykgRWxsaXMgUHJpdGNoYXJkLCBHdWFyZGlhbiBVbmxpbWl0ZWQgMjAwMy5cbiAqIENvbnRhY3Q6IGVsbGlzQG51a2luZXRpY3MuY29tXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2UuXG4gKlxuICogT2ZmaWNpYWwgZG9jdW1lbnRhdGlvbjogaHR0cDovL3d3dy5yc2EuY29tL3JzYWxhYnMvbm9kZS5hc3A/aWQ9MjEyNVxuICpcbiAqIEBhdXRob3IgRXZhbiBKb25lcyAoaHR0cDovL2V2YW5qb25lcy5jYS8pXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE0IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vc2hhMScpO1xuXG4vLyBzaG9ydGN1dCBmb3IgUEtDUyMxIEFQSVxudmFyIHBrY3MxID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMSA9IGZvcmdlLnBrY3MxIHx8IHt9O1xuXG4vKipcbiAqIEVuY29kZSB0aGUgZ2l2ZW4gUlNBRVMtT0FFUCBtZXNzYWdlIChNKSB1c2luZyBrZXksIHdpdGggb3B0aW9uYWwgbGFiZWwgKEwpXG4gKiBhbmQgc2VlZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBwZXJmb3JtIFJTQSBlbmNyeXB0aW9uLCBpdCBvbmx5IGVuY29kZXMgdGhlIG1lc3NhZ2VcbiAqIHVzaW5nIFJTQUVTLU9BRVAuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgUlNBIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBsYWJlbCBhbiBvcHRpb25hbCBsYWJlbCB0byB1c2UuXG4gKiAgICAgICAgICBzZWVkIHRoZSBzZWVkIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZW5jb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gIC8vIHBhcnNlIGFyZ3VtZW50c1xuICB2YXIgbGFiZWw7XG4gIHZhciBzZWVkO1xuICB2YXIgbWQ7XG4gIHZhciBtZ2YxTWQ7XG4gIC8vIGxlZ2FjeSBhcmdzIChsYWJlbCwgc2VlZCwgbWQpXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGxhYmVsID0gb3B0aW9ucztcbiAgICBzZWVkID0gYXJndW1lbnRzWzNdIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IGFyZ3VtZW50c1s0XSB8fCB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZihvcHRpb25zKSB7XG4gICAgbGFiZWwgPSBvcHRpb25zLmxhYmVsIHx8IHVuZGVmaW5lZDtcbiAgICBzZWVkID0gb3B0aW9ucy5zZWVkIHx8IHVuZGVmaW5lZDtcbiAgICBtZCA9IG9wdGlvbnMubWQgfHwgdW5kZWZpbmVkO1xuICAgIGlmKG9wdGlvbnMubWdmMSAmJiBvcHRpb25zLm1nZjEubWQpIHtcbiAgICAgIG1nZjFNZCA9IG9wdGlvbnMubWdmMS5tZDtcbiAgICB9XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIW1kKSB7XG4gICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIG1kLnN0YXJ0KCk7XG4gIH1cblxuICAvLyBkZWZhdWx0IE1HRi0xIHRvIHNhbWUgYXMgT0FFUFxuICBpZighbWdmMU1kKSB7XG4gICAgbWdmMU1kID0gbWQ7XG4gIH1cblxuICAvLyBjb21wdXRlIGxlbmd0aCBpbiBieXRlcyBhbmQgY2hlY2sgb3V0cHV0XG4gIHZhciBrZXlMZW5ndGggPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdmFyIG1heExlbmd0aCA9IGtleUxlbmd0aCAtIDIgKiBtZC5kaWdlc3RMZW5ndGggLSAyO1xuICBpZihtZXNzYWdlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUlNBRVMtT0FFUCBpbnB1dCBtZXNzYWdlIGxlbmd0aCBpcyB0b28gbG9uZy4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBtZXNzYWdlLmxlbmd0aDtcbiAgICBlcnJvci5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKTtcblxuICB2YXIgUFMgPSAnJztcbiAgdmFyIFBTX2xlbmd0aCA9IG1heExlbmd0aCAtIG1lc3NhZ2UubGVuZ3RoO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgUFNfbGVuZ3RoOyBpKyspIHtcbiAgICBQUyArPSAnXFx4MDAnO1xuICB9XG5cbiAgdmFyIERCID0gbEhhc2guZ2V0Qnl0ZXMoKSArIFBTICsgJ1xceDAxJyArIG1lc3NhZ2U7XG5cbiAgaWYoIXNlZWQpIHtcbiAgICBzZWVkID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG1kLmRpZ2VzdExlbmd0aCk7XG4gIH0gZWxzZSBpZihzZWVkLmxlbmd0aCAhPT0gbWQuZGlnZXN0TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIFJTQUVTLU9BRVAgc2VlZC4gVGhlIHNlZWQgbGVuZ3RoIG11c3QgJyArXG4gICAgICAnbWF0Y2ggdGhlIGRpZ2VzdCBsZW5ndGguJyk7XG4gICAgZXJyb3Iuc2VlZExlbmd0aCA9IHNlZWQubGVuZ3RoO1xuICAgIGVycm9yLmRpZ2VzdExlbmd0aCA9IG1kLmRpZ2VzdExlbmd0aDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgbWFza2VkREIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKERCLCBkYk1hc2ssIERCLmxlbmd0aCk7XG5cbiAgdmFyIHNlZWRNYXNrID0gcnNhX21nZjEobWFza2VkREIsIG1kLmRpZ2VzdExlbmd0aCwgbWdmMU1kKTtcbiAgdmFyIG1hc2tlZFNlZWQgPSBmb3JnZS51dGlsLnhvckJ5dGVzKHNlZWQsIHNlZWRNYXNrLCBzZWVkLmxlbmd0aCk7XG5cbiAgLy8gcmV0dXJuIGVuY29kZWQgbWVzc2FnZVxuICByZXR1cm4gJ1xceDAwJyArIG1hc2tlZFNlZWQgKyBtYXNrZWREQjtcbn07XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSAoRU0pIHVzaW5nIGtleSwgd2l0aCBvcHRpb25hbFxuICogbGFiZWwgKEwpLlxuICpcbiAqIFRoaXMgbWV0aG9kIGRvZXMgbm90IHBlcmZvcm0gUlNBIGRlY3J5cHRpb24sIGl0IG9ubHkgZGVjb2RlcyB0aGUgbWVzc2FnZVxuICogdXNpbmcgUlNBRVMtT0FFUC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBlbSB0aGUgZW5jb2RlZCBtZXNzYWdlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIGxhYmVsIGFuIG9wdGlvbmFsIGxhYmVsIHRvIHVzZS5cbiAqICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBPQUVQLCB1bmRlZmluZWQgZm9yIFNIQS0xLlxuICogICAgICAgICAgbWdmMSBvcHRpb25hbCBtZ2YxIHBhcmFtZXRlcnM6XG4gKiAgICAgICAgICAgIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIGZvciBNR0YxLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgbWVzc2FnZSBieXRlcy5cbiAqL1xucGtjczEuZGVjb2RlX3JzYV9vYWVwID0gZnVuY3Rpb24oa2V5LCBlbSwgb3B0aW9ucykge1xuICAvLyBwYXJzZSBhcmdzXG4gIHZhciBsYWJlbDtcbiAgdmFyIG1kO1xuICB2YXIgbWdmMU1kO1xuICAvLyBsZWdhY3kgYXJnc1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBsYWJlbCA9IG9wdGlvbnM7XG4gICAgbWQgPSBhcmd1bWVudHNbM10gfHwgdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYob3B0aW9ucykge1xuICAgIGxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCB1bmRlZmluZWQ7XG4gICAgbWQgPSBvcHRpb25zLm1kIHx8IHVuZGVmaW5lZDtcbiAgICBpZihvcHRpb25zLm1nZjEgJiYgb3B0aW9ucy5tZ2YxLm1kKSB7XG4gICAgICBtZ2YxTWQgPSBvcHRpb25zLm1nZjEubWQ7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBsZW5ndGggaW4gYnl0ZXNcbiAgdmFyIGtleUxlbmd0aCA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGVtLmxlbmd0aCAhPT0ga2V5TGVuZ3RoKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdSU0FFUy1PQUVQIGVuY29kZWQgbWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZC4nKTtcbiAgICBlcnJvci5sZW5ndGggPSBlbS5sZW5ndGg7XG4gICAgZXJyb3IuZXhwZWN0ZWRMZW5ndGggPSBrZXlMZW5ndGg7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBkZWZhdWx0IE9BRVAgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYobWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICBtZC5zdGFydCgpO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBNR0YtMSB0byBzYW1lIGFzIE9BRVBcbiAgaWYoIW1nZjFNZCkge1xuICAgIG1nZjFNZCA9IG1kO1xuICB9XG5cbiAgaWYoa2V5TGVuZ3RoIDwgMiAqIG1kLmRpZ2VzdExlbmd0aCArIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTQUVTLU9BRVAga2V5IGlzIHRvbyBzaG9ydCBmb3IgdGhlIGhhc2ggZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZighbGFiZWwpIHtcbiAgICBsYWJlbCA9ICcnO1xuICB9XG4gIG1kLnVwZGF0ZShsYWJlbCwgJ3JhdycpO1xuICB2YXIgbEhhc2ggPSBtZC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gIC8vIHNwbGl0IHRoZSBtZXNzYWdlIGludG8gaXRzIHBhcnRzXG4gIHZhciB5ID0gZW0uY2hhckF0KDApO1xuICB2YXIgbWFza2VkU2VlZCA9IGVtLnN1YnN0cmluZygxLCBtZC5kaWdlc3RMZW5ndGggKyAxKTtcbiAgdmFyIG1hc2tlZERCID0gZW0uc3Vic3RyaW5nKDEgKyBtZC5kaWdlc3RMZW5ndGgpO1xuXG4gIHZhciBzZWVkTWFzayA9IHJzYV9tZ2YxKG1hc2tlZERCLCBtZC5kaWdlc3RMZW5ndGgsIG1nZjFNZCk7XG4gIHZhciBzZWVkID0gZm9yZ2UudXRpbC54b3JCeXRlcyhtYXNrZWRTZWVkLCBzZWVkTWFzaywgbWFza2VkU2VlZC5sZW5ndGgpO1xuXG4gIHZhciBkYk1hc2sgPSByc2FfbWdmMShzZWVkLCBrZXlMZW5ndGggLSBtZC5kaWdlc3RMZW5ndGggLSAxLCBtZ2YxTWQpO1xuICB2YXIgZGIgPSBmb3JnZS51dGlsLnhvckJ5dGVzKG1hc2tlZERCLCBkYk1hc2ssIG1hc2tlZERCLmxlbmd0aCk7XG5cbiAgdmFyIGxIYXNoUHJpbWUgPSBkYi5zdWJzdHJpbmcoMCwgbWQuZGlnZXN0TGVuZ3RoKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIHRoYXQgYWxsIHZhbHVlcyBtYXRjaCB3aGF0IGlzIGV4cGVjdGVkXG4gIHZhciBlcnJvciA9ICh5ICE9PSAnXFx4MDAnKTtcblxuICAvLyBjb25zdGFudCB0aW1lIGNoZWNrIGxIYXNoIHZzIGxIYXNoUHJpbWVcbiAgZm9yKHZhciBpID0gMDsgaSA8IG1kLmRpZ2VzdExlbmd0aDsgKytpKSB7XG4gICAgZXJyb3IgfD0gKGxIYXNoLmNoYXJBdChpKSAhPT0gbEhhc2hQcmltZS5jaGFyQXQoaSkpO1xuICB9XG5cbiAgLy8gXCJjb25zdGFudCB0aW1lXCIgZmluZCB0aGUgMHgxIGJ5dGUgc2VwYXJhdGluZyB0aGUgcGFkZGluZyAoemVyb3MpIGZyb20gdGhlXG4gIC8vIG1lc3NhZ2VcbiAgLy8gVE9ETzogSXQgbXVzdCBiZSBwb3NzaWJsZSB0byBkbyB0aGlzIGluIGEgYmV0dGVyL3NtYXJ0ZXIgd2F5P1xuICB2YXIgaW5fcHMgPSAxO1xuICB2YXIgaW5kZXggPSBtZC5kaWdlc3RMZW5ndGg7XG4gIGZvcih2YXIgaiA9IG1kLmRpZ2VzdExlbmd0aDsgaiA8IGRiLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGNvZGUgPSBkYi5jaGFyQ29kZUF0KGopO1xuXG4gICAgdmFyIGlzXzAgPSAoY29kZSAmIDB4MSkgXiAweDE7XG5cbiAgICAvLyBub24temVybyBpZiBub3QgMCBvciAxIGluIHRoZSBwcyBzZWN0aW9uXG4gICAgdmFyIGVycm9yX21hc2sgPSBpbl9wcyA/IDB4ZmZmZSA6IDB4MDAwMDtcbiAgICBlcnJvciB8PSAoY29kZSAmIGVycm9yX21hc2spO1xuXG4gICAgLy8gbGF0Y2ggaW5fcHMgdG8gemVybyBhZnRlciB3ZSBmaW5kIDB4MVxuICAgIGluX3BzID0gaW5fcHMgJiBpc18wO1xuICAgIGluZGV4ICs9IGluX3BzO1xuICB9XG5cbiAgaWYoZXJyb3IgfHwgZGIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU0FFUy1PQUVQIHBhZGRpbmcuJyk7XG4gIH1cblxuICByZXR1cm4gZGIuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG59O1xuXG5mdW5jdGlvbiByc2FfbWdmMShzZWVkLCBtYXNrTGVuZ3RoLCBoYXNoKSB7XG4gIC8vIGRlZmF1bHQgdG8gU0hBLTEgbWVzc2FnZSBkaWdlc3RcbiAgaWYoIWhhc2gpIHtcbiAgICBoYXNoID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgfVxuICB2YXIgdCA9ICcnO1xuICB2YXIgY291bnQgPSBNYXRoLmNlaWwobWFza0xlbmd0aCAvIGhhc2guZGlnZXN0TGVuZ3RoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAoaSA+PiAyNCkgJiAweEZGLCAoaSA+PiAxNikgJiAweEZGLCAoaSA+PiA4KSAmIDB4RkYsIGkgJiAweEZGKTtcbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUoc2VlZCArIGMpO1xuICAgIHQgKz0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuICB9XG4gIHJldHVybiB0LnN1YnN0cmluZygwLCBtYXNrTGVuZ3RoKTtcbn1cbiIsIi8qKlxuICogSmF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBQS0NTIzEyLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbCA8c3Rlc2llQGJyb2tlbnBpcGUuZGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLTIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBQS0NTIzEyIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgZnRwOi8vZnRwLnJzYXNlY3VyaXR5LmNvbS9wdWIvcGtjcy9wa2NzLTEyL3BrY3MtMTItdGMxLnBkZiBmb3IgZGV0YWlscylcbiAqXG4gKiBQRlggOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgSU5URUdFUiB7djMoMyl9KHYzLC4uLiksXG4gKiAgIGF1dGhTYWZlIENvbnRlbnRJbmZvLFxuICogICBtYWNEYXRhICBNYWNEYXRhIE9QVElPTkFMXG4gKiB9XG4gKlxuICogTWFjRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICBtYWMgRGlnZXN0SW5mbyxcbiAqICAgbWFjU2FsdCBPQ1RFVCBTVFJJTkcsXG4gKiAgIGl0ZXJhdGlvbnMgSU5URUdFUiBERUZBVUxUIDFcbiAqIH1cbiAqIE5vdGU6IFRoZSBpdGVyYXRpb25zIGRlZmF1bHQgaXMgZm9yIGhpc3RvcmljYWwgcmVhc29ucyBhbmQgaXRzIHVzZSBpc1xuICogZGVwcmVjYXRlZC4gQSBoaWdoZXIgdmFsdWUsIGxpa2UgMTAyNCwgaXMgcmVjb21tZW5kZWQuXG4gKlxuICogRGlnZXN0SW5mbyBpcyBkZWZpbmVkIGluIFBLQ1MjNyBhcyBmb2xsb3dzOlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIFNIQTEgdGhlcmUgaXMgbm9uZS5cbiAqXG4gKiBBbGdvcml0aG1JZGVudGlmZXIgOjo9IFNFUVVFTkNFIHtcbiAqICAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAqXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgIFswXSBFWFBMSUNJVCBBTlkgREVGSU5FRCBCWSBjb250ZW50VHlwZSBPUFRJT05BTFxuICogfVxuICpcbiAqIENvbnRlbnRUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICpcbiAqIEF1dGhlbnRpY2F0ZWRTYWZlIDo6PSBTRVFVRU5DRSBPRiBDb250ZW50SW5mb1xuICogLS0gRGF0YSBpZiB1bmVuY3J5cHRlZFxuICogLS0gRW5jcnlwdGVkRGF0YSBpZiBwYXNzd29yZC1lbmNyeXB0ZWRcbiAqIC0tIEVudmVsb3BlZERhdGEgaWYgcHVibGljIGtleS1lbmNyeXB0ZWRcbiAqXG4gKlxuICogU2FmZUNvbnRlbnRzIDo6PSBTRVFVRU5DRSBPRiBTYWZlQmFnXG4gKlxuICogU2FmZUJhZyA6Oj0gU0VRVUVOQ0Uge1xuICogICBiYWdJZCAgICAgQkFHLVRZUEUuJmlkICh7UEtDUzEyQmFnU2V0fSlcbiAqICAgYmFnVmFsdWUgIFswXSBFWFBMSUNJVCBCQUctVFlQRS4mVHlwZSh7UEtDUzEyQmFnU2V0fXtAYmFnSWR9KSxcbiAqICAgYmFnQXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogUEtDUzEyQXR0cmlidXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGF0dHJJZCBBVFRSSUJVVEUuJmlkICh7UEtDUzEyQXR0clNldH0pLFxuICogICBhdHRyVmFsdWVzIFNFVCBPRiBBVFRSSUJVVEUuJlR5cGUgKHtQS0NTMTJBdHRyU2V0fXtAYXR0cklkfSlcbiAqIH0gLS0gVGhpcyB0eXBlIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgWC41MDAgdHlwZSAnQXR0cmlidXRlJ1xuICpcbiAqIFBLQ1MxMkF0dHJTZXQgQVRUUklCVVRFIDo6PSB7XG4gKiAgIGZyaWVuZGx5TmFtZSB8IC0tIGZyb20gUEtDUyAjOVxuICogICBsb2NhbEtleUlkLCAtLSBmcm9tIFBLQ1MgIzlcbiAqICAgLi4uIC0tIE90aGVyIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWRcbiAqIH1cbiAqXG4gKiBDZXJ0QmFnIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGNlcnRJZCAgICBCQUctVFlQRS4maWQgICAoe0NlcnRUeXBlc30pLFxuICogICBjZXJ0VmFsdWUgWzBdIEVYUExJQ0lUIEJBRy1UWVBFLiZUeXBlICh7Q2VydFR5cGVzfXtAY2VydElkfSlcbiAqIH1cbiAqXG4gKiB4NTA5Q2VydGlmaWNhdGUgQkFHLVRZUEUgOjo9IHtPQ1RFVCBTVFJJTkcgSURFTlRJRklFRCBCWSB7Y2VydFR5cGVzIDF9fVxuICogICAtLSBERVItZW5jb2RlZCBYLjUwOSBjZXJ0aWZpY2F0ZSBzdG9yZWQgaW4gT0NURVQgU1RSSU5HXG4gKlxuICogc2RzaUNlcnRpZmljYXRlIEJBRy1UWVBFIDo6PSB7SUE1U3RyaW5nIElERU5USUZJRUQgQlkge2NlcnRUeXBlcyAyfX1cbiAqIC0tIEJhc2U2NC1lbmNvZGVkIFNEU0kgY2VydGlmaWNhdGUgc3RvcmVkIGluIElBNVN0cmluZ1xuICpcbiAqIENlcnRUeXBlcyBCQUctVFlQRSA6Oj0ge1xuICogICB4NTA5Q2VydGlmaWNhdGUgfFxuICogICBzZHNpQ2VydGlmaWNhdGUsXG4gKiAgIC4uLiAtLSBGb3IgZnV0dXJlIGV4dGVuc2lvbnNcbiAqIH1cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2htYWMnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wa2NzN2FzbjEnKTtcbnJlcXVpcmUoJy4vcGJlJyk7XG5yZXF1aXJlKCcuL3JhbmRvbScpO1xucmVxdWlyZSgnLi9yc2EnKTtcbnJlcXVpcmUoJy4vc2hhMScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL3g1MDknKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xICYgUEtJIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xudmFyIHBraSA9IGZvcmdlLnBraTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjMTIgQVBJXG52YXIgcDEyID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wa2NzMTIgPSBmb3JnZS5wa2NzMTIgfHwge307XG5cbnZhciBjb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0NvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsICAvLyBhIENvbnRlbnRJbmZvXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnQ29udGVudEluZm8uY29udGVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xuXG52YXIgcGZ4VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUEZYJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnUEZYLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ZlcnNpb24nXG4gIH0sXG4gIGNvbnRlbnRJbmZvVmFsaWRhdG9yLCB7XG4gICAgbmFtZTogJ1BGWC5tYWNEYXRhJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnbWFjJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLCAgLy8gRGlnZXN0SW5mb1xuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ1BGWC5tYWNEYXRhLm1hYy5kaWdlc3RBbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSwgIC8vIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbe1xuICAgICAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWMuZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYWNBbGdvcml0aG0nXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdEFsZ29yaXRobS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6ICdtYWNBbGdvcml0aG1QYXJhbWV0ZXJzJ1xuICAgICAgICB9XVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnUEZYLm1hY0RhdGEubWFjLmRpZ2VzdCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdtYWNEaWdlc3QnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5tYWNTYWx0JyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdtYWNTYWx0J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdQRlgubWFjRGF0YS5pdGVyYXRpb25zJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjYXB0dXJlOiAnbWFjSXRlcmF0aW9ucydcbiAgICB9XVxuICB9XVxufTtcblxudmFyIHNhZmVCYWdWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTYWZlQmFnJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdJZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdiYWdJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdTYWZlQmFnLmJhZ1ZhbHVlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnYmFnVmFsdWUnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2FmZUJhZy5iYWdBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFVCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnYmFnQXR0cmlidXRlcydcbiAgfV1cbn07XG5cbnZhciBhdHRyaWJ1dGVWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdBdHRyaWJ1dGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0cklkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ29pZCdcbiAgfSwge1xuICAgIG5hbWU6ICdBdHRyaWJ1dGUuYXR0clZhbHVlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZTogJ3ZhbHVlcydcbiAgfV1cbn07XG5cbnZhciBjZXJ0QmFnVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydEJhZycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NlcnRCYWcuY2VydElkJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NlcnRJZCdcbiAgfSwge1xuICAgIG5hbWU6ICdDZXJ0QmFnLmNlcnRWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAvKiBTbyBmYXIgd2Ugb25seSBzdXBwb3J0IFguNTA5IGNlcnRpZmljYXRlcyAod2hpY2ggYXJlIHdyYXBwZWQgaW5cbiAgICAgICBhbiBPQ1RFVCBTVFJJTkcsIGhlbmNlIGhhcmQgY29kZSB0aGF0IGhlcmUpLiAqL1xuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ0NlcnRCYWcuY2VydFZhbHVlWzBdJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydCdcbiAgICB9XVxuICB9XVxufTtcblxuLyoqXG4gKiBTZWFyY2ggU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSBmb3IgYmFncyB3aXRoIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIHNlYXJjaCBjYW4gb3B0aW9uYWxseSBiZSBuYXJyb3dlZCBieSBhIGNlcnRhaW4gYmFnIHR5cGUuXG4gKlxuICogQHBhcmFtIHNhZmVDb250ZW50cyB0aGUgU2FmZUNvbnRlbnRzIHN0cnVjdHVyZSB0byBzZWFyY2ggaW4uXG4gKiBAcGFyYW0gYXR0ck5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb21wYXJlIGFnYWluc3QuXG4gKiBAcGFyYW0gYXR0clZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAqXG4gKiBAcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhZ3MuXG4gKi9cbmZ1bmN0aW9uIF9nZXRCYWdzQnlBdHRyaWJ1dGUoc2FmZUNvbnRlbnRzLCBhdHRyTmFtZSwgYXR0clZhbHVlLCBiYWdUeXBlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgc2FmZUNvbnRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNhZmVDb250ZW50c1tpXS5zYWZlQmFncy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGJhZyA9IHNhZmVDb250ZW50c1tpXS5zYWZlQmFnc1tqXTtcbiAgICAgIGlmKGJhZ1R5cGUgIT09IHVuZGVmaW5lZCAmJiBiYWcudHlwZSAhPT0gYmFnVHlwZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIG9ubHkgZmlsdGVyIGJ5IGJhZyB0eXBlLCBubyBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICBpZihhdHRyTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmKGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGJhZy5hdHRyaWJ1dGVzW2F0dHJOYW1lXS5pbmRleE9mKGF0dHJWYWx1ZSkgPj0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChiYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbiBpbnRvIGEgUEZYIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqIFRoZSBQS0NTIzEyIFBGWCBpbiBBU04uMSBub3RhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byB1c2Ugc3RyaWN0IERFUiBkZWNvZGluZywgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIFBLQ1MjMTIgUEZYIG9iamVjdC5cbiAqL1xucDEyLnBrY3MxMkZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGhhbmRsZSBhcmdzXG4gIGlmKHR5cGVvZiBzdHJpY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFzc3dvcmQgPSBzdHJpY3Q7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHN0cmljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIFBGWCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBwZnhWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFBLQ1MjMTIgUEZYLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFBLQ1MjMTIgUEZYLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9yO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIHBmeCA9IHtcbiAgICB2ZXJzaW9uOiBjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSxcbiAgICBzYWZlQ29udGVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBiYWdzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgdGhlIGF0dHJpYnV0ZXMgdG8gZmlsdGVyIGJ5OlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkXSB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtsb2NhbEtleUlkSGV4XSB0aGUgbG9jYWxLZXlJZCBpbiBoZXggdG8gc2VhcmNoIGZvci5cbiAgICAgKiAgICAgICAgICBbZnJpZW5kbHlOYW1lXSB0aGUgZnJpZW5kbHkgbmFtZSB0byBzZWFyY2ggZm9yLlxuICAgICAqICAgICAgICAgIFtiYWdUeXBlXSBiYWcgdHlwZSB0byBuYXJyb3cgZWFjaCBhdHRyaWJ1dGUgc2VhcmNoIGJ5LlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgdHlwZSB0byBhbiBhcnJheSBvZiBtYXRjaGluZyBiYWdzIG9yLCBpZiBub1xuICAgICAqICAgICAgICAgICBhdHRyaWJ1dGUgd2FzIGdpdmVuIGJ1dCBhIGJhZyB0eXBlLCB0aGUgbWFwIGtleSB3aWxsIGJlIHRoZVxuICAgICAqICAgICAgICAgICBiYWcgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRCYWdzOiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgIHZhciBydmFsID0ge307XG5cbiAgICAgIHZhciBsb2NhbEtleUlkO1xuICAgICAgaWYoJ2xvY2FsS2V5SWQnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZmlsdGVyLmxvY2FsS2V5SWQ7XG4gICAgICB9IGVsc2UgaWYoJ2xvY2FsS2V5SWRIZXgnIGluIGZpbHRlcikge1xuICAgICAgICBsb2NhbEtleUlkID0gZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGZpbHRlci5sb2NhbEtleUlkSGV4KTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlsdGVyIG9uIGJhZ1R5cGUgb25seVxuICAgICAgaWYobG9jYWxLZXlJZCA9PT0gdW5kZWZpbmVkICYmICEoJ2ZyaWVuZGx5TmFtZScgaW4gZmlsdGVyKSAmJlxuICAgICAgICAnYmFnVHlwZScgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJ2YWxbZmlsdGVyLmJhZ1R5cGVdID0gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCBudWxsLCBudWxsLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGxvY2FsS2V5SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBydmFsLmxvY2FsS2V5SWQgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdsb2NhbEtleUlkJyxcbiAgICAgICAgICBsb2NhbEtleUlkLCBmaWx0ZXIuYmFnVHlwZSk7XG4gICAgICB9XG4gICAgICBpZignZnJpZW5kbHlOYW1lJyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgcnZhbC5mcmllbmRseU5hbWUgPSBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICAgIHBmeC5zYWZlQ29udGVudHMsICdmcmllbmRseU5hbWUnLFxuICAgICAgICAgIGZpbHRlci5mcmllbmRseU5hbWUsIGZpbHRlci5iYWdUeXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgZnJpZW5kbHlOYW1lIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcmllbmRseU5hbWUgdGhlIGZyaWVuZGx5IG5hbWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gW2JhZ1R5cGVdIGJhZyB0eXBlIHRvIG5hcnJvdyBzZWFyY2ggYnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGJhZ3Mgd2l0aCBtYXRjaGluZyBmcmllbmRseU5hbWUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUZyaWVuZGx5TmFtZTogZnVuY3Rpb24oZnJpZW5kbHlOYW1lLCBiYWdUeXBlKSB7XG4gICAgICByZXR1cm4gX2dldEJhZ3NCeUF0dHJpYnV0ZShcbiAgICAgICAgcGZ4LnNhZmVDb250ZW50cywgJ2ZyaWVuZGx5TmFtZScsIGZyaWVuZGx5TmFtZSwgYmFnVHlwZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBnZXRCYWdzKCkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEdldCBiYWdzIHdpdGggbWF0Y2hpbmcgbG9jYWxLZXlJZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxLZXlJZCB0aGUgbG9jYWxLZXlJZCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBbYmFnVHlwZV0gYmFnIHR5cGUgdG8gbmFycm93IHNlYXJjaCBieS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYmFncyB3aXRoIG1hdGNoaW5nIGxvY2FsS2V5SWQgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldEJhZ3NCeUxvY2FsS2V5SWQ6IGZ1bmN0aW9uKGxvY2FsS2V5SWQsIGJhZ1R5cGUpIHtcbiAgICAgIHJldHVybiBfZ2V0QmFnc0J5QXR0cmlidXRlKFxuICAgICAgICBwZnguc2FmZUNvbnRlbnRzLCAnbG9jYWxLZXlJZCcsIGxvY2FsS2V5SWQsIGJhZ1R5cGUpO1xuICAgIH1cbiAgfTtcblxuICBpZihjYXB0dXJlLnZlcnNpb24uY2hhckNvZGVBdCgwKSAhPT0gMykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUEtDUyMxMiBQRlggb2YgdmVyc2lvbiBvdGhlciB0aGFuIDMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci52ZXJzaW9uID0gY2FwdHVyZS52ZXJzaW9uLmNoYXJDb2RlQXQoMCk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBpZihhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpICE9PSBwa2kub2lkcy5kYXRhKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdPbmx5IFBLQ1MjMTIgUEZYIGluIHBhc3N3b3JkIGludGVncml0eSBtb2RlIHN1cHBvcnRlZC4nKTtcbiAgICBlcnJvci5vaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gIGlmKGRhdGEudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGRhdGEudHlwZSAhPT0gYXNuMS5UeXBlLk9DVEVUU1RSSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIGF1dGhTYWZlIGNvbnRlbnQgZGF0YSBpcyBub3QgYW4gT0NURVQgU1RSSU5HLicpO1xuICB9XG4gIGRhdGEgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpO1xuXG4gIC8vIGNoZWNrIGZvciBNQUNcbiAgaWYoY2FwdHVyZS5tYWMpIHtcbiAgICB2YXIgbWQgPSBudWxsO1xuICAgIHZhciBtYWNLZXlCeXRlcyA9IDA7XG4gICAgdmFyIG1hY0FsZ29yaXRobSA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5tYWNBbGdvcml0aG0pO1xuICAgIHN3aXRjaChtYWNBbGdvcml0aG0pIHtcbiAgICBjYXNlIHBraS5vaWRzLnNoYTE6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDIwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5zaGEyNTY6XG4gICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHBraS5vaWRzLnNoYTM4NDpcbiAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgbWFjS2V5Qnl0ZXMgPSA0ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgcGtpLm9pZHMuc2hhNTEyOlxuICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICBtYWNLZXlCeXRlcyA9IDY0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5tZDU6XG4gICAgICBtZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgIG1hY0tleUJ5dGVzID0gMTY7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiB1c2VzIHVuc3VwcG9ydGVkIE1BQyBhbGdvcml0aG06ICcgKyBtYWNBbGdvcml0aG0pO1xuICAgIH1cblxuICAgIC8vIHZlcmlmeSBNQUMgKGl0ZXJhdGlvbnMgZGVmYXVsdCB0byAxKVxuICAgIHZhciBtYWNTYWx0ID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcihjYXB0dXJlLm1hY1NhbHQpO1xuICAgIHZhciBtYWNJdGVyYXRpb25zID0gKCgnbWFjSXRlcmF0aW9ucycgaW4gY2FwdHVyZSkgP1xuICAgICAgcGFyc2VJbnQoZm9yZ2UudXRpbC5ieXRlc1RvSGV4KGNhcHR1cmUubWFjSXRlcmF0aW9ucyksIDE2KSA6IDEpO1xuICAgIHZhciBtYWNLZXkgPSBwMTIuZ2VuZXJhdGVLZXkoXG4gICAgICBwYXNzd29yZCwgbWFjU2FsdCwgMywgbWFjSXRlcmF0aW9ucywgbWFjS2V5Qnl0ZXMsIG1kKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQobWQsIG1hY0tleSk7XG4gICAgbWFjLnVwZGF0ZShkYXRhLnZhbHVlKTtcbiAgICB2YXIgbWFjVmFsdWUgPSBtYWMuZ2V0TWFjKCk7XG4gICAgaWYobWFjVmFsdWUuZ2V0Qnl0ZXMoKSAhPT0gY2FwdHVyZS5tYWNEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBNQUMgY291bGQgbm90IGJlIHZlcmlmaWVkLiBJbnZhbGlkIHBhc3N3b3JkPycpO1xuICAgIH1cbiAgfVxuXG4gIF9kZWNvZGVBdXRoZW50aWNhdGVkU2FmZShwZngsIGRhdGEudmFsdWUsIHN0cmljdCwgcGFzc3dvcmQpO1xuICByZXR1cm4gcGZ4O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIFBLQ1MjNyBEYXRhLiBQS0NTIzcgKFJGQyAyMzE1KSBkZWZpbmVzIFwiRGF0YVwiIGFzIGFuIE9DVEVUIFNUUklORyxcbiAqIGJ1dCBpdCBpcyBzb21ldGltZXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaXMgY29tcG9zZWQvY29uc3RydWN0ZWQgb2YgY2h1bmtzLFxuICogZWFjaCBpdHMgb3duIE9DVEVUIFNUUklORy4gVGhpcyBpcyBCRVItZW5jb2RpbmcgdnMuIERFUi1lbmNvZGluZy4gVGhpc1xuICogZnVuY3Rpb24gdHJhbnNmb3JtcyB0aGlzIGNvcm5lci1jYXNlIGludG8gdGhlIHVzdWFsIHNpbXBsZSxcbiAqIG5vbi1jb21wb3NlZC9jb25zdHJ1Y3RlZCBPQ1RFVCBTVFJJTkcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBtYXkgYmUgbW92ZWQgdG8gQVNOLjEgYXQgc29tZSBwb2ludCB0byBiZXR0ZXIgZGVhbCB3aXRoXG4gKiBtb3JlIEJFUi1lbmNvZGluZyBpc3N1ZXMsIHNob3VsZCB0aGV5IGFyaXNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIHRoZSBBU04uMSBEYXRhIG9iamVjdCB0byB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVQa2NzN0RhdGEoZGF0YSkge1xuICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIFwiY2h1bmtlZFwiIGRhdGEgY29udGVudDogYW4gb2N0ZXQgc3RyaW5nIGNvbXBvc2VkXG4gIC8vIG9mIG90aGVyIG9jdGV0IHN0cmluZ3NcbiAgaWYoZGF0YS5jb21wb3NlZCB8fCBkYXRhLmNvbnN0cnVjdGVkKSB7XG4gICAgdmFyIHZhbHVlID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsdWUucHV0Qnl0ZXMoZGF0YS52YWx1ZVtpXS52YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEuY29tcG9zZWQgPSBkYXRhLmNvbnN0cnVjdGVkID0gZmFsc2U7XG4gICAgZGF0YS52YWx1ZSA9IHZhbHVlLmdldEJ5dGVzKCk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIFBLQ1MjMTIgQXV0aGVudGljYXRlZFNhZmUgKEJFUiBlbmNvZGVkKSBpbnRvIFBGWCBvYmplY3QuXG4gKlxuICogVGhlIEF1dGhlbnRpY2F0ZWRTYWZlIGlzIGEgQkVSLWVuY29kZWQgU0VRVUVOQ0UgT0YgQ29udGVudEluZm8uXG4gKlxuICogQHBhcmFtIHBmeCBUaGUgUEtDUyMxMiBQRlggb2JqZWN0IHRvIGZpbGwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFNhZmUgQkVSLWVuY29kZWQgQXV0aGVudGljYXRlZFNhZmUuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUF1dGhlbnRpY2F0ZWRTYWZlKHBmeCwgYXV0aFNhZmUsIHN0cmljdCwgcGFzc3dvcmQpIHtcbiAgYXV0aFNhZmUgPSBhc24xLmZyb21EZXIoYXV0aFNhZmUsIHN0cmljdCk7ICAvKiBhY3R1YWxseSBpdCdzIEJFUiBlbmNvZGVkICovXG5cbiAgaWYoYXV0aFNhZmUudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgIGF1dGhTYWZlLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgICBhdXRoU2FmZS5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUEtDUyMxMiBBdXRoZW50aWNhdGVkU2FmZSBleHBlY3RlZCB0byBiZSBhICcgK1xuICAgICAgJ1NFUVVFTkNFIE9GIENvbnRlbnRJbmZvJyk7XG4gIH1cblxuICBmb3IodmFyIGkgPSAwOyBpIDwgYXV0aFNhZmUudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29udGVudEluZm8gPSBhdXRoU2FmZS52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIGNvbnRlbnRJbmZvIGFuZCBjYXB0dXJlIGRhdGFcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZighYXNuMS52YWxpZGF0ZShjb250ZW50SW5mbywgY29udGVudEluZm9WYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgQ29udGVudEluZm8uJyk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgZW5jcnlwdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdmFyIHNhZmVDb250ZW50cyA9IG51bGw7XG4gICAgdmFyIGRhdGEgPSBjYXB0dXJlLmNvbnRlbnQudmFsdWVbMF07XG4gICAgc3dpdGNoKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jb250ZW50VHlwZSkpIHtcbiAgICBjYXNlIHBraS5vaWRzLmRhdGE6XG4gICAgICBpZihkYXRhLnRhZ0NsYXNzICE9PSBhc24xLkNsYXNzLlVOSVZFUlNBTCB8fFxuICAgICAgICAgZGF0YS50eXBlICE9PSBhc24xLlR5cGUuT0NURVRTVFJJTkcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzEyIFNhZmVDb250ZW50cyBEYXRhIGlzIG5vdCBhbiBPQ1RFVCBTVFJJTkcuJyk7XG4gICAgICB9XG4gICAgICBzYWZlQ29udGVudHMgPSBfZGVjb2RlUGtjczdEYXRhKGRhdGEpLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBwa2kub2lkcy5lbmNyeXB0ZWREYXRhOlxuICAgICAgc2FmZUNvbnRlbnRzID0gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpO1xuICAgICAgb2JqLmVuY3J5cHRlZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQS0NTIzEyIGNvbnRlbnRUeXBlLicpO1xuICAgICAgZXJyb3IuY29udGVudFR5cGUgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgb2JqLnNhZmVCYWdzID0gX2RlY29kZVNhZmVDb250ZW50cyhzYWZlQ29udGVudHMsIHN0cmljdCwgcGFzc3dvcmQpO1xuICAgIHBmeC5zYWZlQ29udGVudHMucHVzaChvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBQS0NTIzcgRW5jcnlwdGVkRGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIGRhdGEgQVNOLjEgZW5jb2RlZCBFbmNyeXB0ZWRDb250ZW50SW5mbyBvYmplY3QuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHVzZXItcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHJldHVybiBUaGUgZGVjcnlwdGVkIFNhZmVDb250ZW50cyAoQVNOLjEgb2JqZWN0KS5cbiAqL1xuZnVuY3Rpb24gX2RlY3J5cHRTYWZlQ29udGVudHMoZGF0YSwgcGFzc3dvcmQpIHtcbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShcbiAgICBkYXRhLCBmb3JnZS5wa2NzNy5hc24xLmVuY3J5cHRlZERhdGFWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEVuY3J5cHRlZENvbnRlbnRJbmZvLicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUuY29udGVudFR5cGUpO1xuICBpZihvaWQgIT09IHBraS5vaWRzLmRhdGEpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAnUEtDUyMxMiBFbmNyeXB0ZWRDb250ZW50SW5mbyBDb250ZW50VHlwZSBpcyBub3QgRGF0YS4nKTtcbiAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgY2lwaGVyXG4gIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5lbmNBbGdvcml0aG0pO1xuICB2YXIgY2lwaGVyID0gcGtpLnBiZS5nZXRDaXBoZXIob2lkLCBjYXB0dXJlLmVuY1BhcmFtZXRlciwgcGFzc3dvcmQpO1xuXG4gIC8vIGdldCBlbmNyeXB0ZWQgZGF0YVxuICB2YXIgZW5jcnlwdGVkQ29udGVudEFzbjEgPSBfZGVjb2RlUGtjczdEYXRhKGNhcHR1cmUuZW5jcnlwdGVkQ29udGVudEFzbjEpO1xuICB2YXIgZW5jcnlwdGVkID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW5jcnlwdGVkQ29udGVudEFzbjEudmFsdWUpO1xuXG4gIGNpcGhlci51cGRhdGUoZW5jcnlwdGVkKTtcbiAgaWYoIWNpcGhlci5maW5pc2goKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgUEtDUyMxMiBTYWZlQ29udGVudHMuJyk7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLm91dHB1dC5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNhZmVDb250ZW50cyAoQkVSLWVuY29kZWQpIGludG8gYXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKlxuICogVGhlIHNhZmVDb250ZW50cyBpcyBhIEJFUi1lbmNvZGVkIFNFUVVFTkNFIE9GIFNhZmVCYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNhZmVDb250ZW50cyBCRVItZW5jb2RlZCBzYWZlQ29udGVudHMuXG4gKiBAcGFyYW0gc3RyaWN0IHRydWUgdG8gdXNlIHN0cmljdCBERVIgZGVjb2RpbmcsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBQYXNzd29yZCB0byBkZWNyeXB0IHdpdGggKG9wdGlvbmFsKS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQmFnIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIF9kZWNvZGVTYWZlQ29udGVudHMoc2FmZUNvbnRlbnRzLCBzdHJpY3QsIHBhc3N3b3JkKSB7XG4gIC8vIGlmIHN0cmljdCBhbmQgbm8gc2FmZSBjb250ZW50cywgcmV0dXJuIGVtcHR5IHNhZmVzXG4gIGlmKCFzdHJpY3QgJiYgc2FmZUNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIGFjdHVhbGx5IGl0J3MgQkVSLWVuY29kZWRcbiAgc2FmZUNvbnRlbnRzID0gYXNuMS5mcm9tRGVyKHNhZmVDb250ZW50cywgc3RyaWN0KTtcblxuICBpZihzYWZlQ29udGVudHMudGFnQ2xhc3MgIT09IGFzbjEuQ2xhc3MuVU5JVkVSU0FMIHx8XG4gICAgc2FmZUNvbnRlbnRzLnR5cGUgIT09IGFzbjEuVHlwZS5TRVFVRU5DRSB8fFxuICAgIHNhZmVDb250ZW50cy5jb25zdHJ1Y3RlZCAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdQS0NTIzEyIFNhZmVDb250ZW50cyBleHBlY3RlZCB0byBiZSBhIFNFUVVFTkNFIE9GIFNhZmVCYWcuJyk7XG4gIH1cblxuICB2YXIgcmVzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzYWZlQ29udGVudHMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2FmZUJhZyA9IHNhZmVDb250ZW50cy52YWx1ZVtpXTtcblxuICAgIC8vIHZhbGlkYXRlIFNhZmVCYWcgYW5kIGNhcHR1cmUgZGF0YVxuICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGlmKCFhc24xLnZhbGlkYXRlKHNhZmVCYWcsIHNhZmVCYWdWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgU2FmZUJhZy4nKTtcbiAgICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8qIENyZWF0ZSBiYWcgb2JqZWN0IGFuZCBwdXNoIHRvIHJlc3VsdCBhcnJheS4gKi9cbiAgICB2YXIgYmFnID0ge1xuICAgICAgdHlwZTogYXNuMS5kZXJUb09pZChjYXB0dXJlLmJhZ0lkKSxcbiAgICAgIGF0dHJpYnV0ZXM6IF9kZWNvZGVCYWdBdHRyaWJ1dGVzKGNhcHR1cmUuYmFnQXR0cmlidXRlcylcbiAgICB9O1xuICAgIHJlcy5wdXNoKGJhZyk7XG5cbiAgICB2YXIgdmFsaWRhdG9yLCBkZWNvZGVyO1xuICAgIHZhciBiYWdBc24xID0gY2FwdHVyZS5iYWdWYWx1ZS52YWx1ZVswXTtcbiAgICBzd2l0Y2goYmFnLnR5cGUpIHtcbiAgICAgIGNhc2UgcGtpLm9pZHMucGtjczhTaHJvdWRlZEtleUJhZzpcbiAgICAgICAgLyogYmFnQXNuMSBoYXMgYSBFbmNyeXB0ZWRQcml2YXRlS2V5SW5mbywgd2hpY2ggd2UgbmVlZCB0byBkZWNyeXB0LlxuICAgICAgICAgICBBZnRlcndhcmRzIHdlIGNhbiBoYW5kbGUgaXQgbGlrZSBhIGtleUJhZyxcbiAgICAgICAgICAgd2hpY2ggaXMgYSBQcml2YXRlS2V5SW5mby4gKi9cbiAgICAgICAgYmFnQXNuMSA9IHBraS5kZWNyeXB0UHJpdmF0ZUtleUluZm8oYmFnQXNuMSwgcGFzc3dvcmQpO1xuICAgICAgICBpZihiYWdBc24xID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1VuYWJsZSB0byBkZWNyeXB0IFBLQ1MjOCBTaHJvdWRlZEtleUJhZywgd3JvbmcgcGFzc3dvcmQ/Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgcGtpLm9pZHMua2V5QmFnOlxuICAgICAgICAvKiBBIFBLQ1MjMTIga2V5QmFnIGlzIGEgc2ltcGxlIFByaXZhdGVLZXlJbmZvIGFzIHVuZGVyc3Rvb2QgYnkgb3VyXG4gICAgICAgICAgIFBLSSBtb2R1bGUsIGhlbmNlIHdlIGRvbid0IGhhdmUgdG8gZG8gdmFsaWRhdGlvbi9jYXB0dXJpbmcgaGVyZSxcbiAgICAgICAgICAganVzdCBwYXNzIHdoYXQgd2UgYWxyZWFkeSBnb3QuICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYmFnLmtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoYmFnQXNuMSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8vIGlnbm9yZSB1bmtub3duIGtleSB0eXBlLCBwYXNzIGFzbjEgdmFsdWVcbiAgICAgICAgICBiYWcua2V5ID0gbnVsbDtcbiAgICAgICAgICBiYWcuYXNuMSA9IGJhZ0FzbjE7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7ICAvKiBOb3RoaW5nIG1vcmUgdG8gZG8uICovXG5cbiAgICAgIGNhc2UgcGtpLm9pZHMuY2VydEJhZzpcbiAgICAgICAgLyogQSBQS0NTIzEyIGNlcnRCYWcgY2FuIHdyYXAgYm90aCBYLjUwOSBhbmQgc2RzaSBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgICAgIFRoZXJlZm9yZSBwdXQgdGhlIFNhZmVCYWcgY29udGVudCB0aHJvdWdoIGFub3RoZXIgdmFsaWRhdG9yIHRvXG4gICAgICAgICAgIGNhcHR1cmUgdGhlIGZpZWxkcy4gIEFmdGVyd2FyZHMgY2hlY2sgJiBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICAgICAgdmFsaWRhdG9yID0gY2VydEJhZ1ZhbGlkYXRvcjtcbiAgICAgICAgZGVjb2RlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0SWQpICE9PSBwa2kub2lkcy54NTA5Q2VydGlmaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIGNlcnRpZmljYXRlIHR5cGUsIG9ubHkgWC41MDkgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gYXNuMS5kZXJUb09pZChjYXB0dXJlLmNlcnRJZCk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0cnVlPXByb2R1Y2UgY2VydCBoYXNoXG4gICAgICAgICAgdmFyIGNlcnRBc24xID0gYXNuMS5mcm9tRGVyKGNhcHR1cmUuY2VydCwgc3RyaWN0KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYmFnLmNlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tQXNuMShjZXJ0QXNuMSwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjZXJ0IHR5cGUsIHBhc3MgYXNuMSB2YWx1ZVxuICAgICAgICAgICAgYmFnLmNlcnQgPSBudWxsO1xuICAgICAgICAgICAgYmFnLmFzbjEgPSBjZXJ0QXNuMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBLQ1MjMTIgU2FmZUJhZyB0eXBlLicpO1xuICAgICAgICBlcnJvci5vaWQgPSBiYWcudHlwZTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgU2FmZUJhZyB2YWx1ZSAoaS5lLiBDZXJ0QmFnLCBldGMuKSBhbmQgY2FwdHVyZSBkYXRhIGlmIG5lZWRlZC4gKi9cbiAgICBpZih2YWxpZGF0b3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICFhc24xLnZhbGlkYXRlKGJhZ0FzbjEsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyICcgKyB2YWxpZGF0b3IubmFtZSk7XG4gICAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvKiBDYWxsIGRlY29kZXIgZnVuY3Rpb24gZnJvbSBhYm92ZSB0byBzdG9yZSB0aGUgcmVzdWx0cy4gKi9cbiAgICBkZWNvZGVyKCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIERlY29kZSBQS0NTIzEyIFNFVCBPRiBQS0NTMTJBdHRyaWJ1dGUgaW50byBKYXZhU2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBTRVQgT0YgUEtDUzEyQXR0cmlidXRlIChBU04uMSBvYmplY3QpLlxuICpcbiAqIEByZXR1cm4gdGhlIGRlY29kZWQgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gX2RlY29kZUJhZ0F0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICB2YXIgZGVjb2RlZEF0dHJzID0ge307XG5cbiAgaWYoYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjYXB0dXJlID0ge307XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZighYXNuMS52YWxpZGF0ZShhdHRyaWJ1dGVzW2ldLCBhdHRyaWJ1dGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBQS0NTIzEyIEJhZ0F0dHJpYnV0ZS4nKTtcbiAgICAgICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5vaWQpO1xuICAgICAgaWYocGtpLm9pZHNbb2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGF0dHJpYnV0ZSB0eXBlLCBpZ25vcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0gPSBbXTtcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjYXB0dXJlLnZhbHVlcy5sZW5ndGg7ICsraikge1xuICAgICAgICBkZWNvZGVkQXR0cnNbcGtpLm9pZHNbb2lkXV0ucHVzaChjYXB0dXJlLnZhbHVlc1tqXS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRBdHRycztcbn1cblxuLyoqXG4gKiBXcmFwcyBhIHByaXZhdGUga2V5IGFuZCBjZXJ0aWZpY2F0ZSBpbiBhIFBLQ1MjMTIgUEZYIHdyYXBwZXIuIElmIGFcbiAqIHBhc3N3b3JkIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHByaXZhdGUga2V5IHdpbGwgYmUgZW5jcnlwdGVkLlxuICpcbiAqIEFuIGVudGlyZSBjZXJ0aWZpY2F0ZSBjaGFpbiBtYXkgYWxzbyBiZSBpbmNsdWRlZC4gVG8gZG8gdGhpcywgcGFzc1xuICogYW4gYXJyYXkgZm9yIHRoZSBcImNlcnRcIiBwYXJhbWV0ZXIgd2hlcmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlIGlzXG4gKiB0aGUgb25lIHRoYXQgaXMgcGFpcmVkIHdpdGggdGhlIHByaXZhdGUga2V5IGFuZCBlYWNoIHN1YnNlcXVlbnQgb25lXG4gKiB2ZXJpZmllcyB0aGUgcHJldmlvdXMgb25lLiBUaGUgY2VydGlmaWNhdGVzIG1heSBiZSBpbiBQRU0gZm9ybWF0IG9yXG4gKiBoYXZlIGJlZW4gYWxyZWFkeSBwYXJzZWQgYnkgRm9yZ2UuXG4gKlxuICogQHRvZG8gaW1wbGVtZW50IHBhc3N3b3JkLWJhc2VkLWVuY3J5cHRpb24gZm9yIHRoZSB3aG9sZSBwYWNrYWdlXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgKG1heSBiZSBhbiBhcnJheSBvZiBjZXJ0aWZpY2F0ZXMgaW4gb3JkZXJcbiAqICAgICAgICAgIHRvIHNwZWNpZnkgYSBjZXJ0aWZpY2F0ZSBjaGFpbikuXG4gKiBAcGFyYW0gcGFzc3dvcmQgdGhlIHBhc3N3b3JkIHRvIHVzZSwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBvcHRpb25zOlxuICogICAgICAgICAgYWxnb3JpdGhtIHRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobSB0byB1c2VcbiAqICAgICAgICAgICAgKCdhZXMxMjgnLCAnYWVzMTkyJywgJ2FlczI1NicsICczZGVzJyksIGRlZmF1bHRzIHRvICdhZXMxMjgnLlxuICogICAgICAgICAgY291bnQgdGhlIGl0ZXJhdGlvbiBjb3VudCB0byB1c2UuXG4gKiAgICAgICAgICBzYWx0U2l6ZSB0aGUgc2FsdCBzaXplIHRvIHVzZS5cbiAqICAgICAgICAgIHVzZU1hYyB0cnVlIHRvIGluY2x1ZGUgYSBNQUMsIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqICAgICAgICAgIGxvY2FsS2V5SWQgdGhlIGxvY2FsIGtleSBJRCB0byB1c2UsIGluIGhleC5cbiAqICAgICAgICAgIGZyaWVuZGx5TmFtZSB0aGUgZnJpZW5kbHkgbmFtZSB0byB1c2UuXG4gKiAgICAgICAgICBnZW5lcmF0ZUxvY2FsS2V5SWQgdHJ1ZSB0byBnZW5lcmF0ZSBhIHJhbmRvbSBsb2NhbCBrZXkgSUQsXG4gKiAgICAgICAgICAgIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQS0NTIzEyIFBGWCBBU04uMSBvYmplY3QuXG4gKi9cbnAxMi50b1BrY3MxMkFzbjEgPSBmdW5jdGlvbihrZXksIGNlcnQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuc2FsdFNpemUgPSBvcHRpb25zLnNhbHRTaXplIHx8IDg7XG4gIG9wdGlvbnMuY291bnQgPSBvcHRpb25zLmNvdW50IHx8IDIwNDg7XG4gIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0gfHwgb3B0aW9ucy5lbmNBbGdvcml0aG0gfHwgJ2FlczEyOCc7XG4gIGlmKCEoJ3VzZU1hYycgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLnVzZU1hYyA9IHRydWU7XG4gIH1cbiAgaWYoISgnbG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmxvY2FsS2V5SWQgPSBudWxsO1xuICB9XG4gIGlmKCEoJ2dlbmVyYXRlTG9jYWxLZXlJZCcgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmdlbmVyYXRlTG9jYWxLZXlJZCA9IHRydWU7XG4gIH1cblxuICB2YXIgbG9jYWxLZXlJZCA9IG9wdGlvbnMubG9jYWxLZXlJZDtcbiAgdmFyIGJhZ0F0dHJzO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgbG9jYWxLZXlJZCA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhsb2NhbEtleUlkKTtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZ2VuZXJhdGVMb2NhbEtleUlkKSB7XG4gICAgLy8gdXNlIFNIQS0xIG9mIHBhaXJlZCBjZXJ0LCBpZiBhdmFpbGFibGVcbiAgICBpZihjZXJ0KSB7XG4gICAgICB2YXIgcGFpcmVkQ2VydCA9IGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSA/IGNlcnRbMF0gOiBjZXJ0O1xuICAgICAgaWYodHlwZW9mIHBhaXJlZENlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhaXJlZENlcnQgPSBwa2kuY2VydGlmaWNhdGVGcm9tUGVtKHBhaXJlZENlcnQpO1xuICAgICAgfVxuICAgICAgdmFyIHNoYTEgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgc2hhMS51cGRhdGUoYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEocGFpcmVkQ2VydCkpLmdldEJ5dGVzKCkpO1xuICAgICAgbG9jYWxLZXlJZCA9IHNoYTEuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRklYTUU6IGNvbnNpZGVyIHVzaW5nIFNIQS0xIG9mIHB1YmxpYyBrZXkgKHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGZyb20gcHJpdmF0ZSBrZXkgY29tcG9uZW50cyksIHNlZTogY2VydC5nZW5lcmF0ZVN1YmplY3RLZXlJZGVudGlmaWVyXG4gICAgICAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXNcbiAgICAgIGxvY2FsS2V5SWQgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoMjApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhdHRycyA9IFtdO1xuICBpZihsb2NhbEtleUlkICE9PSBudWxsKSB7XG4gICAgYXR0cnMucHVzaChcbiAgICAgIC8vIGxvY2FsS2V5SURcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYXR0cklkXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmxvY2FsS2V5SWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICAgICAgICBsb2NhbEtleUlkKVxuICAgICAgICBdKVxuICAgICAgXSkpO1xuICB9XG4gIGlmKCdmcmllbmRseU5hbWUnIGluIG9wdGlvbnMpIHtcbiAgICBhdHRycy5wdXNoKFxuICAgICAgLy8gZnJpZW5kbHlOYW1lXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGF0dHJJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5mcmllbmRseU5hbWUpLmdldEJ5dGVzKCkpLFxuICAgICAgICAvLyBhdHRyVmFsdWVzXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CTVBTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9ucy5mcmllbmRseU5hbWUpXG4gICAgICAgIF0pXG4gICAgICBdKSk7XG4gIH1cblxuICBpZihhdHRycy5sZW5ndGggPiAwKSB7XG4gICAgYmFnQXR0cnMgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFVCwgdHJ1ZSwgYXR0cnMpO1xuICB9XG5cbiAgLy8gY29sbGVjdCBjb250ZW50cyBmb3IgQXV0aGVudGljYXRlZFNhZmVcbiAgdmFyIGNvbnRlbnRzID0gW107XG5cbiAgLy8gY3JlYXRlIHNhZmUgYmFnKHMpIGZvciBjZXJ0aWZpY2F0ZSBjaGFpblxuICB2YXIgY2hhaW4gPSBbXTtcbiAgaWYoY2VydCAhPT0gbnVsbCkge1xuICAgIGlmKGZvcmdlLnV0aWwuaXNBcnJheShjZXJ0KSkge1xuICAgICAgY2hhaW4gPSBjZXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFpbiA9IFtjZXJ0XTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2VydFNhZmVCYWdzID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjaGFpbi5sZW5ndGg7ICsraSkge1xuICAgIC8vIGNvbnZlcnQgY2VydCBmcm9tIFBFTSBhcyBuZWNlc3NhcnlcbiAgICBjZXJ0ID0gY2hhaW5baV07XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gcGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBTYWZlQmFnXG4gICAgdmFyIGNlcnRCYWdBdHRycyA9IChpID09PSAwKSA/IGJhZ0F0dHJzIDogdW5kZWZpbmVkO1xuICAgIHZhciBjZXJ0QXNuMSA9IHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KTtcbiAgICB2YXIgY2VydFNhZmVCYWcgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5jZXJ0QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gQ2VydEJhZ1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIC8vIGNlcnRJZFxuICAgICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLng1MDlDZXJ0aWZpY2F0ZSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICAvLyBjZXJ0VmFsdWUgKHg1MDlDZXJ0aWZpY2F0ZSlcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW1xuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLnRvRGVyKGNlcnRBc24xKS5nZXRCeXRlcygpKVxuICAgICAgICAgICAgXSldKV0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgY2VydEJhZ0F0dHJzXG4gICAgICBdKTtcbiAgICBjZXJ0U2FmZUJhZ3MucHVzaChjZXJ0U2FmZUJhZyk7XG4gIH1cblxuICBpZihjZXJ0U2FmZUJhZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBjZXJ0U2FmZUNvbnRlbnRzID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBjZXJ0U2FmZUJhZ3MpO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIgY2VydENJID1cbiAgICAgIC8vIFBLQ1MjNyBDb250ZW50SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBjb250ZW50VHlwZVxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMuZGF0YSkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoXG4gICAgICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEudG9EZXIoY2VydFNhZmVDb250ZW50cykuZ2V0Qnl0ZXMoKSlcbiAgICAgICAgXSlcbiAgICAgIF0pO1xuICAgIGNvbnRlbnRzLnB1c2goY2VydENJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBzYWZlIGNvbnRlbnRzIGZvciBwcml2YXRlIGtleVxuICB2YXIga2V5QmFnID0gbnVsbDtcbiAgaWYoa2V5ICE9PSBudWxsKSB7XG4gICAgLy8gU2FmZUJhZ1xuICAgIHZhciBwa0FzbjEgPSBwa2kud3JhcFJzYVByaXZhdGVLZXkocGtpLnByaXZhdGVLZXlUb0FzbjEoa2V5KSk7XG4gICAgaWYocGFzc3dvcmQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vIGVuY3J5cHRpb25cbiAgICAgIGtleUJhZyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgLy8gYmFnSWRcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMua2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa0FzbjFcbiAgICAgICAgXSksXG4gICAgICAgIC8vIGJhZ0F0dHJpYnV0ZXMgKE9QVElPTkFMKVxuICAgICAgICBiYWdBdHRyc1xuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuY3J5cHRlZCBQcml2YXRlS2V5SW5mb1xuICAgICAga2V5QmFnID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBiYWdJZFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5wa2NzOFNocm91ZGVkS2V5QmFnKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gYmFnVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgICAgLy8gRW5jcnlwdGVkUHJpdmF0ZUtleUluZm9cbiAgICAgICAgICBwa2kuZW5jcnlwdFByaXZhdGVLZXlJbmZvKHBrQXNuMSwgcGFzc3dvcmQsIG9wdGlvbnMpXG4gICAgICAgIF0pLFxuICAgICAgICAvLyBiYWdBdHRyaWJ1dGVzIChPUFRJT05BTClcbiAgICAgICAgYmFnQXR0cnNcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIC8vIFNhZmVDb250ZW50c1xuICAgIHZhciBrZXlTYWZlQ29udGVudHMgPVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW2tleUJhZ10pO1xuXG4gICAgLy8gQ29udGVudEluZm9cbiAgICB2YXIga2V5Q0kgPVxuICAgICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIGNvbnRlbnRUeXBlXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAvLyBPSUQgZm9yIHRoZSBjb250ZW50IHR5cGUgaXMgJ2RhdGEnXG4gICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5kYXRhKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS50b0RlcihrZXlTYWZlQ29udGVudHMpLmdldEJ5dGVzKCkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICBjb250ZW50cy5wdXNoKGtleUNJKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBBdXRoZW50aWNhdGVkU2FmZSBieSBzdHJpbmdpbmcgdG9nZXRoZXIgdGhlIGNvbnRlbnRzXG4gIHZhciBzYWZlID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgY29udGVudHMpO1xuXG4gIHZhciBtYWNEYXRhO1xuICBpZihvcHRpb25zLnVzZU1hYykge1xuICAgIC8vIE1hY0RhdGFcbiAgICB2YXIgc2hhMSA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgdmFyIG1hY1NhbHQgPSBuZXcgZm9yZ2UudXRpbC5CeXRlQnVmZmVyKFxuICAgICAgZm9yZ2UucmFuZG9tLmdldEJ5dGVzKG9wdGlvbnMuc2FsdFNpemUpKTtcbiAgICB2YXIgY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIC8vIDE2MC1iaXQga2V5XG4gICAgdmFyIGtleSA9IHAxMi5nZW5lcmF0ZUtleShwYXNzd29yZCwgbWFjU2FsdCwgMywgY291bnQsIDIwKTtcbiAgICB2YXIgbWFjID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICBtYWMuc3RhcnQoc2hhMSwga2V5KTtcbiAgICBtYWMudXBkYXRlKGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIG1hY1ZhbHVlID0gbWFjLmdldE1hYygpO1xuICAgIG1hY0RhdGEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBtYWMgRGlnZXN0SW5mb1xuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAvLyBkaWdlc3RBbGdvcml0aG1cbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICAgIC8vIGFsZ29yaXRobSA9IFNIQS0xXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5zaGExKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAvLyBwYXJhbWV0ZXJzID0gTnVsbFxuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICBdKSxcbiAgICAgICAgLy8gZGlnZXN0XG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgICAgZmFsc2UsIG1hY1ZhbHVlLmdldEJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIC8vIG1hY1NhbHQgT0NURVQgU1RSSU5HXG4gICAgICBhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIG1hY1NhbHQuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBpdGVyYXRpb25zIElOVEVHRVIgKFhYWDogT25seSBzdXBwb3J0IGNvdW50IDwgNjU1MzYpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0Rlcihjb3VudCkuZ2V0Qnl0ZXMoKVxuICAgICAgKVxuICAgIF0pO1xuICB9XG5cbiAgLy8gUEZYXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMylcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMykuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gUEtDUyM3IENvbnRlbnRJbmZvXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gY29udGVudFR5cGVcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgLy8gT0lEIGZvciB0aGUgY29udGVudCB0eXBlIGlzICdkYXRhJ1xuICAgICAgICBhc24xLm9pZFRvRGVyKHBraS5vaWRzLmRhdGEpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gY29udGVudFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLFxuICAgICAgICAgIGFzbjEudG9EZXIoc2FmZSkuZ2V0Qnl0ZXMoKSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgbWFjRGF0YVxuICBdKTtcbn07XG5cbi8qKlxuICogRGVyaXZlcyBhIFBLQ1MjMTIga2V5LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdG8gZGVyaXZlIHRoZSBrZXkgbWF0ZXJpYWwgZnJvbSwgbnVsbCBvclxuICogICAgICAgICAgdW5kZWZpbmVkIGZvciBub25lLlxuICogQHBhcmFtIHNhbHQgdGhlIHNhbHQsIGFzIGEgQnl0ZUJ1ZmZlciwgdG8gdXNlLlxuICogQHBhcmFtIGlkIHRoZSBQS0NTIzEyIElEIGJ5dGUgKDEgPSBrZXkgbWF0ZXJpYWwsIDIgPSBJViwgMyA9IE1BQykuXG4gKiBAcGFyYW0gaXRlciB0aGUgaXRlcmF0aW9uIGNvdW50LlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBieXRlcyB0byBkZXJpdmUgZnJvbSB0aGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IHRvIHVzZSwgZGVmYXVsdHMgdG8gU0hBLTEuXG4gKlxuICogQHJldHVybiBhIEJ5dGVCdWZmZXIgd2l0aCB0aGUgYnl0ZXMgZGVyaXZlZCBmcm9tIHRoZSBwYXNzd29yZC5cbiAqL1xucDEyLmdlbmVyYXRlS2V5ID0gZm9yZ2UucGJlLmdlbmVyYXRlUGtjczEyS2V5O1xuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEFTTi4xIHZhbGlkYXRvcnMgZm9yIFBLQ1MjNyB2MS41LlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqXG4gKiBUaGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgUEtDUyM3IGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDICMyMzE1IGZvciBkZXRhaWxzLCBodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMzE1LnR4dCk6XG4gKlxuICogQSBQS0NTIzcgbWVzc2FnZSBjb25zaXN0cyBvZiBhIENvbnRlbnRJbmZvIG9uIHJvb3QgbGV2ZWwsIHdoaWNoIG1heVxuICogY29udGFpbiBhbnkgbnVtYmVyIG9mIGZ1cnRoZXIgQ29udGVudEluZm8gbmVzdGVkIGludG8gaXQuXG4gKlxuICogQ29udGVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgY29udGVudFR5cGUgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnQgICAgICAgICAgICAgICBbMF0gIEVYUExJQ0lUIEFOWSBERUZJTkVEIEJZIGNvbnRlbnRUeXBlIE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudFR5cGUgOjo9IE9CSkVDVCBJREVOVElGSUVSXG4gKlxuICogRW52ZWxvcGVkRGF0YSA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICByZWNpcGllbnRJbmZvcyAgICAgICAgICAgICBSZWNpcGllbnRJbmZvcyxcbiAqICAgZW5jcnlwdGVkQ29udGVudEluZm8gICAgICAgRW5jcnlwdGVkQ29udGVudEluZm9cbiAqIH1cbiAqXG4gKiBFbmNyeXB0ZWREYXRhIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGVuY3J5cHRlZENvbnRlbnRJbmZvICAgICAgIEVuY3J5cHRlZENvbnRlbnRJbmZvXG4gKiB9XG4gKlxuICogaWQtc2lnbmVkRGF0YSBPQkpFQ1QgSURFTlRJRklFUiA6Oj0geyBpc28oMSkgbWVtYmVyLWJvZHkoMilcbiAqICAgdXMoODQwKSByc2Fkc2koMTEzNTQ5KSBwa2NzKDEpIHBrY3M3KDcpIDIgfVxuICpcbiAqIFNpZ25lZERhdGEgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgSU5URUdFUixcbiAqICAgZGlnZXN0QWxnb3JpdGhtcyAgRGlnZXN0QWxnb3JpdGhtSWRlbnRpZmllcnMsXG4gKiAgIGNvbnRlbnRJbmZvICAgICAgIENvbnRlbnRJbmZvLFxuICogICBjZXJ0aWZpY2F0ZXMgICAgICBbMF0gSU1QTElDSVQgQ2VydGlmaWNhdGVzIE9QVElPTkFMLFxuICogICBjcmxzICAgICAgICAgICAgICBbMV0gSU1QTElDSVQgQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMgT1BUSU9OQUwsXG4gKiAgIHNpZ25lckluZm9zICAgICAgIFNpZ25lckluZm9zXG4gKiB9XG4gKlxuICogU2lnbmVySW5mb3MgOjo9IFNFVCBPRiBTaWduZXJJbmZvXG4gKlxuICogU2lnbmVySW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgICBWZXJzaW9uLFxuICogICBpc3N1ZXJBbmRTZXJpYWxOdW1iZXIgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGRpZ2VzdEFsZ29yaXRobSAgICAgICAgICAgIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICAgIFswXSBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMLFxuICogICBkaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtICBEaWdlc3RFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkRGlnZXN0ICAgICAgICAgICAgRW5jcnlwdGVkRGlnZXN0LFxuICogICB1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzICBbMV0gSU1QTElDSVQgQXR0cmlidXRlcyBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZERpZ2VzdCA6Oj0gT0NURVQgU1RSSU5HXG4gKlxuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEF0dHJpYnV0ZSA6Oj0gU0VRVUVOQ0Uge1xuICogICBhdHRyVHlwZSAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgYXR0clZhbHVlcyAgU0VUIE9GIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWVxuICpcbiAqIFZlcnNpb24gOjo9IElOVEVHRVJcbiAqXG4gKiBSZWNpcGllbnRJbmZvcyA6Oj0gU0VUIE9GIFJlY2lwaWVudEluZm9cbiAqXG4gKiBFbmNyeXB0ZWRDb250ZW50SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICBjb250ZW50VHlwZSAgICAgICAgICAgICAgICAgQ29udGVudFR5cGUsXG4gKiAgIGNvbnRlbnRFbmNyeXB0aW9uQWxnb3JpdGhtICBDb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGVuY3J5cHRlZENvbnRlbnQgICAgICAgWzBdICBJTVBMSUNJVCBFbmNyeXB0ZWRDb250ZW50IE9QVElPTkFMXG4gKiB9XG4gKlxuICogQ29udGVudEVuY3J5cHRpb25BbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogVGhlIEFsZ29yaXRobUlkZW50aWZpZXIgY29udGFpbnMgYW4gT2JqZWN0IElkZW50aWZpZXIgKE9JRCkgYW5kIHBhcmFtZXRlcnNcbiAqIGZvciB0aGUgYWxnb3JpdGhtLCBpZiBhbnkuIEluIHRoZSBjYXNlIG9mIEFFUyBhbmQgREVTMywgdGhlcmUgaXMgb25seSBvbmUsXG4gKiB0aGUgSVYuXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgICBwYXJhbWV0ZXJzIEFOWSBERUZJTkVEIEJZIGFsZ29yaXRobSBPUFRJT05BTFxuICogfVxuICpcbiAqIEVuY3J5cHRlZENvbnRlbnQgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIFJlY2lwaWVudEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIGlzc3VlckFuZFNlcmlhbE51bWJlciAgICAgICBJc3N1ZXJBbmRTZXJpYWxOdW1iZXIsXG4gKiAgIGtleUVuY3J5cHRpb25BbGdvcml0aG0gICAgICBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgZW5jcnlwdGVkS2V5ICAgICAgICAgICAgICAgIEVuY3J5cHRlZEtleVxuICogfVxuICpcbiAqIElzc3VlckFuZFNlcmlhbE51bWJlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBpc3N1ZXIgICAgICAgICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgc2VyaWFsTnVtYmVyICAgICAgICAgICAgICAgIENlcnRpZmljYXRlU2VyaWFsTnVtYmVyXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGVTZXJpYWxOdW1iZXIgOjo9IElOVEVHRVJcbiAqXG4gKiBLZXlFbmNyeXB0aW9uQWxnb3JpdGhtSWRlbnRpZmllciA6Oj0gQWxnb3JpdGhtSWRlbnRpZmllclxuICpcbiAqIEVuY3J5cHRlZEtleSA6Oj0gT0NURVQgU1RSSU5HXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vYXNuMScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBBU04uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLy8gc2hvcnRjdXQgZm9yIFBLQ1MjNyBBUElcbnZhciBwN3YgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBrY3M3YXNuMSA9IGZvcmdlLnBrY3M3YXNuMSB8fCB7fTtcbmZvcmdlLnBrY3M3ID0gZm9yZ2UucGtjczcgfHwge307XG5mb3JnZS5wa2NzNy5hc24xID0gcDd2O1xuXG52YXIgY29udGVudEluZm9WYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDb250ZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLkNvbnRlbnRUeXBlJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ2NvbnRlbnRUeXBlJ1xuICB9LCB7XG4gICAgbmFtZTogJ0NvbnRlbnRJbmZvLmNvbnRlbnQnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NvbnRlbnQnXG4gIH1dXG59O1xucDd2LmNvbnRlbnRJbmZvVmFsaWRhdG9yID0gY29udGVudEluZm9WYWxpZGF0b3I7XG5cbnZhciBlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ0VuY3J5cHRlZENvbnRlbnRJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudFR5cGUnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY29udGVudFR5cGUnXG4gIH0sIHtcbiAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnRW5jcnlwdGVkQ29udGVudEluZm8uY29udGVudEVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5jb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobS5wYXJhbWV0ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgY2FwdHVyZUFzbjE6ICdlbmNQYXJhbWV0ZXInXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdFbmNyeXB0ZWRDb250ZW50SW5mby5lbmNyeXB0ZWRDb250ZW50JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgLyogVGhlIFBLQ1MjNyBzdHJ1Y3R1cmUgb3V0cHV0IGJ5IE9wZW5TU0wgc29tZXdoYXQgZGlmZmVycyBmcm9tIHdoYXRcbiAgICAgKiBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZG8gZ2VuZXJhdGUuXG4gICAgICpcbiAgICAgKiBPcGVuU1NMIGdlbmVyYXRlcyBhIHN0cnVjdHVyZSBsaWtlIHRoaXM6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXVxuICAgICAqICAgICAgIDI2IERBIDY3IEQyIDE3IDlDIDQ1IDNDIEIxIDJBIEE4IDU5IDJGIDI5IDMzIDM4XG4gICAgICogICAgICAgQzMgQzMgREYgODYgNzEgNzQgN0EgMTkgOUYgNDAgRDAgMjkgQkUgODUgOTAgNDVcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBXaGVyZWFzIG90aGVyIGltcGxlbWVudGF0aW9ucyAoYW5kIHRoaXMgUEtDUyM3IG1vZHVsZSkgZ2VuZXJhdGU6XG4gICAgICogU0VRVUVOQ0Uge1xuICAgICAqICAgIC4uLlxuICAgICAqICAgIFswXSB7XG4gICAgICogICAgICAgT0NURVQgU1RSSU5HXG4gICAgICogICAgICAgICAgMjYgREEgNjcgRDIgMTcgOUMgNDUgM0MgQjEgMkEgQTggNTkgMkYgMjkgMzMgMzhcbiAgICAgKiAgICAgICAgICBDMyBDMyBERiA4NiA3MSA3NCA3QSAxOSA5RiA0MCBEMCAyOSBCRSA4NSA5MCA0NVxuICAgICAqICAgICAgICAgIC4uLlxuICAgICAqICAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBzdXBwb3J0IGJvdGgsIHdlIGp1c3QgY2FwdHVyZSB0aGUgY29udGV4dCBzcGVjaWZpY1xuICAgICAqIGZpZWxkIGhlcmUuICBUaGUgT0NURVQgU1RSSU5HIGJpdCBpcyByZW1vdmVkIGJlbG93LlxuICAgICAqL1xuICAgIGNhcHR1cmU6ICdlbmNyeXB0ZWRDb250ZW50JyxcbiAgICBjYXB0dXJlQXNuMTogJ2VuY3J5cHRlZENvbnRlbnRBc24xJ1xuICB9XVxufTtcblxucDd2LmVudmVsb3BlZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdFbnZlbG9wZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnRW52ZWxvcGVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ0VudmVsb3BlZERhdGEuUmVjaXBpZW50SW5mb3MnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VULFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAncmVjaXBpZW50SW5mb3MnXG4gIH1dLmNvbmNhdChlbmNyeXB0ZWRDb250ZW50SW5mb1ZhbGlkYXRvcilcbn07XG5cbnA3di5lbmNyeXB0ZWREYXRhVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnRW5jcnlwdGVkRGF0YScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ0VuY3J5cHRlZERhdGEuVmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfV0uY29uY2F0KGVuY3J5cHRlZENvbnRlbnRJbmZvVmFsaWRhdG9yKVxufTtcblxudmFyIHNpZ25lclZhbGlkYXRvciA9IHtcbiAgbmFtZTogJ1NpZ25lckluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLnZlcnNpb24nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdTaWduZXJJbmZvLmlzc3VlckFuZFNlcmlhbE51bWJlci5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5pc3N1ZXJBbmRTZXJpYWxOdW1iZXIuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0QWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2RpZ2VzdEFsZ29yaXRobSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnU2lnbmVySW5mby5kaWdlc3RBbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZGlnZXN0UGFyYW1ldGVyJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfV1cbiAgfSwge1xuICAgIG5hbWU6ICdTaWduZXJJbmZvLmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDAsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY2FwdHVyZTogJ2F1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZGlnZXN0RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlQWxnb3JpdGhtJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8uZW5jcnlwdGVkRGlnZXN0JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnc2lnbmF0dXJlJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lckluZm8udW5hdXRoZW50aWNhdGVkQXR0cmlidXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAxLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmU6ICd1bmF1dGhlbnRpY2F0ZWRBdHRyaWJ1dGVzJ1xuICB9XVxufTtcblxucDd2LnNpZ25lZERhdGFWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdTaWduZWREYXRhJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5WZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICd2ZXJzaW9uJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuRGlnZXN0QWxnb3JpdGhtcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdkaWdlc3RBbGdvcml0aG1zJ1xuICB9LFxuICBjb250ZW50SW5mb1ZhbGlkYXRvcixcbiAge1xuICAgIG5hbWU6ICdTaWduZWREYXRhLkNlcnRpZmljYXRlcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAwLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGNhcHR1cmVBc24xOiAnY2VydGlmaWNhdGVzJ1xuICB9LCB7XG4gICAgbmFtZTogJ1NpZ25lZERhdGEuQ2VydGlmaWNhdGVSZXZvY2F0aW9uTGlzdHMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ2NybHMnXG4gIH0sIHtcbiAgICBuYW1lOiAnU2lnbmVkRGF0YS5TaWduZXJJbmZvcycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgY2FwdHVyZTogJ3NpZ25lckluZm9zJyxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3NpZ25lclZhbGlkYXRvcl1cbiAgfV1cbn07XG5cbnA3di5yZWNpcGllbnRJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnUmVjaXBpZW50SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAndmVyc2lvbidcbiAgfSwge1xuICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmlzc3VlckFuZFNlcmlhbC5pc3N1ZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogJ2lzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5pc3N1ZXJBbmRTZXJpYWwuc2VyaWFsTnVtYmVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3NlcmlhbCdcbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ1JlY2lwaWVudEluZm8ua2V5RW5jcnlwdGlvbkFsZ29yaXRobScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnZW5jQWxnb3JpdGhtJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdSZWNpcGllbnRJbmZvLmtleUVuY3J5cHRpb25BbGdvcml0aG0ucGFyYW1ldGVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnZW5jUGFyYW1ldGVyJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAnUmVjaXBpZW50SW5mby5lbmNyeXB0ZWRLZXknLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdlbmNLZXknXG4gIH1dXG59O1xuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIGEgYmFzaWMgUHVibGljIEtleSBJbmZyYXN0cnVjdHVyZSwgaW5jbHVkaW5nXG4gKiBzdXBwb3J0IGZvciBSU0EgcHVibGljIGFuZCBwcml2YXRlIGtleXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FzbjEnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wYmUnKTtcbnJlcXVpcmUoJy4vcGVtJyk7XG5yZXF1aXJlKCcuL3Bia2RmMicpO1xucmVxdWlyZSgnLi9wa2NzMTInKTtcbnJlcXVpcmUoJy4vcHNzJyk7XG5yZXF1aXJlKCcuL3JzYScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL3g1MDknKTtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vKiBQdWJsaWMgS2V5IEluZnJhc3RydWN0dXJlIChQS0kpIGltcGxlbWVudGF0aW9uLiAqL1xudmFyIHBraSA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpID0gZm9yZ2UucGtpIHx8IHt9O1xuXG4vKipcbiAqIE5PVEU6IFRISVMgTUVUSE9EIElTIERFUFJFQ0FURUQuIFVzZSBwZW0uZGVjb2RlKCkgaW5zdGVhZC5cbiAqXG4gKiBDb252ZXJ0cyBQRU0tZm9ybWF0dGVkIGRhdGEgdG8gREVSLlxuICpcbiAqIEBwYXJhbSBwZW0gdGhlIFBFTS1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBERVItZm9ybWF0dGVkIGRhdGEuXG4gKi9cbnBraS5wZW1Ub0RlciA9IGZ1bmN0aW9uKHBlbSkge1xuICB2YXIgbXNnID0gZm9yZ2UucGVtLmRlY29kZShwZW0pWzBdO1xuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBQRU0gdG8gREVSOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG4gIHJldHVybiBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihtc2cuYm9keSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwcml2YXRlIGtleSBmcm9tIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBwcml2YXRlIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlGcm9tUGVtID0gZnVuY3Rpb24ocGVtKSB7XG4gIHZhciBtc2cgPSBmb3JnZS5wZW0uZGVjb2RlKHBlbSlbMF07XG5cbiAgaWYobXNnLnR5cGUgIT09ICdQUklWQVRFIEtFWScgJiYgbXNnLnR5cGUgIT09ICdSU0EgUFJJVkFURSBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwcml2YXRlIGtleSBmcm9tIFBFTTsgUEVNICcgK1xuICAgICAgJ2hlYWRlciB0eXBlIGlzIG5vdCBcIlBSSVZBVEUgS0VZXCIgb3IgXCJSU0EgUFJJVkFURSBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHJpdmF0ZSBrZXkgZnJvbSBQRU07IFBFTSBpcyBlbmNyeXB0ZWQuJyk7XG4gIH1cblxuICAvLyBjb252ZXJ0IERFUiB0byBBU04uMSBvYmplY3RcbiAgdmFyIG9iaiA9IGFzbjEuZnJvbURlcihtc2cuYm9keSk7XG5cbiAgcmV0dXJuIHBraS5wcml2YXRlS2V5RnJvbUFzbjEob2JqKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHByaXZhdGUga2V5IHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleVRvUGVtID0gZnVuY3Rpb24oa2V5LCBtYXhsaW5lKSB7XG4gIC8vIGNvbnZlcnQgdG8gQVNOLjEsIHRoZW4gREVSLCB0aGVuIFBFTS1lbmNvZGVcbiAgdmFyIG1zZyA9IHtcbiAgICB0eXBlOiAnUlNBIFBSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5wcml2YXRlS2V5VG9Bc24xKGtleSkpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFByaXZhdGVLZXlJbmZvIHRvIFBFTSBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHBraSB0aGUgUHJpdmF0ZUtleUluZm8uXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHByaXZhdGUga2V5LlxuICovXG5wa2kucHJpdmF0ZUtleUluZm9Ub1BlbSA9IGZ1bmN0aW9uKHBraSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BSSVZBVEUgS0VZJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuIiwiLyoqXG4gKiBQcmltZSBudW1iZXIgZ2VuZXJhdGlvbiBBUEkuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcbnJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbihmdW5jdGlvbigpIHtcblxuLy8gZm9yZ2UucHJpbWUgYWxyZWFkeSBkZWZpbmVkXG5pZihmb3JnZS5wcmltZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnByaW1lO1xuICByZXR1cm47XG59XG5cbi8qIFBSSU1FIEFQSSAqL1xudmFyIHByaW1lID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5wcmltZSA9IGZvcmdlLnByaW1lIHx8IHt9O1xuXG52YXIgQmlnSW50ZWdlciA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlcjtcblxuLy8gcHJpbWVzIGFyZSAzMGsraSBmb3IgaSA9IDEsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjlcbnZhciBHQ0RfMzBfREVMVEEgPSBbNiwgNCwgMiwgNCwgMiwgNCwgNiwgMl07XG52YXIgVEhJUlRZID0gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG5USElSVFkuZnJvbUludCgzMCk7XG52YXIgb3Bfb3IgPSBmdW5jdGlvbih4LCB5KSB7cmV0dXJuIHh8eTt9O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBwcm9iYWJsZSBwcmltZSB3aXRoIHRoZSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqXG4gKiBBbHRlcm5hdGl2ZSBhbGdvcml0aG1zIGNhbiBiZSBzcGVjaWZpZWQgYnkgbmFtZSBhcyBhIHN0cmluZyBvciBhcyBhblxuICogb2JqZWN0IHdpdGggY3VzdG9tIG9wdGlvbnMgbGlrZSBzbzpcbiAqXG4gKiB7XG4gKiAgIG5hbWU6ICdQUklNRUlOQycsXG4gKiAgIG9wdGlvbnM6IHtcbiAqICAgICBtYXhCbG9ja1RpbWU6IDx0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byBibG9jayB0aGUgbWFpblxuICogICAgICAgdGhyZWFkIGJlZm9yZSBhbGxvd2luZyBJL08gb3RoZXIgSlMgdG8gcnVuPixcbiAqICAgICBtaWxsZXJSYWJpblRlc3RzOiA8dGhlIG51bWJlciBvZiBtaWxsZXItcmFiaW4gdGVzdHMgdG8gcnVuPixcbiAqICAgICB3b3JrZXJTY3JpcHQ6IDx0aGUgd29ya2VyIHNjcmlwdCBVUkw+LFxuICogICAgIHdvcmtlcnM6IDx0aGUgbnVtYmVyIG9mIHdlYiB3b3JrZXJzIChpZiBzdXBwb3J0ZWQpIHRvIHVzZSxcbiAqICAgICAgIC0xIHRvIHVzZSBlc3RpbWF0ZWQgY29yZXMgbWludXMgb25lPi5cbiAqICAgICB3b3JrTG9hZDogdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgbnVtYmVycyBmb3IgZWFjaCB3ZWIgd29ya2VyIHRvIGNoZWNrIHBlciB3b3JrIGFzc2lnbm1lbnQsXG4gKiAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqICAgfVxuICogfVxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBudW1iZXIgb2YgYml0cyBmb3IgdGhlIHByaW1lIG51bWJlci5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZS5cbiAqICAgICAgICAgIFthbGdvcml0aG1dIHRoZSBhbGdvcml0aG0gdG8gdXNlIChkZWZhdWx0OiAnUFJJTUVJTkMnKS5cbiAqICAgICAgICAgIFtwcm5nXSBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi5cbiAqXG4gKiBAcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVtKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xucHJpbWUuZ2VuZXJhdGVQcm9iYWJsZVByaW1lID0gZnVuY3Rpb24oYml0cywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGRlZmF1bHQgdG8gUFJJTUVJTkMgYWxnb3JpdGhtXG4gIHZhciBhbGdvcml0aG0gPSBvcHRpb25zLmFsZ29yaXRobSB8fCAnUFJJTUVJTkMnO1xuICBpZih0eXBlb2YgYWxnb3JpdGhtID09PSAnc3RyaW5nJykge1xuICAgIGFsZ29yaXRobSA9IHtuYW1lOiBhbGdvcml0aG19O1xuICB9XG4gIGFsZ29yaXRobS5vcHRpb25zID0gYWxnb3JpdGhtLm9wdGlvbnMgfHwge307XG5cbiAgLy8gY3JlYXRlIHBybmcgd2l0aCBhcGkgdGhhdCBtYXRjaGVzIEJpZ0ludGVnZXIgc2VjdXJlIHJhbmRvbVxuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gIHZhciBybmcgPSB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBiID0gcHJuZy5nZXRCeXRlc1N5bmMoeC5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaWYoYWxnb3JpdGhtLm5hbWUgPT09ICdQUklNRUlOQycpIHtcbiAgICByZXR1cm4gcHJpbWVpbmNGaW5kUHJpbWUoYml0cywgcm5nLCBhbGdvcml0aG0ub3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaW1lIGdlbmVyYXRpb24gYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtLm5hbWUpO1xufTtcblxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWUoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZignd29ya2VycycgaW4gb3B0aW9ucykge1xuICAgIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwcmltZWluY0ZpbmRQcmltZVdpdGhvdXRXb3JrZXJzKGJpdHMsIHJuZywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gaW5pdGlhbGl6ZSByYW5kb20gbnVtYmVyXG4gIHZhciBudW0gPSBnZW5lcmF0ZVJhbmRvbShiaXRzLCBybmcpO1xuXG4gIC8qIE5vdGU6IEFsbCBwcmltZXMgYXJlIG9mIHRoZSBmb3JtIDMwaytpIGZvciBpIDwgMzAgYW5kIGdjZCgzMCwgaSk9MS4gVGhlXG4gIG51bWJlciB3ZSBhcmUgZ2l2ZW4gaXMgYWx3YXlzIGFsaWduZWQgYXQgMzBrICsgMS4gRWFjaCB0aW1lIHRoZSBudW1iZXIgaXNcbiAgZGV0ZXJtaW5lZCBub3QgdG8gYmUgcHJpbWUgd2UgYWRkIHRvIGdldCB0byB0aGUgbmV4dCAnaScsIGVnOiBpZiB0aGUgbnVtYmVyXG4gIHdhcyBhdCAzMGsgKyAxIHdlIGFkZCA2LiAqL1xuICB2YXIgZGVsdGFJZHggPSAwO1xuXG4gIC8vIGdldCByZXF1aXJlZCBudW1iZXIgb2YgTVIgdGVzdHNcbiAgdmFyIG1yVGVzdHMgPSBnZXRNaWxsZXJSYWJpblRlc3RzKG51bS5iaXRMZW5ndGgoKSk7XG4gIGlmKCdtaWxsZXJSYWJpblRlc3RzJyBpbiBvcHRpb25zKSB7XG4gICAgbXJUZXN0cyA9IG9wdGlvbnMubWlsbGVyUmFiaW5UZXN0cztcbiAgfVxuXG4gIC8vIGZpbmQgcHJpbWUgbmVhcmVzdCB0byAnbnVtJyBmb3IgbWF4QmxvY2tUaW1lIG1zXG4gIC8vIDEwIG1zIGdpdmVzIDVtcyBvZiBsZWV3YXkgZm9yIG90aGVyIGNhbGN1bGF0aW9ucyBiZWZvcmUgZHJvcHBpbmdcbiAgLy8gYmVsb3cgNjBmcHMgKDEwMDAvNjAgPT0gMTYuNjcpLCBidXQgaW4gcmVhbGl0eSwgdGhlIG51bWJlciB3aWxsXG4gIC8vIGxpa2VseSBiZSBoaWdoZXIgZHVlIHRvIGFuICdhdG9taWMnIGJpZyBpbnQgbW9kUG93XG4gIHZhciBtYXhCbG9ja1RpbWUgPSAxMDtcbiAgaWYoJ21heEJsb2NrVGltZScgaW4gb3B0aW9ucykge1xuICAgIG1heEJsb2NrVGltZSA9IG9wdGlvbnMubWF4QmxvY2tUaW1lO1xuICB9XG5cbiAgX3ByaW1laW5jKG51bSwgYml0cywgcm5nLCBkZWx0YUlkeCwgbXJUZXN0cywgbWF4QmxvY2tUaW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spIHtcbiAgdmFyIHN0YXJ0ID0gK25ldyBEYXRlKCk7XG4gIGRvIHtcbiAgICAvLyBvdmVyZmxvdywgcmVnZW5lcmF0ZSByYW5kb20gbnVtYmVyXG4gICAgaWYobnVtLmJpdExlbmd0aCgpID4gYml0cykge1xuICAgICAgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICB9XG4gICAgLy8gZG8gcHJpbWFsaXR5IHRlc3RcbiAgICBpZihudW0uaXNQcm9iYWJsZVByaW1lKG1yVGVzdHMpKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVtKTtcbiAgICB9XG4gICAgLy8gZ2V0IG5leHQgcG90ZW50aWFsIHByaW1lXG4gICAgbnVtLmRBZGRPZmZzZXQoR0NEXzMwX0RFTFRBW2RlbHRhSWR4KysgJSA4XSwgMCk7XG4gIH0gd2hpbGUobWF4QmxvY2tUaW1lIDwgMCB8fCAoK25ldyBEYXRlKCkgLSBzdGFydCA8IG1heEJsb2NrVGltZSkpO1xuXG4gIC8vIGtlZXAgdHJ5aW5nIGxhdGVyXG4gIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIF9wcmltZWluYyhudW0sIGJpdHMsIHJuZywgZGVsdGFJZHgsIG1yVGVzdHMsIG1heEJsb2NrVGltZSwgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuLy8gTk9URTogVGhpcyBhbGdvcml0aG0gaXMgaW5kZXRlcm1pbmF0ZSBpbiBuYXR1cmUgYmVjYXVzZSB3b3JrZXJzXG4vLyBydW4gaW4gcGFyYWxsZWwgbG9va2luZyBhdCBkaWZmZXJlbnQgc2VnbWVudHMgb2YgbnVtYmVycy4gRXZlbiBpZiB0aGlzXG4vLyBhbGdvcml0aG0gaXMgcnVuIHR3aWNlIHdpdGggdGhlIHNhbWUgaW5wdXQgZnJvbSBhIHByZWRpY3RhYmxlIFJORywgaXRcbi8vIG1heSBwcm9kdWNlIGRpZmZlcmVudCBvdXRwdXRzLlxuZnVuY3Rpb24gcHJpbWVpbmNGaW5kUHJpbWVXaXRoV29ya2VycyhiaXRzLCBybmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIHdlYiB3b3JrZXJzIHVuYXZhaWxhYmxlXG4gIGlmKHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHByaW1laW5jRmluZFByaW1lV2l0aG91dFdvcmtlcnMoYml0cywgcm5nLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHJhbmRvbSBudW1iZXJcbiAgdmFyIG51bSA9IGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZyk7XG5cbiAgLy8gdXNlIHdlYiB3b3JrZXJzIHRvIGdlbmVyYXRlIGtleXNcbiAgdmFyIG51bVdvcmtlcnMgPSBvcHRpb25zLndvcmtlcnM7XG4gIHZhciB3b3JrTG9hZCA9IG9wdGlvbnMud29ya0xvYWQgfHwgMTAwO1xuICB2YXIgcmFuZ2UgPSB3b3JrTG9hZCAqIDMwIC8gODtcbiAgdmFyIHdvcmtlclNjcmlwdCA9IG9wdGlvbnMud29ya2VyU2NyaXB0IHx8ICdmb3JnZS9wcmltZS53b3JrZXIuanMnO1xuICBpZihudW1Xb3JrZXJzID09PSAtMSkge1xuICAgIHJldHVybiBmb3JnZS51dGlsLmVzdGltYXRlQ29yZXMoZnVuY3Rpb24oZXJyLCBjb3Jlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gMlxuICAgICAgICBjb3JlcyA9IDI7XG4gICAgICB9XG4gICAgICBudW1Xb3JrZXJzID0gY29yZXMgLSAxO1xuICAgICAgZ2VuZXJhdGUoKTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZSgpO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIC8vIHJlcXVpcmUgYXQgbGVhc3QgMSB3b3JrZXJcbiAgICBudW1Xb3JrZXJzID0gTWF0aC5tYXgoMSwgbnVtV29ya2Vycyk7XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBvcHRpbWl6aW5nIGJ5IHN0YXJ0aW5nIHdvcmtlcnMgb3V0c2lkZSBnZXRQcmltZSgpIC4uLlxuICAgIC8vIG5vdGUgdGhhdCBpbiBvcmRlciB0byBjbGVhbiB1cCB0aGV5IHdpbGwgaGF2ZSB0byBiZSBtYWRlIGludGVybmFsbHlcbiAgICAvLyBhc3luY2hyb25vdXMgd2hpY2ggbWF5IGFjdHVhbGx5IGJlIHNsb3dlclxuXG4gICAgLy8gc3RhcnQgd29ya2VycyBpbW1lZGlhdGVseVxuICAgIHZhciB3b3JrZXJzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgLy8gRklYTUU6IGZpeCBwYXRoIG9yIHVzZSBibG9iIFVSTHNcbiAgICAgIHdvcmtlcnNbaV0gPSBuZXcgV29ya2VyKHdvcmtlclNjcmlwdCk7XG4gICAgfVxuICAgIHZhciBydW5uaW5nID0gbnVtV29ya2VycztcblxuICAgIC8vIGxpc3RlbiBmb3IgcmVxdWVzdHMgZnJvbSB3b3JrZXJzIGFuZCBhc3NpZ24gcmFuZ2VzIHRvIGZpbmQgcHJpbWVcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICB3b3JrZXJzW2ldLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJNZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKiBOb3RlOiBUaGUgZGlzdHJpYnV0aW9uIG9mIHJhbmRvbSBudW1iZXJzIGlzIHVua25vd24uIFRoZXJlZm9yZSwgZWFjaFxuICAgIHdlYiB3b3JrZXIgaXMgY29udGludW91c2x5IGFsbG9jYXRlZCBhIHJhbmdlIG9mIG51bWJlcnMgdG8gY2hlY2sgZm9yIGFcbiAgICByYW5kb20gbnVtYmVyIHVudGlsIG9uZSBpcyBmb3VuZC5cblxuICAgIEV2ZXJ5IDMwIG51bWJlcnMgd2lsbCBiZSBjaGVja2VkIGp1c3QgOCB0aW1lcywgYmVjYXVzZSBwcmltZSBudW1iZXJzXG4gICAgaGF2ZSB0aGUgZm9ybTpcblxuICAgIDMwaytpLCBmb3IgaSA8IDMwIGFuZCBnY2QoMzAsIGkpPTEgKHRoZXJlIGFyZSA4IHZhbHVlcyBvZiBpIGZvciB0aGlzKVxuXG4gICAgVGhlcmVmb3JlLCBpZiB3ZSB3YW50IGEgd2ViIHdvcmtlciB0byBydW4gTiBjaGVja3MgYmVmb3JlIGFza2luZyBmb3JcbiAgICBhIG5ldyByYW5nZSBvZiBudW1iZXJzLCBlYWNoIHJhbmdlIG11c3QgY29udGFpbiBOKjMwLzggbnVtYmVycy5cblxuICAgIEZvciAxMDAgY2hlY2tzICh3b3JrTG9hZCksIHRoaXMgaXMgYSByYW5nZSBvZiAzNzUuICovXG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB3b3JrZXJNZXNzYWdlKGUpIHtcbiAgICAgIC8vIGlnbm9yZSBtZXNzYWdlLCBwcmltZSBhbHJlYWR5IGZvdW5kXG4gICAgICBpZihmb3VuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC0tcnVubmluZztcbiAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgaWYoZGF0YS5mb3VuZCkge1xuICAgICAgICAvLyB0ZXJtaW5hdGUgYWxsIHdvcmtlcnNcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHdvcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB3b3JrZXJzW2ldLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG5ldyBCaWdJbnRlZ2VyKGRhdGEucHJpbWUsIDE2KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJmbG93LCByZWdlbmVyYXRlIHJhbmRvbSBudW1iZXJcbiAgICAgIGlmKG51bS5iaXRMZW5ndGgoKSA+IGJpdHMpIHtcbiAgICAgICAgbnVtID0gZ2VuZXJhdGVSYW5kb20oYml0cywgcm5nKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzaWduIG5ldyByYW5nZSB0byBjaGVja1xuICAgICAgdmFyIGhleCA9IG51bS50b1N0cmluZygxNik7XG5cbiAgICAgIC8vIHN0YXJ0IHByaW1lIHNlYXJjaFxuICAgICAgZS50YXJnZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBoZXg6IGhleCxcbiAgICAgICAgd29ya0xvYWQ6IHdvcmtMb2FkXG4gICAgICB9KTtcblxuICAgICAgbnVtLmRBZGRPZmZzZXQocmFuZ2UsIDApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgdXNpbmcgdGhlIGdpdmVuIG51bWJlciBvZiBiaXRzIGFuZCBSTkcuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIG51bWJlciBvZiBiaXRzIGZvciB0aGUgbnVtYmVyLlxuICogQHBhcmFtIHJuZyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tKGJpdHMsIHJuZykge1xuICB2YXIgbnVtID0gbmV3IEJpZ0ludGVnZXIoYml0cywgcm5nKTtcbiAgLy8gZm9yY2UgTVNCIHNldFxuICB2YXIgYml0czEgPSBiaXRzIC0gMTtcbiAgaWYoIW51bS50ZXN0Qml0KGJpdHMxKSkge1xuICAgIG51bS5iaXR3aXNlVG8oQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSwgb3Bfb3IsIG51bSk7XG4gIH1cbiAgLy8gYWxpZ24gbnVtYmVyIG9uIDMwaysxIGJvdW5kYXJ5XG4gIG51bS5kQWRkT2Zmc2V0KDMxIC0gbnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgcmV0dXJuIG51bTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgTWlsbGVyLVJhYmluIHRlc3RzIHRvIGdlbmVyYXRlIGFcbiAqIHByaW1lIHdpdGggYW4gZXJyb3IgcHJvYmFiaWxpdHkgb2YgKDEvMileODAuXG4gKlxuICogU2VlIEhhbmRib29rIG9mIEFwcGxpZWQgQ3J5cHRvZ3JhcGh5IENoYXB0ZXIgNCwgVGFibGUgNC40LlxuICpcbiAqIEBwYXJhbSBiaXRzIHRoZSBiaXQgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZ2V0TWlsbGVyUmFiaW5UZXN0cyhiaXRzKSB7XG4gIGlmKGJpdHMgPD0gMTAwKSByZXR1cm4gMjc7XG4gIGlmKGJpdHMgPD0gMTUwKSByZXR1cm4gMTg7XG4gIGlmKGJpdHMgPD0gMjAwKSByZXR1cm4gMTU7XG4gIGlmKGJpdHMgPD0gMjUwKSByZXR1cm4gMTI7XG4gIGlmKGJpdHMgPD0gMzAwKSByZXR1cm4gOTtcbiAgaWYoYml0cyA8PSAzNTApIHJldHVybiA4O1xuICBpZihiaXRzIDw9IDQwMCkgcmV0dXJuIDc7XG4gIGlmKGJpdHMgPD0gNTAwKSByZXR1cm4gNjtcbiAgaWYoYml0cyA8PSA2MDApIHJldHVybiA1O1xuICBpZihiaXRzIDw9IDgwMCkgcmV0dXJuIDQ7XG4gIGlmKGJpdHMgPD0gMTI1MCkgcmV0dXJuIDM7XG4gIHJldHVybiAyO1xufVxuXG59KSgpO1xuIiwiLyoqXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmVcbiAqIFBzZXVkbyBSYW5kb20gTnVtYmVyIEdlbmVyYXRvciAoUFJORykuIFRoZSBGb3J0dW5hIGFsZ29yaXRobSBpcyBmb2xsb3dlZFxuICogaGVyZSB0aG91Z2ggdGhlIHVzZSBvZiBTSEEtMjU2IGlzIG5vdCBlbmZvcmNlZDsgd2hlbiBnZW5lcmF0aW5nIGFuXG4gKiBhIFBSTkcgY29udGV4dCwgdGhlIGhhc2hpbmcgYWxnb3JpdGhtIGFuZCBibG9jayBjaXBoZXIgdXNlZCBmb3JcbiAqIHRoZSBnZW5lcmF0b3IgYXJlIHNwZWNpZmllZCB2aWEgYSBwbHVnaW4uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIF9jcnlwdG8gPSBudWxsO1xuaWYoZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJlxuICAhcHJvY2Vzcy52ZXJzaW9uc1snbm9kZS13ZWJraXQnXSkge1xuICBfY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG59XG5cbi8qIFBSTkcgQVBJICovXG52YXIgcHJuZyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHJuZyA9IGZvcmdlLnBybmcgfHwge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQUk5HIGNvbnRleHQuXG4gKlxuICogQSBQUk5HIHBsdWdpbiBtdXN0IGJlIHBhc3NlZCBpbiB0aGF0IHdpbGwgcHJvdmlkZTpcbiAqXG4gKiAxLiBBIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGtleSBhbmQgc2VlZCBvZiBhIFBSTkcgY29udGV4dC4gSXRcbiAqICAgd2lsbCBiZSBnaXZlbiBhIDE2IGJ5dGUga2V5IGFuZCBhIDE2IGJ5dGUgc2VlZC4gQW55IGtleSBleHBhbnNpb25cbiAqICAgb3IgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHNlZWQgZnJvbSBhIGJ5dGUgc3RyaW5nIGludG8gYW4gYXJyYXkgb2ZcbiAqICAgaW50ZWdlcnMgKG9yIHNpbWlsYXIpIHNob3VsZCBiZSBwZXJmb3JtZWQuXG4gKiAyLiBUaGUgY3J5cHRvZ3JhcGhpYyBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBnZW5lcmF0b3IuIEl0IHRha2VzIGEga2V5IGFuZFxuICogICBhIHNlZWQuXG4gKiAzLiBBIHNlZWQgaW5jcmVtZW50IGZ1bmN0aW9uLiBJdCB0YWtlcyB0aGUgc2VlZCBhbmQgcmV0dXJucyBzZWVkICsgMS5cbiAqIDQuIEFuIGFwaSB0byBjcmVhdGUgYSBtZXNzYWdlIGRpZ2VzdC5cbiAqXG4gKiBGb3IgYW4gZXhhbXBsZSwgc2VlIHJhbmRvbS5qcy5cbiAqXG4gKiBAcGFyYW0gcGx1Z2luIHRoZSBQUk5HIHBsdWdpbiB0byB1c2UuXG4gKi9cbnBybmcuY3JlYXRlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gIHZhciBjdHggPSB7XG4gICAgcGx1Z2luOiBwbHVnaW4sXG4gICAga2V5OiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgdGltZTogbnVsbCxcbiAgICAvLyBudW1iZXIgb2YgcmVzZWVkcyBzbyBmYXJcbiAgICByZXNlZWRzOiAwLFxuICAgIC8vIGFtb3VudCBvZiBkYXRhIGdlbmVyYXRlZCBzbyBmYXJcbiAgICBnZW5lcmF0ZWQ6IDAsXG4gICAgLy8gbm8gaW5pdGlhbCBrZXkgYnl0ZXNcbiAgICBrZXlCeXRlczogJydcbiAgfTtcblxuICAvLyBjcmVhdGUgMzIgZW50cm9weSBwb29scyAoZWFjaCBpcyBhIG1lc3NhZ2UgZGlnZXN0KVxuICB2YXIgbWQgPSBwbHVnaW4ubWQ7XG4gIHZhciBwb29scyA9IG5ldyBBcnJheSgzMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgcG9vbHNbaV0gPSBtZC5jcmVhdGUoKTtcbiAgfVxuICBjdHgucG9vbHMgPSBwb29scztcblxuICAvLyBlbnRyb3B5IHBvb2xzIGFyZSB3cml0dGVuIHRvIGN5Y2xpY2FsbHksIHN0YXJ0aW5nIGF0IGluZGV4IDBcbiAgY3R4LnBvb2wgPSAwO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcmFuZG9tIGJ5dGVzLiBUaGUgYnl0ZXMgbWF5IGJlIGdlbmVyYXRlZCBzeW5jaHJvbm91c2x5IG9yXG4gICAqIGFzeW5jaHJvbm91c2x5LiBXZWIgd29ya2VycyBtdXN0IHVzZSB0aGUgYXN5bmNocm9ub3VzIGludGVyZmFjZSBvclxuICAgKiBlbHNlIHRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIFtjYWxsYmFjayhlcnIsIGJ5dGVzKV0gY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4gY291bnQgcmFuZG9tIGJ5dGVzIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgY3R4LmdlbmVyYXRlID0gZnVuY3Rpb24oY291bnQsIGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gc3luY2hyb25vdXNseVxuICAgIGlmKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGN0eC5nZW5lcmF0ZVN5bmMoY291bnQpO1xuICAgIH1cblxuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcbiAgICB2YXIgYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHJlc2V0IGtleSBmb3IgZXZlcnkgcmVxdWVzdCB0byBwcm90ZWN0IHByZXZpb3VzbHlcbiAgICAvLyBnZW5lcmF0ZWQgcmFuZG9tIGJ5dGVzIHNob3VsZCB0aGUga2V5IGJlIGRpc2NvdmVyZWQ7XG4gICAgLy8gdGhlcmUgaXMgbm8gMTAwbXMgYmFzZWQgcmVzZWVkaW5nIGJlY2F1c2Ugb2YgdGhpc1xuICAgIC8vIGZvcmNlZCByZXNlZWQgZm9yIGV2ZXJ5IGBnZW5lcmF0ZWAgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgZ2VuZXJhdGUoKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGVycikge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzdWZmaWNpZW50IGJ5dGVzIGdlbmVyYXRlZFxuICAgICAgaWYoYi5sZW5ndGgoKSA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYi5nZXRCeXRlcyhjb3VudCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbW91bnQgb2YgZGF0YSBnZW5lcmF0ZWQgaXMgZ3JlYXRlciB0aGFuIDEgTWlCLCB0cmlnZ2VyIHJlc2VlZFxuICAgICAgaWYoY3R4LmdlbmVyYXRlZCA+IDB4ZmZmZmYpIHtcbiAgICAgICAgY3R4LmtleSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKGN0eC5rZXkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gcHJldmVudCBzdGFjayBvdmVyZmxvd1xuICAgICAgICByZXR1cm4gZm9yZ2UudXRpbC5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBfcmVzZWVkKGdlbmVyYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG5cbiAgICAgIGZvcmdlLnV0aWwuc2V0SW1tZWRpYXRlKGdlbmVyYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByYW5kb20gYnl0ZXMgc3luY2hyb25vdXNseS5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIGNvdW50IHJhbmRvbSBieXRlcyBhcyBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZW5lcmF0ZVN5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIHNpbXBsZSBnZW5lcmF0b3IgdXNpbmcgY291bnRlci1iYXNlZCBDQkNcbiAgICB2YXIgY2lwaGVyID0gY3R4LnBsdWdpbi5jaXBoZXI7XG4gICAgdmFyIGluY3JlbWVudCA9IGN0eC5wbHVnaW4uaW5jcmVtZW50O1xuICAgIHZhciBmb3JtYXRLZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleTtcbiAgICB2YXIgZm9ybWF0U2VlZCA9IGN0eC5wbHVnaW4uZm9ybWF0U2VlZDtcblxuICAgIC8vIHBhcmFub2lkIGRldmlhdGlvbiBmcm9tIEZvcnR1bmE6XG4gICAgLy8gcmVzZXQga2V5IGZvciBldmVyeSByZXF1ZXN0IHRvIHByb3RlY3QgcHJldmlvdXNseVxuICAgIC8vIGdlbmVyYXRlZCByYW5kb20gYnl0ZXMgc2hvdWxkIHRoZSBrZXkgYmUgZGlzY292ZXJlZDtcbiAgICAvLyB0aGVyZSBpcyBubyAxMDBtcyBiYXNlZCByZXNlZWRpbmcgYmVjYXVzZSBvZiB0aGlzXG4gICAgLy8gZm9yY2VkIHJlc2VlZCBmb3IgZXZlcnkgYGdlbmVyYXRlU3luY2AgY2FsbFxuICAgIGN0eC5rZXkgPSBudWxsO1xuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHdoaWxlKGIubGVuZ3RoKCkgPCBjb3VudCkge1xuICAgICAgLy8gaWYgYW1vdW50IG9mIGRhdGEgZ2VuZXJhdGVkIGlzIGdyZWF0ZXIgdGhhbiAxIE1pQiwgdHJpZ2dlciByZXNlZWRcbiAgICAgIGlmKGN0eC5nZW5lcmF0ZWQgPiAweGZmZmZmKSB7XG4gICAgICAgIGN0eC5rZXkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZihjdHgua2V5ID09PSBudWxsKSB7XG4gICAgICAgIF9yZXNlZWRTeW5jKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYXRlIHRoZSByYW5kb20gYnl0ZXNcbiAgICAgIHZhciBieXRlcyA9IGNpcGhlcihjdHgua2V5LCBjdHguc2VlZCk7XG4gICAgICBjdHguZ2VuZXJhdGVkICs9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGIucHV0Qnl0ZXMoYnl0ZXMpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBieXRlcyBmb3IgYSBuZXcga2V5IGFuZCBzZWVkXG4gICAgICBjdHgua2V5ID0gZm9ybWF0S2V5KGNpcGhlcihjdHgua2V5LCBpbmNyZW1lbnQoY3R4LnNlZWQpKSk7XG4gICAgICBjdHguc2VlZCA9IGZvcm1hdFNlZWQoY2lwaGVyKGN0eC5rZXksIGN0eC5zZWVkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMoY291bnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrKGVycikgY2FsbGVkIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfcmVzZWVkKGNhbGxiYWNrKSB7XG4gICAgaWYoY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGggPj0gMzIpIHtcbiAgICAgIF9zZWVkKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LnNlZWRGaWxlKG5lZWRlZCwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgaWYoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY3R4LmNvbGxlY3QoYnl0ZXMpO1xuICAgICAgX3NlZWQoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IHN5bmNocm9ub3VzbHkgcmVzZWVkcyBhIGdlbmVyYXRvci5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNlZWRTeW5jKCkge1xuICAgIGlmKGN0eC5wb29sc1swXS5tZXNzYWdlTGVuZ3RoID49IDMyKSB7XG4gICAgICByZXR1cm4gX3NlZWQoKTtcbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCBzZWVkIGRhdGEuLi5cbiAgICB2YXIgbmVlZGVkID0gKDMyIC0gY3R4LnBvb2xzWzBdLm1lc3NhZ2VMZW5ndGgpIDw8IDU7XG4gICAgY3R4LmNvbGxlY3QoY3R4LnNlZWRGaWxlU3luYyhuZWVkZWQpKTtcbiAgICBfc2VlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBzZWVkcyBhIGdlbmVyYXRvciBvbmNlIGVub3VnaCBieXRlcyBhcmUgYXZhaWxhYmxlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NlZWQoKSB7XG4gICAgLy8gdXBkYXRlIHJlc2VlZCBjb3VudFxuICAgIGN0eC5yZXNlZWRzID0gKGN0eC5yZXNlZWRzID09PSAweGZmZmZmZmZmKSA/IDAgOiBjdHgucmVzZWVkcyArIDE7XG5cbiAgICAvLyBnb2FsIGlzIHRvIHVwZGF0ZSBga2V5YCB2aWE6XG4gICAgLy8ga2V5ID0gaGFzaChrZXkgKyBzKVxuICAgIC8vICAgd2hlcmUgJ3MnIGlzIGFsbCBjb2xsZWN0ZWQgZW50cm9weSBmcm9tIHNlbGVjdGVkIHBvb2xzLCB0aGVuLi4uXG5cbiAgICAvLyBjcmVhdGUgYSBwbHVnaW4tYmFzZWQgbWVzc2FnZSBkaWdlc3RcbiAgICB2YXIgbWQgPSBjdHgucGx1Z2luLm1kLmNyZWF0ZSgpO1xuXG4gICAgLy8gY29uc3VtZSBjdXJyZW50IGtleSBieXRlc1xuICAgIG1kLnVwZGF0ZShjdHgua2V5Qnl0ZXMpO1xuXG4gICAgLy8gZGlnZXN0IHRoZSBlbnRyb3B5IG9mIHBvb2xzIHdob3NlIGluZGV4IGsgbWVldCB0aGVcbiAgICAvLyBjb25kaXRpb24gJ24gbW9kIDJeayA9PSAwJyB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgcmVzZWVkc1xuICAgIHZhciBfMnBvd0sgPSAxO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCAzMjsgKytrKSB7XG4gICAgICBpZihjdHgucmVzZWVkcyAlIF8ycG93SyA9PT0gMCkge1xuICAgICAgICBtZC51cGRhdGUoY3R4LnBvb2xzW2tdLmRpZ2VzdCgpLmdldEJ5dGVzKCkpO1xuICAgICAgICBjdHgucG9vbHNba10uc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIF8ycG93SyA9IF8ycG93SyA8PCAxO1xuICAgIH1cblxuICAgIC8vIGdldCBkaWdlc3QgZm9yIGtleSBieXRlc1xuICAgIGN0eC5rZXlCeXRlcyA9IG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCk7XG5cbiAgICAvLyBwYXJhbm9pZCBkZXZpYXRpb24gZnJvbSBGb3J0dW5hOlxuICAgIC8vIHVwZGF0ZSBgc2VlZGAgdmlhIGBzZWVkID0gaGFzaChrZXkpYFxuICAgIC8vIGluc3RlYWQgb2YgaW5pdGlhbGl6aW5nIHRvIHplcm8gb25jZSBhbmQgb25seVxuICAgIC8vIGV2ZXIgaW5jcmVtZW50aW5nIGl0XG4gICAgbWQuc3RhcnQoKTtcbiAgICBtZC51cGRhdGUoY3R4LmtleUJ5dGVzKTtcbiAgICB2YXIgc2VlZEJ5dGVzID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgIGN0eC5rZXkgPSBjdHgucGx1Z2luLmZvcm1hdEtleShjdHgua2V5Qnl0ZXMpO1xuICAgIGN0eC5zZWVkID0gY3R4LnBsdWdpbi5mb3JtYXRTZWVkKHNlZWRCeXRlcyk7XG4gICAgY3R4LmdlbmVyYXRlZCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJ1aWx0LWluIGRlZmF1bHQgc2VlZEZpbGUuIFRoaXMgc2VlZEZpbGUgaXMgdXNlZCB3aGVuIGVudHJvcHlcbiAgICogaXMgbmVlZGVkIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBAcGFyYW0gbmVlZGVkIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZhdWx0U2VlZEZpbGUobmVlZGVkKSB7XG4gICAgLy8gdXNlIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHN0cm9uZyBzb3VyY2Ugb2YgZW50cm9weSBpZiBhdmFpbGFibGVcbiAgICB2YXIgZ2V0UmFuZG9tVmFsdWVzID0gbnVsbDtcbiAgICB2YXIgZ2xvYmFsU2NvcGUgPSBmb3JnZS51dGlsLmdsb2JhbFNjb3BlO1xuICAgIHZhciBfY3J5cHRvID0gZ2xvYmFsU2NvcGUuY3J5cHRvIHx8IGdsb2JhbFNjb3BlLm1zQ3J5cHRvO1xuICAgIGlmKF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgICAgICByZXR1cm4gX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGIgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGlmKGdldFJhbmRvbVZhbHVlcykge1xuICAgICAgd2hpbGUoYi5sZW5ndGgoKSA8IG5lZWRlZCkge1xuICAgICAgICAvLyBtYXggYnl0ZSBsZW5ndGggaXMgNjU1MzYgYmVmb3JlIFF1b3RhRXhjZWVkZWRFcnJvciBpcyB0aHJvd25cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvV2ViQ3J5cHRvQVBJLyNSYW5kb21Tb3VyY2UtbWV0aG9kLWdldFJhbmRvbVZhbHVlc1xuICAgICAgICB2YXIgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihuZWVkZWQgLSBiLmxlbmd0aCgpLCA2NTUzNikgLyA0KTtcbiAgICAgICAgdmFyIGVudHJvcHkgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5mbG9vcihjb3VudCkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdldFJhbmRvbVZhbHVlcyhlbnRyb3B5KTtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYi5wdXRJbnQzMihlbnRyb3B5W2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgIC8qIG9ubHkgaWdub3JlIFF1b3RhRXhjZWVkZWRFcnJvciAqL1xuICAgICAgICAgIGlmKCEodHlwZW9mIFF1b3RhRXhjZWVkZWRFcnJvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBRdW90YUV4Y2VlZGVkRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJlIHNhZCBhbmQgYWRkIHNvbWUgd2VhayByYW5kb20gZGF0YVxuICAgIGlmKGIubGVuZ3RoKCkgPCBuZWVkZWQpIHtcbiAgICAgIC8qIERyYXdzIGZyb20gUGFyay1NaWxsZXIgXCJtaW5pbWFsIHN0YW5kYXJkXCIgMzEgYml0IFBSTkcsXG4gICAgICBpbXBsZW1lbnRlZCB3aXRoIERhdmlkIEcuIENhcnRhJ3Mgb3B0aW1pemF0aW9uOiB3aXRoIDMyIGJpdCBtYXRoXG4gICAgICBhbmQgd2l0aG91dCBkaXZpc2lvbiAoUHVibGljIERvbWFpbikuICovXG4gICAgICB2YXIgaGksIGxvLCBuZXh0O1xuICAgICAgdmFyIHNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDAxMDAwMCk7XG4gICAgICB3aGlsZShiLmxlbmd0aCgpIDwgbmVlZGVkKSB7XG4gICAgICAgIGxvID0gMTY4MDcgKiAoc2VlZCAmIDB4RkZGRik7XG4gICAgICAgIGhpID0gMTY4MDcgKiAoc2VlZCA+PiAxNik7XG4gICAgICAgIGxvICs9IChoaSAmIDB4N0ZGRikgPDwgMTY7XG4gICAgICAgIGxvICs9IGhpID4+IDE1O1xuICAgICAgICBsbyA9IChsbyAmIDB4N0ZGRkZGRkYpICsgKGxvID4+IDMxKTtcbiAgICAgICAgc2VlZCA9IGxvICYgMHhGRkZGRkZGRjtcblxuICAgICAgICAvLyBjb25zdW1lIGxvd2VyIDMgYnl0ZXMgb2Ygc2VlZFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgaW4gbW9yZSBwc2V1ZG8gcmFuZG9tXG4gICAgICAgICAgbmV4dCA9IHNlZWQgPj4+IChpIDw8IDMpO1xuICAgICAgICAgIG5leHQgXj0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgwMTAwKTtcbiAgICAgICAgICBiLnB1dEJ5dGUoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0ICYgMHhGRikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuZ2V0Qnl0ZXMobmVlZGVkKTtcbiAgfVxuICAvLyBpbml0aWFsaXplIHNlZWQgZmlsZSBBUElzXG4gIGlmKF9jcnlwdG8pIHtcbiAgICAvLyB1c2Ugbm9kZWpzIGFzeW5jIEFQSVxuICAgIGN0eC5zZWVkRmlsZSA9IGZ1bmN0aW9uKG5lZWRlZCwgY2FsbGJhY2spIHtcbiAgICAgIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgIGlmKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLnRvU3RyaW5nKCkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB1c2Ugbm9kZWpzIHN5bmMgQVBJXG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGZ1bmN0aW9uKG5lZWRlZCkge1xuICAgICAgcmV0dXJuIF9jcnlwdG8ucmFuZG9tQnl0ZXMobmVlZGVkKS50b1N0cmluZygpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY3R4LnNlZWRGaWxlID0gZnVuY3Rpb24obmVlZGVkLCBjYWxsYmFjaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGVmYXVsdFNlZWRGaWxlKG5lZWRlZCkpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3R4LnNlZWRGaWxlU3luYyA9IGRlZmF1bHRTZWVkRmlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGVudHJvcHkgdG8gYSBwcm5nIGN0eCdzIGFjY3VtdWxhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIG9mIGVudHJvcHkgYXMgYSBzdHJpbmcuXG4gICAqL1xuICBjdHguY29sbGVjdCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBvb2xzIGRpc3RyaWJ1dGluZyBlbnRyb3B5IGN5Y2xpY2FsbHlcbiAgICB2YXIgY291bnQgPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGN0eC5wb29sc1tjdHgucG9vbF0udXBkYXRlKGJ5dGVzLnN1YnN0cihpLCAxKSk7XG4gICAgICBjdHgucG9vbCA9IChjdHgucG9vbCA9PT0gMzEpID8gMCA6IGN0eC5wb29sICsgMTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbGxlY3RzIGFuIGludGVnZXIgb2YgbiBiaXRzLlxuICAgKlxuICAgKiBAcGFyYW0gaSB0aGUgaW50ZWdlciBlbnRyb3B5LlxuICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIuXG4gICAqL1xuICBjdHguY29sbGVjdEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgICB2YXIgYnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgbjsgeCArPSA4KSB7XG4gICAgICBieXRlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpID4+IHgpICYgMHhGRik7XG4gICAgfVxuICAgIGN0eC5jb2xsZWN0KGJ5dGVzKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgV2ViIFdvcmtlciB0byByZWNlaXZlIGltbWVkaWF0ZSBlbnRyb3B5IGZyb20gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB1bnRpbCBXZWIgV29ya2VycyBjYW4gYWNjZXNzIHRoZSBuYXRpdmUgY3J5cHRvXG4gICAqIEFQSS4gVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0d2ljZSBmb3IgZWFjaCBjcmVhdGVkIHdvcmtlciwgb25jZSBpblxuICAgKiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBvbmNlIGluIHRoZSB3b3JrZXIgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0gd29ya2VyIHRoZSB3b3JrZXIgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBjdHgucmVnaXN0ZXJXb3JrZXIgPSBmdW5jdGlvbih3b3JrZXIpIHtcbiAgICAvLyB3b3JrZXIgcmVjZWl2ZXMgcmFuZG9tIGJ5dGVzXG4gICAgaWYod29ya2VyID09PSBzZWxmKSB7XG4gICAgICBjdHguc2VlZEZpbGUgPSBmdW5jdGlvbihuZWVkZWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YTtcbiAgICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YS5mb3JnZS5wcm5nLmVyciwgZGF0YS5mb3JnZS5wcm5nLmJ5dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtmb3JnZToge3Bybmc6IHtuZWVkZWQ6IG5lZWRlZH19fSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYWluIHRocmVhZCBzZW5kcyByYW5kb20gYnl0ZXMgdXBvbiByZXF1ZXN0XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICBpZihkYXRhLmZvcmdlICYmIGRhdGEuZm9yZ2UucHJuZykge1xuICAgICAgICAgIGN0eC5zZWVkRmlsZShkYXRhLmZvcmdlLnBybmcubmVlZGVkLCBmdW5jdGlvbihlcnIsIGJ5dGVzKSB7XG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe2ZvcmdlOiB7cHJuZzoge2VycjogZXJyLCBieXRlczogYnl0ZXN9fX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0byByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIHdvcmtlciBkaWVzP1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjdHg7XG59O1xuIiwiLyoqXG4gKiBKYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIFBLQ1MjMSBQU1Mgc2lnbmF0dXJlIHBhZGRpbmcuXG4gKlxuICogQGF1dGhvciBTdGVmYW4gU2llZ2xcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgU3RlZmFuIFNpZWdsIDxzdGVzaWVAYnJva2VucGlwZS5kZT5cbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBzaG9ydGN1dCBmb3IgUFNTIEFQSVxudmFyIHBzcyA9IG1vZHVsZS5leHBvcnRzID0gZm9yZ2UucHNzID0gZm9yZ2UucHNzIHx8IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQU1Mgc2lnbmF0dXJlIHNjaGVtZSBvYmplY3QuXG4gKlxuICogVGhlcmUgYXJlIHNldmVyYWwgd2F5cyB0byBwcm92aWRlIGEgc2FsdCBmb3IgZW5jb2Rpbmc6XG4gKlxuICogMS4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBvbmx5IGFuZCB0aGUgYnVpbHQtaW4gUFJORyB3aWxsIGdlbmVyYXRlIGl0LlxuICogMi4gU3BlY2lmeSB0aGUgc2FsdExlbmd0aCBhbmQgYSBjdXN0b20gUFJORyB3aXRoICdnZXRCeXRlc1N5bmMnIGRlZmluZWQgdGhhdFxuICogICB3aWxsIGJlIHVzZWQuXG4gKiAzLiBTcGVjaWZ5IHRoZSBzYWx0IGl0c2VsZiBhcyBhIGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSwgYSBmb3JnZSBtZCBpbnN0YW5jZS5cbiAqICAgICAgICAgIG1nZiB0aGUgbWFzayBnZW5lcmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSwgYSBmb3JnZSBtZ2YgaW5zdGFuY2UuXG4gKiAgICAgICAgICBbc2FsdExlbmd0aF0gdGhlIGxlbmd0aCBvZiB0aGUgc2FsdCBpbiBvY3RldHMuXG4gKiAgICAgICAgICBbcHJuZ10gdGhlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UgdG8gcHJvZHVjZSBhIHNhbHQuXG4gKiAgICAgICAgICBbc2FsdF0gdGhlIHNhbHQgdG8gdXNlIHdoZW4gZW5jb2RpbmcuXG4gKlxuICogQHJldHVybiBhIHNpZ25hdHVyZSBzY2hlbWUgb2JqZWN0LlxuICovXG5wc3MuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3L2xlZ2FjeSBhcmdzOiBoYXNoLCBtZ2YsIHNMZW5cbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBtZDogYXJndW1lbnRzWzBdLFxuICAgICAgbWdmOiBhcmd1bWVudHNbMV0sXG4gICAgICBzYWx0TGVuZ3RoOiBhcmd1bWVudHNbMl1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGhhc2ggPSBvcHRpb25zLm1kO1xuICB2YXIgbWdmID0gb3B0aW9ucy5tZ2Y7XG4gIHZhciBoTGVuID0gaGFzaC5kaWdlc3RMZW5ndGg7XG5cbiAgdmFyIHNhbHRfID0gb3B0aW9ucy5zYWx0IHx8IG51bGw7XG4gIGlmKHR5cGVvZiBzYWx0XyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBhc3N1bWUgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAgc2FsdF8gPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihzYWx0Xyk7XG4gIH1cblxuICB2YXIgc0xlbjtcbiAgaWYoJ3NhbHRMZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICBzTGVuID0gb3B0aW9ucy5zYWx0TGVuZ3RoO1xuICB9IGVsc2UgaWYoc2FsdF8gIT09IG51bGwpIHtcbiAgICBzTGVuID0gc2FsdF8ubGVuZ3RoKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTYWx0IGxlbmd0aCBub3Qgc3BlY2lmaWVkIG9yIHNwZWNpZmljIHNhbHQgbm90IGdpdmVuLicpO1xuICB9XG5cbiAgaWYoc2FsdF8gIT09IG51bGwgJiYgc2FsdF8ubGVuZ3RoKCkgIT09IHNMZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dpdmVuIHNhbHQgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGxlbmd0aCBvZiBnaXZlbiBzYWx0LicpO1xuICB9XG5cbiAgdmFyIHBybmcgPSBvcHRpb25zLnBybmcgfHwgZm9yZ2UucmFuZG9tO1xuXG4gIHZhciBwc3NvYmogPSB7fTtcblxuICAvKipcbiAgICogRW5jb2RlcyBhIFBTUyBzaWduYXR1cmUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyBFTVNBLVBTUy1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LCBzZWN0aW9uIDkuMS4xLlxuICAgKlxuICAgKiBAcGFyYW0gbWQgdGhlIG1lc3NhZ2UgZGlnZXN0IG9iamVjdCB3aXRoIHRoZSBoYXNoIHRvIHNpZ24uXG4gICAqIEBwYXJhbSBtb2RzQml0cyB0aGUgbGVuZ3RoIG9mIHRoZSBSU0EgbW9kdWx1cyBpbiBiaXRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgbGVuZ3RoXG4gICAqICAgICAgICAgICBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KS5cbiAgICovXG4gIHBzc29iai5lbmNvZGUgPSBmdW5jdGlvbihtZCwgbW9kQml0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBlbUJpdHMgPSBtb2RCaXRzIC0gMTtcbiAgICB2YXIgZW1MZW4gPSBNYXRoLmNlaWwoZW1CaXRzIC8gOCk7XG5cbiAgICAvKiAyLiBMZXQgbUhhc2ggPSBIYXNoKE0pLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgdmFyIG1IYXNoID0gbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDMuIElmIGVtTGVuIDwgaExlbiArIHNMZW4gKyAyLCBvdXRwdXQgXCJlbmNvZGluZyBlcnJvclwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaXMgdG9vIGxvbmcgdG8gZW5jcnlwdC4nKTtcbiAgICB9XG5cbiAgICAvKiA0LiBHZW5lcmF0ZSBhIHJhbmRvbSBvY3RldCBzdHJpbmcgc2FsdCBvZiBsZW5ndGggc0xlbjsgaWYgc0xlbiA9IDAsXG4gICAgICogICAgdGhlbiBzYWx0IGlzIHRoZSBlbXB0eSBzdHJpbmcuICovXG4gICAgdmFyIHNhbHQ7XG4gICAgaWYoc2FsdF8gPT09IG51bGwpIHtcbiAgICAgIHNhbHQgPSBwcm5nLmdldEJ5dGVzU3luYyhzTGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2FsdCA9IHNhbHRfLmJ5dGVzKCk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IE0nID0gKDB4KTAwIDAwIDAwIDAwIDAwIDAwIDAwIDAwIHx8IG1IYXNoIHx8IHNhbHQ7ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiA2LiBMZXQgSCA9IEhhc2goTScpLCBhbiBvY3RldCBzdHJpbmcgb2YgbGVuZ3RoIGhMZW4uICovXG4gICAgaGFzaC5zdGFydCgpO1xuICAgIGhhc2gudXBkYXRlKG1fLmdldEJ5dGVzKCkpO1xuICAgIHZhciBoID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogNy4gR2VuZXJhdGUgYW4gb2N0ZXQgc3RyaW5nIFBTIGNvbnNpc3Rpbmcgb2YgZW1MZW4gLSBzTGVuIC0gaExlbiAtIDJcbiAgICAgKiAgICB6ZXJvIG9jdGV0cy4gIFRoZSBsZW5ndGggb2YgUFMgbWF5IGJlIDAuICovXG4gICAgdmFyIHBzID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIHBzLmZpbGxXaXRoQnl0ZSgwLCBlbUxlbiAtIHNMZW4gLSBoTGVuIC0gMik7XG5cbiAgICAvKiA4LiBMZXQgREIgPSBQUyB8fCAweDAxIHx8IHNhbHQ7IERCIGlzIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGhcbiAgICAgKiAgICBlbUxlbiAtIGhMZW4gLSAxLiAqL1xuICAgIHBzLnB1dEJ5dGUoMHgwMSk7XG4gICAgcHMucHV0Qnl0ZXMoc2FsdCk7XG4gICAgdmFyIGRiID0gcHMuZ2V0Qnl0ZXMoKTtcblxuICAgIC8qIDkuIExldCBkYk1hc2sgPSBNR0YoSCwgZW1MZW4gLSBoTGVuIC0gMSkuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBkYk1hc2sgPSBtZ2YuZ2VuZXJhdGUoaCwgbWFza0xlbik7XG5cbiAgICAvKiAxMC4gTGV0IG1hc2tlZERCID0gREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBtYXNrZWREQiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgbWFza2VkREIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDExLiBTZXQgdGhlIGxlZnRtb3N0IDhlbUxlbiAtIGVtQml0cyBiaXRzIG9mIHRoZSBsZWZ0bW9zdCBvY3RldCBpblxuICAgICAqICAgICBtYXNrZWREQiB0byB6ZXJvLiAqL1xuICAgIHZhciBtYXNrID0gKDB4RkYwMCA+PiAoOCAqIGVtTGVuIC0gZW1CaXRzKSkgJiAweEZGO1xuICAgIG1hc2tlZERCID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KDApICYgfm1hc2spICtcbiAgICAgIG1hc2tlZERCLnN1YnN0cigxKTtcblxuICAgIC8qIDEyLiBMZXQgRU0gPSBtYXNrZWREQiB8fCBIIHx8IDB4YmMuXG4gICAgICogMTMuIE91dHB1dCBFTS4gKi9cbiAgICByZXR1cm4gbWFza2VkREIgKyBoICsgU3RyaW5nLmZyb21DaGFyQ29kZSgweGJjKTtcbiAgfTtcblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBQU1Mgc2lnbmF0dXJlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGltcGxlbWVudHMgRU1TQS1QU1MtVkVSSUZZIGFzIHBlciBSRkMgMzQ0Nywgc2VjdGlvbiA5LjEuMi5cbiAgICpcbiAgICogQHBhcmFtIG1IYXNoIHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoLCBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZywgdG9cbiAgICogICAgICAgICBjb21wYXJlIGFnYWluc3QgdGhlIHNpZ25hdHVyZS5cbiAgICogQHBhcmFtIGVtIHRoZSBlbmNvZGVkIG1lc3NhZ2UsIGFzIGEgYmluYXJ5LWVuY29kZWQgc3RyaW5nXG4gICAqICAgICAgICAgIChSU0EgZGVjcnlwdGlvbiByZXN1bHQpLlxuICAgKiBAcGFyYW0gbW9kc0JpdHMgdGhlIGxlbmd0aCBvZiB0aGUgUlNBIG1vZHVsdXMgaW4gYml0cy5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBwc3NvYmoudmVyaWZ5ID0gZnVuY3Rpb24obUhhc2gsIGVtLCBtb2RCaXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGVtQml0cyA9IG1vZEJpdHMgLSAxO1xuICAgIHZhciBlbUxlbiA9IE1hdGguY2VpbChlbUJpdHMgLyA4KTtcblxuICAgIC8qIGMuIENvbnZlcnQgdGhlIG1lc3NhZ2UgcmVwcmVzZW50YXRpdmUgbSB0byBhbiBlbmNvZGVkIG1lc3NhZ2UgRU1cbiAgICAgKiAgICBvZiBsZW5ndGggZW1MZW4gPSBjZWlsKChtb2RCaXRzIC0gMSkgLyA4KSBvY3RldHMsIHdoZXJlIG1vZEJpdHNcbiAgICAgKiAgICBpcyB0aGUgbGVuZ3RoIGluIGJpdHMgb2YgdGhlIFJTQSBtb2R1bHVzIG4gKi9cbiAgICBlbSA9IGVtLnN1YnN0cigtZW1MZW4pO1xuXG4gICAgLyogMy4gSWYgZW1MZW4gPCBoTGVuICsgc0xlbiArIDIsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtTGVuIDwgaExlbiArIHNMZW4gKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29uc2lzdGVudCBwYXJhbWV0ZXJzIHRvIFBTUyBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLicpO1xuICAgIH1cblxuICAgIC8qIDQuIElmIHRoZSByaWdodG1vc3Qgb2N0ZXQgb2YgRU0gZG9lcyBub3QgaGF2ZSBoZXhhZGVjaW1hbCB2YWx1ZVxuICAgICAqICAgIDB4YmMsIG91dHB1dCBcImluY29uc2lzdGVudFwiIGFuZCBzdG9wLiAqL1xuICAgIGlmKGVtLmNoYXJDb2RlQXQoZW1MZW4gLSAxKSAhPT0gMHhiYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGVkIG1lc3NhZ2UgZG9lcyBub3QgZW5kIGluIDB4QkMuJyk7XG4gICAgfVxuXG4gICAgLyogNS4gTGV0IG1hc2tlZERCIGJlIHRoZSBsZWZ0bW9zdCBlbUxlbiAtIGhMZW4gLSAxIG9jdGV0cyBvZiBFTSwgYW5kXG4gICAgICogICAgbGV0IEggYmUgdGhlIG5leHQgaExlbiBvY3RldHMuICovXG4gICAgdmFyIG1hc2tMZW4gPSBlbUxlbiAtIGhMZW4gLSAxO1xuICAgIHZhciBtYXNrZWREQiA9IGVtLnN1YnN0cigwLCBtYXNrTGVuKTtcbiAgICB2YXIgaCA9IGVtLnN1YnN0cihtYXNrTGVuLCBoTGVuKTtcblxuICAgIC8qIDYuIElmIHRoZSBsZWZ0bW9zdCA4ZW1MZW4gLSBlbUJpdHMgYml0cyBvZiB0aGUgbGVmdG1vc3Qgb2N0ZXQgaW5cbiAgICAgKiAgICBtYXNrZWREQiBhcmUgbm90IGFsbCBlcXVhbCB0byB6ZXJvLCBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgbWFzayA9ICgweEZGMDAgPj4gKDggKiBlbUxlbiAtIGVtQml0cykpICYgMHhGRjtcbiAgICBpZigobWFza2VkREIuY2hhckNvZGVBdCgwKSAmIG1hc2spICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdHMgYmV5b25kIGtleXNpemUgbm90IHplcm8gYXMgZXhwZWN0ZWQuJyk7XG4gICAgfVxuXG4gICAgLyogNy4gTGV0IGRiTWFzayA9IE1HRihILCBlbUxlbiAtIGhMZW4gLSAxKS4gKi9cbiAgICB2YXIgZGJNYXNrID0gbWdmLmdlbmVyYXRlKGgsIG1hc2tMZW4pO1xuXG4gICAgLyogOC4gTGV0IERCID0gbWFza2VkREIgXFx4b3IgZGJNYXNrLiAqL1xuICAgIHZhciBkYiA9ICcnO1xuICAgIGZvcihpID0gMDsgaSA8IG1hc2tMZW47IGkrKykge1xuICAgICAgZGIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXNrZWREQi5jaGFyQ29kZUF0KGkpIF4gZGJNYXNrLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cblxuICAgIC8qIDkuIFNldCB0aGUgbGVmdG1vc3QgOGVtTGVuIC0gZW1CaXRzIGJpdHMgb2YgdGhlIGxlZnRtb3N0IG9jdGV0XG4gICAgICogaW4gREIgdG8gemVyby4gKi9cbiAgICBkYiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGIuY2hhckNvZGVBdCgwKSAmIH5tYXNrKSArIGRiLnN1YnN0cigxKTtcblxuICAgIC8qIDEwLiBJZiB0aGUgZW1MZW4gLSBoTGVuIC0gc0xlbiAtIDIgbGVmdG1vc3Qgb2N0ZXRzIG9mIERCIGFyZSBub3QgemVyb1xuICAgICAqIG9yIGlmIHRoZSBvY3RldCBhdCBwb3NpdGlvbiBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMSAodGhlIGxlZnRtb3N0XG4gICAgICogcG9zaXRpb24gaXMgXCJwb3NpdGlvbiAxXCIpIGRvZXMgbm90IGhhdmUgaGV4YWRlY2ltYWwgdmFsdWUgMHgwMSxcbiAgICAgKiBvdXRwdXQgXCJpbmNvbnNpc3RlbnRcIiBhbmQgc3RvcC4gKi9cbiAgICB2YXIgY2hlY2tMZW4gPSBlbUxlbiAtIGhMZW4gLSBzTGVuIC0gMjtcbiAgICBmb3IoaSA9IDA7IGkgPCBjaGVja0xlbjsgaSsrKSB7XG4gICAgICBpZihkYi5jaGFyQ29kZUF0KGkpICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVmdG1vc3Qgb2N0ZXRzIG5vdCB6ZXJvIGFzIGV4cGVjdGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZGIuY2hhckNvZGVBdChjaGVja0xlbikgIT09IDB4MDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb25zaXN0ZW50IFBTUyBzaWduYXR1cmUsIDB4MDEgbWFya2VyIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIC8qIDExLiBMZXQgc2FsdCBiZSB0aGUgbGFzdCBzTGVuIG9jdGV0cyBvZiBEQi4gKi9cbiAgICB2YXIgc2FsdCA9IGRiLnN1YnN0cigtc0xlbik7XG5cbiAgICAvKiAxMi4gIExldCBNJyA9ICgweCkwMCAwMCAwMCAwMCAwMCAwMCAwMCAwMCB8fCBtSGFzaCB8fCBzYWx0ICovXG4gICAgdmFyIG1fID0gbmV3IGZvcmdlLnV0aWwuQnl0ZUJ1ZmZlcigpO1xuICAgIG1fLmZpbGxXaXRoQnl0ZSgwLCA4KTtcbiAgICBtXy5wdXRCeXRlcyhtSGFzaCk7XG4gICAgbV8ucHV0Qnl0ZXMoc2FsdCk7XG5cbiAgICAvKiAxMy4gTGV0IEgnID0gSGFzaChNJyksIGFuIG9jdGV0IHN0cmluZyBvZiBsZW5ndGggaExlbi4gKi9cbiAgICBoYXNoLnN0YXJ0KCk7XG4gICAgaGFzaC51cGRhdGUobV8uZ2V0Qnl0ZXMoKSk7XG4gICAgdmFyIGhfID0gaGFzaC5kaWdlc3QoKS5nZXRCeXRlcygpO1xuXG4gICAgLyogMTQuIElmIEggPSBIJywgb3V0cHV0IFwiY29uc2lzdGVudC5cIiBPdGhlcndpc2UsIG91dHB1dCBcImluY29uc2lzdGVudC5cIiAqL1xuICAgIHJldHVybiBoID09PSBoXztcbiAgfTtcblxuICByZXR1cm4gcHNzb2JqO1xufTtcbiIsIi8qKlxuICogQW4gQVBJIGZvciBnZXR0aW5nIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gYnl0ZXMuIFRoZSBieXRlcyBhcmVcbiAqIGdlbmVyYXRlZCB1c2luZyB0aGUgRm9ydHVuYSBhbGdvcml0aG0gZGV2aXNlZCBieSBCcnVjZSBTY2huZWllciBhbmRcbiAqIE5pZWxzIEZlcmd1c29uLlxuICpcbiAqIEdldHRpbmcgc3Ryb25nIHJhbmRvbSBieXRlcyBpcyBub3QgeWV0IGVhc3kgdG8gZG8gaW4gamF2YXNjcmlwdC4gVGhlIG9ubHlcbiAqIHRydWlzaCByYW5kb20gZW50cm9weSB0aGF0IGNhbiBiZSBjb2xsZWN0ZWQgaXMgZnJvbSB0aGUgbW91c2UsIGtleWJvYXJkLCBvclxuICogZnJvbSB0aW1pbmcgd2l0aCByZXNwZWN0IHRvIHBhZ2UgbG9hZHMsIGV0Yy4gVGhpcyBnZW5lcmF0b3IgbWFrZXMgYSBwb29yXG4gKiBhdHRlbXB0IGF0IHByb3ZpZGluZyByYW5kb20gYnl0ZXMgd2hlbiB0aG9zZSBzb3VyY2VzIGhhdmVuJ3QgeWV0IHByb3ZpZGVkXG4gKiBlbm91Z2ggZW50cm9weSB0byBpbml0aWFsbHkgc2VlZCBvciB0byByZXNlZWQgdGhlIFBSTkcuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9zaGEyNTYnKTtcbnJlcXVpcmUoJy4vcHJuZycpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbihmdW5jdGlvbigpIHtcblxuLy8gZm9yZ2UucmFuZG9tIGFscmVhZHkgZGVmaW5lZFxuaWYoZm9yZ2UucmFuZG9tICYmIGZvcmdlLnJhbmRvbS5nZXRCeXRlcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJhbmRvbTtcbiAgcmV0dXJuO1xufVxuXG4oZnVuY3Rpb24oalF1ZXJ5KSB7XG5cbi8vIHRoZSBkZWZhdWx0IHBybmcgcGx1Z2luLCB1c2VzIEFFUy0xMjhcbnZhciBwcm5nX2FlcyA9IHt9O1xudmFyIF9wcm5nX2Flc19vdXRwdXQgPSBuZXcgQXJyYXkoNCk7XG52YXIgX3BybmdfYWVzX2J1ZmZlciA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5wcm5nX2Flcy5mb3JtYXRLZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgLy8gY29udmVydCB0aGUga2V5IGludG8gMzItYml0IGludGVnZXJzXG4gIHZhciB0bXAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihrZXkpO1xuICBrZXkgPSBuZXcgQXJyYXkoNCk7XG4gIGtleVswXSA9IHRtcC5nZXRJbnQzMigpO1xuICBrZXlbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAga2V5WzJdID0gdG1wLmdldEludDMyKCk7XG4gIGtleVszXSA9IHRtcC5nZXRJbnQzMigpO1xuXG4gIC8vIHJldHVybiB0aGUgZXhwYW5kZWQga2V5XG4gIHJldHVybiBmb3JnZS5hZXMuX2V4cGFuZEtleShrZXksIGZhbHNlKTtcbn07XG5wcm5nX2Flcy5mb3JtYXRTZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICAvLyBjb252ZXJ0IHNlZWQgaW50byAzMi1iaXQgaW50ZWdlcnNcbiAgdmFyIHRtcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKHNlZWQpO1xuICBzZWVkID0gbmV3IEFycmF5KDQpO1xuICBzZWVkWzBdID0gdG1wLmdldEludDMyKCk7XG4gIHNlZWRbMV0gPSB0bXAuZ2V0SW50MzIoKTtcbiAgc2VlZFsyXSA9IHRtcC5nZXRJbnQzMigpO1xuICBzZWVkWzNdID0gdG1wLmdldEludDMyKCk7XG4gIHJldHVybiBzZWVkO1xufTtcbnBybmdfYWVzLmNpcGhlciA9IGZ1bmN0aW9uKGtleSwgc2VlZCkge1xuICBmb3JnZS5hZXMuX3VwZGF0ZUJsb2NrKGtleSwgc2VlZCwgX3BybmdfYWVzX291dHB1dCwgZmFsc2UpO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMF0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMV0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbMl0pO1xuICBfcHJuZ19hZXNfYnVmZmVyLnB1dEludDMyKF9wcm5nX2Flc19vdXRwdXRbM10pO1xuICByZXR1cm4gX3BybmdfYWVzX2J1ZmZlci5nZXRCeXRlcygpO1xufTtcbnBybmdfYWVzLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgLy8gRklYTUU6IGRvIHdlIGNhcmUgYWJvdXQgY2Fycnkgb3Igc2lnbmVkIGlzc3Vlcz9cbiAgKytzZWVkWzNdO1xuICByZXR1cm4gc2VlZDtcbn07XG5wcm5nX2Flcy5tZCA9IGZvcmdlLm1kLnNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBSTkcuXG4gKi9cbmZ1bmN0aW9uIHNwYXduUHJuZygpIHtcbiAgdmFyIGN0eCA9IGZvcmdlLnBybmcuY3JlYXRlKHBybmdfYWVzKTtcblxuICAvKipcbiAgICogR2V0cyByYW5kb20gYnl0ZXMuIElmIGEgbmF0aXZlIHNlY3VyZSBjcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlLCB0aGlzXG4gICAqIG1ldGhvZCB0cmllcyB0byBtYWtlIHRoZSBieXRlcyBtb3JlIHVucHJlZGljdGFibGUgYnkgZHJhd2luZyBmcm9tIGRhdGEgdGhhdFxuICAgKiBjYW4gYmUgY29sbGVjdGVkIGZyb20gdGhlIHVzZXIgb2YgdGhlIGJyb3dzZXIsIGVnOiBtb3VzZSBtb3ZlbWVudC5cbiAgICpcbiAgICogSWYgYSBjYWxsYmFjayBpcyBnaXZlbiwgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZXQuXG4gICAqIEBwYXJhbSBbY2FsbGJhY2soZXJyLCBieXRlcyldIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByYW5kb20gYnl0ZXMgaW4gYSBzdHJpbmcuXG4gICAqL1xuICBjdHguZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY3R4LmdlbmVyYXRlKGNvdW50LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgcmFuZG9tIGJ5dGVzIGFzeW5jaHJvbm91c2x5LiBJZiBhIG5hdGl2ZSBzZWN1cmUgY3J5cHRvIEFQSSBpc1xuICAgKiB1bmF2YWlsYWJsZSwgdGhpcyBtZXRob2QgdHJpZXMgdG8gbWFrZSB0aGUgYnl0ZXMgbW9yZSB1bnByZWRpY3RhYmxlIGJ5XG4gICAqIGRyYXdpbmcgZnJvbSBkYXRhIHRoYXQgY2FuIGJlIGNvbGxlY3RlZCBmcm9tIHRoZSB1c2VyIG9mIHRoZSBicm93c2VyLFxuICAgKiBlZzogbW91c2UgbW92ZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZXQuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJhbmRvbSBieXRlcyBpbiBhIHN0cmluZy5cbiAgICovXG4gIGN0eC5nZXRCeXRlc1N5bmMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHJldHVybiBjdHguZ2VuZXJhdGUoY291bnQpO1xuICB9O1xuXG4gIHJldHVybiBjdHg7XG59XG5cbi8vIGNyZWF0ZSBkZWZhdWx0IHBybmcgY29udGV4dFxudmFyIF9jdHggPSBzcGF3blBybmcoKTtcblxuLy8gYWRkIG90aGVyIHNvdXJjZXMgb2YgZW50cm9weSBvbmx5IGlmIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIGlzIG5vdFxuLy8gYXZhaWxhYmxlIC0tIG90aGVyd2lzZSB0aGlzIHNvdXJjZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXNlZCBieSB0aGUgcHJuZ1xudmFyIGdldFJhbmRvbVZhbHVlcyA9IG51bGw7XG52YXIgZ2xvYmFsU2NvcGUgPSBmb3JnZS51dGlsLmdsb2JhbFNjb3BlO1xudmFyIF9jcnlwdG8gPSBnbG9iYWxTY29wZS5jcnlwdG8gfHwgZ2xvYmFsU2NvcGUubXNDcnlwdG87XG5pZihfY3J5cHRvICYmIF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIGdldFJhbmRvbVZhbHVlcyA9IGZ1bmN0aW9uKGFycikge1xuICAgIHJldHVybiBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICB9O1xufVxuXG5pZihmb3JnZS5vcHRpb25zLnVzZVB1cmVKYXZhU2NyaXB0IHx8XG4gICghZm9yZ2UudXRpbC5pc05vZGVqcyAmJiAhZ2V0UmFuZG9tVmFsdWVzKSkge1xuICAvLyBpZiB0aGlzIGlzIGEgd2ViIHdvcmtlciwgZG8gbm90IHVzZSB3ZWFrIGVudHJvcHksIGluc3RlYWQgcmVnaXN0ZXIgdG9cbiAgLy8gcmVjZWl2ZSBzdHJvbmcgZW50cm9weSBhc3luY2hyb25vdXNseSBmcm9tIHRoZSBtYWluIHRocmVhZFxuICBpZih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cuZG9jdW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEZJWE1FOlxuICB9XG5cbiAgLy8gZ2V0IGxvYWQgdGltZSBlbnRyb3B5XG4gIF9jdHguY29sbGVjdEludCgrbmV3IERhdGUoKSwgMzIpO1xuXG4gIC8vIGFkZCBzb21lIGVudHJvcHkgZnJvbSBuYXZpZ2F0b3Igb2JqZWN0XG4gIGlmKHR5cGVvZihuYXZpZ2F0b3IpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBfbmF2Qnl0ZXMgPSAnJztcbiAgICBmb3IodmFyIGtleSBpbiBuYXZpZ2F0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKHR5cGVvZihuYXZpZ2F0b3Jba2V5XSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBfbmF2Qnl0ZXMgKz0gbmF2aWdhdG9yW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvKiBTb21lIG5hdmlnYXRvciBrZXlzIG1pZ2h0IG5vdCBiZSBhY2Nlc3NpYmxlLCBlLmcuIHRoZSBnZW9sb2NhdGlvblxuICAgICAgICAgIGF0dHJpYnV0ZSB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRvdWNoZWQgaW4gTW96aWxsYSBjaHJvbWU6Ly9cbiAgICAgICAgICBjb250ZXh0LlxuXG4gICAgICAgICAgU2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIGp1c3QgZG9uJ3QgdXNlIHRoaXMgYXMgYSBzb3VyY2Ugb2ZcbiAgICAgICAgICBlbnRyb3B5LiAqL1xuICAgICAgfVxuICAgIH1cbiAgICBfY3R4LmNvbGxlY3QoX25hdkJ5dGVzKTtcbiAgICBfbmF2Qnl0ZXMgPSBudWxsO1xuICB9XG5cbiAgLy8gYWRkIG1vdXNlIGFuZCBrZXlib2FyZCBjb2xsZWN0b3JzIGlmIGpxdWVyeSBpcyBhdmFpbGFibGVcbiAgaWYoalF1ZXJ5KSB7XG4gICAgLy8gc2V0IHVwIG1vdXNlIGVudHJvcHkgY2FwdHVyZVxuICAgIGpRdWVyeSgpLm1vdXNlbW92ZShmdW5jdGlvbihlKSB7XG4gICAgICAvLyBhZGQgbW91c2UgY29vcmRzXG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jbGllbnRYLCAxNik7XG4gICAgICBfY3R4LmNvbGxlY3RJbnQoZS5jbGllbnRZLCAxNik7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdXAga2V5Ym9hcmQgZW50cm9weSBjYXB0dXJlXG4gICAgalF1ZXJ5KCkua2V5cHJlc3MoZnVuY3Rpb24oZSkge1xuICAgICAgX2N0eC5jb2xsZWN0SW50KGUuY2hhckNvZGUsIDgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qIFJhbmRvbSBBUEkgKi9cbmlmKCFmb3JnZS5yYW5kb20pIHtcbiAgZm9yZ2UucmFuZG9tID0gX2N0eDtcbn0gZWxzZSB7XG4gIC8vIGV4dGVuZCBmb3JnZS5yYW5kb20gd2l0aCBfY3R4XG4gIGZvcih2YXIga2V5IGluIF9jdHgpIHtcbiAgICBmb3JnZS5yYW5kb21ba2V5XSA9IF9jdHhba2V5XTtcbiAgfVxufVxuXG4vLyBleHBvc2Ugc3Bhd24gUFJOR1xuZm9yZ2UucmFuZG9tLmNyZWF0ZUluc3RhbmNlID0gc3Bhd25Qcm5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJhbmRvbTtcblxufSkodHlwZW9mKGpRdWVyeSkgIT09ICd1bmRlZmluZWQnID8galF1ZXJ5IDogbnVsbCk7XG5cbn0pKCk7XG4iLCIvKipcbiAqIFJDMiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAYXV0aG9yIFN0ZWZhbiBTaWVnbFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBTdGVmYW4gU2llZ2wgPHN0ZXNpZUBicm9rZW5waXBlLmRlPlxuICpcbiAqIEluZm9ybWF0aW9uIG9uIHRoZSBSQzIgY2lwaGVyIGlzIGF2YWlsYWJsZSBmcm9tIFJGQyAjMjI2OCxcbiAqIGh0dHA6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNjgudHh0XG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgcGlUYWJsZSA9IFtcbiAgMHhkOSwgMHg3OCwgMHhmOSwgMHhjNCwgMHgxOSwgMHhkZCwgMHhiNSwgMHhlZCwgMHgyOCwgMHhlOSwgMHhmZCwgMHg3OSwgMHg0YSwgMHhhMCwgMHhkOCwgMHg5ZCxcbiAgMHhjNiwgMHg3ZSwgMHgzNywgMHg4MywgMHgyYiwgMHg3NiwgMHg1MywgMHg4ZSwgMHg2MiwgMHg0YywgMHg2NCwgMHg4OCwgMHg0NCwgMHg4YiwgMHhmYiwgMHhhMixcbiAgMHgxNywgMHg5YSwgMHg1OSwgMHhmNSwgMHg4NywgMHhiMywgMHg0ZiwgMHgxMywgMHg2MSwgMHg0NSwgMHg2ZCwgMHg4ZCwgMHgwOSwgMHg4MSwgMHg3ZCwgMHgzMixcbiAgMHhiZCwgMHg4ZiwgMHg0MCwgMHhlYiwgMHg4NiwgMHhiNywgMHg3YiwgMHgwYiwgMHhmMCwgMHg5NSwgMHgyMSwgMHgyMiwgMHg1YywgMHg2YiwgMHg0ZSwgMHg4MixcbiAgMHg1NCwgMHhkNiwgMHg2NSwgMHg5MywgMHhjZSwgMHg2MCwgMHhiMiwgMHgxYywgMHg3MywgMHg1NiwgMHhjMCwgMHgxNCwgMHhhNywgMHg4YywgMHhmMSwgMHhkYyxcbiAgMHgxMiwgMHg3NSwgMHhjYSwgMHgxZiwgMHgzYiwgMHhiZSwgMHhlNCwgMHhkMSwgMHg0MiwgMHgzZCwgMHhkNCwgMHgzMCwgMHhhMywgMHgzYywgMHhiNiwgMHgyNixcbiAgMHg2ZiwgMHhiZiwgMHgwZSwgMHhkYSwgMHg0NiwgMHg2OSwgMHgwNywgMHg1NywgMHgyNywgMHhmMiwgMHgxZCwgMHg5YiwgMHhiYywgMHg5NCwgMHg0MywgMHgwMyxcbiAgMHhmOCwgMHgxMSwgMHhjNywgMHhmNiwgMHg5MCwgMHhlZiwgMHgzZSwgMHhlNywgMHgwNiwgMHhjMywgMHhkNSwgMHgyZiwgMHhjOCwgMHg2NiwgMHgxZSwgMHhkNyxcbiAgMHgwOCwgMHhlOCwgMHhlYSwgMHhkZSwgMHg4MCwgMHg1MiwgMHhlZSwgMHhmNywgMHg4NCwgMHhhYSwgMHg3MiwgMHhhYywgMHgzNSwgMHg0ZCwgMHg2YSwgMHgyYSxcbiAgMHg5NiwgMHgxYSwgMHhkMiwgMHg3MSwgMHg1YSwgMHgxNSwgMHg0OSwgMHg3NCwgMHg0YiwgMHg5ZiwgMHhkMCwgMHg1ZSwgMHgwNCwgMHgxOCwgMHhhNCwgMHhlYyxcbiAgMHhjMiwgMHhlMCwgMHg0MSwgMHg2ZSwgMHgwZiwgMHg1MSwgMHhjYiwgMHhjYywgMHgyNCwgMHg5MSwgMHhhZiwgMHg1MCwgMHhhMSwgMHhmNCwgMHg3MCwgMHgzOSxcbiAgMHg5OSwgMHg3YywgMHgzYSwgMHg4NSwgMHgyMywgMHhiOCwgMHhiNCwgMHg3YSwgMHhmYywgMHgwMiwgMHgzNiwgMHg1YiwgMHgyNSwgMHg1NSwgMHg5NywgMHgzMSxcbiAgMHgyZCwgMHg1ZCwgMHhmYSwgMHg5OCwgMHhlMywgMHg4YSwgMHg5MiwgMHhhZSwgMHgwNSwgMHhkZiwgMHgyOSwgMHgxMCwgMHg2NywgMHg2YywgMHhiYSwgMHhjOSxcbiAgMHhkMywgMHgwMCwgMHhlNiwgMHhjZiwgMHhlMSwgMHg5ZSwgMHhhOCwgMHgyYywgMHg2MywgMHgxNiwgMHgwMSwgMHgzZiwgMHg1OCwgMHhlMiwgMHg4OSwgMHhhOSxcbiAgMHgwZCwgMHgzOCwgMHgzNCwgMHgxYiwgMHhhYiwgMHgzMywgMHhmZiwgMHhiMCwgMHhiYiwgMHg0OCwgMHgwYywgMHg1ZiwgMHhiOSwgMHhiMSwgMHhjZCwgMHgyZSxcbiAgMHhjNSwgMHhmMywgMHhkYiwgMHg0NywgMHhlNSwgMHhhNSwgMHg5YywgMHg3NywgMHgwYSwgMHhhNiwgMHgyMCwgMHg2OCwgMHhmZSwgMHg3ZiwgMHhjMSwgMHhhZFxuXTtcblxudmFyIHMgPSBbMSwgMiwgMywgNV07XG5cbi8qKlxuICogUm90YXRlIGEgd29yZCBsZWZ0IGJ5IGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIEJpdHMgdGhhdCBhcmUgc2hpZnRlZCBvdXQgb24gdGhlIGxlZnQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSByaWdodFxuICogaGFuZCBzaWRlLlxuICpcbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIHRvIHNoaWZ0IGxlZnQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb2wgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgPDwgYml0cykgJiAweGZmZmYpIHwgKCh3b3JkICYgMHhmZmZmKSA+PiAoMTYgLSBiaXRzKSk7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIHdvcmQgcmlnaHQgYnkgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKlxuICogQml0cyB0aGF0IGFyZSBzaGlmdGVkIG91dCBvbiB0aGUgcmlnaHQgYXJlIHB1dCBiYWNrIGluIG9uIHRoZSBsZWZ0XG4gKiBoYW5kIHNpZGUuXG4gKlxuICogQHBhcmFtIHdvcmQgVGhlIHdvcmQgdG8gc2hpZnQgcmlnaHQuXG4gKiBAcGFyYW0gYml0cyBUaGUgbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnQgYnkuXG4gKiBAcmV0dXJuIFRoZSByb3RhdGVkIHdvcmQuXG4gKi9cbnZhciByb3IgPSBmdW5jdGlvbih3b3JkLCBiaXRzKSB7XG4gIHJldHVybiAoKHdvcmQgJiAweGZmZmYpID4+IGJpdHMpIHwgKCh3b3JkIDw8ICgxNiAtIGJpdHMpKSAmIDB4ZmZmZik7XG59O1xuXG4vKiBSQzIgQVBJICovXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnJjMiA9IGZvcmdlLnJjMiB8fCB7fTtcblxuLyoqXG4gKiBQZXJmb3JtIFJDMiBrZXkgZXhwYW5zaW9uIGFzIHBlciBSRkMgIzIyNjgsIHNlY3Rpb24gMi5cbiAqXG4gKiBAcGFyYW0ga2V5IHZhcmlhYmxlLWxlbmd0aCB1c2VyIGtleSAoYmV0d2VlbiAxIGFuZCAxMjggYnl0ZXMpXG4gKiBAcGFyYW0gZWZmS2V5Qml0cyBudW1iZXIgb2YgZWZmZWN0aXZlIGtleSBiaXRzIChkZWZhdWx0OiAxMjgpXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCBSQzIga2V5IChCeXRlQnVmZmVyIG9mIDEyOCBieXRlcylcbiAqL1xuZm9yZ2UucmMyLmV4cGFuZEtleSA9IGZ1bmN0aW9uKGtleSwgZWZmS2V5Qml0cykge1xuICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGtleSk7XG4gIH1cbiAgZWZmS2V5Qml0cyA9IGVmZktleUJpdHMgfHwgMTI4O1xuXG4gIC8qIGludHJvZHVjZSB2YXJpYWJsZXMgdGhhdCBtYXRjaCB0aGUgbmFtZXMgdXNlZCBpbiBSRkMgIzIyNjggKi9cbiAgdmFyIEwgPSBrZXk7XG4gIHZhciBUID0ga2V5Lmxlbmd0aCgpO1xuICB2YXIgVDEgPSBlZmZLZXlCaXRzO1xuICB2YXIgVDggPSBNYXRoLmNlaWwoVDEgLyA4KTtcbiAgdmFyIFRNID0gMHhmZiA+PiAoVDEgJiAweDA3KTtcbiAgdmFyIGk7XG5cbiAgZm9yKGkgPSBUOyBpIDwgMTI4OyBpKyspIHtcbiAgICBMLnB1dEJ5dGUocGlUYWJsZVsoTC5hdChpIC0gMSkgKyBMLmF0KGkgLSBUKSkgJiAweGZmXSk7XG4gIH1cblxuICBMLnNldEF0KDEyOCAtIFQ4LCBwaVRhYmxlW0wuYXQoMTI4IC0gVDgpICYgVE1dKTtcblxuICBmb3IoaSA9IDEyNyAtIFQ4OyBpID49IDA7IGktLSkge1xuICAgIEwuc2V0QXQoaSwgcGlUYWJsZVtMLmF0KGkgKyAxKSBeIEwuYXQoaSArIFQ4KV0pO1xuICB9XG5cbiAgcmV0dXJuIEw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBSQzIgY2lwaGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZSAoYXMgYmFzZSBmb3Iga2V5IGdlbmVyYXRpb24pLlxuICogQHBhcmFtIGJpdHMgdGhlIG51bWJlciBvZiBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKiBAcGFyYW0gZW5jcnlwdCBmYWxzZSBmb3IgZGVjcnlwdGlvbiwgdHJ1ZSBmb3IgZW5jcnlwdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbnZhciBjcmVhdGVDaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMsIGVuY3J5cHQpIHtcbiAgdmFyIF9maW5pc2ggPSBmYWxzZSwgX2lucHV0ID0gbnVsbCwgX291dHB1dCA9IG51bGwsIF9pdiA9IG51bGw7XG4gIHZhciBtaXhSb3VuZCwgbWFzaFJvdW5kO1xuICB2YXIgaSwgaiwgSyA9IFtdO1xuXG4gIC8qIEV4cGFuZCBrZXkgYW5kIGZpbGwgaW50byBLW10gQXJyYXkgKi9cbiAga2V5ID0gZm9yZ2UucmMyLmV4cGFuZEtleShrZXksIGJpdHMpO1xuICBmb3IoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgSy5wdXNoKGtleS5nZXRJbnQxNkxlKCkpO1xuICB9XG5cbiAgaWYoZW5jcnlwdCkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1peGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWl4aW5nIG9uLlxuICAgICAqL1xuICAgIG1peFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBSW2ldID0gcm9sKFJbaV0sIHNbaV0pO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIG1hc2hpbmcgcm91bmQgXCJpbiBwbGFjZVwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIFIgQXJyYXkgb2YgZm91ciB3b3JkcyB0byBwZXJmb3JtIG1hc2hpbmcgb24uXG4gICAgICovXG4gICAgbWFzaFJvdW5kID0gZnVuY3Rpb24oUikge1xuICAgICAgZm9yKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIFJbaV0gKz0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWl4aW5nIHJvdW5kIFwiaW4gcGxhY2VcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBSIEFycmF5IG9mIGZvdXIgd29yZHMgdG8gcGVyZm9ybSBtaXhpbmcgb24uXG4gICAgICovXG4gICAgbWl4Um91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gPSByb3IoUltpXSwgc1tpXSk7XG4gICAgICAgIFJbaV0gLT0gS1tqXSArIChSWyhpICsgMykgJSA0XSAmIFJbKGkgKyAyKSAlIDRdKSArXG4gICAgICAgICAgKCh+UlsoaSArIDMpICUgNF0pICYgUlsoaSArIDEpICUgNF0pO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gb25lIHItbWFzaGluZyByb3VuZCBcImluIHBsYWNlXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUiBBcnJheSBvZiBmb3VyIHdvcmRzIHRvIHBlcmZvcm0gbWFzaGluZyBvbi5cbiAgICAgKi9cbiAgICBtYXNoUm91bmQgPSBmdW5jdGlvbihSKSB7XG4gICAgICBmb3IoaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIFJbaV0gLT0gS1tSWyhpICsgMykgJSA0XSAmIDYzXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgc3BlY2lmaWVkIGNpcGhlciBleGVjdXRpb24gcGxhbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBmb3VyIHdvcmRzIGZyb20gdGhlIGlucHV0IGJ1ZmZlciwgYXBwbGllcyB0aGUgSVYgb25cbiAgICogaXQgKGlmIHJlcXVlc3RlZCkgYW5kIHJ1bnMgdGhlIHByb3ZpZGVkIGV4ZWN1dGlvbiBwbGFuLlxuICAgKlxuICAgKiBUaGUgcGxhbiBtdXN0IGJlIHB1dCB0b2dldGhlciBpbiBmb3JtIG9mIGEgYXJyYXkgb2YgYXJyYXlzLiAgV2hlcmUgdGhlXG4gICAqIG91dGVyIG9uZSBpcyBzaW1wbHkgYSBsaXN0IG9mIHN0ZXBzIHRvIHBlcmZvcm0gYW5kIHRoZSBpbm5lciBvbmUgbmVlZHNcbiAgICogdG8gaGF2ZSB0d28gZWxlbWVudHM6IHRoZSBmaXJzdCBvbmUgdGVsbGluZyBob3cgbWFueSByb3VuZHMgdG8gcGVyZm9ybSxcbiAgICogdGhlIHNlY29uZCBvbmUgdGVsbGluZyB3aGF0IHRvIGRvIChpLmUuIHRoZSBmdW5jdGlvbiB0byBjYWxsKS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcGxhbiBUaGUgcGxhbiB0byBleGVjdXRlLlxuICAgKi9cbiAgdmFyIHJ1blBsYW4gPSBmdW5jdGlvbihwbGFuKSB7XG4gICAgdmFyIFIgPSBbXTtcblxuICAgIC8qIEdldCBkYXRhIGZyb20gaW5wdXQgYnVmZmVyIGFuZCBmaWxsIHRoZSBmb3VyIHdvcmRzIGludG8gUiAqL1xuICAgIGZvcihpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IF9pbnB1dC5nZXRJbnQxNkxlKCk7XG5cbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZywgYXBwbHkgdGhlIElWIGZpcnN0LiAqL1xuICAgICAgICAgIHZhbCBePSBfaXYuZ2V0SW50MTZMZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFdlJ3JlIGRlY3J5cHRpb24sIGtlZXAgY2lwaGVyIHRleHQgZm9yIG5leHQgYmxvY2suICovXG4gICAgICAgICAgX2l2LnB1dEludDE2TGUodmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSLnB1c2godmFsICYgMHhmZmZmKTtcbiAgICB9XG5cbiAgICAvKiBSZXNldCBnbG9iYWwgXCJqXCIgdmFyaWFibGUgYXMgcGVyIHNwZWMuICovXG4gICAgaiA9IGVuY3J5cHQgPyAwIDogNjM7XG5cbiAgICAvKiBSdW4gZXhlY3V0aW9uIHBsYW4uICovXG4gICAgZm9yKHZhciBwdHIgPSAwOyBwdHIgPCBwbGFuLmxlbmd0aDsgcHRyKyspIHtcbiAgICAgIGZvcih2YXIgY3RyID0gMDsgY3RyIDwgcGxhbltwdHJdWzBdOyBjdHIrKykge1xuICAgICAgICBwbGFuW3B0cl1bMV0oUik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogV3JpdGUgYmFjayByZXN1bHQgdG8gb3V0cHV0IGJ1ZmZlci4gKi9cbiAgICBmb3IoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGlmKF9pdiAhPT0gbnVsbCkge1xuICAgICAgICBpZihlbmNyeXB0KSB7XG4gICAgICAgICAgLyogV2UncmUgZW5jcnlwdGluZyBpbiBDQkMtbW9kZSwgZmVlZCBiYWNrIGVuY3J5cHRlZCBieXRlcyBpbnRvXG4gICAgICAgICAgICAgSVYgYnVmZmVyIHRvIGNhcnJ5IGl0IGZvcndhcmQgdG8gbmV4dCBibG9jay4gKi9cbiAgICAgICAgICBfaXYucHV0SW50MTZMZShSW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSW2ldIF49IF9pdi5nZXRJbnQxNkxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX291dHB1dC5wdXRJbnQxNkxlKFJbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKiBDcmVhdGUgY2lwaGVyIG9iamVjdCAqL1xuICB2YXIgY2lwaGVyID0gbnVsbDtcbiAgY2lwaGVyID0ge1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBvciByZXN0YXJ0cyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MsIHdoaWNoZXZlclxuICAgICAqIHdhcyBwcmV2aW91c2x5IGNvbmZpZ3VyZWQuXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIGNpcGhlciBpbiBDQkMgbW9kZSwgaXYgbWF5IGJlIGdpdmVuIGVpdGhlciBhcyBhIHN0cmluZ1xuICAgICAqIG9mIGJ5dGVzLCBvciBhcyBhIGJ5dGUgYnVmZmVyLiAgRm9yIEVDQiBtb2RlLCBnaXZlIG51bGwgYXMgaXYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UsIG51bGwgZm9yIEVDQiBtb2RlLlxuICAgICAqIEBwYXJhbSBvdXRwdXQgdGhlIG91dHB1dCB0aGUgYnVmZmVyIHRvIHdyaXRlIHRvLCBudWxsIHRvIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKGl2LCBvdXRwdXQpIHtcbiAgICAgIGlmKGl2KSB7XG4gICAgICAgIC8qIENCQyBtb2RlICovXG4gICAgICAgIGlmKHR5cGVvZiBpdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpdiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGl2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZmluaXNoID0gZmFsc2U7XG4gICAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgX291dHB1dCA9IG91dHB1dCB8fCBuZXcgZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIF9pdiA9IGl2O1xuXG4gICAgICBjaXBoZXIub3V0cHV0ID0gX291dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbmV4dCBibG9jay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighX2ZpbmlzaCkge1xuICAgICAgICAvLyBub3QgZmluaXNoaW5nLCBzbyBmaWxsIHRoZSBpbnB1dCBidWZmZXIgd2l0aCBtb3JlIGlucHV0XG4gICAgICAgIF9pbnB1dC5wdXRCdWZmZXIoaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZShfaW5wdXQubGVuZ3RoKCkgPj0gOCkge1xuICAgICAgICBydW5QbGFuKFtcbiAgICAgICAgICAgIFsgNSwgbWl4Um91bmQgXSxcbiAgICAgICAgICAgIFsgMSwgbWFzaFJvdW5kIF0sXG4gICAgICAgICAgICBbIDYsIG1peFJvdW5kIF0sXG4gICAgICAgICAgICBbIDEsIG1hc2hSb3VuZCBdLFxuICAgICAgICAgICAgWyA1LCBtaXhSb3VuZCBdXG4gICAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaGVzIGVuY3J5cHRpbmcgb3IgZGVjcnlwdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWQgYSBwYWRkaW5nIGZ1bmN0aW9uIHRvIHVzZSwgbnVsbCBmb3IgUEtDUyM3IHBhZGRpbmcsXG4gICAgICogICAgICAgICAgIHNpZ25hdHVyZShibG9ja1NpemUsIGJ1ZmZlciwgZGVjcnlwdCkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb24gZXJyb3IuXG4gICAgICovXG4gICAgZmluaXNoOiBmdW5jdGlvbihwYWQpIHtcbiAgICAgIHZhciBydmFsID0gdHJ1ZTtcblxuICAgICAgaWYoZW5jcnlwdCkge1xuICAgICAgICBpZihwYWQpIHtcbiAgICAgICAgICBydmFsID0gcGFkKDgsIF9pbnB1dCwgIWVuY3J5cHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFkZCBQS0NTIzcgcGFkZGluZyB0byBibG9jayAoZWFjaCBwYWQgYnl0ZSBpcyB0aGVcbiAgICAgICAgICAvLyB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHBhZCBieXRlcylcbiAgICAgICAgICB2YXIgcGFkZGluZyA9IChfaW5wdXQubGVuZ3RoKCkgPT09IDgpID8gOCA6ICg4IC0gX2lucHV0Lmxlbmd0aCgpKTtcbiAgICAgICAgICBfaW5wdXQuZmlsbFdpdGhCeXRlKHBhZGRpbmcsIHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHJ2YWwpIHtcbiAgICAgICAgLy8gZG8gZmluYWwgdXBkYXRlXG4gICAgICAgIF9maW5pc2ggPSB0cnVlO1xuICAgICAgICBjaXBoZXIudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCFlbmNyeXB0KSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBlcnJvcjogaW5wdXQgZGF0YSBub3QgYSBtdWx0aXBsZSBvZiBibG9jayBzaXplXG4gICAgICAgIHJ2YWwgPSAoX2lucHV0Lmxlbmd0aCgpID09PSAwKTtcbiAgICAgICAgaWYocnZhbCkge1xuICAgICAgICAgIGlmKHBhZCkge1xuICAgICAgICAgICAgcnZhbCA9IHBhZCg4LCBfb3V0cHV0LCAhZW5jcnlwdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBwYWRkaW5nIGJ5dGUgY291bnQgaXMgdmFsaWRcbiAgICAgICAgICAgIHZhciBsZW4gPSBfb3V0cHV0Lmxlbmd0aCgpO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gX291dHB1dC5hdChsZW4gLSAxKTtcblxuICAgICAgICAgICAgaWYoY291bnQgPiBsZW4pIHtcbiAgICAgICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdHJpbSBvZmYgcGFkZGluZyBieXRlc1xuICAgICAgICAgICAgICBfb3V0cHV0LnRydW5jYXRlKGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZW5jcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuIFRoZSBvdXRwdXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlICdvdXRwdXQnIG1lbWJlclxuICogb2YgdGhlIHJldHVybmVkIGNpcGhlci5cbiAqXG4gKiBUaGUga2V5IGFuZCBpdiBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqIFRoZSBjaXBoZXIgaXMgaW5pdGlhbGl6ZWQgdG8gdXNlIDEyOCBlZmZlY3RpdmUga2V5IGJpdHMuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgc3ltbWV0cmljIGtleSB0byB1c2UuXG4gKiBAcGFyYW0gaXYgdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB0byB1c2UuXG4gKiBAcGFyYW0gb3V0cHV0IHRoZSBidWZmZXIgdG8gd3JpdGUgdG8sIG51bGwgdG8gY3JlYXRlIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5zdGFydEVuY3J5cHRpbmcgPSBmdW5jdGlvbihrZXksIGl2LCBvdXRwdXQpIHtcbiAgdmFyIGNpcGhlciA9IGZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyKGtleSwgMTI4KTtcbiAgY2lwaGVyLnN0YXJ0KGl2LCBvdXRwdXQpO1xuICByZXR1cm4gY2lwaGVyO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIFJDMiBjaXBoZXIgb2JqZWN0IHRvIGVuY3J5cHQgZGF0YSBpbiBFQ0Igb3IgQ0JDIG1vZGUgdXNpbmcgdGhlXG4gKiBnaXZlbiBzeW1tZXRyaWMga2V5LlxuICpcbiAqIFRoZSBrZXkgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nIG9mIGJ5dGVzIG9yIGEgYnl0ZSBidWZmZXIuXG4gKlxuICogVG8gc3RhcnQgZW5jcnlwdGluZyBjYWxsIHN0YXJ0KCkgb24gdGhlIGNpcGhlciB3aXRoIGFuIGl2IGFuZCBvcHRpb25hbFxuICogb3V0cHV0IGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjaXBoZXIuXG4gKi9cbmZvcmdlLnJjMi5jcmVhdGVFbmNyeXB0aW9uQ2lwaGVyID0gZnVuY3Rpb24oa2V5LCBiaXRzKSB7XG4gIHJldHVybiBjcmVhdGVDaXBoZXIoa2V5LCBiaXRzLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBSQzIgY2lwaGVyIG9iamVjdCB0byBkZWNyeXB0IGRhdGEgaW4gRUNCIG9yIENCQyBtb2RlIHVzaW5nIHRoZVxuICogZ2l2ZW4gc3ltbWV0cmljIGtleS4gVGhlIG91dHB1dCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgJ291dHB1dCcgbWVtYmVyXG4gKiBvZiB0aGUgcmV0dXJuZWQgY2lwaGVyLlxuICpcbiAqIFRoZSBrZXkgYW5kIGl2IG1heSBiZSBnaXZlbiBhcyBhIHN0cmluZyBvZiBieXRlcyBvciBhIGJ5dGUgYnVmZmVyLlxuICogVGhlIGNpcGhlciBpcyBpbml0aWFsaXplZCB0byB1c2UgMTI4IGVmZmVjdGl2ZSBrZXkgYml0cy5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBzeW1tZXRyaWMga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBpdiB0aGUgaW5pdGlhbGl6YXRpb24gdmVjdG9yIHRvIHVzZS5cbiAqIEBwYXJhbSBvdXRwdXQgdGhlIGJ1ZmZlciB0byB3cml0ZSB0bywgbnVsbCB0byBjcmVhdGUgb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLnN0YXJ0RGVjcnlwdGluZyA9IGZ1bmN0aW9uKGtleSwgaXYsIG91dHB1dCkge1xuICB2YXIgY2lwaGVyID0gZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIoa2V5LCAxMjgpO1xuICBjaXBoZXIuc3RhcnQoaXYsIG91dHB1dCk7XG4gIHJldHVybiBjaXBoZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUkMyIGNpcGhlciBvYmplY3QgdG8gZGVjcnlwdCBkYXRhIGluIEVDQiBvciBDQkMgbW9kZSB1c2luZyB0aGVcbiAqIGdpdmVuIHN5bW1ldHJpYyBrZXkuXG4gKlxuICogVGhlIGtleSBtYXkgYmUgZ2l2ZW4gYXMgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBieXRlIGJ1ZmZlci5cbiAqXG4gKiBUbyBzdGFydCBkZWNyeXB0aW5nIGNhbGwgc3RhcnQoKSBvbiB0aGUgY2lwaGVyIHdpdGggYW4gaXYgYW5kIG9wdGlvbmFsXG4gKiBvdXRwdXQgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHN5bW1ldHJpYyBrZXkgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNpcGhlci5cbiAqL1xuZm9yZ2UucmMyLmNyZWF0ZURlY3J5cHRpb25DaXBoZXIgPSBmdW5jdGlvbihrZXksIGJpdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNpcGhlcihrZXksIGJpdHMsIGZhbHNlKTtcbn07XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYmFzaWMgUlNBIGFsZ29yaXRobXMuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBvbmx5IGFsZ29yaXRobSBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBQS0kgaXMgUlNBLlxuICpcbiAqIEFuIFJTQSBrZXkgaXMgb2Z0ZW4gc3RvcmVkIGluIEFTTi4xIERFUiBmb3JtYXQuIFRoZSBTdWJqZWN0UHVibGljS2V5SW5mb1xuICogQVNOLjEgc3RydWN0dXJlIGlzIGNvbXBvc2VkIG9mIGFuIGFsZ29yaXRobSBvZiB0eXBlIEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIGFuZCBhIHN1YmplY3RQdWJsaWNLZXkgb2YgdHlwZSBiaXQgc3RyaW5nLlxuICpcbiAqIFRoZSBBbGdvcml0aG1JZGVudGlmaWVyIGNvbnRhaW5zIGFuIE9iamVjdCBJZGVudGlmaWVyIChPSUQpIGFuZCBwYXJhbWV0ZXJzXG4gKiBmb3IgdGhlIGFsZ29yaXRobSwgaWYgYW55LiBJbiB0aGUgY2FzZSBvZiBSU0EsIHRoZXJlIGFyZW4ndCBhbnkuXG4gKlxuICogU3ViamVjdFB1YmxpY0tleUluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgYWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgQklUIFNUUklOR1xuICogfVxuICpcbiAqIEFsZ29yaXRobUlkZW50aWZlciA6Oj0gU0VRVUVOQ0Uge1xuICogICBhbGdvcml0aG0gT0JKRUNUIElERU5USUZJRVIsXG4gKiAgIHBhcmFtZXRlcnMgQU5ZIERFRklORUQgQlkgYWxnb3JpdGhtIE9QVElPTkFMXG4gKiB9XG4gKlxuICogRm9yIGFuIFJTQSBwdWJsaWMga2V5LCB0aGUgc3ViamVjdFB1YmxpY0tleSBpczpcbiAqXG4gKiBSU0FQdWJsaWNLZXkgOjo9IFNFUVVFTkNFIHtcbiAqICAgbW9kdWx1cyAgICAgICAgICAgIElOVEVHRVIsICAgIC0tIG5cbiAqICAgcHVibGljRXhwb25lbnQgICAgIElOVEVHRVIgICAgIC0tIGVcbiAqIH1cbiAqXG4gKiBQcml2YXRlS2V5SW5mbyA6Oj0gU0VRVUVOQ0Uge1xuICogICB2ZXJzaW9uICAgICAgICAgICAgICAgICAgIFZlcnNpb24sXG4gKiAgIHByaXZhdGVLZXlBbGdvcml0aG0gICAgICAgUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHByaXZhdGVLZXkgICAgICAgICAgICAgICAgUHJpdmF0ZUtleSxcbiAqICAgYXR0cmlidXRlcyAgICAgICAgICAgWzBdICBJTVBMSUNJVCBBdHRyaWJ1dGVzIE9QVElPTkFMXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICogUHJpdmF0ZUtleUFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAqIFByaXZhdGVLZXkgOjo9IE9DVEVUIFNUUklOR1xuICogQXR0cmlidXRlcyA6Oj0gU0VUIE9GIEF0dHJpYnV0ZVxuICpcbiAqIEFuIFJTQSBwcml2YXRlIGtleSBhcyB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAqXG4gKiBSU0FQcml2YXRlS2V5IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gVmVyc2lvbixcbiAqICAgbW9kdWx1cyBJTlRFR0VSLCAtLSBuXG4gKiAgIHB1YmxpY0V4cG9uZW50IElOVEVHRVIsIC0tIGVcbiAqICAgcHJpdmF0ZUV4cG9uZW50IElOVEVHRVIsIC0tIGRcbiAqICAgcHJpbWUxIElOVEVHRVIsIC0tIHBcbiAqICAgcHJpbWUyIElOVEVHRVIsIC0tIHFcbiAqICAgZXhwb25lbnQxIElOVEVHRVIsIC0tIGQgbW9kIChwLTEpXG4gKiAgIGV4cG9uZW50MiBJTlRFR0VSLCAtLSBkIG1vZCAocS0xKVxuICogICBjb2VmZmljaWVudCBJTlRFR0VSIC0tIChpbnZlcnNlIG9mIHEpIG1vZCBwXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUlxuICpcbiAqIFRoZSBPSUQgZm9yIHRoZSBSU0Ega2V5IGFsZ29yaXRobSBpczogMS4yLjg0MC4xMTM1NDkuMS4xLjFcbiAqL1xudmFyIGZvcmdlID0gcmVxdWlyZSgnLi9mb3JnZScpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2pzYm4nKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wa2NzMScpO1xucmVxdWlyZSgnLi9wcmltZScpO1xucmVxdWlyZSgnLi9yYW5kb20nKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG5pZih0eXBlb2YgQmlnSW50ZWdlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXI7XG59XG5cbnZhciBfY3J5cHRvID0gZm9yZ2UudXRpbC5pc05vZGVqcyA/IHJlcXVpcmUoJ2NyeXB0bycpIDogbnVsbDtcblxuLy8gc2hvcnRjdXQgZm9yIGFzbi4xIEFQSVxudmFyIGFzbjEgPSBmb3JnZS5hc24xO1xuXG4vLyBzaG9ydGN1dCBmb3IgdXRpbCBBUElcbnZhciB1dGlsID0gZm9yZ2UudXRpbDtcblxuLypcbiAqIFJTQSBlbmNyeXB0aW9uIGFuZCBkZWNyeXB0aW9uLCBzZWUgUkZDIDIzMTMuXG4gKi9cbmZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbm1vZHVsZS5leHBvcnRzID0gZm9yZ2UucGtpLnJzYSA9IGZvcmdlLnJzYSA9IGZvcmdlLnJzYSB8fCB7fTtcbnZhciBwa2kgPSBmb3JnZS5wa2k7XG5cbi8vIGZvciBmaW5kaW5nIHByaW1lcywgd2hpY2ggYXJlIDMwaytpIGZvciBpID0gMSwgNywgMTEsIDEzLCAxNywgMTksIDIzLCAyOVxudmFyIEdDRF8zMF9ERUxUQSA9IFs2LCA0LCAyLCA0LCAyLCA0LCA2LCAyXTtcblxuLy8gdmFsaWRhdG9yIGZvciBhIFByaXZhdGVLZXlJbmZvIHN0cnVjdHVyZVxudmFyIHByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIG5hbWU6ICdQcml2YXRlS2V5SW5mbycsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUHJpdmF0ZUtleUluZm8udmVyc2lvbicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVZlcnNpb24nXG4gIH0sIHtcbiAgICAvLyBwcml2YXRlS2V5QWxnb3JpdGhtXG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5T2lkJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgbmFtZTogJ1ByaXZhdGVLZXlJbmZvJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleSdcbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYW4gUlNBIHByaXZhdGUga2V5XG52YXIgcnNhUHJpdmF0ZUtleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHJpdmF0ZUtleVxuICBuYW1lOiAnUlNBUHJpdmF0ZUtleScsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFt7XG4gICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS52ZXJzaW9uJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5VmVyc2lvbidcbiAgfSwge1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkubW9kdWx1cycsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleU1vZHVsdXMnXG4gIH0sIHtcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wdWJsaWNFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVB1YmxpY0V4cG9uZW50J1xuICB9LCB7XG4gICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LnByaXZhdGVFeHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCdcbiAgfSwge1xuICAgIC8vIHByaW1lMSAocClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5wcmltZTEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlQcmltZTEnXG4gIH0sIHtcbiAgICAvLyBwcmltZTIgKHEpXG4gICAgbmFtZTogJ1JTQVByaXZhdGVLZXkucHJpbWUyJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwcml2YXRlS2V5UHJpbWUyJ1xuICB9LCB7XG4gICAgLy8gZXhwb25lbnQxIChkIG1vZCAocC0xKSlcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5leHBvbmVudDEnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgY2FwdHVyZTogJ3ByaXZhdGVLZXlFeHBvbmVudDEnXG4gIH0sIHtcbiAgICAvLyBleHBvbmVudDIgKGQgbW9kIChxLTEpKVxuICAgIG5hbWU6ICdSU0FQcml2YXRlS2V5LmV4cG9uZW50MicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUV4cG9uZW50MidcbiAgfSwge1xuICAgIC8vIGNvZWZmaWNpZW50ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAgICBuYW1lOiAnUlNBUHJpdmF0ZUtleS5jb2VmZmljaWVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHJpdmF0ZUtleUNvZWZmaWNpZW50J1xuICB9XVxufTtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBSU0EgcHVibGljIGtleVxudmFyIHJzYVB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgLy8gUlNBUHVibGljS2V5XG4gIG5hbWU6ICdSU0FQdWJsaWNLZXknLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5tb2R1bHVzJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmU6ICdwdWJsaWNLZXlNb2R1bHVzJ1xuICB9LCB7XG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgbmFtZTogJ1JTQVB1YmxpY0tleS5leHBvbmVudCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAncHVibGljS2V5RXhwb25lbnQnXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGFuIFN1YmplY3RQdWJsaWNLZXlJbmZvIHN0cnVjdHVyZVxuLy8gTm90ZTogQ3VycmVudGx5IG9ubHkgd29ya3Mgd2l0aCBhbiBSU0EgcHVibGljIGtleVxudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IGZvcmdlLnBraS5yc2EucHVibGljS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIGNhcHR1cmVBc24xOiAnc3ViamVjdFB1YmxpY0tleUluZm8nLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAnU3ViamVjdFB1YmxpY0tleUluZm8uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3B1YmxpY0tleU9pZCdcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gc3ViamVjdFB1YmxpY0tleVxuICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5JyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgdmFsdWU6IFt7XG4gICAgICAvLyBSU0FQdWJsaWNLZXlcbiAgICAgIG5hbWU6ICdTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LlJTQVB1YmxpY0tleScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdyc2FQdWJsaWNLZXknXG4gICAgfV1cbiAgfV1cbn07XG5cbi8qKlxuICogV3JhcCBkaWdlc3QgaW4gRGlnZXN0SW5mbyBvYmplY3QuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIEVNU0EtUEtDUzEtdjFfNS1FTkNPREUgYXMgcGVyIFJGQyAzNDQ3LlxuICpcbiAqIERpZ2VzdEluZm8gOjo9IFNFUVVFTkNFIHtcbiAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIGRpZ2VzdCBEaWdlc3RcbiAqIH1cbiAqXG4gKiBEaWdlc3RBbGdvcml0aG1JZGVudGlmaWVyIDo6PSBBbGdvcml0aG1JZGVudGlmaWVyXG4gKiBEaWdlc3QgOjo9IE9DVEVUIFNUUklOR1xuICpcbiAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBlbmNvZGVkIG1lc3NhZ2UgKHJlYWR5IGZvciBSU0EgZW5jcnl0aW9uKVxuICovXG52YXIgZW1zYVBrY3MxdjE1ZW5jb2RlID0gZnVuY3Rpb24obWQpIHtcbiAgLy8gZ2V0IHRoZSBvaWQgZm9yIHRoZSBhbGdvcml0aG1cbiAgdmFyIG9pZDtcbiAgaWYobWQuYWxnb3JpdGhtIGluIHBraS5vaWRzKSB7XG4gICAgb2lkID0gcGtpLm9pZHNbbWQuYWxnb3JpdGhtXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSBkaWdlc3QgYWxnb3JpdGhtLicpO1xuICAgIGVycm9yLmFsZ29yaXRobSA9IG1kLmFsZ29yaXRobTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB2YXIgb2lkQnl0ZXMgPSBhc24xLm9pZFRvRGVyKG9pZCkuZ2V0Qnl0ZXMoKTtcblxuICAvLyBjcmVhdGUgdGhlIGRpZ2VzdCBpbmZvXG4gIHZhciBkaWdlc3RJbmZvID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICB2YXIgZGlnZXN0QWxnb3JpdGhtID0gYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICBkaWdlc3RBbGdvcml0aG0udmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsIG9pZEJ5dGVzKSk7XG4gIGRpZ2VzdEFsZ29yaXRobS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKSk7XG4gIHZhciBkaWdlc3QgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLFxuICAgIGZhbHNlLCBtZC5kaWdlc3QoKS5nZXRCeXRlcygpKTtcbiAgZGlnZXN0SW5mby52YWx1ZS5wdXNoKGRpZ2VzdEFsZ29yaXRobSk7XG4gIGRpZ2VzdEluZm8udmFsdWUucHVzaChkaWdlc3QpO1xuXG4gIC8vIGVuY29kZSBkaWdlc3QgaW5mb1xuICByZXR1cm4gYXNuMS50b0RlcihkaWdlc3RJbmZvKS5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyB4XmMgbW9kIG4gKFJTQSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gb3BlcmF0aW9uKS5cbiAqXG4gKiBAcGFyYW0geCB0aGUgbnVtYmVyIHRvIHJhaXNlIGFuZCBtb2QuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGlmIHRoZSBrZXkgaXMgcHVibGljLCBmYWxzZSBpZiBwcml2YXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiB4XmMgbW9kIG4uXG4gKi9cbnZhciBfbW9kUG93ID0gZnVuY3Rpb24oeCwga2V5LCBwdWIpIHtcbiAgaWYocHViKSB7XG4gICAgcmV0dXJuIHgubW9kUG93KGtleS5lLCBrZXkubik7XG4gIH1cblxuICBpZigha2V5LnAgfHwgIWtleS5xKSB7XG4gICAgLy8gYWxsb3cgY2FsY3VsYXRpb24gd2l0aG91dCBDUlQgcGFyYW1zIChzbG93KVxuICAgIHJldHVybiB4Lm1vZFBvdyhrZXkuZCwga2V5Lm4pO1xuICB9XG5cbiAgLy8gcHJlLWNvbXB1dGUgZFAsIGRRLCBhbmQgcUludiBpZiBuZWNlc3NhcnlcbiAgaWYoIWtleS5kUCkge1xuICAgIGtleS5kUCA9IGtleS5kLm1vZChrZXkucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSkpO1xuICB9XG4gIGlmKCFrZXkuZFEpIHtcbiAgICBrZXkuZFEgPSBrZXkuZC5tb2Qoa2V5LnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpKTtcbiAgfVxuICBpZigha2V5LnFJbnYpIHtcbiAgICBrZXkucUludiA9IGtleS5xLm1vZEludmVyc2Uoa2V5LnApO1xuICB9XG5cbiAgLyogQ2hpbmVzZSByZW1haW5kZXIgdGhlb3JlbSAoQ1JUKSBzdGF0ZXM6XG5cbiAgICBTdXBwb3NlIG4xLCBuMiwgLi4uLCBuayBhcmUgcG9zaXRpdmUgaW50ZWdlcnMgd2hpY2ggYXJlIHBhaXJ3aXNlXG4gICAgY29wcmltZSAobjEgYW5kIG4yIGhhdmUgbm8gY29tbW9uIGZhY3RvcnMgb3RoZXIgdGhhbiAxKS4gRm9yIGFueVxuICAgIGludGVnZXJzIHgxLCB4MiwgLi4uLCB4ayB0aGVyZSBleGlzdHMgYW4gaW50ZWdlciB4IHNvbHZpbmcgdGhlXG4gICAgc3lzdGVtIG9mIHNpbXVsdGFuZW91cyBjb25ncnVlbmNlcyAod2hlcmUgfj0gbWVhbnMgbW9kdWxhcmx5XG4gICAgY29uZ3J1ZW50IHNvIGEgfj0gYiBtb2QgbiBtZWFucyBhIG1vZCBuID0gYiBtb2Qgbik6XG5cbiAgICB4IH49IHgxIG1vZCBuMVxuICAgIHggfj0geDIgbW9kIG4yXG4gICAgLi4uXG4gICAgeCB+PSB4ayBtb2QgbmtcblxuICAgIFRoaXMgc3lzdGVtIG9mIGNvbmdydWVuY2VzIGhhcyBhIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geFxuICAgIGJldHdlZW4gMCBhbmQgbiAtIDEuIEZ1cnRoZXJtb3JlLCBlYWNoIHhrIHNvbHV0aW9uIGFuZCB4IGl0c2VsZlxuICAgIGlzIGNvbmdydWVudCBtb2R1bG8gdGhlIHByb2R1Y3QgbiA9IG4xKm4yKi4uLipuay5cbiAgICBTbyB4MSBtb2QgbiA9IHgyIG1vZCBuID0geGsgbW9kIG4gPSB4IG1vZCBuLlxuXG4gICAgVGhlIHNpbmdsZSBzaW11bHRhbmVvdXMgc29sdXRpb24geCBjYW4gYmUgc29sdmVkIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgIGVxdWF0aW9uOlxuXG4gICAgeCA9IHN1bSh4aSpyaSpzaSkgbW9kIG4gd2hlcmUgcmkgPSBuL25pIGFuZCBzaSA9IHJpXi0xIG1vZCBuaS5cblxuICAgIFdoZXJlIHggaXMgbGVzcyB0aGFuIG4sIHhpID0geCBtb2QgbmkuXG5cbiAgICBGb3IgUlNBIHdlIGFyZSBvbmx5IGNvbmNlcm5lZCB3aXRoIGsgPSAyLiBUaGUgbW9kdWx1cyBuID0gcHEsIHdoZXJlXG4gICAgcCBhbmQgcSBhcmUgY29wcmltZS4gVGhlIFJTQSBkZWNyeXB0aW9uIGFsZ29yaXRobSBpczpcblxuICAgIHkgPSB4XmQgbW9kIG5cblxuICAgIEdpdmVuIHRoZSBhYm92ZTpcblxuICAgIHgxID0geF5kIG1vZCBwXG4gICAgcjEgPSBuL3AgPSBxXG4gICAgczEgPSBxXi0xIG1vZCBwXG4gICAgeDIgPSB4XmQgbW9kIHFcbiAgICByMiA9IG4vcSA9IHBcbiAgICBzMiA9IHBeLTEgbW9kIHFcblxuICAgIFNvIHkgPSAoeDFyMXMxICsgeDJyMnMyKSBtb2QgblxuICAgICAgICAgPSAoKHheZCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZCBtb2QgcSlwKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgQWNjb3JkaW5nIHRvIEZlcm1hdCdzIExpdHRsZSBUaGVvcmVtLCBpZiB0aGUgbW9kdWx1cyBQIGlzIHByaW1lLFxuICAgIGZvciBhbnkgaW50ZWdlciBBIG5vdCBldmVubHkgZGl2aXNpYmxlIGJ5IFAsIEFeKFAtMSkgfj0gMSBtb2QgUC5cbiAgICBTaW5jZSBBIGlzIG5vdCBkaXZpc2libGUgYnkgUCBpdCBmb2xsb3dzIHRoYXQgaWY6XG4gICAgTiB+PSBNIG1vZCAoUCAtIDEpLCB0aGVuIEFeTiBtb2QgUCA9IEFeTSBtb2QgUC4gVGhlcmVmb3JlOlxuXG4gICAgQV5OIG1vZCBQID0gQV4oTSBtb2QgKFAgLSAxKSkgbW9kIFAuIChUaGUgbGF0dGVyIHRha2VzIGxlc3MgZWZmb3J0XG4gICAgdG8gY2FsY3VsYXRlKS4gSW4gb3JkZXIgdG8gY2FsY3VsYXRlIHheZCBtb2QgcCBtb3JlIHF1aWNrbHkgdGhlXG4gICAgZXhwb25lbnQgZCBtb2QgKHAgLSAxKSBpcyBzdG9yZWQgaW4gdGhlIFJTQSBwcml2YXRlIGtleSAodGhlIHNhbWVcbiAgICBpcyBkb25lIGZvciB4XmQgbW9kIHEpLiBUaGVzZSB2YWx1ZXMgYXJlIHJlZmVycmVkIHRvIGFzIGRQIGFuZCBkUVxuICAgIHJlc3BlY3RpdmVseS4gVGhlcmVmb3JlIHdlIG5vdyBoYXZlOlxuXG4gICAgeSA9ICgoeF5kUCBtb2QgcClxKHFeLTEgbW9kIHApICsgKHheZFEgbW9kIHEpcChwXi0xIG1vZCBxKSkgbW9kIG5cblxuICAgIFNpbmNlIHdlJ2xsIGJlIHJlZHVjaW5nIHheZFAgYnkgbW9kdWxvIHAgKHNhbWUgZm9yIHEpIHdlIGNhbiBhbHNvXG4gICAgcmVkdWNlIHggYnkgcCAoYW5kIHEgcmVzcGVjdGl2ZWx5KSBiZWZvcmUgaGFuZC4gVGhlcmVmb3JlLCBsZXRcblxuICAgIHhwID0gKCh4IG1vZCBwKV5kUCBtb2QgcCksIGFuZFxuICAgIHhxID0gKCh4IG1vZCBxKV5kUSBtb2QgcSksIHlpZWxkaW5nOlxuXG4gICAgeSA9ICh4cCpxKihxXi0xIG1vZCBwKSArIHhxKnAqKHBeLTEgbW9kIHEpKSBtb2QgblxuXG4gICAgVGhpcyBjYW4gYmUgZnVydGhlciByZWR1Y2VkIHRvIGEgc2ltcGxlIGFsZ29yaXRobSB0aGF0IG9ubHlcbiAgICByZXF1aXJlcyAxIGludmVyc2UgKHRoZSBxIGludmVyc2UgaXMgdXNlZCkgdG8gYmUgdXNlZCBhbmQgc3RvcmVkLlxuICAgIFRoZSBhbGdvcml0aG0gaXMgY2FsbGVkIEdhcm5lcidzIGFsZ29yaXRobS4gSWYgcUludiBpcyB0aGVcbiAgICBpbnZlcnNlIG9mIHEsIHdlIHNpbXBseSBjYWxjdWxhdGU6XG5cbiAgICB5ID0gKHFJbnYqKHhwIC0geHEpIG1vZCBwKSAqIHEgKyB4cVxuXG4gICAgSG93ZXZlciwgdGhlcmUgYXJlIHR3byBmdXJ0aGVyIGNvbXBsaWNhdGlvbnMuIEZpcnN0LCB3ZSBuZWVkIHRvXG4gICAgZW5zdXJlIHRoYXQgeHAgPiB4cSB0byBwcmV2ZW50IHNpZ25lZCBCaWdJbnRlZ2VycyBmcm9tIGJlaW5nIHVzZWRcbiAgICBzbyB3ZSBhZGQgcCB1bnRpbCB0aGlzIGlzIHRydWUgKHNpbmNlIHdlIHdpbGwgYmUgbW9kJ2luZyB3aXRoXG4gICAgcCBhbnl3YXkpLiBUaGVuLCB0aGVyZSBpcyBhIGtub3duIHRpbWluZyBhdHRhY2sgb24gYWxnb3JpdGhtc1xuICAgIHVzaW5nIHRoZSBDUlQuIFRvIG1pdGlnYXRlIHRoaXMgcmlzaywgXCJjcnlwdG9ncmFwaGljIGJsaW5kaW5nXCJcbiAgICBzaG91bGQgYmUgdXNlZC4gVGhpcyByZXF1aXJlcyBzaW1wbHkgZ2VuZXJhdGluZyBhIHJhbmRvbSBudW1iZXIgclxuICAgIGJldHdlZW4gMCBhbmQgbi0xIGFuZCBpdHMgaW52ZXJzZSBhbmQgbXVsdGlwbHlpbmcgeCBieSByXmUgYmVmb3JlXG4gICAgY2FsY3VsYXRpbmcgeSBhbmQgdGhlbiBtdWx0aXBseWluZyB5IGJ5IHJeLTEgYWZ0ZXJ3YXJkcy4gTm90ZSB0aGF0XG4gICAgciBtdXN0IGJlIGNvcHJpbWUgd2l0aCBuIChnY2QociwgbikgPT09IDEpIGluIG9yZGVyIHRvIGhhdmUgYW5cbiAgICBpbnZlcnNlLlxuICAqL1xuXG4gIC8vIGNyeXB0b2dyYXBoaWMgYmxpbmRpbmdcbiAgdmFyIHI7XG4gIGRvIHtcbiAgICByID0gbmV3IEJpZ0ludGVnZXIoXG4gICAgICBmb3JnZS51dGlsLmJ5dGVzVG9IZXgoZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleS5uLmJpdExlbmd0aCgpIC8gOCkpLFxuICAgICAgMTYpO1xuICB9IHdoaWxlKHIuY29tcGFyZVRvKGtleS5uKSA+PSAwIHx8ICFyLmdjZChrZXkubikuZXF1YWxzKEJpZ0ludGVnZXIuT05FKSk7XG4gIHggPSB4Lm11bHRpcGx5KHIubW9kUG93KGtleS5lLCBrZXkubikpLm1vZChrZXkubik7XG5cbiAgLy8gY2FsY3VsYXRlIHhwIGFuZCB4cVxuICB2YXIgeHAgPSB4Lm1vZChrZXkucCkubW9kUG93KGtleS5kUCwga2V5LnApO1xuICB2YXIgeHEgPSB4Lm1vZChrZXkucSkubW9kUG93KGtleS5kUSwga2V5LnEpO1xuXG4gIC8vIHhwIG11c3QgYmUgbGFyZ2VyIHRoYW4geHEgdG8gYXZvaWQgc2lnbmVkIGJpdCB1c2FnZVxuICB3aGlsZSh4cC5jb21wYXJlVG8oeHEpIDwgMCkge1xuICAgIHhwID0geHAuYWRkKGtleS5wKTtcbiAgfVxuXG4gIC8vIGRvIGxhc3Qgc3RlcFxuICB2YXIgeSA9IHhwLnN1YnRyYWN0KHhxKVxuICAgIC5tdWx0aXBseShrZXkucUludikubW9kKGtleS5wKVxuICAgIC5tdWx0aXBseShrZXkucSkuYWRkKHhxKTtcblxuICAvLyByZW1vdmUgZWZmZWN0IG9mIHJhbmRvbSBmb3IgY3J5cHRvZ3JhcGhpYyBibGluZGluZ1xuICB5ID0geS5tdWx0aXBseShyLm1vZEludmVyc2Uoa2V5Lm4pKS5tb2Qoa2V5Lm4pO1xuXG4gIHJldHVybiB5O1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ3NpZ24nIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAnZW5jcnlwdCcgb24gYSBwdWJsaWMga2V5IG9iamVjdCBpbnN0ZWFkLlxuICpcbiAqIFBlcmZvcm1zIFJTQSBlbmNyeXB0aW9uLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgYnQgY29udHJvbHMgd2hldGhlciB0byBwdXQgcGFkZGluZyBieXRlcyBiZWZvcmUgdGhlXG4gKiBtZXNzYWdlIHBhc3NlZCBpbi4gU2V0IGJ0IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZ1xuICogY29tcGxldGVseSAoaW4gb3JkZXIgdG8gaGFuZGxlIGUuZy4gRU1TQS1QU1MgZW5jb2Rpbmcgc2VwZXJhdGVseSBiZWZvcmUpLFxuICogc2lnbmFsaW5nIHdoZXRoZXIgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uIGlzIGEgcHVibGljIGtleSBvcGVyYXRpb25cbiAqIChpLmUuIGVuY3J5cHRpbmcgZGF0YSkgb3Igbm90LCBpLmUuIHByaXZhdGUga2V5IG9wZXJhdGlvbiAoZGF0YSBzaWduaW5nKS5cbiAqXG4gKiBGb3IgUEtDUyMxIHYxLjUgcGFkZGluZyBwYXNzIGluIHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMVxuICogKGZvciBzaWduaW5nKSBvciAweDAyIChmb3IgZW5jcnlwdGlvbikuIFRoZSBrZXkgb3BlcmF0aW9uIG1vZGUgKHByaXZhdGVcbiAqIG9yIHB1YmxpYykgaXMgZGVyaXZlZCBmcm9tIHRoaXMgZmxhZyBpbiB0aGF0IGNhc2UpLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY3J5cHQgYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLCB0aGUgYmxvY2sgdHlwZSB0byB1c2VcbiAqICAgKDB4MDEgZm9yIHByaXZhdGUga2V5LCAweDAyIGZvciBwdWJsaWMpLFxuICogICB0byBkaXNhYmxlIHBhZGRpbmc6IHRydWUgPSBwdWJsaWMga2V5LCBmYWxzZSA9IHByaXZhdGUga2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIGVuY3J5cHRlZCBieXRlcyBhcyBhIHN0cmluZy5cbiAqL1xucGtpLnJzYS5lbmNyeXB0ID0gZnVuY3Rpb24obSwga2V5LCBidCkge1xuICB2YXIgcHViID0gYnQ7XG4gIHZhciBlYjtcblxuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIGlmKGJ0ICE9PSBmYWxzZSAmJiBidCAhPT0gdHJ1ZSkge1xuICAgIC8vIGxlZ2FjeSwgZGVmYXVsdCB0byBQS0NTIzEgdjEuNSBwYWRkaW5nXG4gICAgcHViID0gKGJ0ID09PSAweDAyKTtcbiAgICBlYiA9IF9lbmNvZGVQa2NzMV92MV81KG0sIGtleSwgYnQpO1xuICB9IGVsc2Uge1xuICAgIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBlYi5wdXRCeXRlcyhtKTtcbiAgfVxuXG4gIC8vIGxvYWQgZW5jcnlwdGlvbiBibG9jayBhcyBiaWcgaW50ZWdlciAneCdcbiAgLy8gRklYTUU6IGhleCBjb252ZXJzaW9uIGluZWZmaWNpZW50LCBnZXQgQmlnSW50ZWdlciB3L2J5dGUgc3RyaW5nc1xuICB2YXIgeCA9IG5ldyBCaWdJbnRlZ2VyKGViLnRvSGV4KCksIDE2KTtcblxuICAvLyBkbyBSU0EgZW5jcnlwdGlvblxuICB2YXIgeSA9IF9tb2RQb3coeCwga2V5LCBwdWIpO1xuXG4gIC8vIGNvbnZlcnQgeSBpbnRvIHRoZSBlbmNyeXB0ZWQgZGF0YSBieXRlIHN0cmluZywgaWYgeSBpcyBzaG9ydGVyIGluXG4gIC8vIGJ5dGVzIHRoYW4gaywgdGhlbiBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlZFxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB5aGV4ID0geS50b1N0cmluZygxNik7XG4gIHZhciBlZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeWhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWQucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGVkLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh5aGV4KSk7XG4gIHJldHVybiBlZC5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBOT1RFOiBUSElTIE1FVEhPRCBJUyBERVBSRUNBVEVELCB1c2UgJ2RlY3J5cHQnIG9uIGEgcHJpdmF0ZSBrZXkgb2JqZWN0IG9yXG4gKiAndmVyaWZ5JyBvbiBhIHB1YmxpYyBrZXkgb2JqZWN0IGluc3RlYWQuXG4gKlxuICogUGVyZm9ybXMgUlNBIGRlY3J5cHRpb24uXG4gKlxuICogVGhlIHBhcmFtZXRlciBtbCBjb250cm9scyB3aGV0aGVyIHRvIGFwcGx5IFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAqIG9yIG5vdC4gIFNldCBtbCA9IGZhbHNlIHRvIGRpc2FibGUgcGFkZGluZyByZW1vdmFsIGNvbXBsZXRlbHlcbiAqIChpbiBvcmRlciB0byBoYW5kbGUgZS5nLiBFTVNBLVBTUyBsYXRlciBvbikgYW5kIHNpbXBseSBwYXNzIGJhY2tcbiAqIHRoZSBSU0EgZW5jcnlwdGlvbiBibG9jay5cbiAqXG4gKiBAcGFyYW0gZWQgdGhlIGVuY3J5cHRlZCBkYXRhIHRvIGRlY3J5cHQgaW4gYXMgYSBieXRlIHN0cmluZy5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIHB1YiB0cnVlIGZvciBhIHB1YmxpYyBrZXkgb3BlcmF0aW9uLCBmYWxzZSBmb3IgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIGtub3duLCBmYWxzZSB0byBkaXNhYmxlIHBhZGRpbmcuXG4gKlxuICogQHJldHVybiB0aGUgZGVjcnlwdGVkIG1lc3NhZ2UgYXMgYSBieXRlIHN0cmluZy5cbiAqL1xucGtpLnJzYS5kZWNyeXB0ID0gZnVuY3Rpb24oZWQsIGtleSwgcHViLCBtbCkge1xuICAvLyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgbW9kdWx1cyBpbiBieXRlc1xuICB2YXIgayA9IE1hdGguY2VpbChrZXkubi5iaXRMZW5ndGgoKSAvIDgpO1xuXG4gIC8vIGVycm9yIGlmIHRoZSBsZW5ndGggb2YgdGhlIGVuY3J5cHRlZCBkYXRhIEVEIGlzIG5vdCBrXG4gIGlmKGVkLmxlbmd0aCAhPT0gaykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRW5jcnlwdGVkIG1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWQuJyk7XG4gICAgZXJyb3IubGVuZ3RoID0gZWQubGVuZ3RoO1xuICAgIGVycm9yLmV4cGVjdGVkID0gaztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgZW5jcnlwdGVkIGRhdGEgaW50byBhIGJpZyBpbnRlZ2VyXG4gIC8vIEZJWE1FOiBoZXggY29udmVyc2lvbiBpbmVmZmljaWVudCwgZ2V0IEJpZ0ludGVnZXIgdy9ieXRlIHN0cmluZ3NcbiAgdmFyIHkgPSBuZXcgQmlnSW50ZWdlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihlZCkudG9IZXgoKSwgMTYpO1xuXG4gIC8vIHkgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIG1vZHVsdXMgb3IgaXQgd2Fzbid0IHRoZSByZXN1bHQgb2ZcbiAgLy8gYSBwcmV2aW91cyBtb2Qgb3BlcmF0aW9uIChlbmNyeXB0aW9uKSB1c2luZyB0aGF0IG1vZHVsdXNcbiAgaWYoeS5jb21wYXJlVG8oa2V5Lm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRlZCBtZXNzYWdlIGlzIGludmFsaWQuJyk7XG4gIH1cblxuICAvLyBkbyBSU0EgZGVjcnlwdGlvblxuICB2YXIgeCA9IF9tb2RQb3coeSwga2V5LCBwdWIpO1xuXG4gIC8vIGNyZWF0ZSB0aGUgZW5jcnlwdGlvbiBibG9jaywgaWYgeCBpcyBzaG9ydGVyIGluIGJ5dGVzIHRoYW4gaywgdGhlblxuICAvLyBwcmVwZW5kIHplcm8gYnl0ZXMgdG8gZmlsbCB1cCBlYlxuICAvLyBGSVhNRTogaGV4IGNvbnZlcnNpb24gaW5lZmZpY2llbnQsIGdldCBCaWdJbnRlZ2VyIHcvYnl0ZSBzdHJpbmdzXG4gIHZhciB4aGV4ID0geC50b1N0cmluZygxNik7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gIHZhciB6ZXJvcyA9IGsgLSBNYXRoLmNlaWwoeGhleC5sZW5ndGggLyAyKTtcbiAgd2hpbGUoemVyb3MgPiAwKSB7XG4gICAgZWIucHV0Qnl0ZSgweDAwKTtcbiAgICAtLXplcm9zO1xuICB9XG4gIGViLnB1dEJ5dGVzKGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4aGV4KSk7XG5cbiAgaWYobWwgIT09IGZhbHNlKSB7XG4gICAgLy8gbGVnYWN5LCBkZWZhdWx0IHRvIFBLQ1MjMSB2MS41IHBhZGRpbmdcbiAgICByZXR1cm4gX2RlY29kZVBrY3MxX3YxXzUoZWIuZ2V0Qnl0ZXMoKSwga2V5LCBwdWIpO1xuICB9XG5cbiAgLy8gcmV0dXJuIG1lc3NhZ2VcbiAgcmV0dXJuIGViLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gUlNBIGtleS1wYWlyIGdlbmVyYXRpb24gc3RhdGUgb2JqZWN0LiBJdCBpcyB1c2VkIHRvIGFsbG93XG4gKiBrZXktZ2VuZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgaW4gc3RlcHMuIEl0IGFsc28gYWxsb3dzIGZvciBhIFVJIHRvXG4gKiBkaXNwbGF5IHByb2dyZXNzIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIGUgdGhlIHB1YmxpYyBleHBvbmVudCB0byB1c2UsIGRlZmF1bHRzIHRvIDY1NTM3ICgweDEwMDAxKS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgcHJuZyBhIGN1c3RvbSBjcnlwdG8tc2VjdXJlIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciB0byB1c2UsXG4gKiAgICAgICAgICAgIHRoYXQgbXVzdCBkZWZpbmUgXCJnZXRCeXRlc1N5bmNcIi5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKlxuICogQHJldHVybiB0aGUgc3RhdGUgb2JqZWN0IHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUga2V5LXBhaXIuXG4gKi9cbnBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSA9IGZ1bmN0aW9uKGJpdHMsIGUsIG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuXG4gIC8vIHNldCBkZWZhdWx0IGJpdHNcbiAgaWYodHlwZW9mKGJpdHMpID09PSAnc3RyaW5nJykge1xuICAgIGJpdHMgPSBwYXJzZUludChiaXRzLCAxMCk7XG4gIH1cbiAgYml0cyA9IGJpdHMgfHwgMjA0ODtcblxuICAvLyBjcmVhdGUgcHJuZyB3aXRoIGFwaSB0aGF0IG1hdGNoZXMgQmlnSW50ZWdlciBzZWN1cmUgcmFuZG9tXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcHJuZyA9IG9wdGlvbnMucHJuZyB8fCBmb3JnZS5yYW5kb207XG4gIHZhciBybmcgPSB7XG4gICAgLy8geCBpcyBhbiBhcnJheSB0byBmaWxsIHdpdGggYnl0ZXNcbiAgICBuZXh0Qnl0ZXM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBiID0gcHJuZy5nZXRCeXRlc1N5bmMoeC5sZW5ndGgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeFtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtIHx8ICdQUklNRUlOQyc7XG5cbiAgLy8gY3JlYXRlIFBSSU1FSU5DIGFsZ29yaXRobSBzdGF0ZVxuICB2YXIgcnZhbDtcbiAgaWYoYWxnb3JpdGhtID09PSAnUFJJTUVJTkMnKSB7XG4gICAgcnZhbCA9IHtcbiAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtLFxuICAgICAgc3RhdGU6IDAsXG4gICAgICBiaXRzOiBiaXRzLFxuICAgICAgcm5nOiBybmcsXG4gICAgICBlSW50OiBlIHx8IDY1NTM3LFxuICAgICAgZTogbmV3IEJpZ0ludGVnZXIobnVsbCksXG4gICAgICBwOiBudWxsLFxuICAgICAgcTogbnVsbCxcbiAgICAgIHFCaXRzOiBiaXRzID4+IDEsXG4gICAgICBwQml0czogYml0cyAtIChiaXRzID4+IDEpLFxuICAgICAgcHFTdGF0ZTogMCxcbiAgICAgIG51bTogbnVsbCxcbiAgICAgIGtleXM6IG51bGxcbiAgICB9O1xuICAgIHJ2YWwuZS5mcm9tSW50KHJ2YWwuZUludCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBnZW5lcmF0aW9uIGFsZ29yaXRobTogJyArIGFsZ29yaXRobSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcnVucyB0aGUga2V5LWdlbmVyYXRpb24gYWxnb3JpdGhtIGZvciBhdCBtb3N0IG4gc2Vjb25kc1xuICogKGFwcHJveGltYXRlbHkpIHVzaW5nIHRoZSBnaXZlbiBzdGF0ZS4gV2hlbiBrZXktZ2VuZXJhdGlvbiBoYXMgY29tcGxldGVkLFxuICogdGhlIGtleXMgd2lsbCBiZSBzdG9yZWQgaW4gc3RhdGUua2V5cy5cbiAqXG4gKiBUbyB1c2UgdGhpcyBmdW5jdGlvbiB0byB1cGRhdGUgYSBVSSB3aGlsZSBnZW5lcmF0aW5nIGEga2V5IG9yIHRvIHByZXZlbnRcbiAqIGNhdXNpbmcgYnJvd3NlciBsb2NrdXBzL3dhcm5pbmdzLCBzZXQgXCJuXCIgdG8gYSB2YWx1ZSBvdGhlciB0aGFuIDAuIEFcbiAqIHNpbXBsZSBwYXR0ZXJuIGZvciBnZW5lcmF0aW5nIGEga2V5IGFuZCBzaG93aW5nIGEgcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzOlxuICpcbiAqIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZSgyMDQ4KTtcbiAqIHZhciBzdGVwID0gZnVuY3Rpb24oKSB7XG4gKiAgIC8vIHN0ZXAga2V5LWdlbmVyYXRpb24sIHJ1biBhbGdvcml0aG0gZm9yIDEwMCBtcywgcmVwZWF0XG4gKiAgIGlmKCFmb3JnZS5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlKHN0YXRlLCAxMDApKSB7XG4gKiAgICAgc2V0VGltZW91dChzdGVwLCAxKTtcbiAqICAgfSBlbHNlIHtcbiAqICAgICAvLyBrZXktZ2VuZXJhdGlvbiBjb21wbGV0ZVxuICogICAgIC8vIFRPRE86IHR1cm4gb2ZmIHByb2dyZXNzIGluZGljYXRvciBoZXJlXG4gKiAgICAgLy8gVE9ETzogdXNlIHRoZSBnZW5lcmF0ZWQga2V5LXBhaXIgaW4gXCJzdGF0ZS5rZXlzXCJcbiAqICAgfVxuICogfTtcbiAqIC8vIFRPRE86IHR1cm4gb24gcHJvZ3Jlc3MgaW5kaWNhdG9yIGhlcmVcbiAqIHNldFRpbWVvdXQoc3RlcCwgMCk7XG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSB0byB1c2UuXG4gKiBAcGFyYW0gbiB0aGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHJ1biB0aGUgYWxnb3JpdGhtIGZvciwgMFxuICogICAgICAgICAgdG8gcnVuIHRoZSBhbGdvcml0aG0gdG8gY29tcGxldGlvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIGtleS1nZW5lcmF0aW9uIGNvbXBsZXRlZCwgZmFsc2UgaWYgbm90LlxuICovXG5wa2kucnNhLnN0ZXBLZXlQYWlyR2VuZXJhdGlvblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIG4pIHtcbiAgLy8gc2V0IGRlZmF1bHQgYWxnb3JpdGhtIGlmIG5vdCBzZXRcbiAgaWYoISgnYWxnb3JpdGhtJyBpbiBzdGF0ZSkpIHtcbiAgICBzdGF0ZS5hbGdvcml0aG0gPSAnUFJJTUVJTkMnO1xuICB9XG5cbiAgLy8gVE9ETzogbWlncmF0ZSBzdGVwLWJhc2VkIHByaW1lIGdlbmVyYXRpb24gY29kZSB0byBmb3JnZS5wcmltZVxuICAvLyBUT0RPOiBhYnN0cmFjdCBhcyBQUklNRUlOQyBhbGdvcml0aG1cblxuICAvLyBkbyBrZXkgZ2VuZXJhdGlvbiAoYmFzZWQgb24gVG9tIFd1J3MgcnNhLmpzLCBzZWUganNibi5qcyBsaWNlbnNlKVxuICAvLyB3aXRoIHNvbWUgbWlub3Igb3B0aW1pemF0aW9ucyBhbmQgZGVzaWduZWQgdG8gcnVuIGluIHN0ZXBzXG5cbiAgLy8gbG9jYWwgc3RhdGUgdmFyc1xuICB2YXIgVEhJUlRZID0gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG4gIFRISVJUWS5mcm9tSW50KDMwKTtcbiAgdmFyIGRlbHRhSWR4ID0gMDtcbiAgdmFyIG9wX29yID0gZnVuY3Rpb24oeCwgeSkge3JldHVybiB4IHwgeTt9O1xuXG4gIC8vIGtlZXAgc3RlcHBpbmcgdW50aWwgdGltZSBsaW1pdCBpcyByZWFjaGVkIG9yIGRvbmVcbiAgdmFyIHQxID0gK25ldyBEYXRlKCk7XG4gIHZhciB0MjtcbiAgdmFyIHRvdGFsID0gMDtcbiAgd2hpbGUoc3RhdGUua2V5cyA9PT0gbnVsbCAmJiAobiA8PSAwIHx8IHRvdGFsIDwgbikpIHtcbiAgICAvLyBnZW5lcmF0ZSBwIG9yIHFcbiAgICBpZihzdGF0ZS5zdGF0ZSA9PT0gMCkge1xuICAgICAgLyogTm90ZTogQWxsIHByaW1lcyBhcmUgb2YgdGhlIGZvcm06XG5cbiAgICAgICAgMzBrK2ksIGZvciBpIDwgMzAgYW5kIGdjZCgzMCwgaSk9MSwgd2hlcmUgdGhlcmUgYXJlIDggdmFsdWVzIGZvciBpXG5cbiAgICAgICAgV2hlbiB3ZSBnZW5lcmF0ZSBhIHJhbmRvbSBudW1iZXIsIHdlIGFsd2F5cyBhbGlnbiBpdCBhdCAzMGsgKyAxLiBFYWNoXG4gICAgICAgIHRpbWUgdGhlIG51bWJlciBpcyBkZXRlcm1pbmVkIG5vdCB0byBiZSBwcmltZSB3ZSBhZGQgdG8gZ2V0IHRvIHRoZVxuICAgICAgICBuZXh0ICdpJywgZWc6IGlmIHRoZSBudW1iZXIgd2FzIGF0IDMwayArIDEgd2UgYWRkIDYuICovXG4gICAgICB2YXIgYml0cyA9IChzdGF0ZS5wID09PSBudWxsKSA/IHN0YXRlLnBCaXRzIDogc3RhdGUucUJpdHM7XG4gICAgICB2YXIgYml0czEgPSBiaXRzIC0gMTtcblxuICAgICAgLy8gZ2V0IGEgcmFuZG9tIG51bWJlclxuICAgICAgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBuZXcgQmlnSW50ZWdlcihiaXRzLCBzdGF0ZS5ybmcpO1xuICAgICAgICAvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgIGlmKCFzdGF0ZS5udW0udGVzdEJpdChiaXRzMSkpIHtcbiAgICAgICAgICBzdGF0ZS5udW0uYml0d2lzZVRvKFxuICAgICAgICAgICAgQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdHMxKSwgb3Bfb3IsIHN0YXRlLm51bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxpZ24gbnVtYmVyIG9uIDMwaysxIGJvdW5kYXJ5XG4gICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KDMxIC0gc3RhdGUubnVtLm1vZChUSElSVFkpLmJ5dGVWYWx1ZSgpLCAwKTtcbiAgICAgICAgZGVsdGFJZHggPSAwO1xuXG4gICAgICAgICsrc3RhdGUucHFTdGF0ZTtcbiAgICAgIH0gZWxzZSBpZihzdGF0ZS5wcVN0YXRlID09PSAxKSB7XG4gICAgICAgIC8vIHRyeSB0byBtYWtlIHRoZSBudW1iZXIgYSBwcmltZVxuICAgICAgICBpZihzdGF0ZS5udW0uYml0TGVuZ3RoKCkgPiBiaXRzKSB7XG4gICAgICAgICAgLy8gb3ZlcmZsb3csIHRyeSBhZ2FpblxuICAgICAgICAgIHN0YXRlLnBxU3RhdGUgPSAwO1xuICAgICAgICAgIC8vIGRvIHByaW1hbGl0eSB0ZXN0XG4gICAgICAgIH0gZWxzZSBpZihzdGF0ZS5udW0uaXNQcm9iYWJsZVByaW1lKFxuICAgICAgICAgIF9nZXRNaWxsZXJSYWJpblRlc3RzKHN0YXRlLm51bS5iaXRMZW5ndGgoKSkpKSB7XG4gICAgICAgICAgKytzdGF0ZS5wcVN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldCBuZXh0IHBvdGVudGlhbCBwcmltZVxuICAgICAgICAgIHN0YXRlLm51bS5kQWRkT2Zmc2V0KEdDRF8zMF9ERUxUQVtkZWx0YUlkeCsrICUgOF0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMikge1xuICAgICAgICAvLyBlbnN1cmUgbnVtYmVyIGlzIGNvcHJpbWUgd2l0aCBlXG4gICAgICAgIHN0YXRlLnBxU3RhdGUgPVxuICAgICAgICAgIChzdGF0ZS5udW0uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpLmdjZChzdGF0ZS5lKVxuICAgICAgICAgICAgLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT09IDApID8gMyA6IDA7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUucHFTdGF0ZSA9PT0gMykge1xuICAgICAgICAvLyBzdG9yZSBwIG9yIHFcbiAgICAgICAgc3RhdGUucHFTdGF0ZSA9IDA7XG4gICAgICAgIGlmKHN0YXRlLnAgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGF0ZS5wID0gc3RhdGUubnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnEgPSBzdGF0ZS5udW07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZHZhbmNlIHN0YXRlIGlmIGJvdGggcCBhbmQgcSBhcmUgcmVhZHlcbiAgICAgICAgaWYoc3RhdGUucCAhPT0gbnVsbCAmJiBzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5udW0gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihzdGF0ZS5zdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gZW5zdXJlIHAgaXMgbGFyZ2VyIHRoYW4gcSAoc3dhcCB0aGVtIGlmIG5vdClcbiAgICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgICBzdGF0ZS5udW0gPSBzdGF0ZS5wO1xuICAgICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgICAgc3RhdGUucSA9IHN0YXRlLm51bTtcbiAgICAgIH1cbiAgICAgICsrc3RhdGUuc3RhdGU7XG4gICAgfSBlbHNlIGlmKHN0YXRlLnN0YXRlID09PSAyKSB7XG4gICAgICAvLyBjb21wdXRlIHBoaTogKHAgLSAxKShxIC0gMSkgKEV1bGVyJ3MgdG90aWVudCBmdW5jdGlvbilcbiAgICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgICBzdGF0ZS5xMSA9IHN0YXRlLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgc3RhdGUucGhpID0gc3RhdGUucDEubXVsdGlwbHkoc3RhdGUucTEpO1xuICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIGVuc3VyZSBlIGFuZCBwaGkgYXJlIGNvcHJpbWVcbiAgICAgIGlmKHN0YXRlLnBoaS5nY2Qoc3RhdGUuZSkuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA9PT0gMCkge1xuICAgICAgICAvLyBwaGkgYW5kIGUgYXJlIGNvcHJpbWUsIGFkdmFuY2VcbiAgICAgICAgKytzdGF0ZS5zdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBoaSBhbmQgZSBhcmVuJ3QgY29wcmltZSwgc28gZ2VuZXJhdGUgYSBuZXcgcCBhbmQgcVxuICAgICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDQpIHtcbiAgICAgIC8vIGNyZWF0ZSBuLCBlbnN1cmUgbiBpcyBoYXMgdGhlIHJpZ2h0IG51bWJlciBvZiBiaXRzXG4gICAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcblxuICAgICAgLy8gZW5zdXJlIG4gaXMgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICAgIGlmKHN0YXRlLm4uYml0TGVuZ3RoKCkgPT09IHN0YXRlLmJpdHMpIHtcbiAgICAgICAgLy8gc3VjY2VzcywgYWR2YW5jZVxuICAgICAgICArK3N0YXRlLnN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFpbGVkLCBnZXQgbmV3IHFcbiAgICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICAgIHN0YXRlLnN0YXRlID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc3RhdGUuc3RhdGUgPT09IDUpIHtcbiAgICAgIC8vIHNldCBrZXlzXG4gICAgICB2YXIgZCA9IHN0YXRlLmUubW9kSW52ZXJzZShzdGF0ZS5waGkpO1xuICAgICAgc3RhdGUua2V5cyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogcGtpLnJzYS5zZXRQcml2YXRlS2V5KFxuICAgICAgICAgIHN0YXRlLm4sIHN0YXRlLmUsIGQsIHN0YXRlLnAsIHN0YXRlLnEsXG4gICAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgICAgc3RhdGUucS5tb2RJbnZlcnNlKHN0YXRlLnApKSxcbiAgICAgICAgcHVibGljS2V5OiBwa2kucnNhLnNldFB1YmxpY0tleShzdGF0ZS5uLCBzdGF0ZS5lKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGltaW5nXG4gICAgdDIgPSArbmV3IERhdGUoKTtcbiAgICB0b3RhbCArPSB0MiAtIHQxO1xuICAgIHQxID0gdDI7XG4gIH1cblxuICByZXR1cm4gc3RhdGUua2V5cyAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIFJTQSBwdWJsaWMtcHJpdmF0ZSBrZXkgcGFpciBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgaW4gc3RlcHMgKHRvIGFsbG93IGZvciBwcm9ncmVzcyB1cGRhdGVzIGFuZCB0b1xuICogcHJldmVudCBibG9ja2luZyBvciB3YXJuaW5ncyBpbiBzbG93IGJyb3dzZXJzKSB0aGVuIHVzZSB0aGUga2V5LXBhaXJcbiAqIGdlbmVyYXRpb24gc3RhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFRvIGdlbmVyYXRlIGEga2V5LXBhaXIgYXN5bmNocm9ub3VzbHkgKGVpdGhlciB0aHJvdWdoIHdlYi13b3JrZXJzLCBpZlxuICogYXZhaWxhYmxlLCBvciBieSBicmVha2luZyB1cCB0aGUgd29yayBvbiB0aGUgbWFpbiB0aHJlYWQpLCBwYXNzIGFcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSBbYml0c10gdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCBkZWZhdWx0cyB0byAyMDQ4LlxuICogQHBhcmFtIFtlXSB0aGUgcHVibGljIGV4cG9uZW50IHRvIHVzZSwgZGVmYXVsdHMgdG8gNjU1MzcuXG4gKiBAcGFyYW0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIGtleS1wYWlyIGdlbmVyYXRpb24sIGlmIGdpdmVuIHRoZW4gJ2JpdHMnXG4gKiAgICAgICAgICAgIGFuZCAnZScgbXVzdCAqbm90KiBiZSBnaXZlbjpcbiAqICAgICAgICAgIGJpdHMgdGhlIHNpemUgZm9yIHRoZSBwcml2YXRlIGtleSBpbiBiaXRzLCAoZGVmYXVsdDogMjA0OCkuXG4gKiAgICAgICAgICBlIHRoZSBwdWJsaWMgZXhwb25lbnQgdG8gdXNlLCAoZGVmYXVsdDogNjU1MzcgKDB4MTAwMDEpKS5cbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMikuXG4gKiAgICAgICAgICB3b3JrTG9hZCB0aGUgc2l6ZSBvZiB0aGUgd29yayBsb2FkLCBpZTogbnVtYmVyIG9mIHBvc3NpYmxlIHByaW1lXG4gKiAgICAgICAgICAgIG51bWJlcnMgZm9yIGVhY2ggd2ViIHdvcmtlciB0byBjaGVjayBwZXIgd29yayBhc3NpZ25tZW50LFxuICogICAgICAgICAgICAoZGVmYXVsdDogMTAwKS5cbiAqICAgICAgICAgIHBybmcgYSBjdXN0b20gY3J5cHRvLXNlY3VyZSBwc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgdG8gdXNlLFxuICogICAgICAgICAgICB0aGF0IG11c3QgZGVmaW5lIFwiZ2V0Qnl0ZXNTeW5jXCIuIERpc2FibGVzIHVzZSBvZiBuYXRpdmUgQVBJcy5cbiAqICAgICAgICAgIGFsZ29yaXRobSB0aGUgYWxnb3JpdGhtIHRvIHVzZSAoZGVmYXVsdDogJ1BSSU1FSU5DJykuXG4gKiBAcGFyYW0gW2NhbGxiYWNrKGVyciwga2V5cGFpcildIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICpcbiAqIEByZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJpdmF0ZUtleSBhbmQgcHVibGljS2V5IHByb3BlcnRpZXMuXG4gKi9cbnBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyID0gZnVuY3Rpb24oYml0cywgZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gKGJpdHMpLCAob3B0aW9ucyksIChjYWxsYmFjaylcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmKHR5cGVvZiBiaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJpdHM7XG4gICAgICBiaXRzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgYml0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBiaXRzO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gKGJpdHMsIGUpLCAoYml0cywgb3B0aW9ucyksIChiaXRzLCBjYWxsYmFjayksIChvcHRpb25zLCBjYWxsYmFjaylcbiAgICBpZih0eXBlb2YgYml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmKHR5cGVvZiBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgICAgZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgb3B0aW9ucyA9IGU7XG4gICAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBiaXRzO1xuICAgICAgY2FsbGJhY2sgPSBlO1xuICAgICAgYml0cyA9IHVuZGVmaW5lZDtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIC8vIChiaXRzLCBlLCBvcHRpb25zKSwgKGJpdHMsIGUsIGNhbGxiYWNrKSwgKGJpdHMsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIGlmKHR5cGVvZiBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gZTtcbiAgICAgIGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZihiaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBiaXRzID0gb3B0aW9ucy5iaXRzIHx8IDIwNDg7XG4gIH1cbiAgaWYoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZSA9IG9wdGlvbnMuZSB8fCAweDEwMDAxO1xuICB9XG5cbiAgLy8gdXNlIG5hdGl2ZSBjb2RlIGlmIHBlcm1pdHRlZCwgYXZhaWxhYmxlLCBhbmQgcGFyYW1ldGVycyBhcmUgYWNjZXB0YWJsZVxuICBpZighZm9yZ2Uub3B0aW9ucy51c2VQdXJlSmF2YVNjcmlwdCAmJiAhb3B0aW9ucy5wcm5nICYmXG4gICAgYml0cyA+PSAyNTYgJiYgYml0cyA8PSAxNjM4NCAmJiAoZSA9PT0gMHgxMDAwMSB8fCBlID09PSAzKSkge1xuICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIGFzeW5jXG4gICAgICBpZihfZGV0ZWN0Tm9kZUNyeXB0bygnZ2VuZXJhdGVLZXlQYWlyJykpIHtcbiAgICAgICAgcmV0dXJuIF9jcnlwdG8uZ2VuZXJhdGVLZXlQYWlyKCdyc2EnLCB7XG4gICAgICAgICAgbW9kdWx1c0xlbmd0aDogYml0cyxcbiAgICAgICAgICBwdWJsaWNFeHBvbmVudDogZSxcbiAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ3Nwa2knLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpdmF0ZUtleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAncGtjczgnLFxuICAgICAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwdWIsIHByaXYpIHtcbiAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0ocHJpdiksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKHB1YilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZihfZGV0ZWN0U3VidGxlQ3J5cHRvKCdnZW5lcmF0ZUtleScpICYmXG4gICAgICAgIF9kZXRlY3RTdWJ0bGVDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIC8vIHVzZSBzdGFuZGFyZCBuYXRpdmUgZ2VuZXJhdGVLZXlcbiAgICAgICAgcmV0dXJuIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBfaW50VG9VaW50OEFycmF5KGUpLFxuICAgICAgICAgIGhhc2g6IHtuYW1lOiAnU0hBLTI1Nid9XG4gICAgICAgIH0sIHRydWUgLyoga2V5IGNhbiBiZSBleHBvcnRlZCovLCBbJ3NpZ24nLCAndmVyaWZ5J10pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5nbG9iYWxTY29wZS5jcnlwdG8uc3VidGxlLmV4cG9ydEtleShcbiAgICAgICAgICAgICdwa2NzOCcsIHBhaXIucHJpdmF0ZUtleSk7XG4gICAgICAgIC8vIGF2b2lkaW5nIGNhdGNoKGZ1bmN0aW9uKGVycikgey4uLn0pIHRvIHN1cHBvcnQgSUUgPD0gOFxuICAgICAgICB9KS50aGVuKHVuZGVmaW5lZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihwa2NzOCkge1xuICAgICAgICAgIGlmKHBrY3M4KSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHBraS5wcml2YXRlS2V5RnJvbUFzbjEoXG4gICAgICAgICAgICAgIGFzbjEuZnJvbURlcihmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihwa2NzOCkpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleSxcbiAgICAgICAgICAgICAgcHVibGljS2V5OiBwa2kuc2V0UnNhUHVibGljS2V5KHByaXZhdGVLZXkubiwgcHJpdmF0ZUtleS5lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKF9kZXRlY3RTdWJ0bGVNc0NyeXB0bygnZ2VuZXJhdGVLZXknKSAmJlxuICAgICAgICBfZGV0ZWN0U3VidGxlTXNDcnlwdG8oJ2V4cG9ydEtleScpKSB7XG4gICAgICAgIHZhciBnZW5PcCA9IHV0aWwuZ2xvYmFsU2NvcGUubXNDcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGJpdHMsXG4gICAgICAgICAgcHVibGljRXhwb25lbnQ6IF9pbnRUb1VpbnQ4QXJyYXkoZSksXG4gICAgICAgICAgaGFzaDoge25hbWU6ICdTSEEtMjU2J31cbiAgICAgICAgfSwgdHJ1ZSAvKiBrZXkgY2FuIGJlIGV4cG9ydGVkKi8sIFsnc2lnbicsICd2ZXJpZnknXSk7XG4gICAgICAgIGdlbk9wLm9uY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgdmFyIGV4cG9ydE9wID0gdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KFxuICAgICAgICAgICAgJ3BrY3M4JywgcGFpci5wcml2YXRlS2V5KTtcbiAgICAgICAgICBleHBvcnRPcC5vbmNvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHBrY3M4ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgdmFyIHByaXZhdGVLZXkgPSBwa2kucHJpdmF0ZUtleUZyb21Bc24xKFxuICAgICAgICAgICAgICBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIocGtjczgpKSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXksXG4gICAgICAgICAgICAgIHB1YmxpY0tleTogcGtpLnNldFJzYVB1YmxpY0tleShwcml2YXRlS2V5Lm4sIHByaXZhdGVLZXkuZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwb3J0T3Aub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBnZW5PcC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cnkgbmF0aXZlIHN5bmNcbiAgICAgIGlmKF9kZXRlY3ROb2RlQ3J5cHRvKCdnZW5lcmF0ZUtleVBhaXJTeW5jJykpIHtcbiAgICAgICAgdmFyIGtleXBhaXIgPSBfY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoJ3JzYScsIHtcbiAgICAgICAgICBtb2R1bHVzTGVuZ3RoOiBiaXRzLFxuICAgICAgICAgIHB1YmxpY0V4cG9uZW50OiBlLFxuICAgICAgICAgIHB1YmxpY0tleUVuY29kaW5nOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3BraScsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdwa2NzOCcsXG4gICAgICAgICAgICBmb3JtYXQ6ICdwZW0nXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcml2YXRlS2V5OiBwa2kucHJpdmF0ZUtleUZyb21QZW0oa2V5cGFpci5wcml2YXRlS2V5KSxcbiAgICAgICAgICBwdWJsaWNLZXk6IHBraS5wdWJsaWNLZXlGcm9tUGVtKGtleXBhaXIucHVibGljS2V5KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHVzZSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uXG4gIHZhciBzdGF0ZSA9IHBraS5yc2EuY3JlYXRlS2V5UGFpckdlbmVyYXRpb25TdGF0ZShiaXRzLCBlLCBvcHRpb25zKTtcbiAgaWYoIWNhbGxiYWNrKSB7XG4gICAgcGtpLnJzYS5zdGVwS2V5UGFpckdlbmVyYXRpb25TdGF0ZShzdGF0ZSwgMCk7XG4gICAgcmV0dXJuIHN0YXRlLmtleXM7XG4gIH1cbiAgX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cyBhbmQgZXhwb25lbnQuXG4gKlxuICogQHBhcmFtIG4gdGhlIG1vZHVsdXMuXG4gKiBAcGFyYW0gZSB0aGUgZXhwb25lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnNldFJzYVB1YmxpY0tleSA9IHBraS5yc2Euc2V0UHVibGljS2V5ID0gZnVuY3Rpb24obiwgZSkge1xuICB2YXIga2V5ID0ge1xuICAgIG46IG4sXG4gICAgZTogZVxuICB9O1xuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHVibGljIGtleS4gTmV3ZXIgYXBwbGljYXRpb25zXG4gICAqIHNob3VsZCB1c2UgdGhlICdSU0EtT0FFUCcgZGVjcnlwdGlvbiBzY2hlbWUsICdSU0FFUy1QS0NTMS1WMV81JyBpcyBmb3JcbiAgICogbGVnYWN5IGFwcGxpY2F0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgdGhlIGJ5dGUgc3RyaW5nIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSBzY2hlbWUgdGhlIGVuY3J5cHRpb24gc2NoZW1lIHRvIHVzZTpcbiAgICogICAgICAgICAgJ1JTQUVTLVBLQ1MxLVYxXzUnIChkZWZhdWx0KSxcbiAgICogICAgICAgICAgJ1JTQS1PQUVQJyxcbiAgICogICAgICAgICAgJ1JBVycsICdOT05FJywgb3IgbnVsbCB0byBwZXJmb3JtIHJhdyBSU0EgZW5jcnlwdGlvbixcbiAgICogICAgICAgICAgYW4gb2JqZWN0IHdpdGggYW4gJ2VuY29kZScgcHJvcGVydHkgc2V0IHRvIGEgZnVuY3Rpb25cbiAgICogICAgICAgICAgd2l0aCB0aGUgc2lnbmF0dXJlICdmdW5jdGlvbihkYXRhLCBrZXkpJyB0aGF0IHJldHVybnNcbiAgICogICAgICAgICAgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlbmNvZGVkIGRhdGEuXG4gICAqIEBwYXJhbSBzY2hlbWVPcHRpb25zIGFueSBzY2hlbWUtc3BlY2lmaWMgb3B0aW9ucy5cbiAgICpcbiAgICogQHJldHVybiB0aGUgZW5jcnlwdGVkIGJ5dGUgc3RyaW5nLlxuICAgKi9cbiAga2V5LmVuY3J5cHQgPSBmdW5jdGlvbihkYXRhLCBzY2hlbWUsIHNjaGVtZU9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgc2NoZW1lID0gc2NoZW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2hlbWUgPSAnUlNBRVMtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBRVMtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbihtLCBrZXksIHB1Yikge1xuICAgICAgICAgIHJldHVybiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIDB4MDIpLmdldEJ5dGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ1JTQS1PQUVQJyB8fCBzY2hlbWUgPT09ICdSU0FFUy1PQUVQJykge1xuICAgICAgc2NoZW1lID0ge1xuICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKG0sIGtleSkge1xuICAgICAgICAgIHJldHVybiBmb3JnZS5wa2NzMS5lbmNvZGVfcnNhX29hZXAoa2V5LCBtLCBzY2hlbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoWydSQVcnLCAnTk9ORScsICdOVUxMJywgbnVsbF0uaW5kZXhPZihzY2hlbWUpICE9PSAtMSkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oZSkge3JldHVybiBlO319O1xuICAgIH0gZWxzZSBpZih0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRvIHNjaGVtZS1iYXNlZCBlbmNvZGluZyB0aGVuIHJzYSBlbmNyeXB0aW9uXG4gICAgdmFyIGUgPSBzY2hlbWUuZW5jb2RlKGRhdGEsIGtleSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChlLCBrZXksIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgZ2l2ZW4gc2lnbmF0dXJlIGFnYWluc3QgdGhlIGdpdmVuIGRpZ2VzdC5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNSwgaW4gd2hpY2ggY2FzZSBvbmNlIFJTQS1kZWNyeXB0ZWQsIHRoZVxuICAgKiBzaWduYXR1cmUgaXMgYW4gT0NURVQgU1RSSU5HIHRoYXQgaG9sZHMgYSBEaWdlc3RJbmZvLlxuICAgKlxuICAgKiBEaWdlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gICAqICAgZGlnZXN0QWxnb3JpdGhtIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIsXG4gICAqICAgZGlnZXN0IERpZ2VzdFxuICAgKiB9XG4gICAqIERpZ2VzdEFsZ29yaXRobUlkZW50aWZpZXIgOjo9IEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICogRGlnZXN0IDo6PSBPQ1RFVCBTVFJJTkdcbiAgICpcbiAgICogVG8gcGVyZm9ybSBQU1Mgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiwgcHJvdmlkZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBGb3JnZSBQU1Mgb2JqZWN0IGFzIHRoZSBzY2hlbWUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gZGlnZXN0IHRoZSBtZXNzYWdlIGRpZ2VzdCBoYXNoIHRvIGNvbXBhcmUgYWdhaW5zdCB0aGUgc2lnbmF0dXJlLFxuICAgKiAgICAgICAgICBhcyBhIGJpbmFyeS1lbmNvZGVkIHN0cmluZy5cbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeSwgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gICAqIEBwYXJhbSBzY2hlbWUgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBU1NBLVBLQ1MxLVYxXzUnIG9yIHVuZGVmaW5lZCBmb3IgUlNBU1NBIFBLQ1MjMSB2MS41LFxuICAgKiAgICAgICAgICBhIEZvcmdlIFBTUyBvYmplY3QgZm9yIFJTQVNTQS1QU1MsXG4gICAqICAgICAgICAgICdOT05FJyBvciBudWxsIGZvciBub25lLCBEaWdlc3RJbmZvIHdpbGwgbm90IGJlIGV4cGVjdGVkLCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHRoZSBzaWduYXR1cmUgd2FzIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBrZXkudmVyaWZ5ID0gZnVuY3Rpb24oZGlnZXN0LCBzaWduYXR1cmUsIHNjaGVtZSkge1xuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNjaGVtZSA9ICdSU0FTU0EtUEtDUzEtVjFfNSc7XG4gICAgfVxuXG4gICAgaWYoc2NoZW1lID09PSAnUlNBU1NBLVBLQ1MxLVYxXzUnKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICAvLyBkIGlzIEFTTi4xIEJFUi1lbmNvZGVkIERpZ2VzdEluZm9cbiAgICAgICAgICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKGQpO1xuICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIGdpdmVuIGRpZ2VzdCB0byB0aGUgZGVjcnlwdGVkIG9uZVxuICAgICAgICAgIHJldHVybiBkaWdlc3QgPT09IG9iai52YWx1ZVsxXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoc2NoZW1lID09PSAnTk9ORScgfHwgc2NoZW1lID09PSAnTlVMTCcgfHwgc2NoZW1lID09PSBudWxsKSB7XG4gICAgICBzY2hlbWUgPSB7XG4gICAgICAgIHZlcmlmeTogZnVuY3Rpb24oZGlnZXN0LCBkKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHBhZGRpbmdcbiAgICAgICAgICBkID0gX2RlY29kZVBrY3MxX3YxXzUoZCwga2V5LCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gZGlnZXN0ID09PSBkO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmcsIHRoZW4gdmVyaWZ5IC0tIHdoaWNoIGRvZXMgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChzaWduYXR1cmUsIGtleSwgdHJ1ZSwgZmFsc2UpO1xuICAgIHJldHVybiBzY2hlbWUudmVyaWZ5KGRpZ2VzdCwgZCwga2V5Lm4uYml0TGVuZ3RoKCkpO1xuICB9O1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gUlNBIHByaXZhdGUga2V5IGZyb20gQmlnSW50ZWdlcnMgbW9kdWx1cywgZXhwb25lbnQsIHByaW1lcyxcbiAqIHByaW1lIGV4cG9uZW50cywgYW5kIG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbW9kdWx1cy5cbiAqIEBwYXJhbSBlIHRoZSBwdWJsaWMgZXhwb25lbnQuXG4gKiBAcGFyYW0gZCB0aGUgcHJpdmF0ZSBleHBvbmVudCAoKGludmVyc2Ugb2YgZSkgbW9kIG4pLlxuICogQHBhcmFtIHAgdGhlIGZpcnN0IHByaW1lLlxuICogQHBhcmFtIHEgdGhlIHNlY29uZCBwcmltZS5cbiAqIEBwYXJhbSBkUCBleHBvbmVudDEgKGQgbW9kIChwLTEpKS5cbiAqIEBwYXJhbSBkUSBleHBvbmVudDIgKGQgbW9kIChxLTEpKS5cbiAqIEBwYXJhbSBxSW52ICgoaW52ZXJzZSBvZiBxKSBtb2QgcClcbiAqXG4gKiBAcmV0dXJuIHRoZSBwcml2YXRlIGtleS5cbiAqL1xucGtpLnNldFJzYVByaXZhdGVLZXkgPSBwa2kucnNhLnNldFByaXZhdGVLZXkgPSBmdW5jdGlvbihcbiAgbiwgZSwgZCwgcCwgcSwgZFAsIGRRLCBxSW52KSB7XG4gIHZhciBrZXkgPSB7XG4gICAgbjogbixcbiAgICBlOiBlLFxuICAgIGQ6IGQsXG4gICAgcDogcCxcbiAgICBxOiBxLFxuICAgIGRQOiBkUCxcbiAgICBkUTogZFEsXG4gICAgcUludjogcUludlxuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoaXMgcHJpdmF0ZSBrZXkuIFRoZSBkZWNyeXB0aW9uIHNjaGVtZVxuICAgKiBtdXN0IG1hdGNoIHRoZSBvbmUgdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSB0aGUgYnl0ZSBzdHJpbmcgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgZGVjcnlwdGlvbiBzY2hlbWUgdG8gdXNlOlxuICAgKiAgICAgICAgICAnUlNBRVMtUEtDUzEtVjFfNScgKGRlZmF1bHQpLFxuICAgKiAgICAgICAgICAnUlNBLU9BRVAnLFxuICAgKiAgICAgICAgICAnUkFXJywgJ05PTkUnLCBvciBudWxsIHRvIHBlcmZvcm0gcmF3IFJTQSBkZWNyeXB0aW9uLlxuICAgKiBAcGFyYW0gc2NoZW1lT3B0aW9ucyBhbnkgc2NoZW1lLXNwZWNpZmljIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGRlY3J5cHRlZCBieXRlIHN0cmluZy5cbiAgICovXG4gIGtleS5kZWNyeXB0ID0gZnVuY3Rpb24oZGF0YSwgc2NoZW1lLCBzY2hlbWVPcHRpb25zKSB7XG4gICAgaWYodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNjaGVtZSA9IHNjaGVtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NoZW1lID0gJ1JTQUVTLVBLQ1MxLVYxXzUnO1xuICAgIH1cblxuICAgIC8vIGRvIHJzYSBkZWNyeXB0aW9uIHcvbyBhbnkgZGVjb2RpbmdcbiAgICB2YXIgZCA9IHBraS5yc2EuZGVjcnlwdChkYXRhLCBrZXksIGZhbHNlLCBmYWxzZSk7XG5cbiAgICBpZihzY2hlbWUgPT09ICdSU0FFUy1QS0NTMS1WMV81Jykge1xuICAgICAgc2NoZW1lID0ge2RlY29kZTogX2RlY29kZVBrY3MxX3YxXzV9O1xuICAgIH0gZWxzZSBpZihzY2hlbWUgPT09ICdSU0EtT0FFUCcgfHwgc2NoZW1lID09PSAnUlNBRVMtT0FFUCcpIHtcbiAgICAgIHNjaGVtZSA9IHtcbiAgICAgICAgZGVjb2RlOiBmdW5jdGlvbihkLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZm9yZ2UucGtjczEuZGVjb2RlX3JzYV9vYWVwKGtleSwgZCwgc2NoZW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKFsnUkFXJywgJ05PTkUnLCAnTlVMTCcsIG51bGxdLmluZGV4T2Yoc2NoZW1lKSAhPT0gLTEpIHtcbiAgICAgIHNjaGVtZSA9IHtkZWNvZGU6IGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDt9fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIHNjaGVtZTogXCInICsgc2NoZW1lICsgJ1wiLicpO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBhY2NvcmRpbmcgdG8gc2NoZW1lXG4gICAgcmV0dXJuIHNjaGVtZS5kZWNvZGUoZCwga2V5LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBkaWdlc3QsIHByb2R1Y2luZyBhIHNpZ25hdHVyZS5cbiAgICpcbiAgICogUEtDUyMxIHN1cHBvcnRzIG11bHRpcGxlIChjdXJyZW50bHkgdHdvKSBzaWduYXR1cmUgc2NoZW1lczpcbiAgICogUlNBU1NBLVBLQ1MxLVYxXzUgYW5kIFJTQVNTQS1QU1MuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQgdGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBcIm9sZCBzY2hlbWVcIiwgaS5lLlxuICAgKiBSU0FTU0EtUEtDUzEtVjFfNS4gSW4gb3JkZXIgdG8gZ2VuZXJhdGUgYSBQU1Mgc2lnbmF0dXJlLCBwcm92aWRlXG4gICAqIGFuIGluc3RhbmNlIG9mIEZvcmdlIFBTUyBvYmplY3QgYXMgdGhlIHNjaGVtZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHdpdGggdGhlIGhhc2ggdG8gc2lnbi5cbiAgICogQHBhcmFtIHNjaGVtZSB0aGUgc2lnbmF0dXJlIHNjaGVtZSB0byB1c2U6XG4gICAqICAgICAgICAgICdSU0FTU0EtUEtDUzEtVjFfNScgb3IgdW5kZWZpbmVkIGZvciBSU0FTU0EgUEtDUyMxIHYxLjUsXG4gICAqICAgICAgICAgIGEgRm9yZ2UgUFNTIG9iamVjdCBmb3IgUlNBU1NBLVBTUyxcbiAgICogICAgICAgICAgJ05PTkUnIG9yIG51bGwgZm9yIG5vbmUsIERpZ2VzdEluZm8gd2lsbCBub3QgYmUgdXNlZCBidXRcbiAgICogICAgICAgICAgICBQS0NTIzEgdjEuNSBwYWRkaW5nIHdpbGwgc3RpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgc2lnbmF0dXJlIGFzIGEgYnl0ZSBzdHJpbmcuXG4gICAqL1xuICBrZXkuc2lnbiA9IGZ1bmN0aW9uKG1kLCBzY2hlbWUpIHtcbiAgICAvKiBOb3RlOiBUaGUgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgUlNBIG9wZXJhdGlvbnMgaXMgYmVpbmdcbiAgICAgIHRyYW5zaXRpb25lZCBhd2F5IGZyb20gYSBQS0NTIzEgdjEuNSBoYXJkLWNvZGVkIHNjaGVtZS4gU29tZSBsZWdhY3lcbiAgICAgIGNvZGUgbGlrZSB0aGUgdXNlIG9mIGFuIGVuY29kaW5nIGJsb2NrIGlkZW50aWZpZXIgJ2J0JyB3aWxsIGV2ZW50dWFsbHlcbiAgICAgIGJlIHJlbW92ZWQuICovXG5cbiAgICAvLyBwcml2YXRlIGtleSBvcGVyYXRpb25cbiAgICB2YXIgYnQgPSBmYWxzZTtcblxuICAgIGlmKHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzY2hlbWUgPSBzY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZihzY2hlbWUgPT09IHVuZGVmaW5lZCB8fCBzY2hlbWUgPT09ICdSU0FTU0EtUEtDUzEtVjFfNScpIHtcbiAgICAgIHNjaGVtZSA9IHtlbmNvZGU6IGVtc2FQa2NzMXYxNWVuY29kZX07XG4gICAgICBidCA9IDB4MDE7XG4gICAgfSBlbHNlIGlmKHNjaGVtZSA9PT0gJ05PTkUnIHx8IHNjaGVtZSA9PT0gJ05VTEwnIHx8IHNjaGVtZSA9PT0gbnVsbCkge1xuICAgICAgc2NoZW1lID0ge2VuY29kZTogZnVuY3Rpb24oKSB7cmV0dXJuIG1kO319O1xuICAgICAgYnQgPSAweDAxO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSBhbmQgdGhlbiBlbmNyeXB0XG4gICAgdmFyIGQgPSBzY2hlbWUuZW5jb2RlKG1kLCBrZXkubi5iaXRMZW5ndGgoKSk7XG4gICAgcmV0dXJuIHBraS5yc2EuZW5jcnlwdChkLCBrZXksIGJ0KTtcbiAgfTtcblxuICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKiBXcmFwcyBhbiBSU0FQcml2YXRlS2V5IEFTTi4xIG9iamVjdCBpbiBhbiBBU04uMSBQcml2YXRlS2V5SW5mbyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJzYUtleSB0aGUgQVNOLjEgUlNBUHJpdmF0ZUtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBQcml2YXRlS2V5SW5mby5cbiAqL1xucGtpLndyYXBSc2FQcml2YXRlS2V5ID0gZnVuY3Rpb24ocnNhS2V5KSB7XG4gIC8vIFByaXZhdGVLZXlJbmZvXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMClcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgYXNuMS5pbnRlZ2VyVG9EZXIoMCkuZ2V0Qnl0ZXMoKSksXG4gICAgLy8gcHJpdmF0ZUtleUFsZ29yaXRobVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIocGtpLm9pZHMucnNhRW5jcnlwdGlvbikuZ2V0Qnl0ZXMoKSksXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBQcml2YXRlS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsXG4gICAgICBhc24xLnRvRGVyKHJzYUtleSkuZ2V0Qnl0ZXMoKSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJpdmF0ZSBrZXkgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYSBQcml2YXRlS2V5SW5mbyBjb250YWluaW5nIGFuXG4gKiAgICAgICAgICBSU0FQcml2YXRlS2V5IG9yIGFuIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHJpdmF0ZSBrZXkuXG4gKi9cbnBraS5wcml2YXRlS2V5RnJvbUFzbjEgPSBmdW5jdGlvbihvYmopIHtcbiAgLy8gZ2V0IFByaXZhdGVLZXlJbmZvXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoYXNuMS52YWxpZGF0ZShvYmosIHByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICBvYmogPSBhc24xLmZyb21EZXIoZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5KSk7XG4gIH1cblxuICAvLyBnZXQgUlNBUHJpdmF0ZUtleVxuICBjYXB0dXJlID0ge307XG4gIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYVByaXZhdGVLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHByaXZhdGUga2V5LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhbiBSU0FQcml2YXRlS2V5LicpO1xuICAgIGVycm9yLmVycm9ycyA9IGVycm9ycztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8vIE5vdGU6IFZlcnNpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4gIC8vIGNhcHR1cmUucHJpdmF0ZUtleVZlcnNpb25cbiAgLy8gRklYTUU6IGluZWZmaWNpZW50LCBnZXQgYSBCaWdJbnRlZ2VyIHRoYXQgdXNlcyBieXRlIHN0cmluZ3NcbiAgdmFyIG4sIGUsIGQsIHAsIHEsIGRQLCBkUSwgcUludjtcbiAgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleU1vZHVsdXMpLnRvSGV4KCk7XG4gIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlQdWJsaWNFeHBvbmVudCkudG9IZXgoKTtcbiAgZCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaXZhdGVFeHBvbmVudCkudG9IZXgoKTtcbiAgcCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMSkudG9IZXgoKTtcbiAgcSA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHJpdmF0ZUtleVByaW1lMikudG9IZXgoKTtcbiAgZFAgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnByaXZhdGVLZXlFeHBvbmVudDEpLnRvSGV4KCk7XG4gIGRRID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5RXhwb25lbnQyKS50b0hleCgpO1xuICBxSW52ID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5wcml2YXRlS2V5Q29lZmZpY2llbnQpLnRvSGV4KCk7XG5cbiAgLy8gc2V0IHByaXZhdGUga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBuZXcgQmlnSW50ZWdlcihuLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGQsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihwLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIocSwgMTYpLFxuICAgIG5ldyBCaWdJbnRlZ2VyKGRQLCAxNiksXG4gICAgbmV3IEJpZ0ludGVnZXIoZFEsIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihxSW52LCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByaXZhdGUga2V5IHRvIGFuIEFTTi4xIFJTQVByaXZhdGVLZXkuXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgcmVwcmVzZW50YXRpb24gb2YgYW4gUlNBUHJpdmF0ZUtleS5cbiAqL1xucGtpLnByaXZhdGVLZXlUb0FzbjEgPSBwa2kucHJpdmF0ZUtleVRvUlNBUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBSU0FQcml2YXRlS2V5XG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gdmVyc2lvbiAoMCA9IG9ubHkgMiBwcmltZXMsIDEgbXVsdGlwbGUgcHJpbWVzKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBhc24xLmludGVnZXJUb0RlcigwKS5nZXRCeXRlcygpKSxcbiAgICAvLyBtb2R1bHVzIChuKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5uKSksXG4gICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmUpKSxcbiAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5LmQpKSxcbiAgICAvLyBwcml2YXRlS2V5UHJpbWUxIChwKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5wKSksXG4gICAgLy8gcHJpdmF0ZUtleVByaW1lMiAocSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkucSkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDEgKGRQKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUCkpLFxuICAgIC8vIHByaXZhdGVLZXlFeHBvbmVudDIgKGRRKVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5kUSkpLFxuICAgIC8vIGNvZWZmaWNpZW50IChxSW52KVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsXG4gICAgICBfYm5Ub0J5dGVzKGtleS5xSW52KSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSBmcm9tIGFuIEFTTi4xIFN1YmplY3RQdWJsaWNLZXlJbmZvIG9yIFJTQVB1YmxpY0tleS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8gb3IgUlNBUHVibGljS2V5LlxuICpcbiAqIEByZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlGcm9tQXNuMSA9IGZ1bmN0aW9uKG9iaikge1xuICAvLyBnZXQgU3ViamVjdFB1YmxpY0tleUluZm9cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZihhc24xLnZhbGlkYXRlKG9iaiwgcHVibGljS2V5VmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgLy8gZ2V0IG9pZFxuICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgICBpZihvaWQgIT09IHBraS5vaWRzLnJzYUVuY3J5cHRpb24pIHtcbiAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgcHVibGljIGtleS4gVW5rbm93biBPSUQuJyk7XG4gICAgICBlcnJvci5vaWQgPSBvaWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgb2JqID0gY2FwdHVyZS5yc2FQdWJsaWNLZXk7XG4gIH1cblxuICAvLyBnZXQgUlNBIHBhcmFtc1xuICBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCByc2FQdWJsaWNLZXlWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHB1YmxpYyBrZXkuICcgK1xuICAgICAgJ0FTTi4xIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFuIFJTQVB1YmxpY0tleS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBGSVhNRTogaW5lZmZpY2llbnQsIGdldCBhIEJpZ0ludGVnZXIgdGhhdCB1c2VzIGJ5dGUgc3RyaW5nc1xuICB2YXIgbiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKGNhcHR1cmUucHVibGljS2V5TW9kdWx1cykudG9IZXgoKTtcbiAgdmFyIGUgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcihjYXB0dXJlLnB1YmxpY0tleUV4cG9uZW50KS50b0hleCgpO1xuXG4gIC8vIHNldCBwdWJsaWMga2V5XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIG5ldyBCaWdJbnRlZ2VyKG4sIDE2KSxcbiAgICBuZXcgQmlnSW50ZWdlcihlLCAxNikpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKlxuICogQHBhcmFtIGtleSB0aGUgcHVibGljIGtleS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIHJlcHJlc2VudGF0aW9uIG9mIGEgU3ViamVjdFB1YmxpY0tleUluZm8uXG4gKi9cbnBraS5wdWJsaWNLZXlUb0FzbjEgPSBwa2kucHVibGljS2V5VG9TdWJqZWN0UHVibGljS2V5SW5mbyA9IGZ1bmN0aW9uKGtleSkge1xuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXJcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBhbGdvcml0aG1cbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgYXNuMS5vaWRUb0Rlcihwa2kub2lkcy5yc2FFbmNyeXB0aW9uKS5nZXRCeXRlcygpKSxcbiAgICAgIC8vIHBhcmFtZXRlcnMgKG51bGwpXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICBdKSxcbiAgICAvLyBzdWJqZWN0UHVibGljS2V5XG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBbXG4gICAgICBwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KVxuICAgIF0pXG4gIF0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gYW4gQVNOLjEgUlNBUHVibGljS2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFJTQVB1YmxpY0tleS5cbiAqL1xucGtpLnB1YmxpY0tleVRvUlNBUHVibGljS2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIFJTQVB1YmxpY0tleVxuICByZXR1cm4gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIF9iblRvQnl0ZXMoa2V5Lm4pKSxcbiAgICAvLyBwdWJsaWNFeHBvbmVudCAoZSlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgX2JuVG9CeXRlcyhrZXkuZSkpXG4gIF0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBtIHRoZSBtZXNzYWdlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBrZXkgdGhlIFJTQSBrZXkgdG8gdXNlLlxuICogQHBhcmFtIGJ0IHRoZSBibG9jayB0eXBlIHRvIHVzZSwgaS5lLiBlaXRoZXIgMHgwMSAoZm9yIHNpZ25pbmcpIG9yIDB4MDJcbiAqICAgICAgICAgIChmb3IgZW5jcnlwdGlvbikuXG4gKlxuICogQHJldHVybiB0aGUgcGFkZGVkIGJ5dGUgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfZW5jb2RlUGtjczFfdjFfNShtLCBrZXksIGJ0KSB7XG4gIHZhciBlYiA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIG1vZHVsdXMgaW4gYnl0ZXNcbiAgdmFyIGsgPSBNYXRoLmNlaWwoa2V5Lm4uYml0TGVuZ3RoKCkgLyA4KTtcblxuICAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyAqL1xuICBpZihtLmxlbmd0aCA+IChrIC0gMTEpKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdNZXNzYWdlIGlzIHRvbyBsb25nIGZvciBQS0NTIzEgdjEuNSBwYWRkaW5nLicpO1xuICAgIGVycm9yLmxlbmd0aCA9IG0ubGVuZ3RoO1xuICAgIGVycm9yLm1heCA9IGsgLSAxMTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIC8qIEEgYmxvY2sgdHlwZSBCVCwgYSBwYWRkaW5nIHN0cmluZyBQUywgYW5kIHRoZSBkYXRhIEQgc2hhbGwgYmVcbiAgICBmb3JtYXR0ZWQgaW50byBhbiBvY3RldCBzdHJpbmcgRUIsIHRoZSBlbmNyeXB0aW9uIGJsb2NrOlxuXG4gICAgRUIgPSAwMCB8fCBCVCB8fCBQUyB8fCAwMCB8fCBEXG5cbiAgICBUaGUgYmxvY2sgdHlwZSBCVCBzaGFsbCBiZSBhIHNpbmdsZSBvY3RldCBpbmRpY2F0aW5nIHRoZSBzdHJ1Y3R1cmUgb2ZcbiAgICB0aGUgZW5jcnlwdGlvbiBibG9jay4gRm9yIHRoaXMgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQgaXQgc2hhbGwgaGF2ZVxuICAgIHZhbHVlIDAwLCAwMSwgb3IgMDIuIEZvciBhIHByaXZhdGUta2V5IG9wZXJhdGlvbiwgdGhlIGJsb2NrIHR5cGVcbiAgICBzaGFsbCBiZSAwMCBvciAwMS4gRm9yIGEgcHVibGljLWtleSBvcGVyYXRpb24sIGl0IHNoYWxsIGJlIDAyLlxuXG4gICAgVGhlIHBhZGRpbmcgc3RyaW5nIFBTIHNoYWxsIGNvbnNpc3Qgb2Ygay0zLXx8RHx8IG9jdGV0cy4gRm9yIGJsb2NrXG4gICAgdHlwZSAwMCwgdGhlIG9jdGV0cyBzaGFsbCBoYXZlIHZhbHVlIDAwOyBmb3IgYmxvY2sgdHlwZSAwMSwgdGhleVxuICAgIHNoYWxsIGhhdmUgdmFsdWUgRkY7IGFuZCBmb3IgYmxvY2sgdHlwZSAwMiwgdGhleSBzaGFsbCBiZVxuICAgIHBzZXVkb3JhbmRvbWx5IGdlbmVyYXRlZCBhbmQgbm9uemVyby4gVGhpcyBtYWtlcyB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIGVuY3J5cHRpb24gYmxvY2sgRUIgZXF1YWwgdG8gay4gKi9cblxuICAvLyBidWlsZCB0aGUgZW5jcnlwdGlvbiBibG9ja1xuICBlYi5wdXRCeXRlKDB4MDApO1xuICBlYi5wdXRCeXRlKGJ0KTtcblxuICAvLyBjcmVhdGUgdGhlIHBhZGRpbmdcbiAgdmFyIHBhZE51bSA9IGsgLSAzIC0gbS5sZW5ndGg7XG4gIHZhciBwYWRCeXRlO1xuICAvLyBwcml2YXRlIGtleSBvcFxuICBpZihidCA9PT0gMHgwMCB8fCBidCA9PT0gMHgwMSkge1xuICAgIHBhZEJ5dGUgPSAoYnQgPT09IDB4MDApID8gMHgwMCA6IDB4RkY7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhZE51bTsgKytpKSB7XG4gICAgICBlYi5wdXRCeXRlKHBhZEJ5dGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwdWJsaWMga2V5IG9wXG4gICAgLy8gcGFkIHdpdGggcmFuZG9tIG5vbi16ZXJvIHZhbHVlc1xuICAgIHdoaWxlKHBhZE51bSA+IDApIHtcbiAgICAgIHZhciBudW1aZXJvcyA9IDA7XG4gICAgICB2YXIgcGFkQnl0ZXMgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMocGFkTnVtKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYWROdW07ICsraSkge1xuICAgICAgICBwYWRCeXRlID0gcGFkQnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYocGFkQnl0ZSA9PT0gMCkge1xuICAgICAgICAgICsrbnVtWmVyb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWIucHV0Qnl0ZShwYWRCeXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFkTnVtID0gbnVtWmVyb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gemVybyBmb2xsb3dlZCBieSBtZXNzYWdlXG4gIGViLnB1dEJ5dGUoMHgwMCk7XG4gIGViLnB1dEJ5dGVzKG0pO1xuXG4gIHJldHVybiBlYjtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSB1c2luZyBQS0NTIzEgdjEuNSBwYWRkaW5nLlxuICpcbiAqIEBwYXJhbSBlbSB0aGUgbWVzc2FnZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0ga2V5IHRoZSBSU0Ega2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBwdWIgdHJ1ZSBpZiB0aGUga2V5IGlzIGEgcHVibGljIGtleSwgZmFsc2UgaWYgaXQgaXMgcHJpdmF0ZS5cbiAqIEBwYXJhbSBtbCB0aGUgbWVzc2FnZSBsZW5ndGgsIGlmIHNwZWNpZmllZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBkZWNvZGVkIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBfZGVjb2RlUGtjczFfdjFfNShlbSwga2V5LCBwdWIsIG1sKSB7XG4gIC8vIGdldCB0aGUgbGVuZ3RoIG9mIHRoZSBtb2R1bHVzIGluIGJ5dGVzXG4gIHZhciBrID0gTWF0aC5jZWlsKGtleS5uLmJpdExlbmd0aCgpIC8gOCk7XG5cbiAgLyogSXQgaXMgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBvY2N1cnM6XG5cbiAgICAxLiBUaGUgZW5jcnlwdGlvbiBibG9jayBFQiBjYW5ub3QgYmUgcGFyc2VkIHVuYW1iaWd1b3VzbHkuXG4gICAgMi4gVGhlIHBhZGRpbmcgc3RyaW5nIFBTIGNvbnNpc3RzIG9mIGZld2VyIHRoYW4gZWlnaHQgb2N0ZXRzXG4gICAgICBvciBpcyBpbmNvbnNpc2VudCB3aXRoIHRoZSBibG9jayB0eXBlIEJULlxuICAgIDMuIFRoZSBkZWNyeXB0aW9uIHByb2Nlc3MgaXMgYSBwdWJsaWMta2V5IG9wZXJhdGlvbiBhbmQgdGhlIGJsb2NrXG4gICAgICB0eXBlIEJUIGlzIG5vdCAwMCBvciAwMSwgb3IgdGhlIGRlY3J5cHRpb24gcHJvY2VzcyBpcyBhXG4gICAgICBwcml2YXRlLWtleSBvcGVyYXRpb24gYW5kIHRoZSBibG9jayB0eXBlIGlzIG5vdCAwMi5cbiAgICovXG5cbiAgLy8gcGFyc2UgdGhlIGVuY3J5cHRpb24gYmxvY2tcbiAgdmFyIGViID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoZW0pO1xuICB2YXIgZmlyc3QgPSBlYi5nZXRCeXRlKCk7XG4gIHZhciBidCA9IGViLmdldEJ5dGUoKTtcbiAgaWYoZmlyc3QgIT09IDB4MDAgfHxcbiAgICAocHViICYmIGJ0ICE9PSAweDAwICYmIGJ0ICE9PSAweDAxKSB8fFxuICAgICghcHViICYmIGJ0ICE9IDB4MDIpIHx8XG4gICAgKHB1YiAmJiBidCA9PT0gMHgwMCAmJiB0eXBlb2YobWwpID09PSAndW5kZWZpbmVkJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHZhciBwYWROdW0gPSAwO1xuICBpZihidCA9PT0gMHgwMCkge1xuICAgIC8vIGNoZWNrIGFsbCBwYWRkaW5nIGJ5dGVzIGZvciAweDAwXG4gICAgcGFkTnVtID0gayAtIDMgLSBtbDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFkTnVtOyArK2kpIHtcbiAgICAgIGlmKGViLmdldEJ5dGUoKSAhPT0gMHgwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGJ5dGUgdGhhdCBpc24ndCAweEZGLCBzaG91bGQgYmUgYWZ0ZXIgYWxsIHBhZGRpbmdcbiAgICBwYWROdW0gPSAwO1xuICAgIHdoaWxlKGViLmxlbmd0aCgpID4gMSkge1xuICAgICAgaWYoZWIuZ2V0Qnl0ZSgpICE9PSAweEZGKSB7XG4gICAgICAgIC0tZWIucmVhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BhZE51bTtcbiAgICB9XG4gIH0gZWxzZSBpZihidCA9PT0gMHgwMikge1xuICAgIC8vIGxvb2sgZm9yIDB4MDAgYnl0ZVxuICAgIHBhZE51bSA9IDA7XG4gICAgd2hpbGUoZWIubGVuZ3RoKCkgPiAxKSB7XG4gICAgICBpZihlYi5nZXRCeXRlKCkgPT09IDB4MDApIHtcbiAgICAgICAgLS1lYi5yZWFkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICsrcGFkTnVtO1xuICAgIH1cbiAgfVxuXG4gIC8vIHplcm8gbXVzdCBiZSAweDAwIGFuZCBwYWROdW0gbXVzdCBiZSAoayAtIDMgLSBtZXNzYWdlIGxlbmd0aClcbiAgdmFyIHplcm8gPSBlYi5nZXRCeXRlKCk7XG4gIGlmKHplcm8gIT09IDB4MDAgfHwgcGFkTnVtICE9PSAoayAtIDMgLSBlYi5sZW5ndGgoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gYmxvY2sgaXMgaW52YWxpZC4nKTtcbiAgfVxuXG4gIHJldHVybiBlYi5nZXRCeXRlcygpO1xufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGtleS1nZW5lcmF0aW9uIGFsZ29yaXRobSBhc3luY2hyb25vdXNseSwgZWl0aGVyIGluIHRoZSBiYWNrZ3JvdW5kXG4gKiB2aWEgV2ViIFdvcmtlcnMsIG9yIHVzaW5nIHRoZSBtYWluIHRocmVhZCBhbmQgc2V0SW1tZWRpYXRlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSB0aGUga2V5LXBhaXIgZ2VuZXJhdGlvbiBzdGF0ZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb3B0aW9ucyBmb3Iga2V5LXBhaXIgZ2VuZXJhdGlvbjpcbiAqICAgICAgICAgIHdvcmtlclNjcmlwdCB0aGUgd29ya2VyIHNjcmlwdCBVUkwuXG4gKiAgICAgICAgICB3b3JrZXJzIHRoZSBudW1iZXIgb2Ygd2ViIHdvcmtlcnMgKGlmIHN1cHBvcnRlZCkgdG8gdXNlLFxuICogICAgICAgICAgICAoZGVmYXVsdDogMiwgLTEgdG8gdXNlIGVzdGltYXRlZCBjb3JlcyBtaW51cyBvbmUpLlxuICogICAgICAgICAgd29ya0xvYWQgdGhlIHNpemUgb2YgdGhlIHdvcmsgbG9hZCwgaWU6IG51bWJlciBvZiBwb3NzaWJsZSBwcmltZVxuICogICAgICAgICAgICBudW1iZXJzIGZvciBlYWNoIHdlYiB3b3JrZXIgdG8gY2hlY2sgcGVyIHdvcmsgYXNzaWdubWVudCxcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IDEwMCkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBrZXlwYWlyKSBjYWxsZWQgb25jZSB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAqL1xuZnVuY3Rpb24gX2dlbmVyYXRlS2V5UGFpcihzdGF0ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBvcHRzID0ge1xuICAgIGFsZ29yaXRobToge1xuICAgICAgbmFtZTogb3B0aW9ucy5hbGdvcml0aG0gfHwgJ1BSSU1FSU5DJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgd29ya2Vyczogb3B0aW9ucy53b3JrZXJzIHx8IDIsXG4gICAgICAgIHdvcmtMb2FkOiBvcHRpb25zLndvcmtMb2FkIHx8IDEwMCxcbiAgICAgICAgd29ya2VyU2NyaXB0OiBvcHRpb25zLndvcmtlclNjcmlwdFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYoJ3BybmcnIGluIG9wdGlvbnMpIHtcbiAgICBvcHRzLnBybmcgPSBvcHRpb25zLnBybmc7XG4gIH1cblxuICBnZW5lcmF0ZSgpO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuICAgIC8vIGZpbmQgcCBhbmQgdGhlbiBxIChkb25lIGluIHNlcmllcyB0byBzaW1wbGlmeSlcbiAgICBnZXRQcmltZShzdGF0ZS5wQml0cywgZnVuY3Rpb24oZXJyLCBudW0pIHtcbiAgICAgIGlmKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnAgPSBudW07XG4gICAgICBpZihzdGF0ZS5xICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2goZXJyLCBzdGF0ZS5xKTtcbiAgICAgIH1cbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJpbWUoYml0cywgY2FsbGJhY2spIHtcbiAgICBmb3JnZS5wcmltZS5nZW5lcmF0ZVByb2JhYmxlUHJpbWUoYml0cywgb3B0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoKGVyciwgbnVtKSB7XG4gICAgaWYoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcVxuICAgIHN0YXRlLnEgPSBudW07XG5cbiAgICAvLyBlbnN1cmUgcCBpcyBsYXJnZXIgdGhhbiBxIChzd2FwIHRoZW0gaWYgbm90KVxuICAgIGlmKHN0YXRlLnAuY29tcGFyZVRvKHN0YXRlLnEpIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IHN0YXRlLnA7XG4gICAgICBzdGF0ZS5wID0gc3RhdGUucTtcbiAgICAgIHN0YXRlLnEgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHAgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5wLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5wID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHEgaXMgY29wcmltZSB3aXRoIGVcbiAgICBpZihzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKS5nY2Qoc3RhdGUuZSlcbiAgICAgIC5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdldFByaW1lKHN0YXRlLnFCaXRzLCBmaW5pc2gpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNvbXB1dGUgcGhpOiAocCAtIDEpKHEgLSAxKSAoRXVsZXIncyB0b3RpZW50IGZ1bmN0aW9uKVxuICAgIHN0YXRlLnAxID0gc3RhdGUucC5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG4gICAgc3RhdGUucTEgPSBzdGF0ZS5xLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICBzdGF0ZS5waGkgPSBzdGF0ZS5wMS5tdWx0aXBseShzdGF0ZS5xMSk7XG5cbiAgICAvLyBlbnN1cmUgZSBhbmQgcGhpIGFyZSBjb3ByaW1lXG4gICAgaWYoc3RhdGUucGhpLmdjZChzdGF0ZS5lKS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9PSAwKSB7XG4gICAgICAvLyBwaGkgYW5kIGUgYXJlbid0IGNvcHJpbWUsIHNvIGdlbmVyYXRlIGEgbmV3IHAgYW5kIHFcbiAgICAgIHN0YXRlLnAgPSBzdGF0ZS5xID0gbnVsbDtcbiAgICAgIGdlbmVyYXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG4sIGVuc3VyZSBuIGlzIGhhcyB0aGUgcmlnaHQgbnVtYmVyIG9mIGJpdHNcbiAgICBzdGF0ZS5uID0gc3RhdGUucC5tdWx0aXBseShzdGF0ZS5xKTtcbiAgICBpZihzdGF0ZS5uLmJpdExlbmd0aCgpICE9PSBzdGF0ZS5iaXRzKSB7XG4gICAgICAvLyBmYWlsZWQsIGdldCBuZXcgcVxuICAgICAgc3RhdGUucSA9IG51bGw7XG4gICAgICBnZXRQcmltZShzdGF0ZS5xQml0cywgZmluaXNoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQga2V5c1xuICAgIHZhciBkID0gc3RhdGUuZS5tb2RJbnZlcnNlKHN0YXRlLnBoaSk7XG4gICAgc3RhdGUua2V5cyA9IHtcbiAgICAgIHByaXZhdGVLZXk6IHBraS5yc2Euc2V0UHJpdmF0ZUtleShcbiAgICAgICAgc3RhdGUubiwgc3RhdGUuZSwgZCwgc3RhdGUucCwgc3RhdGUucSxcbiAgICAgICAgZC5tb2Qoc3RhdGUucDEpLCBkLm1vZChzdGF0ZS5xMSksXG4gICAgICAgIHN0YXRlLnEubW9kSW52ZXJzZShzdGF0ZS5wKSksXG4gICAgICBwdWJsaWNLZXk6IHBraS5yc2Euc2V0UHVibGljS2V5KHN0YXRlLm4sIHN0YXRlLmUpXG4gICAgfTtcblxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLmtleXMpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBwb3NpdGl2ZSBCaWdJbnRlZ2VyIGludG8gMidzLWNvbXBsZW1lbnQgYmlnLWVuZGlhbiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYmlnIGludGVnZXIgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlcy5cbiAqL1xuZnVuY3Rpb24gX2JuVG9CeXRlcyhiKSB7XG4gIC8vIHByZXBlbmQgMHgwMCBpZiBmaXJzdCBieXRlID49IDB4ODBcbiAgdmFyIGhleCA9IGIudG9TdHJpbmcoMTYpO1xuICBpZihoZXhbMF0gPj0gJzgnKSB7XG4gICAgaGV4ID0gJzAwJyArIGhleDtcbiAgfVxuICB2YXIgYnl0ZXMgPSBmb3JnZS51dGlsLmhleFRvQnl0ZXMoaGV4KTtcblxuICAvLyBlbnN1cmUgaW50ZWdlciBpcyBtaW5pbWFsbHktZW5jb2RlZFxuICBpZihieXRlcy5sZW5ndGggPiAxICYmXG4gICAgLy8gbGVhZGluZyAweDAwIGZvciBwb3NpdGl2ZSBpbnRlZ2VyXG4gICAgKChieXRlcy5jaGFyQ29kZUF0KDApID09PSAwICYmXG4gICAgKGJ5dGVzLmNoYXJDb2RlQXQoMSkgJiAweDgwKSA9PT0gMCkgfHxcbiAgICAvLyBsZWFkaW5nIDB4RkYgZm9yIG5lZ2F0aXZlIGludGVnZXJcbiAgICAoYnl0ZXMuY2hhckNvZGVBdCgwKSA9PT0gMHhGRiAmJlxuICAgIChieXRlcy5jaGFyQ29kZUF0KDEpICYgMHg4MCkgPT09IDB4ODApKSkge1xuICAgIHJldHVybiBieXRlcy5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlcXVpcmVkIG51bWJlciBvZiBNaWxsZXItUmFiaW4gdGVzdHMgdG8gZ2VuZXJhdGUgYVxuICogcHJpbWUgd2l0aCBhbiBlcnJvciBwcm9iYWJpbGl0eSBvZiAoMS8yKV44MC5cbiAqXG4gKiBTZWUgSGFuZGJvb2sgb2YgQXBwbGllZCBDcnlwdG9ncmFwaHkgQ2hhcHRlciA0LCBUYWJsZSA0LjQuXG4gKlxuICogQHBhcmFtIGJpdHMgdGhlIGJpdCBzaXplLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiBfZ2V0TWlsbGVyUmFiaW5UZXN0cyhiaXRzKSB7XG4gIGlmKGJpdHMgPD0gMTAwKSByZXR1cm4gMjc7XG4gIGlmKGJpdHMgPD0gMTUwKSByZXR1cm4gMTg7XG4gIGlmKGJpdHMgPD0gMjAwKSByZXR1cm4gMTU7XG4gIGlmKGJpdHMgPD0gMjUwKSByZXR1cm4gMTI7XG4gIGlmKGJpdHMgPD0gMzAwKSByZXR1cm4gOTtcbiAgaWYoYml0cyA8PSAzNTApIHJldHVybiA4O1xuICBpZihiaXRzIDw9IDQwMCkgcmV0dXJuIDc7XG4gIGlmKGJpdHMgPD0gNTAwKSByZXR1cm4gNjtcbiAgaWYoYml0cyA8PSA2MDApIHJldHVybiA1O1xuICBpZihiaXRzIDw9IDgwMCkgcmV0dXJuIDQ7XG4gIGlmKGJpdHMgPD0gMTI1MCkgcmV0dXJuIDM7XG4gIHJldHVybiAyO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBOb2RlIGNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0Tm9kZUNyeXB0byhmbikge1xuICByZXR1cm4gZm9yZ2UudXRpbC5pc05vZGVqcyAmJiB0eXBlb2YgX2NyeXB0b1tmbl0gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZmVhdHVyZSBkZXRlY3Rpb24gb24gdGhlIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIGZuIHRoZSBmZWF0dXJlIChmdW5jdGlvbikgdG8gZGV0ZWN0LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBkZXRlY3RlZCwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfZGV0ZWN0U3VidGxlQ3J5cHRvKGZuKSB7XG4gIHJldHVybiAodHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLmNyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHV0aWwuZ2xvYmFsU2NvcGUuY3J5cHRvLnN1YnRsZVtmbl0gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGZlYXR1cmUgZGV0ZWN0aW9uIG9uIHRoZSBkZXByZWNhdGVkIE1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclxuICogb3V0ZGF0ZWQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSB1c2VkIGFmdGVyXG4gKiBjaGVja2luZyBmb3IgdGhlIG1vZGVybiwgc3RhbmRhcmQgU3VidGxlQ3J5cHRvIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gZm4gdGhlIGZlYXR1cmUgKGZ1bmN0aW9uKSB0byBkZXRlY3QuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGRldGVjdGVkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9kZXRlY3RTdWJ0bGVNc0NyeXB0byhmbikge1xuICByZXR1cm4gKHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvID09PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiB1dGlsLmdsb2JhbFNjb3BlLm1zQ3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdXRpbC5nbG9iYWxTY29wZS5tc0NyeXB0by5zdWJ0bGVbZm5dID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gX2ludFRvVWludDhBcnJheSh4KSB7XG4gIHZhciBieXRlcyA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyh4LnRvU3RyaW5nKDE2KSk7XG4gIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGgpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBidWZmZXJbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVW5zdXBwb3J0ZWQga2V5IGFsZ29yaXRobSBcIicgKyBqd2sua3R5ICsgJ1wiOyBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHJpdmF0ZUtleShcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLm4pLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2suZSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kKSxcbiAgICBfYmFzZTY0VG9CaWdJbnQoandrLnApLFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2sucSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcCksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5kcSksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5xaSkpO1xufVxuXG5mdW5jdGlvbiBfcHVibGljS2V5RnJvbUp3ayhqd2spIHtcbiAgaWYoandrLmt0eSAhPT0gJ1JTQScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleSBhbGdvcml0aG0gbXVzdCBiZSBcIlJTQVwiLicpO1xuICB9XG4gIHJldHVybiBwa2kuc2V0UnNhUHVibGljS2V5KFxuICAgIF9iYXNlNjRUb0JpZ0ludChqd2subiksXG4gICAgX2Jhc2U2NFRvQmlnSW50KGp3ay5lKSk7XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRUb0JpZ0ludChiNjQpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGZvcmdlLnV0aWwuYnl0ZXNUb0hleChmb3JnZS51dGlsLmRlY29kZTY0KGI2NCkpLCAxNik7XG59XG4iLCIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIDE2MC1iaXQgZGlnZXN0IChTSEEtMSkgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL21kJyk7XG5yZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNoYTEgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnNoYTEgPSBmb3JnZS5zaGExIHx8IHt9O1xuZm9yZ2UubWQuc2hhMSA9IGZvcmdlLm1kLmFsZ29yaXRobXMuc2hhMSA9IHNoYTE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNIQS0xIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIGEgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0LlxuICovXG5zaGExLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMSBzdGF0ZSBjb250YWlucyBmaXZlIDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg4MCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGExJyxcbiAgICBibG9ja0xlbmd0aDogNjQsXG4gICAgZGlnZXN0TGVuZ3RoOiAyMCxcbiAgICAvLyA1Ni1iaXQgbGVuZ3RoIG9mIG1lc3NhZ2Ugc28gZmFyIChkb2VzIG5vdCBpbmNsdWRpbmcgcGFkZGluZylcbiAgICBtZXNzYWdlTGVuZ3RoOiAwLFxuICAgIC8vIHRydWUgbWVzc2FnZSBsZW5ndGhcbiAgICBmdWxsTWVzc2FnZUxlbmd0aDogbnVsbCxcbiAgICAvLyBzaXplIG9mIG1lc3NhZ2UgbGVuZ3RoIGluIGJ5dGVzXG4gICAgbWVzc2FnZUxlbmd0aFNpemU6IDhcbiAgfTtcblxuICAvKipcbiAgICogU3RhcnRzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB1cCB0byA1Ni1iaXQgbWVzc2FnZSBsZW5ndGggZm9yIGNvbnZlbmllbmNlXG4gICAgbWQubWVzc2FnZUxlbmd0aCA9IDA7XG5cbiAgICAvLyBmdWxsIG1lc3NhZ2UgbGVuZ3RoIChzZXQgbWQubWVzc2FnZUxlbmd0aDY0IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSlcbiAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aCA9IG1kLm1lc3NhZ2VMZW5ndGg2NCA9IFtdO1xuICAgIHZhciBpbnQzMnMgPSBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSAvIDQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGludDMyczsgKytpKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aC5wdXNoKDApO1xuICAgIH1cbiAgICBfaW5wdXQgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIF9zdGF0ZSA9IHtcbiAgICAgIGgwOiAweDY3NDUyMzAxLFxuICAgICAgaDE6IDB4RUZDREFCODksXG4gICAgICBoMjogMHg5OEJBRENGRSxcbiAgICAgIGgzOiAweDEwMzI1NDc2LFxuICAgICAgaDQ6IDB4QzNEMkUxRjBcbiAgICB9O1xuICAgIHJldHVybiBtZDtcbiAgfTtcbiAgLy8gc3RhcnQgZGlnZXN0IGF1dG9tYXRpY2FsbHkgZm9yIGZpcnN0IHRpbWVcbiAgbWQuc3RhcnQoKTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZGlnZXN0IHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UgaW5wdXQuIFRoZSBnaXZlbiBpbnB1dCBjYW5cbiAgICogdHJlYXRlZCBhcyByYXcgaW5wdXQgKG5vIGVuY29kaW5nIHdpbGwgYmUgYXBwbGllZCkgb3IgYW4gZW5jb2Rpbmcgb2ZcbiAgICogJ3V0ZjgnIG1heWJlIGdpdmVuIHRvIGVuY29kZSB0aGUgaW5wdXQgdXNpbmcgVVRGLTguXG4gICAqXG4gICAqIEBwYXJhbSBtc2cgdGhlIG1lc3NhZ2UgaW5wdXQgdG8gdXBkYXRlIHdpdGguXG4gICAqIEBwYXJhbSBlbmNvZGluZyB0aGUgZW5jb2RpbmcgdG8gdXNlIChkZWZhdWx0OiAncmF3Jywgb3RoZXI6ICd1dGY4JykuXG4gICAqXG4gICAqIEByZXR1cm4gdGhpcyBkaWdlc3Qgb2JqZWN0LlxuICAgKi9cbiAgbWQudXBkYXRlID0gZnVuY3Rpb24obXNnLCBlbmNvZGluZykge1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIG1zZyA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOChtc2cpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBtZXNzYWdlIGxlbmd0aFxuICAgIHZhciBsZW4gPSBtc2cubGVuZ3RoO1xuICAgIG1kLm1lc3NhZ2VMZW5ndGggKz0gbGVuO1xuICAgIGxlbiA9IFsobGVuIC8gMHgxMDAwMDAwMDApID4+PiAwLCBsZW4gPj4+IDBdO1xuICAgIGZvcih2YXIgaSA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSArPSBsZW5bMV07XG4gICAgICBsZW5bMV0gPSBsZW5bMF0gKyAoKG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPj4+IDA7XG4gICAgICBsZW5bMF0gPSAoKGxlblsxXSAvIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJ5dGVzIHRvIGlucHV0IGJ1ZmZlclxuICAgIF9pbnB1dC5wdXRCeXRlcyhtc2cpO1xuXG4gICAgLy8gcHJvY2VzcyBieXRlc1xuICAgIF91cGRhdGUoX3N0YXRlLCBfdywgX2lucHV0KTtcblxuICAgIC8vIGNvbXBhY3QgaW5wdXQgYnVmZmVyIGV2ZXJ5IDJLIG9yIGlmIGVtcHR5XG4gICAgaWYoX2lucHV0LnJlYWQgPiAyMDQ4IHx8IF9pbnB1dC5sZW5ndGgoKSA9PT0gMCkge1xuICAgICAgX2lucHV0LmNvbXBhY3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBkaWdlc3QuXG4gICAqXG4gICAqIEByZXR1cm4gYSBieXRlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBkaWdlc3QgdmFsdWUuXG4gICAqL1xuICBtZC5kaWdlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBOb3RlOiBIZXJlIHdlIGNvcHkgdGhlIHJlbWFpbmluZyBieXRlcyBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZFxuICAgIGFkZCB0aGUgYXBwcm9wcmlhdGUgU0hBLTEgcGFkZGluZy4gVGhlbiB3ZSBkbyB0aGUgZmluYWwgdXBkYXRlXG4gICAgb24gYSBjb3B5IG9mIHRoZSBzdGF0ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHdhbnRzIHRvIGdldFxuICAgIGludGVybWVkaWF0ZSBkaWdlc3RzIHRoZXkgY2FuIGRvIHNvLiAqL1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBtdXN0IGJlIGFkZGVkIHRvIHRoZSBtZXNzYWdlXG4gICAgdG8gZW5zdXJlIGl0cyBsZW5ndGggaXMgY29uZ3J1ZW50IHRvIDQ0OCBtb2QgNTEyLiBJbiBvdGhlciB3b3JkcyxcbiAgICB0aGUgZGF0YSB0byBiZSBkaWdlc3RlZCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNTEyIGJpdHMgKG9yIDEyOCBieXRlcykuXG4gICAgVGhpcyBkYXRhIGluY2x1ZGVzIHRoZSBtZXNzYWdlLCBzb21lIHBhZGRpbmcsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIG1lc3NhZ2UuIFNpbmNlIHRoZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2Ugd2lsbCBiZSBlbmNvZGVkIGFzIDggYnl0ZXMgKDY0XG4gICAgYml0cyksIHRoYXQgbWVhbnMgdGhhdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBkYXRhIG11c3QgaGF2ZSA1NiBieXRlc1xuICAgICg0NDggYml0cykgb2YgbWVzc2FnZSBhbmQgcGFkZGluZy4gVGhlcmVmb3JlLCB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlXG4gICAgcGx1cyB0aGUgcGFkZGluZyBtdXN0IGJlIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiBiZWNhdXNlXG4gICAgNTEyIC0gMTI4ID0gNDQ4LlxuXG4gICAgSW4gb3JkZXIgdG8gZmlsbCB1cCB0aGUgbWVzc2FnZSBsZW5ndGggaXQgbXVzdCBiZSBmaWxsZWQgd2l0aFxuICAgIHBhZGRpbmcgdGhhdCBiZWdpbnMgd2l0aCAxIGJpdCBmb2xsb3dlZCBieSBhbGwgMCBiaXRzLiBQYWRkaW5nXG4gICAgbXVzdCAqYWx3YXlzKiBiZSBwcmVzZW50LCBzbyBpZiB0aGUgbWVzc2FnZSBsZW5ndGggaXMgYWxyZWFkeVxuICAgIGNvbmdydWVudCB0byA0NDggbW9kIDUxMiwgdGhlbiA1MTIgcGFkZGluZyBiaXRzIG11c3QgYmUgYWRkZWQuICovXG5cbiAgICB2YXIgZmluYWxCbG9jayA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfaW5wdXQuYnl0ZXMoKSk7XG5cbiAgICAvLyBjb21wdXRlIHJlbWFpbmluZyBzaXplIHRvIGJlIGRpZ2VzdGVkIChpbmNsdWRlIG1lc3NhZ2UgbGVuZ3RoIHNpemUpXG4gICAgdmFyIHJlbWFpbmluZyA9IChcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW21kLmZ1bGxNZXNzYWdlTGVuZ3RoLmxlbmd0aCAtIDFdICtcbiAgICAgIG1kLm1lc3NhZ2VMZW5ndGhTaXplKTtcblxuICAgIC8vIGFkZCBwYWRkaW5nIGZvciBvdmVyZmxvdyBibG9ja1NpemUgLSBvdmVyZmxvd1xuICAgIC8vIF9wYWRkaW5nIHN0YXJ0cyB3aXRoIDEgYnl0ZSB3aXRoIGZpcnN0IGJpdCBpcyBzZXQgKGJ5dGUgdmFsdWUgMTI4KSwgdGhlblxuICAgIC8vIHRoZXJlIG1heSBiZSB1cCB0byAoYmxvY2tTaXplIC0gMSkgb3RoZXIgcGFkIGJ5dGVzXG4gICAgdmFyIG92ZXJmbG93ID0gcmVtYWluaW5nICYgKG1kLmJsb2NrTGVuZ3RoIC0gMSk7XG4gICAgZmluYWxCbG9jay5wdXRCeXRlcyhfcGFkZGluZy5zdWJzdHIoMCwgbWQuYmxvY2tMZW5ndGggLSBvdmVyZmxvdykpO1xuXG4gICAgLy8gc2VyaWFsaXplIG1lc3NhZ2UgbGVuZ3RoIGluIGJpdHMgaW4gYmlnLWVuZGlhbiBvcmRlcjsgc2luY2UgbGVuZ3RoXG4gICAgLy8gaXMgc3RvcmVkIGluIGJ5dGVzIHdlIG11bHRpcGx5IGJ5IDggYW5kIGFkZCBjYXJyeSBmcm9tIG5leHQgaW50XG4gICAgdmFyIG5leHQsIGNhcnJ5O1xuICAgIHZhciBiaXRzID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbMF0gKiA4O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIG5leHQgPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpICsgMV0gKiA4O1xuICAgICAgY2FycnkgPSAobmV4dCAvIDB4MTAwMDAwMDAwKSA+Pj4gMDtcbiAgICAgIGJpdHMgKz0gY2Fycnk7XG4gICAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMgPj4+IDApO1xuICAgICAgYml0cyA9IG5leHQgPj4+IDA7XG4gICAgfVxuICAgIGZpbmFsQmxvY2sucHV0SW50MzIoYml0cyk7XG5cbiAgICB2YXIgczIgPSB7XG4gICAgICBoMDogX3N0YXRlLmgwLFxuICAgICAgaDE6IF9zdGF0ZS5oMSxcbiAgICAgIGgyOiBfc3RhdGUuaDIsXG4gICAgICBoMzogX3N0YXRlLmgzLFxuICAgICAgaDQ6IF9zdGF0ZS5oNFxuICAgIH07XG4gICAgX3VwZGF0ZShzMiwgX3csIGZpbmFsQmxvY2spO1xuICAgIHZhciBydmFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgwKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgxKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgyKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmgzKTtcbiAgICBydmFsLnB1dEludDMyKHMyLmg0KTtcbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gbWQ7XG59O1xuXG4vLyBzaGEtMSBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbnN0YW50IHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gX2luaXQoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nXG4gIF9wYWRkaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjgpO1xuICBfcGFkZGluZyArPSBmb3JnZS51dGlsLmZpbGxTdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZSgweDAwKSwgNjQpO1xuXG4gIC8vIG5vdyBpbml0aWFsaXplZFxuICBfaW5pdGlhbGl6ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBTSEEtMSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBieXRlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gcyB0aGUgU0hBLTEgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQsIGEsIGIsIGMsIGQsIGUsIGYsIGk7XG4gIHZhciBsZW4gPSBieXRlcy5sZW5ndGgoKTtcbiAgd2hpbGUobGVuID49IDY0KSB7XG4gICAgLy8gdGhlIHcgYXJyYXkgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBzaXh0ZWVuIDMyLWJpdCBiaWctZW5kaWFuIHdvcmRzXG4gICAgLy8gYW5kIHRoZW4gZXh0ZW5kZWQgaW50byA4MCAzMi1iaXQgd29yZHMgYWNjb3JkaW5nIHRvIFNIQS0xIGFsZ29yaXRobVxuICAgIC8vIGFuZCBmb3IgMzItNzkgdXNpbmcgTWF4IExvY2t0eXVraGluJ3Mgb3B0aW1pemF0aW9uXG5cbiAgICAvLyBpbml0aWFsaXplIGhhc2ggdmFsdWUgZm9yIHRoaXMgY2h1bmtcbiAgICBhID0gcy5oMDtcbiAgICBiID0gcy5oMTtcbiAgICBjID0gcy5oMjtcbiAgICBkID0gcy5oMztcbiAgICBlID0gcy5oNDtcblxuICAgIC8vIHJvdW5kIDFcbiAgICBmb3IoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICB0ID0gYnl0ZXMuZ2V0SW50MzIoKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIGZvcig7IGkgPCAyMDsgKytpKSB7XG4gICAgICB0ID0gKHdbaSAtIDNdIF4gd1tpIC0gOF0gXiB3W2kgLSAxNF0gXiB3W2kgLSAxNl0pO1xuICAgICAgdCA9ICh0IDw8IDEpIHwgKHQgPj4+IDMxKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDVBODI3OTk5ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDJcbiAgICBmb3IoOyBpIDwgMzI7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSAzXSBeIHdbaSAtIDhdIF4gd1tpIC0gMTRdIF4gd1tpIC0gMTZdKTtcbiAgICAgIHQgPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgICB3W2ldID0gdDtcbiAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIDB4NkVEOUVCQTEgKyB0O1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIC8vIGA+Pj4gMGAgbmVjZXNzYXJ5IHRvIGF2b2lkIGlPUy9TYWZhcmkgMTAgb3B0aW1pemF0aW9uIGJ1Z1xuICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG4gICAgZm9yKDsgaSA8IDQwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGYgKyBlICsgMHg2RUQ5RUJBMSArIHQ7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICBjID0gKChiIDw8IDMwKSB8IChiID4+PiAyKSkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cbiAgICAvLyByb3VuZCAzXG4gICAgZm9yKDsgaSA8IDYwOyArK2kpIHtcbiAgICAgIHQgPSAod1tpIC0gNl0gXiB3W2kgLSAxNl0gXiB3W2kgLSAyOF0gXiB3W2kgLSAzMl0pO1xuICAgICAgdCA9ICh0IDw8IDIpIHwgKHQgPj4+IDMwKTtcbiAgICAgIHdbaV0gPSB0O1xuICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIF4gYykpO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweDhGMUJCQ0RDICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuICAgIC8vIHJvdW5kIDRcbiAgICBmb3IoOyBpIDwgODA7ICsraSkge1xuICAgICAgdCA9ICh3W2kgLSA2XSBeIHdbaSAtIDE2XSBeIHdbaSAtIDI4XSBeIHdbaSAtIDMyXSk7XG4gICAgICB0ID0gKHQgPDwgMikgfCAodCA+Pj4gMzApO1xuICAgICAgd1tpXSA9IHQ7XG4gICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyAweENBNjJDMUQ2ICsgdDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuXG4gICAgbGVuIC09IDY0O1xuICB9XG59XG4iLCIvKipcbiAqIFNlY3VyZSBIYXNoIEFsZ29yaXRobSB3aXRoIDI1Ni1iaXQgZGlnZXN0IChTSEEtMjU2KSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTZWUgRklQUyAxODAtMiBmb3IgZGV0YWlscy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE1IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnJlcXVpcmUoJy4vbWQnKTtcbnJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgc2hhMjU2ID0gbW9kdWxlLmV4cG9ydHMgPSBmb3JnZS5zaGEyNTYgPSBmb3JnZS5zaGEyNTYgfHwge307XG5mb3JnZS5tZC5zaGEyNTYgPSBmb3JnZS5tZC5hbGdvcml0aG1zLnNoYTI1NiA9IHNoYTI1NjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU0hBLTI1NiBtZXNzYWdlIGRpZ2VzdCBvYmplY3QuXG4gKlxuICogQHJldHVybiBhIG1lc3NhZ2UgZGlnZXN0IG9iamVjdC5cbiAqL1xuc2hhMjU2LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkbyBpbml0aWFsaXphdGlvbiBhcyBuZWNlc3NhcnlcbiAgaWYoIV9pbml0aWFsaXplZCkge1xuICAgIF9pbml0KCk7XG4gIH1cblxuICAvLyBTSEEtMjU2IHN0YXRlIGNvbnRhaW5zIGVpZ2h0IDMyLWJpdCBpbnRlZ2Vyc1xuICB2YXIgX3N0YXRlID0gbnVsbDtcblxuICAvLyBpbnB1dCBidWZmZXJcbiAgdmFyIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG5cbiAgLy8gdXNlZCBmb3Igd29yZCBzdG9yYWdlXG4gIHZhciBfdyA9IG5ldyBBcnJheSg2NCk7XG5cbiAgLy8gbWVzc2FnZSBkaWdlc3Qgb2JqZWN0XG4gIHZhciBtZCA9IHtcbiAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgIGJsb2NrTGVuZ3RoOiA2NCxcbiAgICBkaWdlc3RMZW5ndGg6IDMyLFxuICAgIC8vIDU2LWJpdCBsZW5ndGggb2YgbWVzc2FnZSBzbyBmYXIgKGRvZXMgbm90IGluY2x1ZGluZyBwYWRkaW5nKVxuICAgIG1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gdHJ1ZSBtZXNzYWdlIGxlbmd0aFxuICAgIGZ1bGxNZXNzYWdlTGVuZ3RoOiBudWxsLFxuICAgIC8vIHNpemUgb2YgbWVzc2FnZSBsZW5ndGggaW4gYnl0ZXNcbiAgICBtZXNzYWdlTGVuZ3RoU2l6ZTogOFxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHVwIHRvIDU2LWJpdCBtZXNzYWdlIGxlbmd0aCBmb3IgY29udmVuaWVuY2VcbiAgICBtZC5tZXNzYWdlTGVuZ3RoID0gMDtcblxuICAgIC8vIGZ1bGwgbWVzc2FnZSBsZW5ndGggKHNldCBtZC5tZXNzYWdlTGVuZ3RoNjQgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5KVxuICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoID0gbWQubWVzc2FnZUxlbmd0aDY0ID0gW107XG4gICAgdmFyIGludDMycyA9IG1kLm1lc3NhZ2VMZW5ndGhTaXplIC8gNDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgaW50MzJzOyArK2kpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoLnB1c2goMCk7XG4gICAgfVxuICAgIF9pbnB1dCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgX3N0YXRlID0ge1xuICAgICAgaDA6IDB4NkEwOUU2NjcsXG4gICAgICBoMTogMHhCQjY3QUU4NSxcbiAgICAgIGgyOiAweDNDNkVGMzcyLFxuICAgICAgaDM6IDB4QTU0RkY1M0EsXG4gICAgICBoNDogMHg1MTBFNTI3RixcbiAgICAgIGg1OiAweDlCMDU2ODhDLFxuICAgICAgaDY6IDB4MUY4M0Q5QUIsXG4gICAgICBoNzogMHg1QkUwQ0QxOVxuICAgIH07XG4gICAgcmV0dXJuIG1kO1xuICB9O1xuICAvLyBzdGFydCBkaWdlc3QgYXV0b21hdGljYWxseSBmb3IgZmlyc3QgdGltZVxuICBtZC5zdGFydCgpO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBkaWdlc3Qgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnB1dC4gVGhlIGdpdmVuIGlucHV0IGNhblxuICAgKiB0cmVhdGVkIGFzIHJhdyBpbnB1dCAobm8gZW5jb2Rpbmcgd2lsbCBiZSBhcHBsaWVkKSBvciBhbiBlbmNvZGluZyBvZlxuICAgKiAndXRmOCcgbWF5YmUgZ2l2ZW4gdG8gZW5jb2RlIHRoZSBpbnB1dCB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgbWVzc2FnZSBpbnB1dCB0byB1cGRhdGUgd2l0aC5cbiAgICogQHBhcmFtIGVuY29kaW5nIHRoZSBlbmNvZGluZyB0byB1c2UgKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAgICpcbiAgICogQHJldHVybiB0aGlzIGRpZ2VzdCBvYmplY3QuXG4gICAqL1xuICBtZC51cGRhdGUgPSBmdW5jdGlvbihtc2csIGVuY29kaW5nKSB7XG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgbXNnID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KG1zZyk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIG1lc3NhZ2UgbGVuZ3RoXG4gICAgdmFyIGxlbiA9IG1zZy5sZW5ndGg7XG4gICAgbWQubWVzc2FnZUxlbmd0aCArPSBsZW47XG4gICAgbGVuID0gWyhsZW4gLyAweDEwMDAwMDAwMCkgPj4+IDAsIGxlbiA+Pj4gMF07XG4gICAgZm9yKHZhciBpID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1kLmZ1bGxNZXNzYWdlTGVuZ3RoW2ldICs9IGxlblsxXTtcbiAgICAgIGxlblsxXSA9IGxlblswXSArICgobWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gLyAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAgICAgbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaV0gPSBtZC5mdWxsTWVzc2FnZUxlbmd0aFtpXSA+Pj4gMDtcbiAgICAgIGxlblswXSA9ICgobGVuWzFdIC8gMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYnl0ZXMgdG8gaW5wdXQgYnVmZmVyXG4gICAgX2lucHV0LnB1dEJ5dGVzKG1zZyk7XG5cbiAgICAvLyBwcm9jZXNzIGJ5dGVzXG4gICAgX3VwZGF0ZShfc3RhdGUsIF93LCBfaW5wdXQpO1xuXG4gICAgLy8gY29tcGFjdCBpbnB1dCBidWZmZXIgZXZlcnkgMksgb3IgaWYgZW1wdHlcbiAgICBpZihfaW5wdXQucmVhZCA+IDIwNDggfHwgX2lucHV0Lmxlbmd0aCgpID09PSAwKSB7XG4gICAgICBfaW5wdXQuY29tcGFjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtZDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgdGhlIGRpZ2VzdC5cbiAgICpcbiAgICogQHJldHVybiBhIGJ5dGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGRpZ2VzdCB2YWx1ZS5cbiAgICovXG4gIG1kLmRpZ2VzdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vdGU6IEhlcmUgd2UgY29weSB0aGUgcmVtYWluaW5nIGJ5dGVzIGluIHRoZSBpbnB1dCBidWZmZXIgYW5kXG4gICAgYWRkIHRoZSBhcHByb3ByaWF0ZSBTSEEtMjU2IHBhZGRpbmcuIFRoZW4gd2UgZG8gdGhlIGZpbmFsIHVwZGF0ZVxuICAgIG9uIGEgY29weSBvZiB0aGUgc3RhdGUgc28gdGhhdCBpZiB0aGUgdXNlciB3YW50cyB0byBnZXRcbiAgICBpbnRlcm1lZGlhdGUgZGlnZXN0cyB0aGV5IGNhbiBkbyBzby4gKi9cblxuICAgIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgbXVzdCBiZSBhZGRlZCB0byB0aGUgbWVzc2FnZVxuICAgIHRvIGVuc3VyZSBpdHMgbGVuZ3RoIGlzIGNvbmdydWVudCB0byA0NDggbW9kIDUxMi4gSW4gb3RoZXIgd29yZHMsXG4gICAgdGhlIGRhdGEgdG8gYmUgZGlnZXN0ZWQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDUxMiBiaXRzIChvciAxMjggYnl0ZXMpLlxuICAgIFRoaXMgZGF0YSBpbmNsdWRlcyB0aGUgbWVzc2FnZSwgc29tZSBwYWRkaW5nLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGVcbiAgICBtZXNzYWdlLiBTaW5jZSB0aGUgbGVuZ3RoIG9mIHRoZSBtZXNzYWdlIHdpbGwgYmUgZW5jb2RlZCBhcyA4IGJ5dGVzICg2NFxuICAgIGJpdHMpLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBvZiB0aGUgZGF0YSBtdXN0IGhhdmUgNTYgYnl0ZXNcbiAgICAoNDQ4IGJpdHMpIG9mIG1lc3NhZ2UgYW5kIHBhZGRpbmcuIFRoZXJlZm9yZSwgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZVxuICAgIHBsdXMgdGhlIHBhZGRpbmcgbXVzdCBiZSBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIgYmVjYXVzZVxuICAgIDUxMiAtIDEyOCA9IDQ0OC5cblxuICAgIEluIG9yZGVyIHRvIGZpbGwgdXAgdGhlIG1lc3NhZ2UgbGVuZ3RoIGl0IG11c3QgYmUgZmlsbGVkIHdpdGhcbiAgICBwYWRkaW5nIHRoYXQgYmVnaW5zIHdpdGggMSBiaXQgZm9sbG93ZWQgYnkgYWxsIDAgYml0cy4gUGFkZGluZ1xuICAgIG11c3QgKmFsd2F5cyogYmUgcHJlc2VudCwgc28gaWYgdGhlIG1lc3NhZ2UgbGVuZ3RoIGlzIGFscmVhZHlcbiAgICBjb25ncnVlbnQgdG8gNDQ4IG1vZCA1MTIsIHRoZW4gNTEyIHBhZGRpbmcgYml0cyBtdXN0IGJlIGFkZGVkLiAqL1xuXG4gICAgdmFyIGZpbmFsQmxvY2sgPSBmb3JnZS51dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX2lucHV0LmJ5dGVzKCkpO1xuXG4gICAgLy8gY29tcHV0ZSByZW1haW5pbmcgc2l6ZSB0byBiZSBkaWdlc3RlZCAoaW5jbHVkZSBtZXNzYWdlIGxlbmd0aCBzaXplKVxuICAgIHZhciByZW1haW5pbmcgPSAoXG4gICAgICBtZC5mdWxsTWVzc2FnZUxlbmd0aFttZC5mdWxsTWVzc2FnZUxlbmd0aC5sZW5ndGggLSAxXSArXG4gICAgICBtZC5tZXNzYWdlTGVuZ3RoU2l6ZSk7XG5cbiAgICAvLyBhZGQgcGFkZGluZyBmb3Igb3ZlcmZsb3cgYmxvY2tTaXplIC0gb3ZlcmZsb3dcbiAgICAvLyBfcGFkZGluZyBzdGFydHMgd2l0aCAxIGJ5dGUgd2l0aCBmaXJzdCBiaXQgaXMgc2V0IChieXRlIHZhbHVlIDEyOCksIHRoZW5cbiAgICAvLyB0aGVyZSBtYXkgYmUgdXAgdG8gKGJsb2NrU2l6ZSAtIDEpIG90aGVyIHBhZCBieXRlc1xuICAgIHZhciBvdmVyZmxvdyA9IHJlbWFpbmluZyAmIChtZC5ibG9ja0xlbmd0aCAtIDEpO1xuICAgIGZpbmFsQmxvY2sucHV0Qnl0ZXMoX3BhZGRpbmcuc3Vic3RyKDAsIG1kLmJsb2NrTGVuZ3RoIC0gb3ZlcmZsb3cpKTtcblxuICAgIC8vIHNlcmlhbGl6ZSBtZXNzYWdlIGxlbmd0aCBpbiBiaXRzIGluIGJpZy1lbmRpYW4gb3JkZXI7IHNpbmNlIGxlbmd0aFxuICAgIC8vIGlzIHN0b3JlZCBpbiBieXRlcyB3ZSBtdWx0aXBseSBieSA4IGFuZCBhZGQgY2FycnkgZnJvbSBuZXh0IGludFxuICAgIHZhciBuZXh0LCBjYXJyeTtcbiAgICB2YXIgYml0cyA9IG1kLmZ1bGxNZXNzYWdlTGVuZ3RoWzBdICogODtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWQuZnVsbE1lc3NhZ2VMZW5ndGgubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBuZXh0ID0gbWQuZnVsbE1lc3NhZ2VMZW5ndGhbaSArIDFdICogODtcbiAgICAgIGNhcnJ5ID0gKG5leHQgLyAweDEwMDAwMDAwMCkgPj4+IDA7XG4gICAgICBiaXRzICs9IGNhcnJ5O1xuICAgICAgZmluYWxCbG9jay5wdXRJbnQzMihiaXRzID4+PiAwKTtcbiAgICAgIGJpdHMgPSBuZXh0ID4+PiAwO1xuICAgIH1cbiAgICBmaW5hbEJsb2NrLnB1dEludDMyKGJpdHMpO1xuXG4gICAgdmFyIHMyID0ge1xuICAgICAgaDA6IF9zdGF0ZS5oMCxcbiAgICAgIGgxOiBfc3RhdGUuaDEsXG4gICAgICBoMjogX3N0YXRlLmgyLFxuICAgICAgaDM6IF9zdGF0ZS5oMyxcbiAgICAgIGg0OiBfc3RhdGUuaDQsXG4gICAgICBoNTogX3N0YXRlLmg1LFxuICAgICAgaDY6IF9zdGF0ZS5oNixcbiAgICAgIGg3OiBfc3RhdGUuaDdcbiAgICB9O1xuICAgIF91cGRhdGUoczIsIF93LCBmaW5hbEJsb2NrKTtcbiAgICB2YXIgcnZhbCA9IGZvcmdlLnV0aWwuY3JlYXRlQnVmZmVyKCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oMyk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNCk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNSk7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNik7XG4gICAgcnZhbC5wdXRJbnQzMihzMi5oNyk7XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgcmV0dXJuIG1kO1xufTtcblxuLy8gc2hhLTI1NiBwYWRkaW5nIGJ5dGVzIG5vdCBpbml0aWFsaXplZCB5ZXRcbnZhciBfcGFkZGluZyA9IG51bGw7XG52YXIgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIHRhYmxlIG9mIGNvbnN0YW50c1xudmFyIF9rID0gbnVsbDtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29uc3RhbnQgdGFibGVzLlxuICovXG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgLy8gY3JlYXRlIHBhZGRpbmdcbiAgX3BhZGRpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyOCk7XG4gIF9wYWRkaW5nICs9IGZvcmdlLnV0aWwuZmlsbFN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApLCA2NCk7XG5cbiAgLy8gY3JlYXRlIEsgdGFibGUgZm9yIFNIQS0yNTZcbiAgX2sgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSxcbiAgICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gICAgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAgIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNyxcbiAgICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gICAgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAgIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSxcbiAgICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMl07XG5cbiAgLy8gbm93IGluaXRpYWxpemVkXG4gIF9pbml0aWFsaXplZCA9IHRydWU7XG59XG5cbi8qKlxuICogVXBkYXRlcyBhIFNIQS0yNTYgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHMgdGhlIFNIQS0yNTYgc3RhdGUgdG8gdXBkYXRlLlxuICogQHBhcmFtIHcgdGhlIGFycmF5IHRvIHVzZSB0byBzdG9yZSB3b3Jkcy5cbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZSBidWZmZXIgdG8gdXBkYXRlIHdpdGguXG4gKi9cbmZ1bmN0aW9uIF91cGRhdGUocywgdywgYnl0ZXMpIHtcbiAgLy8gY29uc3VtZSA1MTIgYml0ICg2NCBieXRlKSBjaHVua3NcbiAgdmFyIHQxLCB0MiwgczAsIHMxLCBjaCwgbWFqLCBpLCBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoO1xuICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoKCk7XG4gIHdoaWxlKGxlbiA+PSA2NCkge1xuICAgIC8vIHRoZSB3IGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggc2l4dGVlbiAzMi1iaXQgYmlnLWVuZGlhbiB3b3Jkc1xuICAgIC8vIGFuZCB0aGVuIGV4dGVuZGVkIGludG8gNjQgMzItYml0IHdvcmRzIGFjY29yZGluZyB0byBTSEEtMjU2XG4gICAgZm9yKGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgd1tpXSA9IGJ5dGVzLmdldEludDMyKCk7XG4gICAgfVxuICAgIGZvcig7IGkgPCA2NDsgKytpKSB7XG4gICAgICAvLyBYT1Igd29yZCAyIHdvcmRzIGFnbyByb3QgcmlnaHQgMTcsIHJvdCByaWdodCAxOSwgc2hmdCByaWdodCAxMFxuICAgICAgdDEgPSB3W2kgLSAyXTtcbiAgICAgIHQxID1cbiAgICAgICAgKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXlxuICAgICAgICAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeXG4gICAgICAgICh0MSA+Pj4gMTApO1xuICAgICAgLy8gWE9SIHdvcmQgMTUgd29yZHMgYWdvIHJvdCByaWdodCA3LCByb3QgcmlnaHQgMTgsIHNoZnQgcmlnaHQgM1xuICAgICAgdDIgPSB3W2kgLSAxNV07XG4gICAgICB0MiA9XG4gICAgICAgICgodDIgPj4+IDcpIHwgKHQyIDw8IDI1KSkgXlxuICAgICAgICAoKHQyID4+PiAxOCkgfCAodDIgPDwgMTQpKSBeXG4gICAgICAgICh0MiA+Pj4gMyk7XG4gICAgICAvLyBzdW0odDEsIHdvcmQgNyBhZ28sIHQyLCB3b3JkIDE2IGFnbykgbW9kdWxvIDJeMzJcbiAgICAgIHdbaV0gPSAodDEgKyB3W2kgLSA3XSArIHQyICsgd1tpIC0gMTZdKSB8IDA7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rXG4gICAgYSA9IHMuaDA7XG4gICAgYiA9IHMuaDE7XG4gICAgYyA9IHMuaDI7XG4gICAgZCA9IHMuaDM7XG4gICAgZSA9IHMuaDQ7XG4gICAgZiA9IHMuaDU7XG4gICAgZyA9IHMuaDY7XG4gICAgaCA9IHMuaDc7XG5cbiAgICAvLyByb3VuZCBmdW5jdGlvblxuICAgIGZvcihpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIC8vIFN1bTEoZSlcbiAgICAgIHMxID1cbiAgICAgICAgKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXlxuICAgICAgICAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXlxuICAgICAgICAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgIC8vIENoKGUsIGYsIGcpIChvcHRpbWl6ZWQgdGhlIHNhbWUgd2F5IGFzIFNIQS0xKVxuICAgICAgY2ggPSBnIF4gKGUgJiAoZiBeIGcpKTtcbiAgICAgIC8vIFN1bTAoYSlcbiAgICAgIHMwID1cbiAgICAgICAgKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXlxuICAgICAgICAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXlxuICAgICAgICAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAvLyBNYWooYSwgYiwgYykgKG9wdGltaXplZCB0aGUgc2FtZSB3YXkgYXMgU0hBLTEpXG4gICAgICBtYWogPSAoYSAmIGIpIHwgKGMgJiAoYSBeIGIpKTtcblxuICAgICAgLy8gbWFpbiBhbGdvcml0aG1cbiAgICAgIHQxID0gaCArIHMxICsgY2ggKyBfa1tpXSArIHdbaV07XG4gICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgaCA9IGc7XG4gICAgICBnID0gZjtcbiAgICAgIGYgPSBlO1xuICAgICAgLy8gYD4+PiAwYCBuZWNlc3NhcnkgdG8gYXZvaWQgaU9TL1NhZmFyaSAxMCBvcHRpbWl6YXRpb24gYnVnXG4gICAgICAvLyBjYW4ndCB0cnVuY2F0ZSB3aXRoIGB8IDBgXG4gICAgICBlID0gKGQgKyB0MSkgPj4+IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICAvLyBgPj4+IDBgIG5lY2Vzc2FyeSB0byBhdm9pZCBpT1MvU2FmYXJpIDEwIG9wdGltaXphdGlvbiBidWdcbiAgICAgIC8vIGNhbid0IHRydW5jYXRlIHdpdGggYHwgMGBcbiAgICAgIGEgPSAodDEgKyB0MikgPj4+IDA7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGhhc2ggc3RhdGVcbiAgICBzLmgwID0gKHMuaDAgKyBhKSB8IDA7XG4gICAgcy5oMSA9IChzLmgxICsgYikgfCAwO1xuICAgIHMuaDIgPSAocy5oMiArIGMpIHwgMDtcbiAgICBzLmgzID0gKHMuaDMgKyBkKSB8IDA7XG4gICAgcy5oNCA9IChzLmg0ICsgZSkgfCAwO1xuICAgIHMuaDUgPSAocy5oNSArIGYpIHwgMDtcbiAgICBzLmg2ID0gKHMuaDYgKyBnKSB8IDA7XG4gICAgcy5oNyA9IChzLmg3ICsgaCkgfCAwO1xuICAgIGxlbiAtPSA2NDtcbiAgfVxufVxuIiwiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKi9cbnZhciBmb3JnZSA9IHJlcXVpcmUoJy4vZm9yZ2UnKTtcbnZhciBiYXNlTiA9IHJlcXVpcmUoJy4vYmFzZU4nKTtcblxuLyogVXRpbGl0aWVzIEFQSSAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnV0aWwgPSBmb3JnZS51dGlsIHx8IHt9O1xuXG4vLyBkZWZpbmUgc2V0SW1tZWRpYXRlIGFuZCBuZXh0VGlja1xuKGZ1bmN0aW9uKCkge1xuICAvLyB1c2UgbmF0aXZlIG5leHRUaWNrICh1bmxlc3Mgd2UncmUgaW4gd2VicGFjaylcbiAgLy8gd2VicGFjayAob3IgYmV0dGVyIG5vZGUtbGlicy1icm93c2VyIHBvbHlmaWxsKSBzZXRzIHByb2Nlc3MuYnJvd3Nlci5cbiAgLy8gdGhpcyB3YXkgd2UgY2FuIGRldGVjdCB3ZWJwYWNrIHByb3Blcmx5XG4gIGlmKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5leHRUaWNrICYmICFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB1dGlsLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBpZih0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1dGlsLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9seWZpbGwgc2V0SW1tZWRpYXRlIHdpdGggbmV4dFRpY2ssIG9sZGVyIHZlcnNpb25zIG9mIG5vZGVcbiAgICAgIC8vICh0aG9zZSB3L28gc2V0SW1tZWRpYXRlKSB3b24ndCB0b3RhbGx5IHN0YXJ2ZSBJT1xuICAgICAgdXRpbC5zZXRJbW1lZGlhdGUgPSB1dGlsLm5leHRUaWNrO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBwb2x5ZmlsbCBuZXh0VGljayB3aXRoIG5hdGl2ZSBzZXRJbW1lZGlhdGVcbiAgaWYodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBzZXRJbW1lZGlhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpOyB9O1xuICAgIHV0aWwubmV4dFRpY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBOb3RlOiBBIHBvbHlmaWxsIHVwZ3JhZGUgcGF0dGVybiBpcyB1c2VkIGhlcmUgdG8gYWxsb3cgY29tYmluaW5nXG4gIHBvbHlmaWxscy4gRm9yIGV4YW1wbGUsIE11dGF0aW9uT2JzZXJ2ZXIgaXMgZmFzdCwgYnV0IGJsb2NrcyBVSSB1cGRhdGVzLFxuICBzbyBpdCBuZWVkcyB0byBhbGxvdyBVSSB1cGRhdGVzIHBlcmlvZGljYWxseSwgc28gaXQgZmFsbHMgYmFjayBvblxuICBwb3N0TWVzc2FnZSBvciBzZXRUaW1lb3V0LiAqL1xuXG4gIC8vIHBvbHlmaWxsIHdpdGggc2V0VGltZW91dFxuICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gIH07XG5cbiAgLy8gdXBncmFkZSBwb2x5ZmlsbCB0byB1c2UgcG9zdE1lc3NhZ2VcbiAgaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIG1zZyA9ICdmb3JnZS5zZXRJbW1lZGlhdGUnO1xuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAvLyBvbmx5IHNlbmQgbWVzc2FnZSB3aGVuIG9uZSBoYXNuJ3QgYmVlbiBzZW50IGluXG4gICAgICAvLyB0aGUgY3VycmVudCB0dXJuIG9mIHRoZSBldmVudCBsb29wXG4gICAgICBpZihjYWxsYmFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBpZihldmVudC5zb3VyY2UgPT09IHdpbmRvdyAmJiBldmVudC5kYXRhID09PSBtc2cpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjb3B5ID0gY2FsbGJhY2tzLnNsaWNlKCk7XG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfVxuXG4gIC8vIHVwZ3JhZGUgcG9seWZpbGwgdG8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJcbiAgaWYodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gcG9seWZpbGwgd2l0aCBNdXRhdGlvbk9ic2VydmVyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIGF0dHIgPSB0cnVlO1xuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB2YXIgY2FsbGJhY2tzID0gW107XG4gICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29weSA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb3B5LmZvckVhY2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0pLm9ic2VydmUoZGl2LCB7YXR0cmlidXRlczogdHJ1ZX0pO1xuICAgIHZhciBvbGRTZXRJbW1lZGlhdGUgPSB1dGlsLnNldEltbWVkaWF0ZTtcbiAgICB1dGlsLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZihEYXRlLm5vdygpIC0gbm93ID4gMTUpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgb2xkU2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gb25seSB0cmlnZ2VyIG9ic2VydmVyIHdoZW4gaXQgaGFzbid0IGJlZW4gdHJpZ2dlcmVkIGluXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IHR1cm4gb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2EnLCBhdHRyID0gIWF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHV0aWwubmV4dFRpY2sgPSB1dGlsLnNldEltbWVkaWF0ZTtcbn0pKCk7XG5cbi8vIGNoZWNrIGlmIHJ1bm5pbmcgdW5kZXIgTm9kZS5qc1xudXRpbC5pc05vZGVqcyA9XG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcblxuXG4vLyAnc2VsZicgd2lsbCBhbHNvIHdvcmsgaW4gV2ViIFdvcmtlcnMgKGluc3RhbmNlIG9mIFdvcmtlckdsb2JhbFNjb3BlKSB3aGlsZVxuLy8gaXQgd2lsbCBwb2ludCB0byBgd2luZG93YCBpbiB0aGUgbWFpbiB0aHJlYWQuXG4vLyBUbyByZW1haW4gY29tcGF0aWJsZSB3aXRoIG9sZGVyIGJyb3dzZXJzLCB3ZSBmYWxsIGJhY2sgdG8gJ3dpbmRvdycgaWYgJ3NlbGYnXG4vLyBpcyBub3QgYXZhaWxhYmxlLlxudXRpbC5nbG9iYWxTY29wZSA9IChmdW5jdGlvbigpIHtcbiAgaWYodXRpbC5pc05vZGVqcykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZjtcbn0pKCk7XG5cbi8vIGRlZmluZSBpc0FycmF5XG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyXG51dGlsLmlzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5cbi8vIGRlZmluZSBpc0FycmF5QnVmZmVyVmlld1xudXRpbC5pc0FycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggJiYgdXRpbC5pc0FycmF5QnVmZmVyKHguYnVmZmVyKSAmJiB4LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRW5zdXJlIGEgYml0cyBwYXJhbSBpcyA4LCAxNiwgMjQsIG9yIDMyLiBVc2VkIHRvIHZhbGlkYXRlIGlucHV0IGZvclxuICogYWxnb3JpdGhtcyB3aGVyZSBiaXQgbWFuaXB1bGF0aW9uLCBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCBhbmQvb3IgYWxnb3JpdGhtXG4gKiBkZXNpZ24gb25seSBhbGxvdyBmb3IgYnl0ZSBvcGVyYXRpb25zIG9mIGEgbGltaXRlZCBzaXplLlxuICpcbiAqIEBwYXJhbSBuIG51bWJlciBvZiBiaXRzLlxuICpcbiAqIFRocm93IEVycm9yIGlmIG4gaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gX2NoZWNrQml0c1BhcmFtKG4pIHtcbiAgaWYoIShuID09PSA4IHx8IG4gPT09IDE2IHx8IG4gPT09IDI0IHx8IG4gPT09IDMyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSA4LCAxNiwgMjQsIG9yIDMyIGJpdHMgc3VwcG9ydGVkOiAnICsgbik7XG4gIH1cbn1cblxuLy8gVE9ETzogc2V0IEJ5dGVCdWZmZXIgdG8gYmVzdCBhdmFpbGFibGUgYmFja2luZ1xudXRpbC5CeXRlQnVmZmVyID0gQnl0ZVN0cmluZ0J1ZmZlcjtcblxuLyoqIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgYmluYXJ5IHN0cmluZyBiYWNrZWQgYnl0ZSBidWZmZXIuXG4gKlxuICogQHBhcmFtIFtiXSB0aGUgYnl0ZXMgdG8gd3JhcCAoZWl0aGVyIGVuY29kZWQgYXMgc3RyaW5nLCBvbmUgYnl0ZSBwZXJcbiAqICAgICAgICAgIGNoYXJhY3Rlciwgb3IgYXMgYW4gQXJyYXlCdWZmZXIgb3IgVHlwZWQgQXJyYXkpLlxuICovXG5mdW5jdGlvbiBCeXRlU3RyaW5nQnVmZmVyKGIpIHtcbiAgLy8gVE9ETzogdXBkYXRlIHRvIG1hdGNoIERhdGFCdWZmZXIgQVBJXG5cbiAgLy8gdGhlIGRhdGEgaW4gdGhpcyBidWZmZXJcbiAgdGhpcy5kYXRhID0gJyc7XG4gIC8vIHRoZSBwb2ludGVyIGZvciByZWFkaW5nIGZyb20gdGhpcyBidWZmZXJcbiAgdGhpcy5yZWFkID0gMDtcblxuICBpZih0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmRhdGEgPSBiO1xuICB9IGVsc2UgaWYodXRpbC5pc0FycmF5QnVmZmVyKGIpIHx8IHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYikpIHtcbiAgICBpZih0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBiIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLmRhdGEgPSBiLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29udmVydCBuYXRpdmUgYnVmZmVyIHRvIGZvcmdlIGJ1ZmZlclxuICAgICAgLy8gRklYTUU6IHN1cHBvcnQgbmF0aXZlIGJ1ZmZlcnMgaW50ZXJuYWxseSBpbnN0ZWFkXG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRoaXMucHV0Qnl0ZShhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYoYiBpbnN0YW5jZW9mIEJ5dGVTdHJpbmdCdWZmZXIgfHxcbiAgICAodHlwZW9mIGIgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiLmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIGIucmVhZCA9PT0gJ251bWJlcicpKSB7XG4gICAgLy8gY29weSBleGlzdGluZyBidWZmZXJcbiAgICB0aGlzLmRhdGEgPSBiLmRhdGE7XG4gICAgdGhpcy5yZWFkID0gYi5yZWFkO1xuICB9XG5cbiAgLy8gdXNlZCBmb3Igdjggb3B0aW1pemF0aW9uXG4gIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbn1cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlciA9IEJ5dGVTdHJpbmdCdWZmZXI7XG5cbi8qIE5vdGU6IFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBWOC1iYXNlZCBicm93c2Vycy4gV2hlbiBWOCBjb25jYXRlbmF0ZXNcbiAgYSBzdHJpbmcsIHRoZSBzdHJpbmdzIGFyZSBvbmx5IGpvaW5lZCBsb2dpY2FsbHkgdXNpbmcgYSBcImNvbnMgc3RyaW5nXCIgb3JcbiAgXCJjb25zdHJ1Y3RlZC9jb25jYXRlbmF0ZWQgc3RyaW5nXCIuIFRoZXNlIGNvbnRhaW5lcnMga2VlcCByZWZlcmVuY2VzIHRvIG9uZVxuICBhbm90aGVyIGFuZCBjYW4gcmVzdWx0IGluIHZlcnkgbGFyZ2UgbWVtb3J5IHVzYWdlLiBGb3IgZXhhbXBsZSwgaWYgYSAyTUJcbiAgc3RyaW5nIGlzIGNvbnN0cnVjdGVkIGJ5IGNvbmNhdGVuYXRpbmcgNCBieXRlcyB0b2dldGhlciBhdCBhIHRpbWUsIHRoZVxuICBtZW1vcnkgdXNhZ2Ugd2lsbCBiZSB+NDRNQjsgc28gfjIyeCBpbmNyZWFzZS4gVGhlIHN0cmluZ3MgYXJlIG9ubHkgam9pbmVkXG4gIHRvZ2V0aGVyIHdoZW4gYW4gb3BlcmF0aW9uIHJlcXVpcmluZyB0aGVpciBqb2luaW5nIHRha2VzIHBsYWNlLCBzdWNoIGFzXG4gIHN1YnN0cigpLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGFkZGluZyBkYXRhIHRvIHRoaXMgYnVmZmVyIHRvIGVuc3VyZVxuICB0aGVzZSB0eXBlcyBvZiBzdHJpbmdzIGFyZSBwZXJpb2RpY2FsbHkgam9pbmVkIHRvIHJlZHVjZSB0aGUgbWVtb3J5XG4gIGZvb3RwcmludC4gKi9cbnZhciBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEggPSA0MDk2O1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgdGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggKz0geDtcbiAgaWYodGhpcy5fY29uc3RydWN0ZWRTdHJpbmdMZW5ndGggPiBfTUFYX0NPTlNUUlVDVEVEX1NUUklOR19MRU5HVEgpIHtcbiAgICAvLyB0aGlzIHN1YnN0cigpIHNob3VsZCBjYXVzZSB0aGUgY29uc3RydWN0ZWQgc3RyaW5nIHRvIGpvaW5cbiAgICB0aGlzLmRhdGEuc3Vic3RyKDAsIDEpO1xuICAgIHRoaXMuX2NvbnN0cnVjdGVkU3RyaW5nTGVuZ3RoID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFN0cmluZy5mcm9tQ2hhckNvZGUoYikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgYnl0ZSBpbiB0aGlzIGJ1ZmZlciBOIHRpbWVzLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdmFsdWUgYiB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIGIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpO1xuICB2YXIgZCA9IHRoaXMuZGF0YTtcbiAgd2hpbGUobiA+IDApIHtcbiAgICBpZihuICYgMSkge1xuICAgICAgZCArPSBiO1xuICAgIH1cbiAgICBuID4+Pj0gMTtcbiAgICBpZihuID4gMCkge1xuICAgICAgYiArPSBiO1xuICAgIH1cbiAgfVxuICB0aGlzLmRhdGEgPSBkO1xuICB0aGlzLl9vcHRpbWl6ZUNvbnN0cnVjdGVkU3RyaW5nKG4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBieXRlcyBpbiB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIChhcyBhIFVURi04IGVuY29kZWQgc3RyaW5nKSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHRoaXMuZGF0YSArPSBieXRlcztcbiAgdGhpcy5fb3B0aW1pemVDb25zdHJ1Y3RlZFN0cmluZyhieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIFVURi0xNiBlbmNvZGVkIHN0cmluZyBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXModXRpbC5lbmNvZGVVdGY4KHN0cikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNiA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMjQtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMjQtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQyNCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIDMyLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIDMyLWJpdCBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiAyNCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDggJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihpKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKFxuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gOCAmIDB4RkYpICtcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMTYgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDI0ICYgMHhGRikpO1xufTtcblxuLyoqXG4gKiBQdXRzIGFuIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIGJ5dGVzID0gJyc7XG4gIGRvIHtcbiAgICBuIC09IDg7XG4gICAgYnl0ZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaSA+PiBuKSAmIDB4RkYpO1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci4gVHdvJ3NcbiAqIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5wdXRTaWduZWRJbnQgPSBmdW5jdGlvbihpLCBuKSB7XG4gIC8vIHB1dEludCBjaGVja3MgblxuICBpZihpIDwgMCkge1xuICAgIGkgKz0gMiA8PCAobiAtIDEpO1xuICB9XG4gIHJldHVybiB0aGlzLnB1dEludChpLCBuKTtcbn07XG5cbi8qKlxuICogUHV0cyB0aGUgZ2l2ZW4gYnVmZmVyIGludG8gdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciB0aGUgYnVmZmVyIHRvIHB1dCBpbnRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKGJ1ZmZlci5nZXRCeXRlcygpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgZnJvbSB0aGlzIGJ1ZmZlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSAxLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKyspO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDE2IGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMi5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MTYuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgMTYgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDIpKTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDMyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCkgPDwgMjQgXlxuICAgIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMucmVhZCArIDEpIDw8IDE2IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAzKSk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDE2TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldEludDI0TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAoXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkKSBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMSkgPDwgOCBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMikgPDwgMTYpO1xuICB0aGlzLnJlYWQgKz0gMztcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1aW50MzIgZnJvbSB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBhZHZhbmNlcyB0aGUgcmVhZFxuICogcG9pbnRlciBieSA0LlxuICpcbiAqIEByZXR1cm4gdGhlIHdvcmQuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAxKSA8PCA4IF5cbiAgICB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQgKyAyKSA8PCAxNiBeXG4gICAgdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgMykgPDwgMjQpO1xuICB0aGlzLnJlYWQgKz0gNDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZVxuICogcmVhZCBwb2ludGVyIGJ5IGNlaWwobi84KS5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24obikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHZhciBydmFsID0gMDtcbiAgZG8ge1xuICAgIC8vIFRPRE86IFVzZSAocnZhbCAqIDB4MTAwKSBpZiBhZGRpbmcgc3VwcG9ydCBmb3IgMzMgdG8gNTMgYml0cy5cbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgKyB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnJlYWQrKyk7XG4gICAgbiAtPSA4O1xuICB9IHdoaWxlKG4gPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYSBzaWduZWQgbi1iaXQgaW50ZWdlciBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIsIHVzaW5nXG4gKiB0d28ncyBjb21wbGVtZW50LCBhbmQgYWR2YW5jZXMgdGhlIHJlYWQgcG9pbnRlciBieSBuLzguXG4gKlxuICogQHBhcmFtIG4gdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBpbnRlZ2VyICg4LCAxNiwgMjQsIG9yIDMyKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbnRlZ2VyLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldFNpZ25lZEludCA9IGZ1bmN0aW9uKG4pIHtcbiAgLy8gZ2V0SW50IGNoZWNrcyBuXG4gIHZhciB4ID0gdGhpcy5nZXRJbnQobik7XG4gIHZhciBtYXggPSAyIDw8IChuIC0gMik7XG4gIGlmKHggPj0gbWF4KSB7XG4gICAgeCAtPSBtYXggPDwgMTtcbiAgfVxuICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogUmVhZHMgYnl0ZXMgb3V0IGludG8gYSBVVEYtOCBzdHJpbmcgYW5kIGNsZWFycyB0aGVtIGZyb20gdGhlIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLCB1bmRlZmluZWQgb3IgbnVsbCBmb3IgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBVVEYtOCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYoY291bnQpIHtcbiAgICAvLyByZWFkIGNvdW50IGJ5dGVzXG4gICAgY291bnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCgpLCBjb3VudCk7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMucmVhZCArIGNvdW50KTtcbiAgICB0aGlzLnJlYWQgKz0gY291bnQ7XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMCkge1xuICAgIHJ2YWwgPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGFsbCBieXRlcywgb3B0aW1pemUgdG8gb25seSBjb3B5IHdoZW4gbmVlZGVkXG4gICAgcnZhbCA9ICh0aGlzLnJlYWQgPT09IDApID8gdGhpcy5kYXRhIDogdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgVVRGLTggZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGJ5dGVzIGZyb20gdGhpcyBidWZmZXIgd2l0aG91dCBtb2RpZnlpbmdcbiAqIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2V0LCBvbWl0IHRvIGdldCBhbGwuXG4gKlxuICogQHJldHVybiBhIHN0cmluZyBmdWxsIG9mIFVURi04IGVuY29kZWQgY2hhcmFjdGVycy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHJldHVybiAodHlwZW9mKGNvdW50KSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgIHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpIDpcbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCkpO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgYnl0ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aG91dCBtb2RpZnlpbmcgdGhlIHJlYWQgcG9pbnRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgYnl0ZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy5yZWFkICsgaSk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGF0IHRoZSBnaXZlbiBpbmRleCB3aXRob3V0IG1vZGlmeWluZyB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBieXRlIGluZGV4LlxuICogQHBhcmFtIGIgdGhlIGJ5dGUgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUuc2V0QXQgPSBmdW5jdGlvbihpLCBiKSB7XG4gIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zdWJzdHIoMCwgdGhpcy5yZWFkICsgaSkgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoYikgK1xuICAgIHRoaXMuZGF0YS5zdWJzdHIodGhpcy5yZWFkICsgaSArIDEpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBieXRlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHJldHVybiB0aGUgbGFzdCBieXRlLlxuICovXG51dGlsLkJ5dGVTdHJpbmdCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5jaGFyQ29kZUF0KHRoaXMuZGF0YS5sZW5ndGggLSAxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgY29weS5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjID0gdXRpbC5jcmVhdGVCdWZmZXIodGhpcy5kYXRhKTtcbiAgYy5yZWFkID0gdGhpcy5yZWFkO1xuICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMucmVhZCA+IDApIHtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKTtcbiAgICB0aGlzLnJlYWQgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGEgPSAnJztcbiAgdGhpcy5yZWFkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNob3J0ZW5zIHRoaXMgYnVmZmVyIGJ5IHRyaW1pbmcgYnl0ZXMgb2ZmIG9mIHRoZSBlbmQgb2YgdGhpcyBidWZmZXIuXG4gKlxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gdHJpbSBvZmYuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyKHRoaXMucmVhZCwgbGVuKTtcbiAgdGhpcy5yZWFkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbnV0aWwuQnl0ZVN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAnJztcbiAgZm9yKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGIgPSB0aGlzLmRhdGEuY2hhckNvZGVBdChpKTtcbiAgICBpZihiIDwgMTYpIHtcbiAgICAgIHJ2YWwgKz0gJzAnO1xuICAgIH1cbiAgICBydmFsICs9IGIudG9TdHJpbmcoMTYpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBhIFVURi0xNiBzdHJpbmcgKHN0YW5kYXJkIEphdmFTY3JpcHQgc3RyaW5nKS5cbiAqXG4gKiBAcmV0dXJuIGEgVVRGLTE2IHN0cmluZy5cbiAqL1xudXRpbC5CeXRlU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXRpbC5kZWNvZGVVdGY4KHRoaXMuYnl0ZXMoKSk7XG59O1xuXG4vKiogRW5kIEJ1ZmZlciB3L0JpbmFyeVN0cmluZyBiYWNraW5nICovXG5cbi8qKiBCdWZmZXIgdy9VSW50OEFycmF5IGJhY2tpbmcgKi9cblxuLyoqXG4gKiBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbiAqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYW4gQXJyYXlCdWZmZXItYmFja2VkIGJ5dGUgYnVmZmVyLlxuICpcbiAqIFRoZSBidWZmZXIgbWF5IGJlIGNvbnN0cnVjdGVkIGZyb20gYSBzdHJpbmcsIGFuIEFycmF5QnVmZmVyLCBEYXRhVmlldywgb3IgYVxuICogVHlwZWRBcnJheS5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBnaXZlbiwgaXRzIGVuY29kaW5nIHNob3VsZCBiZSBwcm92aWRlZCBhcyBhbiBvcHRpb24sXG4gKiBvdGhlcndpc2UgaXQgd2lsbCBkZWZhdWx0IHRvICdiaW5hcnknLiBBICdiaW5hcnknIHN0cmluZyBpcyBlbmNvZGVkIHN1Y2hcbiAqIHRoYXQgZWFjaCBjaGFyYWN0ZXIgaXMgb25lIGJ5dGUgaW4gbGVuZ3RoIGFuZCBzaXplLlxuICpcbiAqIElmIGFuIEFycmF5QnVmZmVyLCBEYXRhVmlldywgb3IgVHlwZWRBcnJheSBpcyBnaXZlbiwgaXQgd2lsbCBiZSB1c2VkXG4gKiAqZGlyZWN0bHkqIHdpdGhvdXQgYW55IGNvcHlpbmcuIE5vdGUgdGhhdCwgaWYgYSB3cml0ZSB0byB0aGUgYnVmZmVyIHJlcXVpcmVzXG4gKiBtb3JlIHNwYWNlLCB0aGUgYnVmZmVyIHdpbGwgYWxsb2NhdGUgYSBuZXcgYmFja2luZyBBcnJheUJ1ZmZlciB0b1xuICogYWNjb21tb2RhdGUuIFRoZSBzdGFydGluZyByZWFkIGFuZCB3cml0ZSBvZmZzZXRzIGZvciB0aGUgYnVmZmVyIG1heSBiZVxuICogZ2l2ZW4gYXMgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gW2JdIHRoZSBpbml0aWFsIGJ5dGVzIGZvciB0aGlzIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtyZWFkT2Zmc2V0XSB0aGUgc3RhcnRpbmcgcmVhZCBvZmZzZXQgdG8gdXNlIChkZWZhdWx0OiAwKS5cbiAqICAgICAgICAgIFt3cml0ZU9mZnNldF0gdGhlIHN0YXJ0aW5nIHdyaXRlIG9mZnNldCB0byB1c2UgKGRlZmF1bHQ6IHRoZVxuICogICAgICAgICAgICBsZW5ndGggb2YgdGhlIGZpcnN0IHBhcmFtZXRlcikuXG4gKiAgICAgICAgICBbZ3Jvd1NpemVdIHRoZSBtaW5pbXVtIGFtb3VudCwgaW4gYnl0ZXMsIHRvIGdyb3cgdGhlIGJ1ZmZlciBieSB0b1xuICogICAgICAgICAgICBhY2NvbW1vZGF0ZSB3cml0ZXMgKGRlZmF1bHQ6IDEwMjQpLlxuICogICAgICAgICAgW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgKCdiaW5hcnknLCAndXRmOCcsICd1dGYxNicsICdoZXgnKSBmb3IgdGhlXG4gKiAgICAgICAgICAgIGZpcnN0IHBhcmFtZXRlciwgaWYgaXQgaXMgYSBzdHJpbmcgKGRlZmF1bHQ6ICdiaW5hcnknKS5cbiAqL1xuZnVuY3Rpb24gRGF0YUJ1ZmZlcihiLCBvcHRpb25zKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBwb2ludGVycyBmb3IgcmVhZCBmcm9tL3dyaXRlIHRvIGJ1ZmZlclxuICB0aGlzLnJlYWQgPSBvcHRpb25zLnJlYWRPZmZzZXQgfHwgMDtcbiAgdGhpcy5ncm93U2l6ZSA9IG9wdGlvbnMuZ3Jvd1NpemUgfHwgMTAyNDtcblxuICB2YXIgaXNBcnJheUJ1ZmZlciA9IHV0aWwuaXNBcnJheUJ1ZmZlcihiKTtcbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID0gdXRpbC5pc0FycmF5QnVmZmVyVmlldyhiKTtcbiAgaWYoaXNBcnJheUJ1ZmZlciB8fCBpc0FycmF5QnVmZmVyVmlldykge1xuICAgIC8vIHVzZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgIGlmKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRqdXN0IHJlYWQvd3JpdGUgb2Zmc2V0IGJhc2VkIG9uIHRoZSB0eXBlIG9mIHZpZXdcbiAgICAgIC8vIG9yIHNwZWNpZnkgdGhhdCB0aGlzIG11c3QgYmUgZG9uZSBpbiB0aGUgb3B0aW9ucyAuLi4gdGhhdCB0aGVcbiAgICAgIC8vIG9mZnNldHMgYXJlIGJ5dGUtYmFzZWRcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICB0aGlzLndyaXRlID0gKCd3cml0ZU9mZnNldCcgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLndyaXRlT2Zmc2V0IDogdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgdG8gZW1wdHkgYXJyYXkgYnVmZmVyIGFuZCBhZGQgYW55IGdpdmVuIGJ5dGVzIHVzaW5nIHB1dEJ5dGVzXG4gIHRoaXMuZGF0YSA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB0aGlzLndyaXRlID0gMDtcblxuICBpZihiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMucHV0Qnl0ZXMoYik7XG4gIH1cblxuICBpZignd3JpdGVPZmZzZXQnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLndyaXRlID0gb3B0aW9ucy53cml0ZU9mZnNldDtcbiAgfVxufVxudXRpbC5EYXRhQnVmZmVyID0gRGF0YUJ1ZmZlcjtcblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53cml0ZSAtIHRoaXMucmVhZDtcbn07XG5cbi8qKlxuICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGlzIGJ1ZmZlciBpcyBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBidWZmZXIgaXMgZW1wdHksIGZhbHNlIGlmIG5vdC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhpcyBidWZmZXIgaGFzIGVub3VnaCBlbXB0eSBzcGFjZSB0byBhY2NvbW1vZGF0ZSB0aGUgZ2l2ZW4gbnVtYmVyXG4gKiBvZiBieXRlcy4gQW4gb3B0aW9uYWwgcGFyYW1ldGVyIG1heSBiZSBnaXZlbiB0aGF0IGluZGljYXRlcyBhIG1pbmltdW1cbiAqIGFtb3VudCB0byBncm93IHRoZSBidWZmZXIgaWYgbmVjZXNzYXJ5LiBJZiB0aGUgcGFyYW1ldGVyIGlzIG5vdCBnaXZlbixcbiAqIHRoZSBidWZmZXIgd2lsbCBiZSBncm93biBieSBzb21lIHByZXZpb3VzbHktc3BlY2lmaWVkIGRlZmF1bHQgYW1vdW50XG4gKiBvciBoZXVyaXN0aWMuXG4gKlxuICogQHBhcmFtIGFtb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGFjY29tbW9kYXRlLlxuICogQHBhcmFtIFtncm93U2l6ZV0gdGhlIG1pbmltdW0gYW1vdW50LCBpbiBieXRlcywgdG8gZ3JvdyB0aGUgYnVmZmVyIGJ5IGlmXG4gKiAgICAgICAgICBuZWNlc3NhcnkuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYWNjb21tb2RhdGUgPSBmdW5jdGlvbihhbW91bnQsIGdyb3dTaXplKSB7XG4gIGlmKHRoaXMubGVuZ3RoKCkgPj0gYW1vdW50KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3Jvd1NpemUgPSBNYXRoLm1heChncm93U2l6ZSB8fCB0aGlzLmdyb3dTaXplLCBhbW91bnQpO1xuXG4gIC8vIGdyb3cgYnVmZmVyXG4gIHZhciBzcmMgPSBuZXcgVWludDhBcnJheShcbiAgICB0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLmRhdGEuYnl0ZU9mZnNldCwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpO1xuICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgoKSArIGdyb3dTaXplKTtcbiAgZHN0LnNldChzcmMpO1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoZHN0LmJ1ZmZlcik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSBieXRlIGluIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBiIHRoZSBieXRlIHRvIHB1dC5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMSk7XG4gIHRoaXMuZGF0YS5zZXRVaW50OCh0aGlzLndyaXRlKyssIGIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgaW4gdGhpcyBidWZmZXIgTiB0aW1lcy5cbiAqXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIG9mIHZhbHVlIGIgdG8gcHV0LlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZmlsbFdpdGhCeXRlID0gZnVuY3Rpb24oYiwgbikge1xuICB0aGlzLmFjY29tbW9kYXRlKG4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdGhpcy5kYXRhLnNldFVpbnQ4KGIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGJ5dGVzIGluIHRoaXMgYnVmZmVyLiBUaGUgYnl0ZXMgbWF5IGJlIGdpdmVuIGFzIGEgc3RyaW5nLCBhblxuICogQXJyYXlCdWZmZXIsIGEgRGF0YVZpZXcsIG9yIGEgVHlwZWRBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGVzIHRvIHB1dC5cbiAqIEBwYXJhbSBbZW5jb2RpbmddIHRoZSBlbmNvZGluZyBmb3IgdGhlIGZpcnN0IHBhcmFtZXRlciAoJ2JpbmFyeScsICd1dGY4JyxcbiAqICAgICAgICAgICd1dGYxNicsICdoZXgnKSwgaWYgaXQgaXMgYSBzdHJpbmcgKGRlZmF1bHQ6ICdiaW5hcnknKS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIGVuY29kaW5nKSB7XG4gIGlmKHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYnl0ZXMpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgdmFyIGxlbiA9IHNyYy5ieXRlTGVuZ3RoIC0gc3JjLmJ5dGVPZmZzZXQ7XG4gICAgdGhpcy5hY2NvbW1vZGF0ZShsZW4pO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICBkc3Quc2V0KHNyYyk7XG4gICAgdGhpcy53cml0ZSArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZih1dGlsLmlzQXJyYXlCdWZmZXIoYnl0ZXMpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICB0aGlzLmFjY29tbW9kYXRlKHNyYy5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlcik7XG4gICAgZHN0LnNldChzcmMsIHRoaXMud3JpdGUpO1xuICAgIHRoaXMud3JpdGUgKz0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBieXRlcyBpcyBhIHV0aWwuRGF0YUJ1ZmZlciBvciBlcXVpdmFsZW50XG4gIGlmKGJ5dGVzIGluc3RhbmNlb2YgdXRpbC5EYXRhQnVmZmVyIHx8XG4gICAgKHR5cGVvZiBieXRlcyA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgYnl0ZXMucmVhZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGJ5dGVzLndyaXRlID09PSAnbnVtYmVyJyAmJlxuICAgIHV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYnl0ZXMuZGF0YSkpKSB7XG4gICAgdmFyIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmRhdGEuYnl0ZUxlbmd0aCwgYnl0ZXMucmVhZCwgYnl0ZXMubGVuZ3RoKCkpO1xuICAgIHRoaXMuYWNjb21tb2RhdGUoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIHZhciBkc3QgPSBuZXcgVWludDhBcnJheShieXRlcy5kYXRhLmJ5dGVMZW5ndGgsIHRoaXMud3JpdGUpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLndyaXRlICs9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYoYnl0ZXMgaW5zdGFuY2VvZiB1dGlsLkJ5dGVTdHJpbmdCdWZmZXIpIHtcbiAgICAvLyBjb3B5IGJpbmFyeSBzdHJpbmcgYW5kIHByb2Nlc3MgYXMgdGhlIHNhbWUgYXMgYSBzdHJpbmcgcGFyYW1ldGVyIGJlbG93XG4gICAgYnl0ZXMgPSBieXRlcy5kYXRhO1xuICAgIGVuY29kaW5nID0gJ2JpbmFyeSc7XG4gIH1cblxuICAvLyBzdHJpbmcgY29udmVyc2lvblxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICdiaW5hcnknO1xuICBpZih0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZpZXc7XG5cbiAgICAvLyBkZWNvZGUgZnJvbSBzdHJpbmdcbiAgICBpZihlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoTWF0aC5jZWlsKGJ5dGVzLmxlbmd0aCAvIDIpKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkuaGV4LmRlY29kZShieXRlcywgdmlldywgdGhpcy53cml0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChieXRlcy5sZW5ndGggLyA0KSAqIDMpO1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YS5idWZmZXIsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSArPSB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlKGJ5dGVzLCB2aWV3LCB0aGlzLndyaXRlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSB0ZXh0IGFzIFVURi04IGJ5dGVzXG4gICAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgICAgLy8gZW5jb2RlIGFzIFVURi04IHRoZW4gZGVjb2RlIHN0cmluZyBhcyByYXcgYmluYXJ5XG4gICAgICBieXRlcyA9IHV0aWwuZW5jb2RlVXRmOChieXRlcyk7XG4gICAgICBlbmNvZGluZyA9ICdiaW5hcnknO1xuICAgIH1cblxuICAgIC8vIGRlY29kZSBzdHJpbmcgYXMgcmF3IGJpbmFyeVxuICAgIGlmKGVuY29kaW5nID09PSAnYmluYXJ5JyB8fCBlbmNvZGluZyA9PT0gJ3JhdycpIHtcbiAgICAgIC8vIG9uZSBieXRlIHBlciBjaGFyYWN0ZXJcbiAgICAgIHRoaXMuYWNjb21tb2RhdGUoYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEuYnVmZmVyLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgKz0gdXRpbC5iaW5hcnkucmF3LmRlY29kZSh2aWV3KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVuY29kZSB0ZXh0IGFzIFVURi0xNiBieXRlc1xuICAgIGlmKGVuY29kaW5nID09PSAndXRmMTYnKSB7XG4gICAgICAvLyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgICAgdGhpcy5hY2NvbW1vZGF0ZShieXRlcy5sZW5ndGggKiAyKTtcbiAgICAgIHZpZXcgPSBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy53cml0ZSk7XG4gICAgICB0aGlzLndyaXRlICs9IHV0aWwudGV4dC51dGYxNi5lbmNvZGUodmlldyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cblxuICB0aHJvdyBFcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBieXRlcyk7XG59O1xuXG4vKipcbiAqIFB1dHMgdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgdGhlIGJ1ZmZlciB0byBwdXQgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB0aGlzLnB1dEJ5dGVzKGJ1ZmZlcik7XG4gIGJ1ZmZlci5jbGVhcigpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhIHN0cmluZyBpbnRvIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBwdXQuXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgZm9yIHRoZSBzdHJpbmcgKGRlZmF1bHQ6ICd1dGYxNicpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHN0ciwgJ3V0ZjE2Jyk7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAxNi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAxNi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSk7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBiaWctZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSA+PiA4ICYgMHhGRkZGKTtcbiAgdGhpcy5kYXRhLnNldEludDgodGhpcy53cml0ZSwgaSA+PiAxNiAmIDB4RkYpO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMzItYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMzItYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMiA9IGZ1bmN0aW9uKGkpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhLnNldEludDMyKHRoaXMud3JpdGUsIGkpO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgMTYtYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlci5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgMTYtYml0IGludGVnZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlID0gZnVuY3Rpb24oaSkge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGEuc2V0SW50MTYodGhpcy53cml0ZSwgaSwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAyNC1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAyNC1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUsIGkgPj4gMTYgJiAweEZGKTtcbiAgdGhpcy5kYXRhLnNldEludDE2KHRoaXMud3JpdGUsIGkgPj4gOCAmIDB4RkZGRiwgdHJ1ZSk7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFB1dHMgYSAzMi1iaXQgaW50ZWdlciBpbiB0aGlzIGJ1ZmZlciBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBpIHRoZSAzMi1iaXQgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyTGUgPSBmdW5jdGlvbihpKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YS5zZXRJbnQzMih0aGlzLndyaXRlLCBpLCB0cnVlKTtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUHV0cyBhbiBuLWJpdCBpbnRlZ2VyIGluIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIG4tYml0IGludGVnZXIuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24oaSwgbikge1xuICBfY2hlY2tCaXRzUGFyYW0obik7XG4gIHRoaXMuYWNjb21tb2RhdGUobiAvIDgpO1xuICBkbyB7XG4gICAgbiAtPSA4O1xuICAgIHRoaXMuZGF0YS5zZXRJbnQ4KHRoaXMud3JpdGUrKywgKGkgPj4gbikgJiAweEZGKTtcbiAgfSB3aGlsZShuID4gMCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgc2lnbmVkIG4tYml0IGludGVnZXIgaW4gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlci4gVHdvJ3NcbiAqIGNvbXBsZW1lbnQgcmVwcmVzZW50YXRpb24gaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gaSB0aGUgbi1iaXQgaW50ZWdlci5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJuIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKGksIG4pIHtcbiAgX2NoZWNrQml0c1BhcmFtKG4pO1xuICB0aGlzLmFjY29tbW9kYXRlKG4gLyA4KTtcbiAgaWYoaSA8IDApIHtcbiAgICBpICs9IDIgPDwgKG4gLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQoaSwgbik7XG59O1xuXG4vKipcbiAqIEdldHMgYSBieXRlIGZyb20gdGhpcyBidWZmZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkIHBvaW50ZXIgYnkgMS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCsrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMucmVhZCk7XG4gIHRoaXMucmVhZCArPSAyO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQyNCBmcm9tIHRoaXMgYnVmZmVyIGluIGJpZy1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDMuXG4gKlxuICogQHJldHVybiB0aGUgdWludDI0LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gKFxuICAgIHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLnJlYWQpIDw8IDggXlxuICAgIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCArIDIpKTtcbiAgdGhpcy5yZWFkICs9IDM7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDMyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgNC5cbiAqXG4gKiBAcmV0dXJuIHRoZSB3b3JkLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDMyKHRoaXMucmVhZCk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQxNiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDIuXG4gKlxuICogQHJldHVybiB0aGUgdWludDE2LlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2TGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkLCB0cnVlKTtcbiAgdGhpcy5yZWFkICs9IDI7XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgdWludDI0IGZyb20gdGhpcyBidWZmZXIgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlIHJlYWRcbiAqIHBvaW50ZXIgYnkgMy5cbiAqXG4gKiBAcmV0dXJuIHRoZSB1aW50MjQuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcnZhbCA9IChcbiAgICB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLnJlYWQpIF5cbiAgICB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5yZWFkICsgMSwgdHJ1ZSkgPDwgOCk7XG4gIHRoaXMucmVhZCArPSAzO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHVpbnQzMiBmcm9tIHRoaXMgYnVmZmVyIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgYW5kIGFkdmFuY2VzIHRoZSByZWFkXG4gKiBwb2ludGVyIGJ5IDQuXG4gKlxuICogQHJldHVybiB0aGUgd29yZC5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQzMkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydmFsID0gdGhpcy5kYXRhLmdldEludDMyKHRoaXMucmVhZCwgdHJ1ZSk7XG4gIHRoaXMucmVhZCArPSA0O1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhbiBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciBhbmQgYWR2YW5jZXMgdGhlXG4gKiByZWFkIHBvaW50ZXIgYnkgbi84LlxuICpcbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgYml0cyBpbiB0aGUgaW50ZWdlciAoOCwgMTYsIDI0LCBvciAzMikuXG4gKlxuICogQHJldHVybiB0aGUgaW50ZWdlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQgPSBmdW5jdGlvbihuKSB7XG4gIF9jaGVja0JpdHNQYXJhbShuKTtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgLy8gVE9ETzogVXNlIChydmFsICogMHgxMDApIGlmIGFkZGluZyBzdXBwb3J0IGZvciAzMyB0byA1MyBiaXRzLlxuICAgIHJ2YWwgPSAocnZhbCA8PCA4KSArIHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMucmVhZCsrKTtcbiAgICBuIC09IDg7XG4gIH0gd2hpbGUobiA+IDApO1xuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNpZ25lZCBuLWJpdCBpbnRlZ2VyIGZyb20gdGhpcyBidWZmZXIgaW4gYmlnLWVuZGlhbiBvcmRlciwgdXNpbmdcbiAqIHR3bydzIGNvbXBsZW1lbnQsIGFuZCBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIGJ5IG4vOC5cbiAqXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGludGVnZXIgKDgsIDE2LCAyNCwgb3IgMzIpLlxuICpcbiAqIEByZXR1cm4gdGhlIGludGVnZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0U2lnbmVkSW50ID0gZnVuY3Rpb24obikge1xuICAvLyBnZXRJbnQgY2hlY2tzIG5cbiAgdmFyIHggPSB0aGlzLmdldEludChuKTtcbiAgdmFyIG1heCA9IDIgPDwgKG4gLSAyKTtcbiAgaWYoeCA+PSBtYXgpIHtcbiAgICB4IC09IG1heCA8PCAxO1xuICB9XG4gIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBSZWFkcyBieXRlcyBvdXQgaW50byBhIFVURi04IHN0cmluZyBhbmQgY2xlYXJzIHRoZW0gZnJvbSB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQsIHVuZGVmaW5lZCBvciBudWxsIGZvciBhbGwuXG4gKlxuICogQHJldHVybiBhIFVURi04IHN0cmluZyBvZiBieXRlcy5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZSB0aGlzIG1ldGhvZCwgaXQgaXMgcG9vcmx5IG5hbWVkIGFuZFxuICAvLyB0aGlzLnRvU3RyaW5nKCdiaW5hcnknKSByZXBsYWNlcyBpdFxuICAvLyBhZGQgYSB0b1R5cGVkQXJyYXkoKS90b0FycmF5QnVmZmVyKCkgZnVuY3Rpb25cbiAgdmFyIHJ2YWw7XG4gIGlmKGNvdW50KSB7XG4gICAgLy8gcmVhZCBjb3VudCBieXRlc1xuICAgIGNvdW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgoKSwgY291bnQpO1xuICAgIHJ2YWwgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLnJlYWQgKyBjb3VudCk7XG4gICAgdGhpcy5yZWFkICs9IGNvdW50O1xuICB9IGVsc2UgaWYoY291bnQgPT09IDApIHtcbiAgICBydmFsID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBhbGwgYnl0ZXMsIG9wdGltaXplIHRvIG9ubHkgY29weSB3aGVuIG5lZWRlZFxuICAgIHJ2YWwgPSAodGhpcy5yZWFkID09PSAwKSA/IHRoaXMuZGF0YSA6IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogR2V0cyBhIFVURi04IGVuY29kZWQgc3RyaW5nIG9mIHRoZSBieXRlcyBmcm9tIHRoaXMgYnVmZmVyIHdpdGhvdXQgbW9kaWZ5aW5nXG4gKiB0aGUgcmVhZCBwb2ludGVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdldCwgb21pdCB0byBnZXQgYWxsLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgZnVsbCBvZiBVVEYtOCBlbmNvZGVkIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBtZXRob2QsIGl0IGlzIHBvb3JseSBuYW1lZCwgYWRkIFwiZ2V0U3RyaW5nKClcIlxuICByZXR1cm4gKHR5cGVvZihjb3VudCkgPT09ICd1bmRlZmluZWQnID9cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkKSA6XG4gICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMucmVhZCwgdGhpcy5yZWFkICsgY291bnQpKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKlxuICogQHJldHVybiB0aGUgYnl0ZS5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLnJlYWQgKyBpKTtcbn07XG5cbi8qKlxuICogUHV0cyBhIGJ5dGUgYXQgdGhlIGdpdmVuIGluZGV4IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHBhcmFtIGkgdGhlIGJ5dGUgaW5kZXguXG4gKiBAcGFyYW0gYiB0aGUgYnl0ZSB0byBwdXQuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGksIGIpIHtcbiAgdGhpcy5kYXRhLnNldFVpbnQ4KGksIGIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBieXRlIHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSByZWFkIHBvaW50ZXIuXG4gKlxuICogQHJldHVybiB0aGUgbGFzdCBieXRlLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLndyaXRlIC0gMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEByZXR1cm4gdGhlIGNvcHkuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IHV0aWwuRGF0YUJ1ZmZlcih0aGlzKTtcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMucmVhZCA+IDApIHtcbiAgICB2YXIgc3JjID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhLmJ1ZmZlciwgdGhpcy5yZWFkKTtcbiAgICB2YXIgZHN0ID0gbmV3IFVpbnQ4QXJyYXkoc3JjLmJ5dGVMZW5ndGgpO1xuICAgIGRzdC5zZXQoc3JjKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcoZHN0KTtcbiAgICB0aGlzLndyaXRlIC09IHRoaXMucmVhZDtcbiAgICB0aGlzLnJlYWQgPSAwO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBidWZmZXIuXG4gKlxuICogQHJldHVybiB0aGlzIGJ1ZmZlci5cbiAqL1xudXRpbC5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRhdGEgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTaG9ydGVucyB0aGlzIGJ1ZmZlciBieSB0cmltaW5nIGJ5dGVzIG9mZiBvZiB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHRyaW0gb2ZmLlxuICpcbiAqIEByZXR1cm4gdGhpcyBidWZmZXIuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihjb3VudCkge1xuICB0aGlzLndyaXRlID0gTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGgoKSAtIGNvdW50KTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbnV0aWwuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJ2YWwgPSAnJztcbiAgZm9yKHZhciBpID0gdGhpcy5yZWFkOyBpIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGg7ICsraSkge1xuICAgIHZhciBiID0gdGhpcy5kYXRhLmdldFVpbnQ4KGkpO1xuICAgIGlmKGIgPCAxNikge1xuICAgICAgcnZhbCArPSAnMCc7XG4gICAgfVxuICAgIHJ2YWwgKz0gYi50b1N0cmluZygxNik7XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGEgc3RyaW5nLCB1c2luZyB0aGUgZ2l2ZW4gZW5jb2RpbmcuIElmIG5vXG4gKiBlbmNvZGluZyBpcyBnaXZlbiwgJ3V0ZjgnIChVVEYtOCkgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0gW2VuY29kaW5nXSB0aGUgZW5jb2RpbmcgdG8gdXNlOiAnYmluYXJ5JywgJ3V0ZjgnLCAndXRmMTYnLCAnaGV4JyxcbiAqICAgICAgICAgICdiYXNlNjQnIChkZWZhdWx0OiAndXRmOCcpLlxuICpcbiAqIEByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLlxuICovXG51dGlsLkRhdGFCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIHRoaXMucmVhZCwgdGhpcy5sZW5ndGgoKSk7XG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIGVuY29kZSB0byBzdHJpbmdcbiAgaWYoZW5jb2RpbmcgPT09ICdiaW5hcnknIHx8IGVuY29kaW5nID09PSAncmF3Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5yYXcuZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5oZXguZW5jb2RlKHZpZXcpO1xuICB9XG4gIGlmKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIHJldHVybiB1dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlKHZpZXcpO1xuICB9XG5cbiAgLy8gZGVjb2RlIHRvIHRleHRcbiAgaWYoZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIHJldHVybiB1dGlsLnRleHQudXRmOC5kZWNvZGUodmlldyk7XG4gIH1cbiAgaWYoZW5jb2RpbmcgPT09ICd1dGYxNicpIHtcbiAgICByZXR1cm4gdXRpbC50ZXh0LnV0ZjE2LmRlY29kZSh2aWV3KTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbn07XG5cbi8qKiBFbmQgQnVmZmVyIHcvVUludDhBcnJheSBiYWNraW5nICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGJ1ZmZlciB0aGF0IHN0b3JlcyBieXRlcy4gQSB2YWx1ZSBtYXkgYmUgZ2l2ZW4gdG8gcHV0IGludG8gdGhlXG4gKiBidWZmZXIgdGhhdCBpcyBlaXRoZXIgYSBzdHJpbmcgb2YgYnl0ZXMgb3IgYSBVVEYtMTYgc3RyaW5nIHRoYXQgd2lsbFxuICogYmUgZW5jb2RlZCB1c2luZyBVVEYtOCAodG8gZG8gdGhlIGxhdHRlciwgc3BlY2lmeSAndXRmOCcgYXMgdGhlIGVuY29kaW5nKS5cbiAqXG4gKiBAcGFyYW0gW2lucHV0XSB0aGUgYnl0ZXMgdG8gd3JhcCAoYXMgYSBzdHJpbmcpIG9yIGEgVVRGLTE2IHN0cmluZyB0byBlbmNvZGVcbiAqICAgICAgICAgIGFzIFVURi04LlxuICogQHBhcmFtIFtlbmNvZGluZ10gKGRlZmF1bHQ6ICdyYXcnLCBvdGhlcjogJ3V0ZjgnKS5cbiAqL1xudXRpbC5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbihpbnB1dCwgZW5jb2RpbmcpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlLCB1c2UgbmV3IEJ5dGVCdWZmZXIoKSBpbnN0ZWFkXG4gIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3Jhdyc7XG4gIGlmKGlucHV0ICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgPT09ICd1dGY4Jykge1xuICAgIGlucHV0ID0gdXRpbC5lbmNvZGVVdGY4KGlucHV0KTtcbiAgfVxuICByZXR1cm4gbmV3IHV0aWwuQnl0ZUJ1ZmZlcihpbnB1dCk7XG59O1xuXG4vKipcbiAqIEZpbGxzIGEgc3RyaW5nIHdpdGggYSBwYXJ0aWN1bGFyIHZhbHVlLiBJZiB5b3Ugd2FudCB0aGUgc3RyaW5nIHRvIGJlIGEgYnl0ZVxuICogc3RyaW5nLCBwYXNzIGluIFN0cmluZy5mcm9tQ2hhckNvZGUodGhlQnl0ZSkuXG4gKlxuICogQHBhcmFtIGMgdGhlIGNoYXJhY3RlciB0byBmaWxsIHRoZSBzdHJpbmcgd2l0aCwgdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAqICAgICAgICAgIHRvIGZpbGwgdGhlIHN0cmluZyB3aXRoIGEgYnl0ZSB2YWx1ZS5cbiAqIEBwYXJhbSBuIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvZiB2YWx1ZSBjIHRvIGZpbGwgd2l0aC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBmaWxsZWQgc3RyaW5nLlxuICovXG51dGlsLmZpbGxTdHJpbmcgPSBmdW5jdGlvbihjLCBuKSB7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlKG4gPiAwKSB7XG4gICAgaWYobiAmIDEpIHtcbiAgICAgIHMgKz0gYztcbiAgICB9XG4gICAgbiA+Pj49IDE7XG4gICAgaWYobiA+IDApIHtcbiAgICAgIGMgKz0gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgcGVyIGJ5dGUgWE9SIGJldHdlZW4gdHdvIGJ5dGUgc3RyaW5ncyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGFcbiAqIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gczEgZmlyc3Qgc3RyaW5nIG9mIGJ5dGVzLlxuICogQHBhcmFtIHMyIHNlY29uZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIFhPUi5cbiAqXG4gKiBAcmV0dXJuIHRoZSBYT1InZCByZXN1bHQuXG4gKi9cbnV0aWwueG9yQnl0ZXMgPSBmdW5jdGlvbihzMSwgczIsIG4pIHtcbiAgdmFyIHMzID0gJyc7XG4gIHZhciBiID0gJyc7XG4gIHZhciB0ID0gJyc7XG4gIHZhciBpID0gMDtcbiAgdmFyIGMgPSAwO1xuICBmb3IoOyBuID4gMDsgLS1uLCArK2kpIHtcbiAgICBiID0gczEuY2hhckNvZGVBdChpKSBeIHMyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYoYyA+PSAxMCkge1xuICAgICAgczMgKz0gdDtcbiAgICAgIHQgPSAnJztcbiAgICAgIGMgPSAwO1xuICAgIH1cbiAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7XG4gICAgKytjO1xuICB9XG4gIHMzICs9IHQ7XG4gIHJldHVybiBzMztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggc3RyaW5nIGludG8gYSAnYmluYXJ5JyBlbmNvZGVkIHN0cmluZyBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gaGV4IHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuaGV4VG9CeXRlcyA9IGZ1bmN0aW9uKGhleCkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmhleC5kZWNvZGUgaW5zdGVhZC5cIlxuICB2YXIgcnZhbCA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIGlmKGhleC5sZW5ndGggJiAxID09IDEpIHtcbiAgICAvLyBvZGQgbnVtYmVyIG9mIGNoYXJhY3RlcnMsIGNvbnZlcnQgZmlyc3QgY2hhcmFjdGVyIGFsb25lXG4gICAgaSA9IDE7XG4gICAgcnZhbCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleFswXSwgMTYpKTtcbiAgfVxuICAvLyBjb252ZXJ0IDIgY2hhcmFjdGVycyAoMSBieXRlKSBhdCBhIHRpbWVcbiAgZm9yKDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJ2YWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNikpO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzIHRvIGhleC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGJ5dGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKi9cbnV0aWwuYnl0ZXNUb0hleCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8vIFRPRE86IGRlcHJlY2F0ZTogXCJEZXByZWNhdGVkLiBVc2UgdXRpbC5iaW5hcnkuaGV4LmVuY29kZSBpbnN0ZWFkLlwiXG4gIHJldHVybiB1dGlsLmNyZWF0ZUJ1ZmZlcihieXRlcykudG9IZXgoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gMzItYml0IGludGVnZXIgdG8gNC1iaWctZW5kaWFuIGJ5dGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBpIHRoZSBpbnRlZ2VyLlxuICpcbiAqIEByZXR1cm4gdGhlIGJ5dGUgc3RyaW5nLlxuICovXG51dGlsLmludDMyVG9CeXRlcyA9IGZ1bmN0aW9uKGkpIHtcbiAgcmV0dXJuIChcbiAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgPj4gMjQgJiAweEZGKSArXG4gICAgU3RyaW5nLmZyb21DaGFyQ29kZShpID4+IDE2ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA+PiA4ICYgMHhGRikgK1xuICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSAmIDB4RkYpKTtcbn07XG5cbi8vIGJhc2U2NCBjaGFyYWN0ZXJzLCByZXZlcnNlIG1hcHBpbmdcbnZhciBfYmFzZTY0ID1cbiAgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbnZhciBfYmFzZTY0SWR4ID0gW1xuLyo0MyAtNDMgPSAwKi9cbi8qJysnLCAgMSwgIDIsICAzLCcvJyAqL1xuICAgNjIsIC0xLCAtMSwgLTEsIDYzLFxuXG4vKicwJywnMScsJzInLCczJywnNCcsJzUnLCc2JywnNycsJzgnLCc5JyAqL1xuICAgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsXG5cbi8qMTUsIDE2LCAxNywnPScsIDE5LCAyMCwgMjEgKi9cbiAgLTEsIC0xLCAtMSwgNjQsIC0xLCAtMSwgLTEsXG5cbi8qNjUgLSA0MyA9IDIyKi9cbi8qJ0EnLCdCJywnQycsJ0QnLCdFJywnRicsJ0cnLCdIJywnSScsJ0onLCdLJywnTCcsJ00nLCAqL1xuICAgMCwgIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMixcblxuLyonTicsJ08nLCdQJywnUScsJ1InLCdTJywnVCcsJ1UnLCdWJywnVycsJ1gnLCdZJywnWicgKi9cbiAgIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LFxuXG4vKjkxIC0gNDMgPSA0OCAqL1xuLyo0OCwgNDksIDUwLCA1MSwgNTIsIDUzICovXG4gIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG5cbi8qOTcgLSA0MyA9IDU0Ki9cbi8qJ2EnLCdiJywnYycsJ2QnLCdlJywnZicsJ2cnLCdoJywnaScsJ2onLCdrJywnbCcsJ20nICovXG4gICAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCxcblxuLyonbicsJ28nLCdwJywncScsJ3InLCdzJywndCcsJ3UnLCd2JywndycsJ3gnLCd5JywneicgKi9cbiAgIDM5LCA0MCwgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxXG5dO1xuXG4vLyBiYXNlNTggY2hhcmFjdGVycyAoQml0Y29pbiBhbHBoYWJldClcbnZhciBfYmFzZTU4ID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xuXG4vKipcbiAqIEJhc2U2NCBlbmNvZGVzIGEgJ2JpbmFyeScgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcgb2YgYnl0ZXMgdG8gYmFzZTY0LWVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQuXG4gKi9cbnV0aWwuZW5jb2RlNjQgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICAvLyBUT0RPOiBkZXByZWNhdGU6IFwiRGVwcmVjYXRlZC4gVXNlIHV0aWwuYmluYXJ5LmJhc2U2NC5lbmNvZGUgaW5zdGVhZC5cIlxuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBjaHIxLCBjaHIyLCBjaHIzO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xuICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgY2hyMyA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgIC8vIGVuY29kZSA0IGNoYXJhY3RlciBncm91cFxuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoY2hyMSA+PiAyKTtcbiAgICBsaW5lICs9IF9iYXNlNjQuY2hhckF0KCgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCkpO1xuICAgIGlmKGlzTmFOKGNocjIpKSB7XG4gICAgICBsaW5lICs9ICc9PSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpO1xuICAgICAgbGluZSArPSBpc05hTihjaHIzKSA/ICc9JyA6IF9iYXNlNjQuY2hhckF0KGNocjMgJiA2Myk7XG4gICAgfVxuXG4gICAgaWYobWF4bGluZSAmJiBsaW5lLmxlbmd0aCA+IG1heGxpbmUpIHtcbiAgICAgIG91dHB1dCArPSBsaW5lLnN1YnN0cigwLCBtYXhsaW5lKSArICdcXHJcXG4nO1xuICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKG1heGxpbmUpO1xuICAgIH1cbiAgfVxuICBvdXRwdXQgKz0gbGluZTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogQmFzZTY0IGRlY29kZXMgYSBzdHJpbmcgaW50byBhICdiaW5hcnknIGVuY29kZWQgc3RyaW5nIG9mIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgYmFzZTY0LWVuY29kZWQgaW5wdXQuXG4gKlxuICogQHJldHVybiB0aGUgYmluYXJ5IGVuY29kZWQgc3RyaW5nLlxuICovXG51dGlsLmRlY29kZTY0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgLy8gVE9ETzogZGVwcmVjYXRlOiBcIkRlcHJlY2F0ZWQuIFVzZSB1dGlsLmJpbmFyeS5iYXNlNjQuZGVjb2RlIGluc3RlYWQuXCJcblxuICAvLyByZW1vdmUgYWxsIG5vbi1iYXNlNjQgY2hhcmFjdGVyc1xuICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCAnJyk7XG5cbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpKTtcbiAgICBpZihlbmMzICE9PSA2NCkge1xuICAgICAgLy8gZGVjb2RlZCBhdCBsZWFzdCAyIGJ5dGVzXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKSk7XG4gICAgICBpZihlbmM0ICE9PSA2NCkge1xuICAgICAgICAvLyBkZWNvZGVkIDMgYnl0ZXNcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChlbmMzICYgMykgPDwgNikgfCBlbmM0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBVVEYtOCBlbmNvZGVzIHRoZSBnaXZlbiBVVEYtMTYgZW5jb2RlZCBzdHJpbmcgKGEgc3RhbmRhcmQgSmF2YVNjcmlwdFxuICogc3RyaW5nKS4gTm9uLUFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZSBlbmNvZGVkIGFzIG11bHRpcGxlIGJ5dGVzIGFjY29yZGluZ1xuICogdG8gVVRGLTguXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAqL1xudXRpbC5lbmNvZGVVdGY4ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBVVEYtOCBlbmNvZGVkIHN0cmluZyBpbnRvIGEgVVRGLTE2IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIFVURi0xNiBlbmNvZGVkIHN0cmluZyAoc3RhbmRhcmQgSmF2YVNjcmlwdCBzdHJpbmcpLlxuICovXG51dGlsLmRlY29kZVV0ZjggPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59O1xuXG4vLyBiaW5hcnkgZW5jb2RpbmcvZGVjb2RpbmcgdG9vbHNcbi8vIEZJWE1FOiBFeHBlcmltZW50YWwuIERvIG5vdCB1c2UgeWV0LlxudXRpbC5iaW5hcnkgPSB7XG4gIHJhdzoge30sXG4gIGhleDoge30sXG4gIGJhc2U2NDoge30sXG4gIGJhc2U1ODoge30sXG4gIGJhc2VOIDoge1xuICAgIGVuY29kZTogYmFzZU4uZW5jb2RlLFxuICAgIGRlY29kZTogYmFzZU4uZGVjb2RlXG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIFVpbnQ4QXJyYXkgYXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuIFRoaXMgZW5jb2RpbmcgdXNlc1xuICogYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NSBmb3IgZWFjaCBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiaW5hcnktZW5jb2RlZCBzdHJpbmcuXG4gKi9cbnV0aWwuYmluYXJ5LnJhdy5lbmNvZGUgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBiaW5hcnktZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LiBUaGlzIGVuY29kaW5nIHVzZXNcbiAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIGJpbmFyeS1lbmNvZGVkIHN0cmluZyB0byBkZWNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLmJpbmFyeS5yYXcuZGVjb2RlID0gZnVuY3Rpb24oc3RyLCBvdXRwdXQsIG9mZnNldCkge1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgJ2JpbmFyeScgc3RyaW5nLCBBcnJheUJ1ZmZlciwgRGF0YVZpZXcsIFR5cGVkQXJyYXksIG9yXG4gKiBCeXRlQnVmZmVyIGFzIGEgc3RyaW5nIG9mIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIHN0cmluZyBvZiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzLlxuICovXG51dGlsLmJpbmFyeS5oZXguZW5jb2RlID0gdXRpbC5ieXRlc1RvSGV4O1xuXG4vKipcbiAqIERlY29kZXMgYSBoZXgtZW5jb2RlZCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBoZXggdGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC5iaW5hcnkuaGV4LmRlY29kZSA9IGZ1bmN0aW9uKGhleCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMikpO1xuICB9XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7XG4gIGlmKGhleC5sZW5ndGggJiAxKSB7XG4gICAgLy8gb2RkIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBjb252ZXJ0IGZpcnN0IGNoYXJhY3RlciBhbG9uZVxuICAgIGkgPSAxO1xuICAgIG91dFtqKytdID0gcGFyc2VJbnQoaGV4WzBdLCAxNik7XG4gIH1cbiAgLy8gY29udmVydCAyIGNoYXJhY3RlcnMgKDEgYnl0ZSkgYXQgYSB0aW1lXG4gIGZvcig7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBvdXRbaisrXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBCYXNlNjQtZW5jb2RlcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBVaW50OEFycmF5IHRvIGVuY29kZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIG51bWJlciBvZiBlbmNvZGVkIGNoYXJhY3RlcnMgcGVyIGxpbmUgdG8gdXNlLFxuICogICAgICAgICAgZGVmYXVsdHMgdG8gbm9uZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBiYXNlNjQtZW5jb2RlZCBvdXRwdXQgc3RyaW5nLlxuICovXG51dGlsLmJpbmFyeS5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcbiAgdmFyIGkgPSAwO1xuICB3aGlsZShpIDwgaW5wdXQuYnl0ZUxlbmd0aCkge1xuICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgIGNocjIgPSBpbnB1dFtpKytdO1xuICAgIGNocjMgPSBpbnB1dFtpKytdO1xuXG4gICAgLy8gZW5jb2RlIDQgY2hhcmFjdGVyIGdyb3VwXG4gICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdChjaHIxID4+IDIpO1xuICAgIGxpbmUgKz0gX2Jhc2U2NC5jaGFyQXQoKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KSk7XG4gICAgaWYoaXNOYU4oY2hyMikpIHtcbiAgICAgIGxpbmUgKz0gJz09JztcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBfYmFzZTY0LmNoYXJBdCgoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KSk7XG4gICAgICBsaW5lICs9IGlzTmFOKGNocjMpID8gJz0nIDogX2Jhc2U2NC5jaGFyQXQoY2hyMyAmIDYzKTtcbiAgICB9XG5cbiAgICBpZihtYXhsaW5lICYmIGxpbmUubGVuZ3RoID4gbWF4bGluZSkge1xuICAgICAgb3V0cHV0ICs9IGxpbmUuc3Vic3RyKDAsIG1heGxpbmUpICsgJ1xcclxcbic7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHIobWF4bGluZSk7XG4gICAgfVxuICB9XG4gIG91dHB1dCArPSBsaW5lO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGJhc2U2NC1lbmNvZGVkIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSBbb3V0cHV0XSBhbiBvcHRpb25hbCBVaW50OEFycmF5IHRvIHdyaXRlIHRoZSBvdXRwdXQgdG87IGlmIGl0XG4gKiAgICAgICAgICBpcyB0b28gc21hbGwsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqIEBwYXJhbSBbb2Zmc2V0XSB0aGUgc3RhcnQgb2Zmc2V0IGZvciB3cml0aW5nIHRvIHRoZSBvdXRwdXQgKGRlZmF1bHQ6IDApLlxuICpcbiAqIEByZXR1cm4gdGhlIFVpbnQ4QXJyYXkgb3IgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIGlmIG91dHB1dCB3YXMgZ2l2ZW4uXG4gKi9cbnV0aWwuYmluYXJ5LmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyA0KSAqIDMpO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFsbCBub24tYmFzZTY0IGNoYXJhY3RlcnNcbiAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgdmFyIGkgPSAwLCBqID0gb2Zmc2V0O1xuXG4gIHdoaWxlKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICBlbmMxID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG4gICAgZW5jMiA9IF9iYXNlNjRJZHhbaW5wdXQuY2hhckNvZGVBdChpKyspIC0gNDNdO1xuICAgIGVuYzMgPSBfYmFzZTY0SWR4W2lucHV0LmNoYXJDb2RlQXQoaSsrKSAtIDQzXTtcbiAgICBlbmM0ID0gX2Jhc2U2NElkeFtpbnB1dC5jaGFyQ29kZUF0KGkrKykgLSA0M107XG5cbiAgICBvdXRbaisrXSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgaWYoZW5jMyAhPT0gNjQpIHtcbiAgICAgIC8vIGRlY29kZWQgYXQgbGVhc3QgMiBieXRlc1xuICAgICAgb3V0W2orK10gPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgIGlmKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIC8vIGRlY29kZWQgMyBieXRlc1xuICAgICAgICBvdXRbaisrXSA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgcmVzdWx0IGlzIHRoZSBleGFjdCBkZWNvZGVkIGxlbmd0aFxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0LnN1YmFycmF5KDAsIGopO1xufTtcblxuLy8gYWRkIHN1cHBvcnQgZm9yIGJhc2U1OCBlbmNvZGluZy9kZWNvZGluZyB3aXRoIEJpdGNvaW4gYWxwaGFiZXRcbnV0aWwuYmluYXJ5LmJhc2U1OC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCwgbWF4bGluZSkge1xuICByZXR1cm4gdXRpbC5iaW5hcnkuYmFzZU4uZW5jb2RlKGlucHV0LCBfYmFzZTU4LCBtYXhsaW5lKTtcbn07XG51dGlsLmJpbmFyeS5iYXNlNTguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQsIG1heGxpbmUpIHtcbiAgcmV0dXJuIHV0aWwuYmluYXJ5LmJhc2VOLmRlY29kZShpbnB1dCwgX2Jhc2U1OCwgbWF4bGluZSk7XG59O1xuXG4vLyB0ZXh0IGVuY29kaW5nL2RlY29kaW5nIHRvb2xzXG4vLyBGSVhNRTogRXhwZXJpbWVudGFsLiBEbyBub3QgdXNlIHlldC5cbnV0aWwudGV4dCA9IHtcbiAgdXRmODoge30sXG4gIHV0ZjE2OiB7fVxufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTggaW4gYSBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKiBAcGFyYW0gW291dHB1dF0gYW4gb3B0aW9uYWwgVWludDhBcnJheSB0byB3cml0ZSB0aGUgb3V0cHV0IHRvOyBpZiBpdFxuICogICAgICAgICAgaXMgdG9vIHNtYWxsLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKiBAcGFyYW0gW29mZnNldF0gdGhlIHN0YXJ0IG9mZnNldCBmb3Igd3JpdGluZyB0byB0aGUgb3V0cHV0IChkZWZhdWx0OiAwKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBVaW50OEFycmF5IG9yIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiBpZiBvdXRwdXQgd2FzIGdpdmVuLlxuICovXG51dGlsLnRleHQudXRmOC5lbmNvZGUgPSBmdW5jdGlvbihzdHIsIG91dHB1dCwgb2Zmc2V0KSB7XG4gIHN0ciA9IHV0aWwuZW5jb2RlVXRmOChzdHIpO1xuICB2YXIgb3V0ID0gb3V0cHV0O1xuICBpZighb3V0KSB7XG4gICAgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gIH1cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0W2orK10gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtOCBjb250ZW50cyBmcm9tIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIFVpbnQ4QXJyYXkgdG8gZGVjb2RlLlxuICpcbiAqIEByZXR1cm4gdGhlIHJlc3VsdGluZyBzdHJpbmcuXG4gKi9cbnV0aWwudGV4dC51dGY4LmRlY29kZSA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHJldHVybiB1dGlsLmRlY29kZVV0ZjgoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcykpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBzdHJpbmcgYXMgVVRGLTE2IGluIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIFtvdXRwdXRdIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkgdG8gd3JpdGUgdGhlIG91dHB1dCB0bzsgaWYgaXRcbiAqICAgICAgICAgIGlzIHRvbyBzbWFsbCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICogQHBhcmFtIFtvZmZzZXRdIHRoZSBzdGFydCBvZmZzZXQgZm9yIHdyaXRpbmcgdG8gdGhlIG91dHB1dCAoZGVmYXVsdDogMCkuXG4gKlxuICogQHJldHVybiB0aGUgVWludDhBcnJheSBvciB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gaWYgb3V0cHV0IHdhcyBnaXZlbi5cbiAqL1xudXRpbC50ZXh0LnV0ZjE2LmVuY29kZSA9IGZ1bmN0aW9uKHN0ciwgb3V0cHV0LCBvZmZzZXQpIHtcbiAgdmFyIG91dCA9IG91dHB1dDtcbiAgaWYoIW91dCkge1xuICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHN0ci5sZW5ndGggKiAyKTtcbiAgfVxuICB2YXIgdmlldyA9IG5ldyBVaW50MTZBcnJheShvdXQuYnVmZmVyKTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBqID0gb2Zmc2V0O1xuICB2YXIgayA9IG9mZnNldDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaysrXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGogKz0gMjtcbiAgfVxuICByZXR1cm4gb3V0cHV0ID8gKGogLSBvZmZzZXQpIDogb3V0O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBVVEYtMTYgY29udGVudHMgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBVaW50OEFycmF5IHRvIGRlY29kZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICovXG51dGlsLnRleHQudXRmMTYuZGVjb2RlID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ5dGVzLmJ1ZmZlcikpO1xufTtcblxuLyoqXG4gKiBEZWZsYXRlcyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyBhIGZsYXNoIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gYnl0ZXMgdGhlIGRhdGEuXG4gKiBAcGFyYW0gcmF3IHRydWUgdG8gcmV0dXJuIG9ubHkgcmF3IGRlZmxhdGUgZGF0YSwgZmFsc2UgdG8gaW5jbHVkZSB6bGliXG4gKiAgICAgICAgICBoZWFkZXIgYW5kIHRyYWlsZXIuXG4gKlxuICogQHJldHVybiB0aGUgZGVmbGF0ZWQgZGF0YSBhcyBhIHN0cmluZy5cbiAqL1xudXRpbC5kZWZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIGJ5dGVzID0gdXRpbC5kZWNvZGU2NChhcGkuZGVmbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbCk7XG5cbiAgLy8gc3RyaXAgemxpYiBoZWFkZXIgYW5kIHRyYWlsZXIgaWYgbmVjZXNzYXJ5XG4gIGlmKHJhdykge1xuICAgIC8vIHpsaWIgaGVhZGVyIGlzIDIgYnl0ZXMgKENNRixGTEcpIHdoZXJlIEZMRyBpbmRpY2F0ZXMgdGhhdFxuICAgIC8vIHRoZXJlIGlzIGEgNC1ieXRlIERJQ1QgKGFsZGVyLTMyKSBibG9jayBiZWZvcmUgdGhlIGRhdGEgaWZcbiAgICAvLyBpdHMgNXRoIGJpdCBpcyBzZXRcbiAgICB2YXIgc3RhcnQgPSAyO1xuICAgIHZhciBmbGcgPSBieXRlcy5jaGFyQ29kZUF0KDEpO1xuICAgIGlmKGZsZyAmIDB4MjApIHtcbiAgICAgIHN0YXJ0ID0gNjtcbiAgICB9XG4gICAgLy8gemxpYiB0cmFpbGVyIGlzIDQgYnl0ZXMgb2YgYWRsZXItMzJcbiAgICBieXRlcyA9IGJ5dGVzLnN1YnN0cmluZyhzdGFydCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59O1xuXG4vKipcbiAqIEluZmxhdGVzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIGEgZmxhc2ggaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZS5cbiAqIEBwYXJhbSBieXRlcyB0aGUgZGF0YS5cbiAqIEBwYXJhbSByYXcgdHJ1ZSBpZiB0aGUgaW5jb21pbmcgZGF0YSBoYXMgbm8gemxpYiBoZWFkZXIgb3IgdHJhaWxlciBhbmQgaXNcbiAqICAgICAgICAgIHJhdyBERUZMQVRFIGRhdGEuXG4gKlxuICogQHJldHVybiB0aGUgaW5mbGF0ZWQgZGF0YSBhcyBhIHN0cmluZywgbnVsbCBvbiBlcnJvci5cbiAqL1xudXRpbC5pbmZsYXRlID0gZnVuY3Rpb24oYXBpLCBieXRlcywgcmF3KSB7XG4gIC8vIFRPRE86IGFkZCB6bGliIGhlYWRlciBhbmQgdHJhaWxlciBpZiBuZWNlc3NhcnkvcG9zc2libGVcbiAgdmFyIHJ2YWwgPSBhcGkuaW5mbGF0ZSh1dGlsLmVuY29kZTY0KGJ5dGVzKSkucnZhbDtcbiAgcmV0dXJuIChydmFsID09PSBudWxsKSA/IG51bGwgOiB1dGlsLmRlY29kZTY0KHJ2YWwpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgc3RvcmFnZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIG9iaiB0aGUgc3RvcmFnZSBvYmplY3QsIG51bGwgdG8gcmVtb3ZlLlxuICovXG52YXIgX3NldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkLCBvYmopIHtcbiAgaWYoIWFwaSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICB9XG5cbiAgdmFyIHJ2YWw7XG4gIGlmKG9iaiA9PT0gbnVsbCkge1xuICAgIHJ2YWwgPSBhcGkucmVtb3ZlSXRlbShpZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8ganNvbi1lbmNvZGUgYW5kIGJhc2U2NC1lbmNvZGUgb2JqZWN0XG4gICAgb2JqID0gdXRpbC5lbmNvZGU2NChKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICBydmFsID0gYXBpLnNldEl0ZW0oaWQsIG9iaik7XG4gIH1cblxuICAvLyBoYW5kbGUgcG90ZW50aWFsIGZsYXNoIGVycm9yXG4gIGlmKHR5cGVvZihydmFsKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcnZhbC5ydmFsICE9PSB0cnVlKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHJ2YWwuZXJyb3IubWVzc2FnZSk7XG4gICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgIGVycm9yLm5hbWUgPSBydmFsLmVycm9yLm5hbWU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHN0b3JhZ2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBzdG9yYWdlIG9iamVjdCBlbnRyeSBvciBudWxsIGlmIG5vbmUgZXhpc3RzLlxuICovXG52YXIgX2dldFN0b3JhZ2VPYmplY3QgPSBmdW5jdGlvbihhcGksIGlkKSB7XG4gIGlmKCFhcGkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlN0b3JhZ2Ugbm90IGF2YWlsYWJsZS4nKTtcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXhpc3RpbmcgZW50cnlcbiAgdmFyIHJ2YWwgPSBhcGkuZ2V0SXRlbShpZCk7XG5cbiAgLyogTm90ZTogV2UgY2hlY2sgYXBpLmluaXQgYmVjYXVzZSB3ZSBjYW4ndCBkbyAoYXBpID09IGxvY2FsU3RvcmFnZSlcbiAgICBvbiBJRSBiZWNhdXNlIG9mIFwiQ2xhc3MgZG9lc24ndCBzdXBwb3J0IEF1dG9tYXRpb25cIiBleGNlcHRpb24uIE9ubHlcbiAgICB0aGUgZmxhc2ggYXBpIGhhcyBhbiBpbml0IG1ldGhvZCBzbyB0aGlzIHdvcmtzIHRvbywgYnV0IHdlIG5lZWQgYVxuICAgIGJldHRlciBzb2x1dGlvbiBpbiB0aGUgZnV0dXJlLiAqL1xuXG4gIC8vIGZsYXNoIHJldHVybnMgaXRlbSB3cmFwcGVkIGluIGFuIG9iamVjdCwgaGFuZGxlIHNwZWNpYWwgY2FzZVxuICBpZihhcGkuaW5pdCkge1xuICAgIGlmKHJ2YWwucnZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYocnZhbC5lcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocnZhbC5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3IuaWQgPSBydmFsLmVycm9yLmlkO1xuICAgICAgICBlcnJvci5uYW1lID0gcnZhbC5lcnJvci5uYW1lO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIG5vIGVycm9yLCBidXQgYWxzbyBubyBpdGVtXG4gICAgICBydmFsID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnZhbCA9IHJ2YWwucnZhbDtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgZGVjb2RpbmdcbiAgaWYocnZhbCAhPT0gbnVsbCkge1xuICAgIC8vIGJhc2U2NC1kZWNvZGUgYW5kIGpzb24tZGVjb2RlIGRhdGFcbiAgICBydmFsID0gSlNPTi5wYXJzZSh1dGlsLmRlY29kZTY0KHJ2YWwpKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBTdG9yZXMgYW4gaXRlbSBpbiBsb2NhbCBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIHN0b3JhZ2UgaW50ZXJmYWNlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICovXG52YXIgX3NldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGRhdGEpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqID09PSBudWxsKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0b3JhZ2Ugb2JqZWN0XG4gICAgb2JqID0ge307XG4gIH1cbiAgLy8gdXBkYXRlIGtleVxuICBvYmpba2V5XSA9IGRhdGE7XG5cbiAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIF9zZXRTdG9yYWdlT2JqZWN0KGFwaSwgaWQsIG9iaik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBmcm9tIGxvY2FsIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgc3RvcmFnZSBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG52YXIgX2dldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBydmFsID0gX2dldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCk7XG4gIGlmKHJ2YWwgIT09IG51bGwpIHtcbiAgICAvLyByZXR1cm4gZGF0YSBhdCBrZXlcbiAgICBydmFsID0gKGtleSBpbiBydmFsKSA/IHJ2YWxba2V5XSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICovXG52YXIgX3JlbW92ZUl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXkpIHtcbiAgLy8gZ2V0IHN0b3JhZ2Ugb2JqZWN0XG4gIHZhciBvYmogPSBfZ2V0U3RvcmFnZU9iamVjdChhcGksIGlkKTtcbiAgaWYob2JqICE9PSBudWxsICYmIGtleSBpbiBvYmopIHtcbiAgICAvLyByZW1vdmUga2V5XG4gICAgZGVsZXRlIG9ialtrZXldO1xuXG4gICAgLy8gc2VlIGlmIGVudHJ5IGhhcyBubyBrZXlzIHJlbWFpbmluZ1xuICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZihlbXB0eSkge1xuICAgICAgLy8gcmVtb3ZlIGVudHJ5IGVudGlyZWx5IGlmIG5vIGtleXMgYXJlIGxlZnRcbiAgICAgIG9iaiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0b3JhZ2Ugb2JqZWN0XG4gICAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBzdG9yYWdlIGludGVyZmFjZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKi9cbnZhciBfY2xlYXJJdGVtcyA9IGZ1bmN0aW9uKGFwaSwgaWQpIHtcbiAgX3NldFN0b3JhZ2VPYmplY3QoYXBpLCBpZCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgc3RvcmFnZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBsb2NhdGlvbiB0aGUgbG9jYXRpb24gYXJndW1lbnQuXG4gKlxuICogQHJldHVybiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uLlxuICovXG52YXIgX2NhbGxTdG9yYWdlRnVuY3Rpb24gPSBmdW5jdGlvbihmdW5jLCBhcmdzLCBsb2NhdGlvbikge1xuICB2YXIgcnZhbCA9IG51bGw7XG5cbiAgLy8gZGVmYXVsdCBzdG9yYWdlIHR5cGVzXG4gIGlmKHR5cGVvZihsb2NhdGlvbikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9jYXRpb24gPSBbJ3dlYicsICdmbGFzaCddO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RvcmFnZSB0eXBlcyBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gIHZhciB0eXBlO1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgZXhjZXB0aW9uID0gbnVsbDtcbiAgZm9yKHZhciBpZHggaW4gbG9jYXRpb24pIHtcbiAgICB0eXBlID0gbG9jYXRpb25baWR4XTtcbiAgICB0cnkge1xuICAgICAgaWYodHlwZSA9PT0gJ2ZsYXNoJyB8fCB0eXBlID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYoYXJnc1swXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhc2ggbG9jYWwgc3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gKHR5cGUgPT09ICdmbGFzaCcpO1xuICAgICAgfVxuICAgICAgaWYodHlwZSA9PT0gJ3dlYicgfHwgdHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGFyZ3NbMF0gPSBsb2NhbFN0b3JhZ2U7XG4gICAgICAgIHJ2YWwgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGV4KSB7XG4gICAgICBleGNlcHRpb24gPSBleDtcbiAgICB9XG4gICAgaWYoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIWRvbmUpIHtcbiAgICB0aHJvdyBleGNlcHRpb247XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogU3RvcmVzIGFuIGl0ZW0gb24gbG9jYWwgZGlzay5cbiAqXG4gKiBUaGUgYXZhaWxhYmxlIHR5cGVzIG9mIGxvY2FsIHN0b3JhZ2UgaW5jbHVkZSAnZmxhc2gnLCAnd2ViJywgYW5kICdib3RoJy5cbiAqXG4gKiBUaGUgdHlwZSAnZmxhc2gnIHJlZmVycyB0byBmbGFzaCBsb2NhbCBzdG9yYWdlIChTaGFyZWRPYmplY3QpLiBJbiBvcmRlclxuICogdG8gdXNlIGZsYXNoIGxvY2FsIHN0b3JhZ2UsIHRoZSAnYXBpJyBwYXJhbWV0ZXIgbXVzdCBiZSB2YWxpZC4gVGhlIHR5cGVcbiAqICd3ZWInIHJlZmVycyB0byBXZWJTdG9yYWdlLCBpZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSB0eXBlICdib3RoJ1xuICogcmVmZXJzIHRvIHN0b3JpbmcgdXNpbmcgYm90aCAnZmxhc2gnIGFuZCAnd2ViJywgbm90IGp1c3Qgb25lIG9yIHRoZVxuICogb3RoZXIuXG4gKlxuICogVGhlIGxvY2F0aW9uIGFycmF5IHNob3VsZCBsaXN0IHRoZSBzdG9yYWdlIHR5cGVzIHRvIHVzZSBpbiBvcmRlciBvZlxuICogcHJlZmVyZW5jZTpcbiAqXG4gKiBbJ2ZsYXNoJ106IGZsYXNoIG9ubHkgc3RvcmFnZVxuICogWyd3ZWInXTogd2ViIG9ubHkgc3RvcmFnZVxuICogWydib3RoJ106IHRyeSB0byBzdG9yZSBpbiBib3RoXG4gKiBbJ2ZsYXNoJywnd2ViJ106IHN0b3JlIGluIGZsYXNoIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ3dlYidcbiAqIFsnd2ViJywnZmxhc2gnXTogc3RvcmUgaW4gd2ViIGZpcnN0LCBidXQgaWYgbm90IGF2YWlsYWJsZSwgJ2ZsYXNoJ1xuICpcbiAqIFRoZSBsb2NhdGlvbiBhcnJheSBkZWZhdWx0cyB0bzogWyd3ZWInLCAnZmxhc2gnXVxuICpcbiAqIEBwYXJhbSBhcGkgdGhlIGZsYXNoIGludGVyZmFjZSwgbnVsbCB0byB1c2Ugb25seSBXZWJTdG9yYWdlLlxuICogQHBhcmFtIGlkIHRoZSBzdG9yYWdlIElEIHRvIHVzZS5cbiAqIEBwYXJhbSBrZXkgdGhlIGtleSBmb3IgdGhlIGl0ZW0uXG4gKiBAcGFyYW0gZGF0YSB0aGUgZGF0YSBmb3IgdGhlIGl0ZW0gKGFueSBqYXZhc2NyaXB0IG9iamVjdC9wcmltaXRpdmUpLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqL1xudXRpbC5zZXRJdGVtID0gZnVuY3Rpb24oYXBpLCBpZCwga2V5LCBkYXRhLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfc2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UsIG51bGwgdG8gdXNlIG9ubHkgV2ViU3RvcmFnZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0ga2V5IHRoZSBrZXkgZm9yIHRoZSBpdGVtLlxuICogQHBhcmFtIGxvY2F0aW9uIGFuIGFycmF5IHdpdGggdGhlIHByZWZlcnJlZCB0eXBlcyBvZiBzdG9yYWdlIHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpdGVtLlxuICovXG51dGlsLmdldEl0ZW0gPSBmdW5jdGlvbihhcGksIGlkLCBrZXksIGxvY2F0aW9uKSB7XG4gIHJldHVybiBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfZ2V0SXRlbSwgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gaXRlbSBvbiBsb2NhbCBkaXNrLlxuICpcbiAqIFNldCBzZXRJdGVtKCkgZm9yIGRldGFpbHMgb24gc3RvcmFnZSB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gYXBpIHRoZSBmbGFzaCBpbnRlcmZhY2UuXG4gKiBAcGFyYW0gaWQgdGhlIHN0b3JhZ2UgSUQgdG8gdXNlLlxuICogQHBhcmFtIGtleSB0aGUga2V5IGZvciB0aGUgaXRlbS5cbiAqIEBwYXJhbSBsb2NhdGlvbiBhbiBhcnJheSB3aXRoIHRoZSBwcmVmZXJyZWQgdHlwZXMgb2Ygc3RvcmFnZSB0byB1c2UuXG4gKi9cbnV0aWwucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uKGFwaSwgaWQsIGtleSwgbG9jYXRpb24pIHtcbiAgX2NhbGxTdG9yYWdlRnVuY3Rpb24oX3JlbW92ZUl0ZW0sIGFyZ3VtZW50cywgbG9jYXRpb24pO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGxvY2FsIGRpc2sgc3RvcmFnZSBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBTZXQgc2V0SXRlbSgpIGZvciBkZXRhaWxzIG9uIHN0b3JhZ2UgdHlwZXMuXG4gKlxuICogQHBhcmFtIGFwaSB0aGUgZmxhc2ggaW50ZXJmYWNlIGlmIGZsYXNoIGlzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSBpZCB0aGUgc3RvcmFnZSBJRCB0byB1c2UuXG4gKiBAcGFyYW0gbG9jYXRpb24gYW4gYXJyYXkgd2l0aCB0aGUgcHJlZmVycmVkIHR5cGVzIG9mIHN0b3JhZ2UgdG8gdXNlLlxuICovXG51dGlsLmNsZWFySXRlbXMgPSBmdW5jdGlvbihhcGksIGlkLCBsb2NhdGlvbikge1xuICBfY2FsbFN0b3JhZ2VGdW5jdGlvbihfY2xlYXJJdGVtcywgYXJndW1lbnRzLCBsb2NhdGlvbik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgc2NoZW1lLCBob3N0LCBhbmQgcG9ydCBmcm9tIGFuIGh0dHAocykgdXJsLlxuICpcbiAqIEBwYXJhbSBzdHIgdGhlIHVybCBzdHJpbmcuXG4gKlxuICogQHJldHVybiB0aGUgcGFyc2VkIHVybCBvYmplY3Qgb3IgbnVsbCBpZiB0aGUgdXJsIGlzIGludmFsaWQuXG4gKi9cbnV0aWwucGFyc2VVcmwgPSBmdW5jdGlvbihzdHIpIHtcbiAgLy8gRklYTUU6IHRoaXMgcmVnZXggbG9va3MgYSBiaXQgYnJva2VuXG4gIHZhciByZWdleCA9IC9eKGh0dHBzPyk6XFwvXFwvKFteOiZeXFwvXSopOj8oXFxkKikoLiopJC9nO1xuICByZWdleC5sYXN0SW5kZXggPSAwO1xuICB2YXIgbSA9IHJlZ2V4LmV4ZWMoc3RyKTtcbiAgdmFyIHVybCA9IChtID09PSBudWxsKSA/IG51bGwgOiB7XG4gICAgZnVsbDogc3RyLFxuICAgIHNjaGVtZTogbVsxXSxcbiAgICBob3N0OiBtWzJdLFxuICAgIHBvcnQ6IG1bM10sXG4gICAgcGF0aDogbVs0XVxuICB9O1xuICBpZih1cmwpIHtcbiAgICB1cmwuZnVsbEhvc3QgPSB1cmwuaG9zdDtcbiAgICBpZih1cmwucG9ydCkge1xuICAgICAgaWYodXJsLnBvcnQgIT09IDgwICYmIHVybC5zY2hlbWUgPT09ICdodHRwJykge1xuICAgICAgICB1cmwuZnVsbEhvc3QgKz0gJzonICsgdXJsLnBvcnQ7XG4gICAgICB9IGVsc2UgaWYodXJsLnBvcnQgIT09IDQ0MyAmJiB1cmwuc2NoZW1lID09PSAnaHR0cHMnKSB7XG4gICAgICAgIHVybC5mdWxsSG9zdCArPSAnOicgKyB1cmwucG9ydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodXJsLnNjaGVtZSA9PT0gJ2h0dHAnKSB7XG4gICAgICB1cmwucG9ydCA9IDgwO1xuICAgIH0gZWxzZSBpZih1cmwuc2NoZW1lID09PSAnaHR0cHMnKSB7XG4gICAgICB1cmwucG9ydCA9IDQ0MztcbiAgICB9XG4gICAgdXJsLmZ1bGwgPSB1cmwuc2NoZW1lICsgJzovLycgKyB1cmwuZnVsbEhvc3Q7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn07XG5cbi8qIFN0b3JhZ2UgZm9yIHF1ZXJ5IHZhcmlhYmxlcyAqL1xudmFyIF9xdWVyeVZhcmlhYmxlcyA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgd2luZG93IGxvY2F0aW9uIHF1ZXJ5IHZhcmlhYmxlcy4gUXVlcnkgaXMgcGFyc2VkIG9uIHRoZSBmaXJzdFxuICogY2FsbCBhbmQgdGhlIHNhbWUgb2JqZWN0IGlzIHJldHVybmVkIG9uIHN1YnNlcXVlbnQgY2FsbHMuIFRoZSBtYXBwaW5nXG4gKiBpcyBmcm9tIGtleXMgdG8gYW4gYXJyYXkgb2YgdmFsdWVzLiBQYXJhbWV0ZXJzIHdpdGhvdXQgdmFsdWVzIHdpbGwgaGF2ZVxuICogYW4gb2JqZWN0IGtleSBzZXQgYnV0IG5vIHZhbHVlIGFkZGVkIHRvIHRoZSB2YWx1ZSBhcnJheS4gVmFsdWVzIGFyZVxuICogdW5lc2NhcGVkLlxuICpcbiAqIC4uLj9rMT12MSZrMj12MjpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiXSxcbiAqICAgXCJrMlwiOiBbXCJ2MlwiXVxuICogfVxuICpcbiAqIC4uLj9rMT12MSZrMT12MjpcbiAqIHtcbiAqICAgXCJrMVwiOiBbXCJ2MVwiLCBcInYyXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsyOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdLFxuICogICBcImsyXCI6IFtdXG4gKiB9XG4gKlxuICogLi4uP2sxPXYxJmsxOlxuICoge1xuICogICBcImsxXCI6IFtcInYxXCJdXG4gKiB9XG4gKlxuICogLi4uP2sxJmsxOlxuICoge1xuICogICBcImsxXCI6IFtdXG4gKiB9XG4gKlxuICogQHBhcmFtIHF1ZXJ5IHRoZSBxdWVyeSBzdHJpbmcgdG8gcGFyc2UgKG9wdGlvbmFsLCBkZWZhdWx0IHRvIGNhY2hlZFxuICogICAgICAgICAgcmVzdWx0cyBmcm9tIHBhcnNpbmcgd2luZG93IGxvY2F0aW9uIHNlYXJjaCBxdWVyeSkuXG4gKlxuICogQHJldHVybiBvYmplY3QgbWFwcGluZyBrZXlzIHRvIHZhcmlhYmxlcy5cbiAqL1xudXRpbC5nZXRRdWVyeVZhcmlhYmxlcyA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgcnZhbCA9IHt9O1xuICAgIHZhciBrdnBhaXJzID0gcS5zcGxpdCgnJicpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBrdnBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9zID0ga3ZwYWlyc1tpXS5pbmRleE9mKCc9Jyk7XG4gICAgICB2YXIga2V5O1xuICAgICAgdmFyIHZhbDtcbiAgICAgIGlmKHBvcyA+IDApIHtcbiAgICAgICAga2V5ID0ga3ZwYWlyc1tpXS5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgdmFsID0ga3ZwYWlyc1tpXS5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBrdnBhaXJzW2ldO1xuICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYoIShrZXkgaW4gcnZhbCkpIHtcbiAgICAgICAgcnZhbFtrZXldID0gW107XG4gICAgICB9XG4gICAgICAvLyBkaXNhbGxvdyBvdmVycmlkaW5nIG9iamVjdCBwcm90b3R5cGUga2V5c1xuICAgICAgaWYoIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIHJ2YWxba2V5XS5wdXNoKHVuZXNjYXBlKHZhbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAgdmFyIHJ2YWw7XG4gICBpZih0eXBlb2YocXVlcnkpID09PSAndW5kZWZpbmVkJykge1xuICAgICAvLyBzZXQgY2FjaGVkIHZhcmlhYmxlcyBpZiBuZWVkZWRcbiAgICAgaWYoX3F1ZXJ5VmFyaWFibGVzID09PSBudWxsKSB7XG4gICAgICAgaWYodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgICAgLy8gcGFyc2Ugd2luZG93IHNlYXJjaCBxdWVyeVxuICAgICAgICAgIF9xdWVyeVZhcmlhYmxlcyA9IHBhcnNlKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIHF1ZXJ5IHZhcmlhYmxlcyBhdmFpbGFibGVcbiAgICAgICAgICBfcXVlcnlWYXJpYWJsZXMgPSB7fTtcbiAgICAgICB9XG4gICAgIH1cbiAgICAgcnZhbCA9IF9xdWVyeVZhcmlhYmxlcztcbiAgIH0gZWxzZSB7XG4gICAgIC8vIHBhcnNlIGdpdmVuIHF1ZXJ5XG4gICAgIHJ2YWwgPSBwYXJzZShxdWVyeSk7XG4gICB9XG4gICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgZnJhZ21lbnQgaW50byBhIHBhdGggYW5kIHF1ZXJ5LiBUaGlzIG1ldGhvZCB3aWxsIHRha2UgYSBVUklcbiAqIGZyYWdtZW50IGFuZCBicmVhayBpdCB1cCBhcyBpZiBpdCB3ZXJlIHRoZSBtYWluIFVSSS4gRm9yIGV4YW1wbGU6XG4gKiAgICAvYmFyL2Jhej9hPTEmYj0yXG4gKiByZXN1bHRzIGluOlxuICogICAge1xuICogICAgICAgcGF0aDogW1wiYmFyXCIsIFwiYmF6XCJdLFxuICogICAgICAgcXVlcnk6IHtcImsxXCI6IFtcInYxXCJdLCBcImsyXCI6IFtcInYyXCJdfVxuICogICAgfVxuICpcbiAqIEByZXR1cm4gb2JqZWN0IHdpdGggYSBwYXRoIGFycmF5IGFuZCBxdWVyeSBvYmplY3QuXG4gKi9cbnV0aWwucGFyc2VGcmFnbWVudCA9IGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gIC8vIGRlZmF1bHQgdG8gd2hvbGUgZnJhZ21lbnRcbiAgdmFyIGZwID0gZnJhZ21lbnQ7XG4gIHZhciBmcSA9ICcnO1xuICAvLyBzcGxpdCBpbnRvIHBhdGggYW5kIHF1ZXJ5IGlmIHBvc3NpYmxlIGF0IHRoZSBmaXJzdCAnPydcbiAgdmFyIHBvcyA9IGZyYWdtZW50LmluZGV4T2YoJz8nKTtcbiAgaWYocG9zID4gMCkge1xuICAgIGZwID0gZnJhZ21lbnQuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgZnEgPSBmcmFnbWVudC5zdWJzdHJpbmcocG9zICsgMSk7XG4gIH1cbiAgLy8gc3BsaXQgcGF0aCBiYXNlZCBvbiAnLycgYW5kIGlnbm9yZSBmaXJzdCBlbGVtZW50IGlmIGVtcHR5XG4gIHZhciBwYXRoID0gZnAuc3BsaXQoJy8nKTtcbiAgaWYocGF0aC5sZW5ndGggPiAwICYmIHBhdGhbMF0gPT09ICcnKSB7XG4gICAgcGF0aC5zaGlmdCgpO1xuICB9XG4gIC8vIGNvbnZlcnQgcXVlcnkgaW50byBvYmplY3RcbiAgdmFyIHF1ZXJ5ID0gKGZxID09PSAnJykgPyB7fSA6IHV0aWwuZ2V0UXVlcnlWYXJpYWJsZXMoZnEpO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aFN0cmluZzogZnAsXG4gICAgcXVlcnlTdHJpbmc6IGZxLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5XG4gIH07XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgcmVxdWVzdCBvdXQgb2YgYSBVUkktbGlrZSByZXF1ZXN0IHN0cmluZy4gVGhpcyBpcyBpbnRlbmRlZCB0b1xuICogYmUgdXNlZCB3aGVyZSBhIGZyYWdtZW50IGlkIChhZnRlciBhIFVSSSAnIycpIGlzIHBhcnNlZCBhcyBhIFVSSSB3aXRoXG4gKiBwYXRoIGFuZCBxdWVyeSBwYXJ0cy4gVGhlIHN0cmluZyBzaG91bGQgaGF2ZSBhIHBhdGggYmVnaW5uaW5nIGFuZFxuICogZGVsaW1pdGVkIGJ5ICcvJyBhbmQgb3B0aW9uYWwgcXVlcnkgcGFyYW1ldGVycyBmb2xsb3dpbmcgYSAnPycuIFRoZVxuICogcXVlcnkgc2hvdWxkIGJlIGEgc3RhbmRhcmQgVVJMIHNldCBvZiBrZXkgdmFsdWUgcGFpcnMgZGVsaW1pdGVkIGJ5XG4gKiAnJicuIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB0aGUgaW5pdGlhbCAnLycgb24gdGhlIHBhdGggaXMgbm90XG4gKiByZXF1aXJlZC4gVGhlIHJlcXVlc3Qgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIEFQSSwgKGZ1bGx5IGRlc2NyaWJlZFxuICogaW4gdGhlIG1ldGhvZCBjb2RlKTpcbiAqICAgIHtcbiAqICAgICAgIHBhdGg6IDx0aGUgcGF0aCBzdHJpbmcgcGFydD4uXG4gKiAgICAgICBxdWVyeTogPHRoZSBxdWVyeSBzdHJpbmcgcGFydD4sXG4gKiAgICAgICBnZXRQYXRoKGkpOiBnZXQgcGFydCBvciBhbGwgb2YgdGhlIHNwbGl0IHBhdGggYXJyYXksXG4gKiAgICAgICBnZXRRdWVyeShrLCBpKTogZ2V0IHBhcnQgb3IgYWxsIG9mIGEgcXVlcnkga2V5IGFycmF5LFxuICogICAgICAgZ2V0UXVlcnlMYXN0KGssIF9kZWZhdWx0KTogZ2V0IGxhc3QgZWxlbWVudCBvZiBhIHF1ZXJ5IGtleSBhcnJheS5cbiAqICAgIH1cbiAqXG4gKiBAcmV0dXJuIG9iamVjdCB3aXRoIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAqL1xudXRpbC5tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcVN0cmluZykge1xuICB2YXIgZnJhZyA9IHV0aWwucGFyc2VGcmFnbWVudChyZXFTdHJpbmcpO1xuICB2YXIgcmVxID0ge1xuICAgIC8vIGZ1bGwgcGF0aCBzdHJpbmdcbiAgICBwYXRoOiBmcmFnLnBhdGhTdHJpbmcsXG4gICAgLy8gZnVsbCBxdWVyeSBzdHJpbmdcbiAgICBxdWVyeTogZnJhZy5xdWVyeVN0cmluZyxcbiAgICAvKipcbiAgICAgKiBHZXQgcGF0aCBvciBlbGVtZW50IGluIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaSBvcHRpb25hbCBwYXRoIGluZGV4LlxuICAgICAqXG4gICAgICogQHJldHVybiBwYXRoIG9yIHBhcnQgb2YgcGF0aCBpZiBpIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGdldFBhdGg6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAodHlwZW9mKGkpID09PSAndW5kZWZpbmVkJykgPyBmcmFnLnBhdGggOiBmcmFnLnBhdGhbaV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgcXVlcnksIHZhbHVlcyBmb3IgYSBrZXksIG9yIHZhbHVlIGZvciBhIGtleSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrIG9wdGlvbmFsIHF1ZXJ5IGtleS5cbiAgICAgKiBAcGFyYW0gaSBvcHRpb25hbCBxdWVyeSBrZXkgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHF1ZXJ5LCB2YWx1ZXMgZm9yIGEga2V5LCBvciB2YWx1ZSBmb3IgYSBrZXkgaW5kZXguXG4gICAgICovXG4gICAgZ2V0UXVlcnk6IGZ1bmN0aW9uKGssIGkpIHtcbiAgICAgIHZhciBydmFsO1xuICAgICAgaWYodHlwZW9mKGspID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBydmFsID0gZnJhZy5xdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBmcmFnLnF1ZXJ5W2tdO1xuICAgICAgICBpZihydmFsICYmIHR5cGVvZihpKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgcnZhbCA9IHJ2YWxbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH0sXG4gICAgZ2V0UXVlcnlMYXN0OiBmdW5jdGlvbihrLCBfZGVmYXVsdCkge1xuICAgICAgdmFyIHJ2YWw7XG4gICAgICB2YXIgdmFscyA9IHJlcS5nZXRRdWVyeShrKTtcbiAgICAgIGlmKHZhbHMpIHtcbiAgICAgICAgcnZhbCA9IHZhbHNbdmFscy5sZW5ndGggLSAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgPSBfZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBVUkkgb3V0IG9mIGEgcGF0aCwgYW4gb2JqZWN0IHdpdGggcXVlcnkgcGFyYW1ldGVycywgYW5kIGFcbiAqIGZyYWdtZW50LiBVc2VzIGpRdWVyeS5wYXJhbSgpIGludGVybmFsbHkgZm9yIHF1ZXJ5IHN0cmluZyBjcmVhdGlvbi5cbiAqIElmIHRoZSBwYXRoIGlzIGFuIGFycmF5LCBpdCB3aWxsIGJlIGpvaW5lZCB3aXRoICcvJy5cbiAqXG4gKiBAcGFyYW0gcGF0aCBzdHJpbmcgcGF0aCBvciBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHF1ZXJ5IG9iamVjdCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnMuIChvcHRpb25hbClcbiAqIEBwYXJhbSBmcmFnbWVudCBmcmFnbWVudCBzdHJpbmcuIChvcHRpb25hbClcbiAqXG4gKiBAcmV0dXJuIHN0cmluZyBvYmplY3Qgd2l0aCByZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKi9cbnV0aWwubWFrZUxpbmsgPSBmdW5jdGlvbihwYXRoLCBxdWVyeSwgZnJhZ21lbnQpIHtcbiAgLy8gam9pbiBwYXRoIHBhcnRzIGlmIG5lZWRlZFxuICBwYXRoID0galF1ZXJ5LmlzQXJyYXkocGF0aCkgPyBwYXRoLmpvaW4oJy8nKSA6IHBhdGg7XG5cbiAgdmFyIHFzdHIgPSBqUXVlcnkucGFyYW0ocXVlcnkgfHwge30pO1xuICBmcmFnbWVudCA9IGZyYWdtZW50IHx8ICcnO1xuICByZXR1cm4gcGF0aCArXG4gICAgKChxc3RyLmxlbmd0aCA+IDApID8gKCc/JyArIHFzdHIpIDogJycpICtcbiAgICAoKGZyYWdtZW50Lmxlbmd0aCA+IDApID8gKCcjJyArIGZyYWdtZW50KSA6ICcnKTtcbn07XG5cbi8qKlxuICogRm9sbG93cyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgc2V0IGEgdmFsdWUuXG4gKiBJZiBhIGtleSBkb2VzIG5vdCBleGlzdCBvciBpdCdzIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QsIGNyZWF0ZSBhblxuICogb2JqZWN0IGluIGl0J3MgcGxhY2UuIFRoaXMgY2FuIGJlIGRlc3RydWN0aXZlIHRvIGEgb2JqZWN0IHRyZWUgaWZcbiAqIGxlYWYgbm9kZXMgYXJlIGdpdmVuIGFzIG5vbi1maW5hbCBwYXRoIGtleXMuXG4gKiBVc2VkIHRvIGF2b2lkIGV4Y2VwdGlvbnMgZnJvbSBtaXNzaW5nIHBhcnRzIG9mIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgdGhlIHN0YXJ0aW5nIG9iamVjdC5cbiAqIEBwYXJhbSBrZXlzIGFuIGFycmF5IG9mIHN0cmluZyBrZXlzLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBzZXQuXG4gKi9cbnV0aWwuc2V0UGF0aCA9IGZ1bmN0aW9uKG9iamVjdCwga2V5cywgdmFsdWUpIHtcbiAgLy8gbmVlZCB0byBzdGFydCBhdCBhbiBvYmplY3RcbiAgaWYodHlwZW9mKG9iamVjdCkgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUoaSA8IGxlbikge1xuICAgICAgdmFyIG5leHQgPSBrZXlzW2krK107XG4gICAgICBpZihpID09IGxlbikge1xuICAgICAgICAvLyBsYXN0XG4gICAgICAgIG9iamVjdFtuZXh0XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW9yZVxuICAgICAgICB2YXIgaGFzTmV4dCA9IChuZXh0IGluIG9iamVjdCk7XG4gICAgICAgIGlmKCFoYXNOZXh0IHx8XG4gICAgICAgICAgKGhhc05leHQgJiYgdHlwZW9mKG9iamVjdFtuZXh0XSkgIT09ICdvYmplY3QnKSB8fFxuICAgICAgICAgIChoYXNOZXh0ICYmIG9iamVjdFtuZXh0XSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICBvYmplY3RbbmV4dF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3RbbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvbGxvd3MgYSBwYXRoIG9mIGtleXMgZGVlcCBpbnRvIGFuIG9iamVjdCBoaWVyYXJjaHkgYW5kIHJldHVybiBhIHZhbHVlLlxuICogSWYgYSBrZXkgZG9lcyBub3QgZXhpc3QsIGNyZWF0ZSBhbiBvYmplY3QgaW4gaXQncyBwbGFjZS5cbiAqIFVzZWQgdG8gYXZvaWQgZXhjZXB0aW9ucyBmcm9tIG1pc3NpbmcgcGFydHMgb2YgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgc3RhcnRpbmcgb2JqZWN0LlxuICogQHBhcmFtIGtleXMgYW4gYXJyYXkgb2Ygc3RyaW5nIGtleXMuXG4gKiBAcGFyYW0gX2RlZmF1bHQgdmFsdWUgdG8gcmV0dXJuIGlmIHBhdGggbm90IGZvdW5kLlxuICpcbiAqIEByZXR1cm4gdGhlIHZhbHVlIGF0IHRoZSBwYXRoIGlmIGZvdW5kLCBlbHNlIGRlZmF1bHQgaWYgZ2l2ZW4sIGVsc2VcbiAqICAgICAgICAgdW5kZWZpbmVkLlxuICovXG51dGlsLmdldFBhdGggPSBmdW5jdGlvbihvYmplY3QsIGtleXMsIF9kZWZhdWx0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICB2YXIgaGFzTmV4dCA9IHRydWU7XG4gIHdoaWxlKGhhc05leHQgJiYgaSA8IGxlbiAmJlxuICAgIHR5cGVvZihvYmplY3QpID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dCA9IGtleXNbaSsrXTtcbiAgICBoYXNOZXh0ID0gbmV4dCBpbiBvYmplY3Q7XG4gICAgaWYoaGFzTmV4dCkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W25leHRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gKGhhc05leHQgPyBvYmplY3QgOiBfZGVmYXVsdCk7XG59O1xuXG4vKipcbiAqIEZvbGxvdyBhIHBhdGggb2Yga2V5cyBkZWVwIGludG8gYW4gb2JqZWN0IGhpZXJhcmNoeSBhbmQgZGVsZXRlIHRoZVxuICogbGFzdCBvbmUuIElmIGEga2V5IGRvZXMgbm90IGV4aXN0LCBkbyBub3RoaW5nLlxuICogVXNlZCB0byBhdm9pZCBleGNlcHRpb25zIGZyb20gbWlzc2luZyBwYXJ0cyBvZiB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IHRoZSBzdGFydGluZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5cyBhbiBhcnJheSBvZiBzdHJpbmcga2V5cy5cbiAqL1xudXRpbC5kZWxldGVQYXRoID0gZnVuY3Rpb24ob2JqZWN0LCBrZXlzKSB7XG4gIC8vIG5lZWQgdG8gc3RhcnQgYXQgYW4gb2JqZWN0XG4gIGlmKHR5cGVvZihvYmplY3QpID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlKGkgPCBsZW4pIHtcbiAgICAgIHZhciBuZXh0ID0ga2V5c1tpKytdO1xuICAgICAgaWYoaSA9PSBsZW4pIHtcbiAgICAgICAgLy8gbGFzdFxuICAgICAgICBkZWxldGUgb2JqZWN0W25leHRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW9yZVxuICAgICAgICBpZighKG5leHQgaW4gb2JqZWN0KSB8fFxuICAgICAgICAgICh0eXBlb2Yob2JqZWN0W25leHRdKSAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgKG9iamVjdFtuZXh0XSA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W25leHRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHkuXG4gKlxuICogVGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0LWZyb20tanNvbi82Nzk5MzcjNjc5OTM3XG4gKlxuICogQHBhcmFtIG9iamVjdCB0aGUgb2JqZWN0IHRvIGNoZWNrLlxuICovXG51dGlsLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHdpdGggc2ltcGxlIHByaW50Zi1zdHlsZSBpbnRlcnBvbGF0aW9uLlxuICpcbiAqICUlOiBsaXRlcmFsICclJ1xuICogJXMsJW86IGNvbnZlcnQgbmV4dCBhcmd1bWVudCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBmb3JtYXQgdGhlIHN0cmluZyB0byBmb3JtYXQuXG4gKiBAcGFyYW0gLi4uIGFyZ3VtZW50cyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBmb3JtYXQgc3RyaW5nLlxuICovXG51dGlsLmZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICB2YXIgcmUgPSAvJS4vZztcbiAgLy8gY3VycmVudCBtYXRjaFxuICB2YXIgbWF0Y2g7XG4gIC8vIGN1cnJlbnQgcGFydFxuICB2YXIgcGFydDtcbiAgLy8gY3VycmVudCBhcmcgaW5kZXhcbiAgdmFyIGFyZ2kgPSAwO1xuICAvLyBjb2xsZWN0ZWQgcGFydHMgdG8gcmVjb21iaW5lIGxhdGVyXG4gIHZhciBwYXJ0cyA9IFtdO1xuICAvLyBsYXN0IGluZGV4IGZvdW5kXG4gIHZhciBsYXN0ID0gMDtcbiAgLy8gbG9vcCB3aGlsZSBtYXRjaGVzIHJlbWFpblxuICB3aGlsZSgobWF0Y2ggPSByZS5leGVjKGZvcm1hdCkpKSB7XG4gICAgcGFydCA9IGZvcm1hdC5zdWJzdHJpbmcobGFzdCwgcmUubGFzdEluZGV4IC0gMik7XG4gICAgLy8gZG9uJ3QgYWRkIGVtcHR5IHN0cmluZ3MgKGllLCBwYXJ0cyBiZXR3ZWVuICVzJXMpXG4gICAgaWYocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICBsYXN0ID0gcmUubGFzdEluZGV4O1xuICAgIC8vIHN3aXRjaCBvbiAlIGNvZGVcbiAgICB2YXIgY29kZSA9IG1hdGNoWzBdWzFdO1xuICAgIHN3aXRjaChjb2RlKSB7XG4gICAgY2FzZSAncyc6XG4gICAgY2FzZSAnbyc6XG4gICAgICAvLyBjaGVjayBpZiBlbm91Z2ggYXJndW1lbnRzIHdlcmUgZ2l2ZW5cbiAgICAgIGlmKGFyZ2kgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJndW1lbnRzW2FyZ2krKyArIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goJzw/PicpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gRklYTUU6IGRvIHByb3BlciBmb3JtYXRpbmcgZm9yIG51bWJlcnMsIGV0Y1xuICAgIC8vY2FzZSAnZic6XG4gICAgLy9jYXNlICdkJzpcbiAgICBjYXNlICclJzpcbiAgICAgIHBhcnRzLnB1c2goJyUnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwYXJ0cy5wdXNoKCc8JScgKyBjb2RlICsgJz8+Jyk7XG4gICAgfVxuICB9XG4gIC8vIGFkZCB0cmFpbGluZyBwYXJ0IG9mIGZvcm1hdCBzdHJpbmdcbiAgcGFydHMucHVzaChmb3JtYXQuc3Vic3RyaW5nKGxhc3QpKTtcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgbnVtYmVyLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDUvamF2YXNjcmlwdC1udW1iZXJmb3JtYXQtLXBvcnRlZC1mcm9tLXBocC9cbiAqL1xudXRpbC5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbihudW1iZXIsIGRlY2ltYWxzLCBkZWNfcG9pbnQsIHRob3VzYW5kc19zZXApIHtcbiAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBKb25hcyBSYW9uaSBTb2FyZXMgU2lsdmEgKGh0dHA6Ly93d3cuanNmcm9taGVsbC5jb20pXG4gIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gIC8vICsgICAgIGJ1Z2ZpeCBieTogTWljaGFlbCBXaGl0ZSAoaHR0cDovL2NyZXN0aWRnLmNvbSlcbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBCZW5qYW1pbiBMdXB0b25cbiAgLy8gKyAgICAgYnVnZml4IGJ5OiBBbGxhbiBKZW5zZW4gKGh0dHA6Ly93d3cud2ludGVybmV0Lm5vKVxuICAvLyArICAgIHJldmlzZWQgYnk6IEpvbmFzIFJhb25pIFNvYXJlcyBTaWx2YSAoaHR0cDovL3d3dy5qc2Zyb21oZWxsLmNvbSlcbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBudW1iZXJfZm9ybWF0KDEyMzQuNTY3OCwgMiwgJy4nLCAnJyk7XG4gIC8vICogICAgIHJldHVybnMgMTogMTIzNC41N1xuXG4gIHZhciBuID0gbnVtYmVyLCBjID0gaXNOYU4oZGVjaW1hbHMgPSBNYXRoLmFicyhkZWNpbWFscykpID8gMiA6IGRlY2ltYWxzO1xuICB2YXIgZCA9IGRlY19wb2ludCA9PT0gdW5kZWZpbmVkID8gJywnIDogZGVjX3BvaW50O1xuICB2YXIgdCA9IHRob3VzYW5kc19zZXAgPT09IHVuZGVmaW5lZCA/XG4gICAnLicgOiB0aG91c2FuZHNfc2VwLCBzID0gbiA8IDAgPyAnLScgOiAnJztcbiAgdmFyIGkgPSBwYXJzZUludCgobiA9IE1hdGguYWJzKCtuIHx8IDApLnRvRml4ZWQoYykpLCAxMCkgKyAnJztcbiAgdmFyIGogPSAoaS5sZW5ndGggPiAzKSA/IGkubGVuZ3RoICUgMyA6IDA7XG4gIHJldHVybiBzICsgKGogPyBpLnN1YnN0cigwLCBqKSArIHQgOiAnJykgK1xuICAgIGkuc3Vic3RyKGopLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLCAnJDEnICsgdCkgK1xuICAgIChjID8gZCArIE1hdGguYWJzKG4gLSBpKS50b0ZpeGVkKGMpLnNsaWNlKDIpIDogJycpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGEgYnl0ZSBzaXplLlxuICpcbiAqIGh0dHA6Ly9zbmlwcGxyLmNvbS92aWV3LzU5NDkvZm9ybWF0LWh1bWFuaXplLWZpbGUtYnl0ZS1zaXplLXByZXNlbnRhdGlvbi1pbi1qYXZhc2NyaXB0L1xuICovXG51dGlsLmZvcm1hdFNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIGlmKHNpemUgPj0gMTA3Mzc0MTgyNCkge1xuICAgIHNpemUgPSB1dGlsLmZvcm1hdE51bWJlcihzaXplIC8gMTA3Mzc0MTgyNCwgMiwgJy4nLCAnJykgKyAnIEdpQic7XG4gIH0gZWxzZSBpZihzaXplID49IDEwNDg1NzYpIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSAvIDEwNDg1NzYsIDIsICcuJywgJycpICsgJyBNaUInO1xuICB9IGVsc2UgaWYoc2l6ZSA+PSAxMDI0KSB7XG4gICAgc2l6ZSA9IHV0aWwuZm9ybWF0TnVtYmVyKHNpemUgLyAxMDI0LCAwKSArICcgS2lCJztcbiAgfSBlbHNlIHtcbiAgICBzaXplID0gdXRpbC5mb3JtYXROdW1iZXIoc2l6ZSwgMCkgKyAnIGJ5dGVzJztcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gSVB2NCBvciBJUHY2IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgb3IgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgNC1ieXRlIElQdjYgb3IgMTYtYnl0ZSBJUHY2IGFkZHJlc3Mgb3IgbnVsbCBpZiB0aGUgYWRkcmVzcyBjYW4ndFxuICogICAgICAgICBiZSBwYXJzZWQuXG4gKi9cbnV0aWwuYnl0ZXNGcm9tSVAgPSBmdW5jdGlvbihpcCkge1xuICBpZihpcC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNGcm9tSVB2NChpcCk7XG4gIH1cbiAgaWYoaXAuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzRnJvbUlQdjYoaXApO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBpbnRvIGJ5dGVzIChpbiBuZXR3b3JrIG9yZGVyKS5cbiAqXG4gKiBAcGFyYW0gaXAgdGhlIElQdjQgYWRkcmVzcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIDQtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjQgPSBmdW5jdGlvbihpcCkge1xuICBpcCA9IGlwLnNwbGl0KCcuJyk7XG4gIGlmKGlwLmxlbmd0aCAhPT0gNCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBiID0gdXRpbC5jcmVhdGVCdWZmZXIoKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlwLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIG51bSA9IHBhcnNlSW50KGlwW2ldLCAxMCk7XG4gICAgaWYoaXNOYU4obnVtKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGIucHV0Qnl0ZShudW0pO1xuICB9XG4gIHJldHVybiBiLmdldEJ5dGVzKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGludG8gYnl0ZXMgKGluIG5ldHdvcmsgb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBpcCB0aGUgSVB2NiBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgMTYtYnl0ZSBhZGRyZXNzIG9yIG51bGwgaWYgdGhlIGFkZHJlc3MgY2FuJ3QgYmUgcGFyc2VkLlxuICovXG51dGlsLmJ5dGVzRnJvbUlQdjYgPSBmdW5jdGlvbihpcCkge1xuICB2YXIgYmxhbmtzID0gMDtcbiAgaXAgPSBpcC5zcGxpdCgnOicpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgaWYoZS5sZW5ndGggPT09IDApICsrYmxhbmtzO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgdmFyIHplcm9zID0gKDggLSBpcC5sZW5ndGggKyBibGFua3MpICogMjtcbiAgdmFyIGIgPSB1dGlsLmNyZWF0ZUJ1ZmZlcigpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgaWYoIWlwW2ldIHx8IGlwW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYi5maWxsV2l0aEJ5dGUoMCwgemVyb3MpO1xuICAgICAgemVyb3MgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IHV0aWwuaGV4VG9CeXRlcyhpcFtpXSk7XG4gICAgaWYoYnl0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgYi5wdXRCeXRlKDApO1xuICAgIH1cbiAgICBiLnB1dEJ5dGVzKGJ5dGVzKTtcbiAgfVxuICByZXR1cm4gYi5nZXRCeXRlcygpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb3IgMTYtYnl0ZXMgaW50b1xuICogYW4gSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjQgb3IgSVB2NiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaWYgNCBvciAxNiBieXRlcyxcbiAqICAgICAgICAgcmVzcGVjdGl2ZWx5LCBhcmUgZ2l2ZW4sIG90aGVyd2lzZSBudWxsLlxuICovXG51dGlsLmJ5dGVzVG9JUCA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIGlmKGJ5dGVzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiB1dGlsLmJ5dGVzVG9JUHY0KGJ5dGVzKTtcbiAgfVxuICBpZihieXRlcy5sZW5ndGggPT09IDE2KSB7XG4gICAgcmV0dXJuIHV0aWwuYnl0ZXNUb0lQdjYoYnl0ZXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyA0LWJ5dGVzIGludG8gYW4gSVB2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uIFRoZSBieXRlcyBtdXN0IGJlXG4gKiBpbiBuZXR3b3JrIG9yZGVyLlxuICpcbiAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBJUHY0IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjQgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXAgPSBbXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaXAucHVzaChieXRlcy5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gaXAuam9pbignLicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyAxNi1ieXRlcyBpbnRvIGFuIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbi4gVGhlIGJ5dGVzIG11c3QgYmVcbiAqIGluIG5ldHdvcmsgb3JkZXIuXG4gKlxuICogQHBhcmFtIGJ5dGVzIHRoZSBieXRlcyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIElQdjE2IHN0cmluZyByZXByZXNlbnRhdGlvbiBvciBudWxsIGZvciBhbiBpbnZhbGlkICMgb2YgYnl0ZXMuXG4gKi9cbnV0aWwuYnl0ZXNUb0lQdjYgPSBmdW5jdGlvbihieXRlcykge1xuICBpZihieXRlcy5sZW5ndGggIT09IDE2KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGlwID0gW107XG4gIHZhciB6ZXJvR3JvdXBzID0gW107XG4gIHZhciB6ZXJvTWF4R3JvdXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgaGV4ID0gdXRpbC5ieXRlc1RvSGV4KGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdKTtcbiAgICAvLyBjYW5vbmljYWxpemUgemVybyByZXByZXNlbnRhdGlvblxuICAgIHdoaWxlKGhleFswXSA9PT0gJzAnICYmIGhleCAhPT0gJzAnKSB7XG4gICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuICAgIH1cbiAgICBpZihoZXggPT09ICcwJykge1xuICAgICAgdmFyIGxhc3QgPSB6ZXJvR3JvdXBzW3plcm9Hcm91cHMubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgaWR4ID0gaXAubGVuZ3RoO1xuICAgICAgaWYoIWxhc3QgfHwgaWR4ICE9PSBsYXN0LmVuZCArIDEpIHtcbiAgICAgICAgemVyb0dyb3Vwcy5wdXNoKHtzdGFydDogaWR4LCBlbmQ6IGlkeH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdC5lbmQgPSBpZHg7XG4gICAgICAgIGlmKChsYXN0LmVuZCAtIGxhc3Quc3RhcnQpID5cbiAgICAgICAgICAoemVyb0dyb3Vwc1t6ZXJvTWF4R3JvdXBdLmVuZCAtIHplcm9Hcm91cHNbemVyb01heEdyb3VwXS5zdGFydCkpIHtcbiAgICAgICAgICB6ZXJvTWF4R3JvdXAgPSB6ZXJvR3JvdXBzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaXAucHVzaChoZXgpO1xuICB9XG4gIGlmKHplcm9Hcm91cHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBncm91cCA9IHplcm9Hcm91cHNbemVyb01heEdyb3VwXTtcbiAgICAvLyBvbmx5IHNob3J0ZW4gZ3JvdXAgb2YgbGVuZ3RoID4gMFxuICAgIGlmKGdyb3VwLmVuZCAtIGdyb3VwLnN0YXJ0ID4gMCkge1xuICAgICAgaXAuc3BsaWNlKGdyb3VwLnN0YXJ0LCBncm91cC5lbmQgLSBncm91cC5zdGFydCArIDEsICcnKTtcbiAgICAgIGlmKGdyb3VwLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGlwLnVuc2hpZnQoJycpO1xuICAgICAgfVxuICAgICAgaWYoZ3JvdXAuZW5kID09PSA3KSB7XG4gICAgICAgIGlwLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXAuam9pbignOicpO1xufTtcblxuLyoqXG4gKiBFc3RpbWF0ZXMgdGhlIG51bWJlciBvZiBwcm9jZXNzZXMgdGhhdCBjYW4gYmUgcnVuIGNvbmN1cnJlbnRseS4gSWZcbiAqIGNyZWF0aW5nIFdlYiBXb3JrZXJzLCBrZWVwIGluIG1pbmQgdGhhdCB0aGUgbWFpbiBKYXZhU2NyaXB0IHByb2Nlc3MgbmVlZHNcbiAqIGl0cyBvd24gY29yZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICB1cGRhdGUgdHJ1ZSB0byBmb3JjZSBhbiB1cGRhdGUgKG5vdCB1c2UgdGhlIGNhY2hlZCB2YWx1ZSkuXG4gKiBAcGFyYW0gY2FsbGJhY2soZXJyLCBtYXgpIGNhbGxlZCBvbmNlIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICovXG51dGlsLmVzdGltYXRlQ29yZXMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmKCdjb3JlcycgaW4gdXRpbCAmJiAhb3B0aW9ucy51cGRhdGUpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gIH1cbiAgaWYodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnaGFyZHdhcmVDb25jdXJyZW5jeScgaW4gbmF2aWdhdG9yICYmXG4gICAgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPiAwKSB7XG4gICAgdXRpbC5jb3JlcyA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgV29ya2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdvcmtlcnMgbm90IGF2YWlsYWJsZVxuICAgIHV0aWwuY29yZXMgPSAxO1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1dGlsLmNvcmVzKTtcbiAgfVxuICBpZih0eXBlb2YgQmxvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjYW4ndCBlc3RpbWF0ZSwgZGVmYXVsdCB0byAyXG4gICAgdXRpbC5jb3JlcyA9IDI7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHV0aWwuY29yZXMpO1xuICB9XG5cbiAgLy8gY3JlYXRlIHdvcmtlciBjb25jdXJyZW5jeSBlc3RpbWF0aW9uIGNvZGUgYXMgYmxvYlxuICB2YXIgYmxvYlVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycoJyxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gcnVuIHdvcmtlciBmb3IgNCBtc1xuICAgICAgICB2YXIgc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZXQgPSBzdCArIDQ7XG4gICAgICAgIHdoaWxlKERhdGUubm93KCkgPCBldCk7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe3N0OiBzdCwgZXQ6IGV0fSk7XG4gICAgICB9KTtcbiAgICB9LnRvU3RyaW5nKCksXG4gICcpKCknXSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pKTtcblxuICAvLyB0YWtlIDUgc2FtcGxlcyB1c2luZyAxNiB3b3JrZXJzXG4gIHNhbXBsZShbXSwgNSwgMTYpO1xuXG4gIGZ1bmN0aW9uIHNhbXBsZShtYXgsIHNhbXBsZXMsIG51bVdvcmtlcnMpIHtcbiAgICBpZihzYW1wbGVzID09PSAwKSB7XG4gICAgICAvLyBnZXQgb3ZlcmxhcCBhdmVyYWdlXG4gICAgICB2YXIgYXZnID0gTWF0aC5mbG9vcihtYXgucmVkdWNlKGZ1bmN0aW9uKGF2ZywgeCkge1xuICAgICAgICByZXR1cm4gYXZnICsgeDtcbiAgICAgIH0sIDApIC8gbWF4Lmxlbmd0aCk7XG4gICAgICB1dGlsLmNvcmVzID0gTWF0aC5tYXgoMSwgYXZnKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXRpbC5jb3Jlcyk7XG4gICAgfVxuICAgIG1hcChudW1Xb3JrZXJzLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgIG1heC5wdXNoKHJlZHVjZShudW1Xb3JrZXJzLCByZXN1bHRzKSk7XG4gICAgICBzYW1wbGUobWF4LCBzYW1wbGVzIC0gMSwgbnVtV29ya2Vycyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXAobnVtV29ya2VycywgY2FsbGJhY2spIHtcbiAgICB2YXIgd29ya2VycyA9IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGUuZGF0YSk7XG4gICAgICAgIGlmKHJlc3VsdHMubGVuZ3RoID09PSBudW1Xb3JrZXJzKSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG51bVdvcmtlcnM7ICsraSkge1xuICAgICAgICAgICAgd29ya2Vyc1tpXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd29ya2Vycy5wdXNoKHdvcmtlcik7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Xb3JrZXJzOyArK2kpIHtcbiAgICAgIHdvcmtlcnNbaV0ucG9zdE1lc3NhZ2UoaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkdWNlKG51bVdvcmtlcnMsIHJlc3VsdHMpIHtcbiAgICAvLyBmaW5kIG92ZXJsYXBwaW5nIHRpbWUgd2luZG93c1xuICAgIHZhciBvdmVybGFwcyA9IFtdO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBudW1Xb3JrZXJzOyArK24pIHtcbiAgICAgIHZhciByMSA9IHJlc3VsdHNbbl07XG4gICAgICB2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW25dID0gW107XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnVtV29ya2VyczsgKytpKSB7XG4gICAgICAgIGlmKG4gPT09IGkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcjIgPSByZXN1bHRzW2ldO1xuICAgICAgICBpZigocjEuc3QgPiByMi5zdCAmJiByMS5zdCA8IHIyLmV0KSB8fFxuICAgICAgICAgIChyMi5zdCA+IHIxLnN0ICYmIHIyLnN0IDwgcjEuZXQpKSB7XG4gICAgICAgICAgb3ZlcmxhcC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGdldCBtYXhpbXVtIG92ZXJsYXBzIC4uLiBkb24ndCBpbmNsdWRlIG92ZXJsYXBwaW5nIHdvcmtlciBpdHNlbGZcbiAgICAvLyBhcyB0aGUgbWFpbiBKUyBwcm9jZXNzIHdhcyBhbHNvIGJlaW5nIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHdvcmsgYW5kXG4gICAgLy8gd291bGQgaGF2ZSB0byBiZSBzdWJ0cmFjdGVkIGZyb20gdGhlIGVzdGltYXRlIGFueXdheVxuICAgIHJldHVybiBvdmVybGFwcy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBvdmVybGFwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBvdmVybGFwLmxlbmd0aCk7XG4gICAgfSwgMCk7XG4gIH1cbn07XG4iLCIvKipcbiAqIEphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgWC41MDkgYW5kIHJlbGF0ZWQgY29tcG9uZW50cyAoc3VjaCBhc1xuICogQ2VydGlmaWNhdGlvbiBTaWduaW5nIFJlcXVlc3RzKSBvZiBhIFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUuXG4gKlxuICogQGF1dGhvciBEYXZlIExvbmdsZXlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxNCBEaWdpdGFsIEJhemFhciwgSW5jLlxuICpcbiAqIFRoZSBBU04uMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIGNlcnRpZmljYXRlIGlzIGFzIGZvbGxvd3NcbiAqIChzZWUgUkZDIDI0NTkpOlxuICpcbiAqIENlcnRpZmljYXRlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHRic0NlcnRpZmljYXRlICAgICAgIFRCU0NlcnRpZmljYXRlLFxuICogICBzaWduYXR1cmVBbGdvcml0aG0gICBBbGdvcml0aG1JZGVudGlmaWVyLFxuICogICBzaWduYXR1cmVWYWx1ZSAgICAgICBCSVQgU1RSSU5HXG4gKiB9XG4gKlxuICogVEJTQ2VydGlmaWNhdGUgOjo9IFNFUVVFTkNFIHtcbiAqICAgdmVyc2lvbiAgICAgICAgIFswXSAgRVhQTElDSVQgVmVyc2lvbiBERUZBVUxUIHYxLFxuICogICBzZXJpYWxOdW1iZXIgICAgICAgICBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlcixcbiAqICAgc2lnbmF0dXJlICAgICAgICAgICAgQWxnb3JpdGhtSWRlbnRpZmllcixcbiAqICAgaXNzdWVyICAgICAgICAgICAgICAgTmFtZSxcbiAqICAgdmFsaWRpdHkgICAgICAgICAgICAgVmFsaWRpdHksXG4gKiAgIHN1YmplY3QgICAgICAgICAgICAgIE5hbWUsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXlJbmZvIFN1YmplY3RQdWJsaWNLZXlJbmZvLFxuICogICBpc3N1ZXJVbmlxdWVJRCAgWzFdICBJTVBMSUNJVCBVbmlxdWVJZGVudGlmaWVyIE9QVElPTkFMLFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYyIG9yIHYzXG4gKiAgIHN1YmplY3RVbmlxdWVJRCBbMl0gIElNUExJQ0lUIFVuaXF1ZUlkZW50aWZpZXIgT1BUSU9OQUwsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIC0tIElmIHByZXNlbnQsIHZlcnNpb24gc2hhbGwgYmUgdjIgb3IgdjNcbiAqICAgZXh0ZW5zaW9ucyAgICAgIFszXSAgRVhQTElDSVQgRXh0ZW5zaW9ucyBPUFRJT05BTFxuICogICAgICAgICAgICAgICAgICAgICAgICAtLSBJZiBwcmVzZW50LCB2ZXJzaW9uIHNoYWxsIGJlIHYzXG4gKiB9XG4gKlxuICogVmVyc2lvbiA6Oj0gSU5URUdFUiAgeyB2MSgwKSwgdjIoMSksIHYzKDIpIH1cbiAqXG4gKiBDZXJ0aWZpY2F0ZVNlcmlhbE51bWJlciA6Oj0gSU5URUdFUlxuICpcbiAqIE5hbWUgOjo9IENIT0lDRSB7XG4gKiAgIC8vIG9ubHkgb25lIHBvc3NpYmxlIGNob2ljZSBmb3Igbm93XG4gKiAgIFJETlNlcXVlbmNlXG4gKiB9XG4gKlxuICogUkROU2VxdWVuY2UgOjo9IFNFUVVFTkNFIE9GIFJlbGF0aXZlRGlzdGluZ3Vpc2hlZE5hbWVcbiAqXG4gKiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lIDo6PSBTRVQgT0YgQXR0cmlidXRlVHlwZUFuZFZhbHVlXG4gKlxuICogQXR0cmlidXRlVHlwZUFuZFZhbHVlIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICAgIEF0dHJpYnV0ZVR5cGUsXG4gKiAgIHZhbHVlICAgIEF0dHJpYnV0ZVZhbHVlXG4gKiB9XG4gKiBBdHRyaWJ1dGVUeXBlIDo6PSBPQkpFQ1QgSURFTlRJRklFUlxuICogQXR0cmlidXRlVmFsdWUgOjo9IEFOWSBERUZJTkVEIEJZIEF0dHJpYnV0ZVR5cGVcbiAqXG4gKiBWYWxpZGl0eSA6Oj0gU0VRVUVOQ0Uge1xuICogICBub3RCZWZvcmUgICAgICBUaW1lLFxuICogICBub3RBZnRlciAgICAgICBUaW1lXG4gKiB9XG4gKlxuICogVGltZSA6Oj0gQ0hPSUNFIHtcbiAqICAgdXRjVGltZSAgICAgICAgVVRDVGltZSxcbiAqICAgZ2VuZXJhbFRpbWUgICAgR2VuZXJhbGl6ZWRUaW1lXG4gKiB9XG4gKlxuICogVW5pcXVlSWRlbnRpZmllciA6Oj0gQklUIFNUUklOR1xuICpcbiAqIFN1YmplY3RQdWJsaWNLZXlJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSAgICAgICAgICAgIEFsZ29yaXRobUlkZW50aWZpZXIsXG4gKiAgIHN1YmplY3RQdWJsaWNLZXkgICAgIEJJVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBFeHRlbnNpb25zIDo6PSBTRVFVRU5DRSBTSVpFICgxLi5NQVgpIE9GIEV4dGVuc2lvblxuICpcbiAqIEV4dGVuc2lvbiA6Oj0gU0VRVUVOQ0Uge1xuICogICBleHRuSUQgICAgICBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgY3JpdGljYWwgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBleHRuVmFsdWUgICBPQ1RFVCBTVFJJTkdcbiAqIH1cbiAqXG4gKiBUaGUgb25seSBrZXkgYWxnb3JpdGhtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIFBLSSBpcyBSU0EuXG4gKlxuICogUlNBU1NBLVBTUyBzaWduYXR1cmVzIGFyZSBkZXNjcmliZWQgaW4gUkZDIDM0NDcgYW5kIFJGQyA0MDU1LlxuICpcbiAqIFBLQ1MjMTAgdjEuNyBkZXNjcmliZXMgY2VydGlmaWNhdGUgc2lnbmluZyByZXF1ZXN0czpcbiAqXG4gKiBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm86XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIDo6PSBTRVFVRU5DRSB7XG4gKiAgIHZlcnNpb24gICAgICAgSU5URUdFUiB7IHYxKDApIH0gKHYxLC4uLiksXG4gKiAgIHN1YmplY3QgICAgICAgTmFtZSxcbiAqICAgc3ViamVjdFBLSW5mbyBTdWJqZWN0UHVibGljS2V5SW5mb3t7IFBLSW5mb0FsZ29yaXRobXMgfX0sXG4gKiAgIGF0dHJpYnV0ZXMgICAgWzBdIEF0dHJpYnV0ZXN7eyBDUklBdHRyaWJ1dGVzIH19XG4gKiB9XG4gKlxuICogQXR0cmlidXRlcyB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVQgT0YgQXR0cmlidXRle3sgSU9TZXQgfX1cbiAqXG4gKiBDUklBdHRyaWJ1dGVzICBBVFRSSUJVVEUgIDo6PSB7XG4gKiAgIC4uLiAtLSBhZGQgYW55IGxvY2FsbHkgZGVmaW5lZCBhdHRyaWJ1dGVzIGhlcmUgLS0gfVxuICpcbiAqIEF0dHJpYnV0ZSB7IEFUVFJJQlVURTpJT1NldCB9IDo6PSBTRVFVRU5DRSB7XG4gKiAgIHR5cGUgICBBVFRSSUJVVEUuJmlkKHtJT1NldH0pLFxuICogICB2YWx1ZXMgU0VUIFNJWkUoMS4uTUFYKSBPRiBBVFRSSUJVVEUuJlR5cGUoe0lPU2V0fXtAdHlwZX0pXG4gKiB9XG4gKlxuICogQ2VydGlmaWNhdGlvblJlcXVlc3QgOjo9IFNFUVVFTkNFIHtcbiAqICAgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyxcbiAqICAgc2lnbmF0dXJlQWxnb3JpdGhtIEFsZ29yaXRobUlkZW50aWZpZXJ7eyBTaWduYXR1cmVBbGdvcml0aG1zIH19LFxuICogICBzaWduYXR1cmUgICAgICAgICAgQklUIFNUUklOR1xuICogfVxuICovXG52YXIgZm9yZ2UgPSByZXF1aXJlKCcuL2ZvcmdlJyk7XG5yZXF1aXJlKCcuL2FlcycpO1xucmVxdWlyZSgnLi9hc24xJyk7XG5yZXF1aXJlKCcuL2RlcycpO1xucmVxdWlyZSgnLi9tZCcpO1xucmVxdWlyZSgnLi9tZ2YnKTtcbnJlcXVpcmUoJy4vb2lkcycpO1xucmVxdWlyZSgnLi9wZW0nKTtcbnJlcXVpcmUoJy4vcHNzJyk7XG5yZXF1aXJlKCcuL3JzYScpO1xucmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIHNob3J0Y3V0IGZvciBhc24uMSBBUElcbnZhciBhc24xID0gZm9yZ2UuYXNuMTtcblxuLyogUHVibGljIEtleSBJbmZyYXN0cnVjdHVyZSAoUEtJKSBpbXBsZW1lbnRhdGlvbi4gKi9cbnZhciBwa2kgPSBtb2R1bGUuZXhwb3J0cyA9IGZvcmdlLnBraSA9IGZvcmdlLnBraSB8fCB7fTtcbnZhciBvaWRzID0gcGtpLm9pZHM7XG5cbi8vIHNob3J0IG5hbWUgT0lEIG1hcHBpbmdzXG52YXIgX3Nob3J0TmFtZXMgPSB7fTtcbl9zaG9ydE5hbWVzWydDTiddID0gb2lkc1snY29tbW9uTmFtZSddO1xuX3Nob3J0TmFtZXNbJ2NvbW1vbk5hbWUnXSA9ICdDTic7XG5fc2hvcnROYW1lc1snQyddID0gb2lkc1snY291bnRyeU5hbWUnXTtcbl9zaG9ydE5hbWVzWydjb3VudHJ5TmFtZSddID0gJ0MnO1xuX3Nob3J0TmFtZXNbJ0wnXSA9IG9pZHNbJ2xvY2FsaXR5TmFtZSddO1xuX3Nob3J0TmFtZXNbJ2xvY2FsaXR5TmFtZSddID0gJ0wnO1xuX3Nob3J0TmFtZXNbJ1NUJ10gPSBvaWRzWydzdGF0ZU9yUHJvdmluY2VOYW1lJ107XG5fc2hvcnROYW1lc1snc3RhdGVPclByb3ZpbmNlTmFtZSddID0gJ1NUJztcbl9zaG9ydE5hbWVzWydPJ10gPSBvaWRzWydvcmdhbml6YXRpb25OYW1lJ107XG5fc2hvcnROYW1lc1snb3JnYW5pemF0aW9uTmFtZSddID0gJ08nO1xuX3Nob3J0TmFtZXNbJ09VJ10gPSBvaWRzWydvcmdhbml6YXRpb25hbFVuaXROYW1lJ107XG5fc2hvcnROYW1lc1snb3JnYW5pemF0aW9uYWxVbml0TmFtZSddID0gJ09VJztcbl9zaG9ydE5hbWVzWydFJ10gPSBvaWRzWydlbWFpbEFkZHJlc3MnXTtcbl9zaG9ydE5hbWVzWydlbWFpbEFkZHJlc3MnXSA9ICdFJztcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBTdWJqZWN0UHVibGljS2V5SW5mbyBzdHJ1Y3R1cmVcbi8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHdvcmtzIHdpdGggYW4gUlNBIHB1YmxpYyBrZXlcbnZhciBwdWJsaWNLZXlWYWxpZGF0b3IgPSBmb3JnZS5wa2kucnNhLnB1YmxpY0tleVZhbGlkYXRvcjtcblxuLy8gdmFsaWRhdG9yIGZvciBhbiBYLjUwOXYzIGNlcnRpZmljYXRlXG52YXIgeDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGUnLFxuICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBjYXB0dXJlQXNuMTogJ3Ric0NlcnRpZmljYXRlJyxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAwLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbi5pbnRlZ2VyJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnY2VydFZlcnNpb24nXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiAnY2VydFNlcmlhbE51bWJlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUuYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0aW5mb1NpZ25hdHVyZU9pZCdcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcydcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydElzc3VlcidcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHknLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAvLyBOb3RlOiBVVEMgYW5kIGdlbmVyYWxpemVkIHRpbWVzIG1heSBib3RoIGFwcGVhciBzbyB0aGUgY2FwdHVyZVxuICAgICAgLy8gbmFtZXMgYXJlIGJhc2VkIG9uIHRoZWlyIGRldGVjdGVkIG9yZGVyLCB0aGUgbmFtZXMgdXNlZCBiZWxvd1xuICAgICAgLy8gYXJlIG9ubHkgZm9yIHRoZSBjb21tb24gY2FzZSwgd2hpY2ggdmFsaWRpdHkgdGltZSByZWFsbHkgbWVhbnNcbiAgICAgIC8vIFwibm90QmVmb3JlXCIgYW5kIHdoaWNoIG1lYW5zIFwibm90QWZ0ZXJcIiB3aWxsIGJlIGRldGVybWluZWQgYnkgb3JkZXJcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChVVEMgdGltZSBjYXNlKVxuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlICh1dGMpJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTFVVENUaW1lJ1xuICAgICAgfSwge1xuICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChnZW5lcmFsaXplZCB0aW1lIGNhc2UpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKGdlbmVyYWxpemVkKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogJ2NlcnRWYWxpZGl0eTJHZW5lcmFsaXplZFRpbWUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAodXRjKScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHkzVVRDVGltZSdcbiAgICAgIH0sIHtcbiAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyIChnZW5lcmFsaXplZCknLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmU6ICdjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBOYW1lIChzdWJqZWN0KSAoUkROU2VxdWVuY2UpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdCcsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydFN1YmplY3QnXG4gICAgfSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICB7XG4gICAgICAvLyBpc3N1ZXJVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDEsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZCcsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICBjYXB0dXJlQml0U3RyaW5nVmFsdWU6ICdjZXJ0SXNzdWVyVW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICB0eXBlOiAyLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgYXJiaXRyYXJ5IGJpdCBsZW5ndGggaWRzXG4gICAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTdWJqZWN0VW5pcXVlSWQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmV4dGVuc2lvbnMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgIHR5cGU6IDMsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiAnY2VydEV4dGVuc2lvbnMnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XVxuICB9LCB7XG4gICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobScsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ2NlcnRTaWduYXR1cmVPaWQnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ0NlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgY2FwdHVyZUFzbjE6ICdjZXJ0U2lnbmF0dXJlUGFyYW1zJ1xuICAgIH1dXG4gIH0sIHtcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIG5hbWU6ICdDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZScsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NlcnRTaWduYXR1cmUnXG4gIH1dXG59O1xuXG52YXIgcnNhc3NhUHNzUGFyYW1ldGVyVmFsaWRhdG9yID0ge1xuICBuYW1lOiAncnNhcHNzJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW3tcbiAgICBuYW1lOiAncnNhcHNzLmhhc2hBbGdvcml0aG0nLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsdWU6IFt7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MuaGFzaEFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobScsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiAnaGFzaE9pZCdcbiAgICAgICAgLyogcGFyYW1ldGVyIGJsb2NrIG9taXR0ZWQsIGZvciBTSEExIE5VTEwgYW55aG93LiAqL1xuICAgICAgfV1cbiAgICB9XVxuICB9LCB7XG4gICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtJyxcbiAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgIHR5cGU6IDEsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllcicsXG4gICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBhc24xLkNsYXNzLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbe1xuICAgICAgICBuYW1lOiAncnNhcHNzLm1hc2tHZW5BbGdvcml0aG0uQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG0nLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogJ21hc2tHZW5PaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdyc2Fwc3MubWFza0dlbkFsZ29yaXRobS5BbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtcycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFt7XG4gICAgICAgICAgbmFtZTogJ3JzYXBzcy5tYXNrR2VuQWxnb3JpdGhtLkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1zLmFsZ29yaXRobScsXG4gICAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6ICdtYXNrR2VuSGFzaE9pZCdcbiAgICAgICAgICAvKiBwYXJhbWV0ZXIgYmxvY2sgb21pdHRlZCwgZm9yIFNIQTEgTlVMTCBhbnlob3cuICovXG4gICAgICAgIH1dXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnNhbHRMZW5ndGgnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMixcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWx1ZTogW3tcbiAgICAgIG5hbWU6ICdyc2Fwc3Muc2FsdExlbmd0aC5zYWx0TGVuZ3RoJyxcbiAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGFzbjEuQ2xhc3MuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6ICdzYWx0TGVuZ3RoJ1xuICAgIH1dXG4gIH0sIHtcbiAgICBuYW1lOiAncnNhcHNzLnRyYWlsZXJGaWVsZCcsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICB0eXBlOiAzLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbHVlOiBbe1xuICAgICAgbmFtZTogJ3JzYXBzcy50cmFpbGVyLnRyYWlsZXInLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5DbGFzcy5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogJ3RyYWlsZXInXG4gICAgfV1cbiAgfV1cbn07XG5cbi8vIHZhbGlkYXRvciBmb3IgYSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmFsaWRhdG9yID0ge1xuICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvJyxcbiAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICBjYXB0dXJlQXNuMTogJ2NlcnRpZmljYXRpb25SZXF1ZXN0SW5mbycsXG4gIHZhbHVlOiBbe1xuICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8uaW50ZWdlcicsXG4gICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGFzbjEuVHlwZS5JTlRFR0VSLFxuICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvVmVyc2lvbidcbiAgfSwge1xuICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLnN1YmplY3QnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBhc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgY2FwdHVyZUFzbjE6ICdjZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9TdWJqZWN0J1xuICB9LFxuICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICBwdWJsaWNLZXlWYWxpZGF0b3IsXG4gIHtcbiAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgdHlwZTogMCxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICBjYXB0dXJlOiAnY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcycsXG4gICAgdmFsdWU6IFt7XG4gICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgbmFtZTogJ0NlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5hdHRyaWJ1dGVzLnR5cGUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5PSUQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvLmF0dHJpYnV0ZXMudmFsdWUnLFxuICAgICAgICB0YWdDbGFzczogYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGFzbjEuVHlwZS5TRVQsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlXG4gICAgICB9XVxuICAgIH1dXG4gIH1dXG59O1xuXG4vLyB2YWxpZGF0b3IgZm9yIGEgQ2VydGlmaWNhdGlvblJlcXVlc3Qgc3RydWN0dXJlXG52YXIgY2VydGlmaWNhdGlvblJlcXVlc3RWYWxpZGF0b3IgPSB7XG4gIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdCcsXG4gIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgY2FwdHVyZUFzbjE6ICdjc3InLFxuICB2YWx1ZTogW1xuICAgIGNlcnRpZmljYXRpb25SZXF1ZXN0SW5mb1ZhbGlkYXRvciwge1xuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0nLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW3tcbiAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtJyxcbiAgICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBhc24xLlR5cGUuT0lELFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6ICdjc3JTaWduYXR1cmVPaWQnXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmVBbGdvcml0aG0ucGFyYW1ldGVycycsXG4gICAgICAgIHRhZ0NsYXNzOiBhc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgIGNhcHR1cmVBc24xOiAnY3NyU2lnbmF0dXJlUGFyYW1zJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAvLyBzaWduYXR1cmVcbiAgICAgIG5hbWU6ICdDZXJ0aWZpY2F0aW9uUmVxdWVzdC5zaWduYXR1cmUnLFxuICAgICAgdGFnQ2xhc3M6IGFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVCaXRTdHJpbmdWYWx1ZTogJ2NzclNpZ25hdHVyZSdcbiAgICB9XG4gIF1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUkROU2VxdWVuY2Ugb2YgQVNOLjEgREVSLWVuY29kZWQgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZVxuICogc2V0cyBpbnRvIGFuIGFycmF5IHdpdGggb2JqZWN0cyB0aGF0IGhhdmUgdHlwZSBhbmQgdmFsdWUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gcmRuIHRoZSBSRE5TZXF1ZW5jZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIG1kIGEgbWVzc2FnZSBkaWdlc3QgdG8gYXBwZW5kIHR5cGUgYW5kIHZhbHVlIHRvIGlmIHByb3ZpZGVkLlxuICovXG5wa2kuUkROQXR0cmlidXRlc0FzQXJyYXkgPSBmdW5jdGlvbihyZG4sIG1kKSB7XG4gIHZhciBydmFsID0gW107XG5cbiAgLy8gZWFjaCB2YWx1ZSBpbiAncmRuJyBpbiBpcyBhIFNFVCBvZiBSZWxhdGl2ZURpc3Rpbmd1aXNoZWROYW1lXG4gIHZhciBzZXQsIGF0dHIsIG9iajtcbiAgZm9yKHZhciBzaSA9IDA7IHNpIDwgcmRuLnZhbHVlLmxlbmd0aDsgKytzaSkge1xuICAgIC8vIGdldCB0aGUgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICBzZXQgPSByZG4udmFsdWVbc2ldO1xuXG4gICAgLy8gZWFjaCB2YWx1ZSBpbiB0aGUgU0VUIGlzIGFuIEF0dHJpYnV0ZVR5cGVBbmRWYWx1ZSBzZXF1ZW5jZVxuICAgIC8vIGNvbnRhaW5pbmcgZmlyc3QgYSB0eXBlIChhbiBPSUQpIGFuZCBzZWNvbmQgYSB2YWx1ZSAoZGVmaW5lZCBieVxuICAgIC8vIHRoZSBPSUQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNldC52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgb2JqID0ge307XG4gICAgICBhdHRyID0gc2V0LnZhbHVlW2ldO1xuICAgICAgb2JqLnR5cGUgPSBhc24xLmRlclRvT2lkKGF0dHIudmFsdWVbMF0udmFsdWUpO1xuICAgICAgb2JqLnZhbHVlID0gYXR0ci52YWx1ZVsxXS52YWx1ZTtcbiAgICAgIG9iai52YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVsxXS50eXBlO1xuICAgICAgLy8gaWYgdGhlIE9JRCBpcyBrbm93biwgZ2V0IGl0cyBuYW1lIGFuZCBzaG9ydCBuYW1lXG4gICAgICBpZihvYmoudHlwZSBpbiBvaWRzKSB7XG4gICAgICAgIG9iai5uYW1lID0gb2lkc1tvYmoudHlwZV07XG4gICAgICAgIGlmKG9iai5uYW1lIGluIF9zaG9ydE5hbWVzKSB7XG4gICAgICAgICAgb2JqLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW29iai5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYobWQpIHtcbiAgICAgICAgbWQudXBkYXRlKG9iai50eXBlKTtcbiAgICAgICAgbWQudXBkYXRlKG9iai52YWx1ZSk7XG4gICAgICB9XG4gICAgICBydmFsLnB1c2gob2JqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgQVNOLjEgQ1JJQXR0cmlidXRlcyBpbnRvIGFuIGFycmF5IHdpdGggb2JqZWN0cyB0aGF0IGhhdmUgdHlwZSBhbmRcbiAqIHZhbHVlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgdGhlIENSSUF0dHJpYnV0ZXMgdG8gY29udmVydC5cbiAqL1xucGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5ID0gZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICB2YXIgcnZhbCA9IFtdO1xuXG4gIC8vIGVhY2ggdmFsdWUgaW4gJ2F0dHJpYnV0ZXMnIGluIGlzIGEgU0VRVUVOQ0Ugd2l0aCBhbiBPSUQgYW5kIGEgU0VUXG4gIGZvcih2YXIgc2kgPSAwOyBzaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgLy8gZ2V0IHRoZSBhdHRyaWJ1dGUgc2VxdWVuY2VcbiAgICB2YXIgc2VxID0gYXR0cmlidXRlc1tzaV07XG5cbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBTRVFVRU5DRSBjb250YWluaW5nIGZpcnN0IGEgdHlwZSAoYW4gT0lEKSBhbmRcbiAgICAvLyBzZWNvbmQgYSBzZXQgb2YgdmFsdWVzIChkZWZpbmVkIGJ5IHRoZSBPSUQpXG4gICAgdmFyIHR5cGUgPSBhc24xLmRlclRvT2lkKHNlcS52YWx1ZVswXS52YWx1ZSk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcS52YWx1ZVsxXS52YWx1ZTtcbiAgICBmb3IodmFyIHZpID0gMDsgdmkgPCB2YWx1ZXMubGVuZ3RoOyArK3ZpKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBvYmoudHlwZSA9IHR5cGU7XG4gICAgICBvYmoudmFsdWUgPSB2YWx1ZXNbdmldLnZhbHVlO1xuICAgICAgb2JqLnZhbHVlVGFnQ2xhc3MgPSB2YWx1ZXNbdmldLnR5cGU7XG4gICAgICAvLyBpZiB0aGUgT0lEIGlzIGtub3duLCBnZXQgaXRzIG5hbWUgYW5kIHNob3J0IG5hbWVcbiAgICAgIGlmKG9iai50eXBlIGluIG9pZHMpIHtcbiAgICAgICAgb2JqLm5hbWUgPSBvaWRzW29iai50eXBlXTtcbiAgICAgICAgaWYob2JqLm5hbWUgaW4gX3Nob3J0TmFtZXMpIHtcbiAgICAgICAgICBvYmouc2hvcnROYW1lID0gX3Nob3J0TmFtZXNbb2JqLm5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwYXJzZSBleHRlbnNpb25zXG4gICAgICBpZihvYmoudHlwZSA9PT0gb2lkcy5leHRlbnNpb25SZXF1ZXN0KSB7XG4gICAgICAgIG9iai5leHRlbnNpb25zID0gW107XG4gICAgICAgIGZvcih2YXIgZWkgPSAwOyBlaSA8IG9iai52YWx1ZS5sZW5ndGg7ICsrZWkpIHtcbiAgICAgICAgICBvYmouZXh0ZW5zaW9ucy5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbkZyb21Bc24xKG9iai52YWx1ZVtlaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKG9iaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gaXNzdWVyIG9yIHN1YmplY3QgYXR0cmlidXRlIGZyb20gaXRzIG5hbWUsIHR5cGUsIG9yIHNob3J0IG5hbWUuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgaXNzdWVyIG9yIHN1YmplY3Qgb2JqZWN0LlxuICogQHBhcmFtIG9wdGlvbnMgYSBzaG9ydCBuYW1lIHN0cmluZyBvciBhbiBvYmplY3Qgd2l0aDpcbiAqICAgICAgICAgIHNob3J0TmFtZSB0aGUgc2hvcnQgbmFtZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqICAgICAgICAgIG5hbWUgdGhlIG5hbWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICB0eXBlIHRoZSB0eXBlIGZvciB0aGUgYXR0cmlidXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gX2dldEF0dHJpYnV0ZShvYmosIG9wdGlvbnMpIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtzaG9ydE5hbWU6IG9wdGlvbnN9O1xuICB9XG5cbiAgdmFyIHJ2YWwgPSBudWxsO1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgcnZhbCA9PT0gbnVsbCAmJiBpIDwgb2JqLmF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBhdHRyID0gb2JqLmF0dHJpYnV0ZXNbaV07XG4gICAgaWYob3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSA9PT0gYXR0ci50eXBlKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5uYW1lICYmIG9wdGlvbnMubmFtZSA9PT0gYXR0ci5uYW1lKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9IGVsc2UgaWYob3B0aW9ucy5zaG9ydE5hbWUgJiYgb3B0aW9ucy5zaG9ydE5hbWUgPT09IGF0dHIuc2hvcnROYW1lKSB7XG4gICAgICBydmFsID0gYXR0cjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtZXRlcnMgZnJvbSBBU04uMSBzdHJ1Y3R1cmUuXG4gKlxuICogQ3VycmVudGx5IG9ubHkgUlNBU1NBLVBTUyBzdXBwb3J0ZWQuICBUaGUgUEtDUyMxIHYxLjUgc2lnbmF0dXJlIHNjaGVtZSBoYWRcbiAqIG5vIHBhcmFtZXRlcnMuXG4gKlxuICogUlNBU1NBLVBTUy1wYXJhbXMgIDo6PSAgU0VRVUVOQ0UgIHtcbiAqICAgaGFzaEFsZ29yaXRobSAgICAgIFswXSBIYXNoQWxnb3JpdGhtIERFRkFVTFRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGExSWRlbnRpZmllcixcbiAqICAgbWFza0dlbkFsZ29yaXRobSAgIFsxXSBNYXNrR2VuQWxnb3JpdGhtIERFRkFVTFRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZ2YxU0hBMUlkZW50aWZpZXIsXG4gKiAgIHNhbHRMZW5ndGggICAgICAgICBbMl0gSU5URUdFUiBERUZBVUxUIDIwLFxuICogICB0cmFpbGVyRmllbGQgICAgICAgWzNdIElOVEVHRVIgREVGQVVMVCAxXG4gKiB9XG4gKlxuICogSGFzaEFsZ29yaXRobSAgOjo9ICBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogTWFza0dlbkFsZ29yaXRobSAgOjo9ICBBbGdvcml0aG1JZGVudGlmaWVyXG4gKlxuICogQWxnb3JpdGhtSWRlbnRpZmVyIDo6PSBTRVFVRU5DRSB7XG4gKiAgIGFsZ29yaXRobSBPQkpFQ1QgSURFTlRJRklFUixcbiAqICAgcGFyYW1ldGVycyBBTlkgREVGSU5FRCBCWSBhbGdvcml0aG0gT1BUSU9OQUxcbiAqIH1cbiAqXG4gKiBAcGFyYW0gb2lkIFRoZSBPSUQgc3BlY2lmeWluZyB0aGUgc2lnbmF0dXJlIGFsZ29yaXRobVxuICogQHBhcmFtIG9iaiBUaGUgQVNOLjEgc3RydWN0dXJlIGhvbGRpbmcgdGhlIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBmaWxsRGVmYXVsdHMgV2hldGhlciB0byB1c2UgcmV0dXJuIGRlZmF1bHQgdmFsdWVzIHdoZXJlIG9taXR0ZWRcbiAqIEByZXR1cm4gc2lnbmF0dXJlIHBhcmFtZXRlciBvYmplY3RcbiAqL1xudmFyIF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG9pZCwgb2JqLCBmaWxsRGVmYXVsdHMpIHtcbiAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gIGlmKG9pZCAhPT0gb2lkc1snUlNBU1NBLVBTUyddKSB7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIGlmKGZpbGxEZWZhdWx0cykge1xuICAgIHBhcmFtcyA9IHtcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydzaGExJ11cbiAgICAgIH0sXG4gICAgICBtZ2Y6IHtcbiAgICAgICAgYWxnb3JpdGhtT2lkOiBvaWRzWydtZ2YxJ10sXG4gICAgICAgIGhhc2g6IHtcbiAgICAgICAgICBhbGdvcml0aG1PaWQ6IG9pZHNbJ3NoYTEnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2FsdExlbmd0aDogMjBcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhcHR1cmUgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZighYXNuMS52YWxpZGF0ZShvYmosIHJzYXNzYVBzc1BhcmFtZXRlclZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUlNBU1NBLVBTUyBwYXJhbWV0ZXIgYmxvY2suJyk7XG4gICAgZXJyb3IuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgaWYoY2FwdHVyZS5oYXNoT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMuaGFzaCA9IHBhcmFtcy5oYXNoIHx8IHt9O1xuICAgIHBhcmFtcy5oYXNoLmFsZ29yaXRobU9pZCA9IGFzbjEuZGVyVG9PaWQoY2FwdHVyZS5oYXNoT2lkKTtcbiAgfVxuXG4gIGlmKGNhcHR1cmUubWFza0dlbk9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyYW1zLm1nZiA9IHBhcmFtcy5tZ2YgfHwge307XG4gICAgcGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFza0dlbk9pZCk7XG4gICAgcGFyYW1zLm1nZi5oYXNoID0gcGFyYW1zLm1nZi5oYXNoIHx8IHt9O1xuICAgIHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUubWFza0dlbkhhc2hPaWQpO1xuICB9XG5cbiAgaWYoY2FwdHVyZS5zYWx0TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJhbXMuc2FsdExlbmd0aCA9IGNhcHR1cmUuc2FsdExlbmd0aC5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDkgY2VydGlmaWNhdGUgZnJvbSBQRU0gZm9ybWF0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyB0byBiZSB2ZXJpZmllZCB0aGVuIGNvbXB1dGUgaGFzaCBzaG91bGRcbiAqIGJlIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgc2NhbiB0aGUgVEJTQ2VydGlmaWNhdGUgcGFydCBvZiB0aGUgQVNOLjFcbiAqIG9iamVjdCB3aGlsZSBpdCBpcyBjb252ZXJ0ZWQgc28gaXQgZG9lc24ndCBuZWVkIHRvIGJlIGNvbnZlcnRlZCBiYWNrXG4gKiB0byBBU04uMS1ERVItZW5jb2RpbmcgbGF0ZXIuXG4gKlxuICogQHBhcmFtIHBlbSB0aGUgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBjb21wdXRlSGFzaCB0cnVlIHRvIGNvbXB1dGUgdGhlIGhhc2ggZm9yIHZlcmlmaWNhdGlvbi5cbiAqIEBwYXJhbSBzdHJpY3QgdHJ1ZSB0byBiZSBzdHJpY3Qgd2hlbiBjaGVja2luZyBBU04uMSB2YWx1ZSBsZW5ndGhzLCBmYWxzZSB0b1xuICogICAgICAgICAgYWxsb3cgdHJ1bmNhdGVkIHZhbHVlcyAoZGVmYXVsdDogdHJ1ZSkuXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0gPSBmdW5jdGlvbihwZW0sIGNvbXB1dGVIYXNoLCBzdHJpY3QpIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0NFUlRJRklDQVRFJyAmJlxuICAgIG1zZy50eXBlICE9PSAnWDUwOSBDRVJUSUZJQ0FURScgJiZcbiAgICBtc2cudHlwZSAhPT0gJ1RSVVNURUQgQ0VSVElGSUNBVEUnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaGVhZGVyIHR5cGUgJyArXG4gICAgICAnaXMgbm90IFwiQ0VSVElGSUNBVEVcIiwgXCJYNTA5IENFUlRJRklDQVRFXCIsIG9yIFwiVFJVU1RFRCBDRVJUSUZJQ0FURVwiLicpO1xuICAgIGVycm9yLmhlYWRlclR5cGUgPSBtc2cudHlwZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZihtc2cucHJvY1R5cGUgJiYgbXNnLnByb2NUeXBlLnR5cGUgPT09ICdFTkNSWVBURUQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRlIGZyb20gUEVNOyBQRU0gaXMgZW5jcnlwdGVkLicpO1xuICB9XG5cbiAgLy8gY29udmVydCBERVIgdG8gQVNOLjEgb2JqZWN0XG4gIHZhciBvYmogPSBhc24xLmZyb21EZXIobXNnLmJvZHksIHN0cmljdCk7XG5cbiAgcmV0dXJuIHBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xKG9iaiwgY29tcHV0ZUhhc2gpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBjZXJ0aWZpY2F0ZSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZS5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZVRvUGVtID0gZnVuY3Rpb24oY2VydCwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFJyxcbiAgICBib2R5OiBhc24xLnRvRGVyKHBraS5jZXJ0aWZpY2F0ZVRvQXNuMShjZXJ0KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IGZyb20gUEVNIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKlxuICogQHJldHVybiB0aGUgcHVibGljIGtleS5cbiAqL1xucGtpLnB1YmxpY0tleUZyb21QZW0gPSBmdW5jdGlvbihwZW0pIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ1BVQkxJQyBLRVknICYmIG1zZy50eXBlICE9PSAnUlNBIFBVQkxJQyBLRVknKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBwdWJsaWMga2V5IGZyb20gUEVNOyBQRU0gaGVhZGVyICcgK1xuICAgICAgJ3R5cGUgaXMgbm90IFwiUFVCTElDIEtFWVwiIG9yIFwiUlNBIFBVQkxJQyBLRVlcIi4nKTtcbiAgICBlcnJvci5oZWFkZXJUeXBlID0gbXNnLnR5cGU7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgaWYobXNnLnByb2NUeXBlICYmIG1zZy5wcm9jVHlwZS50eXBlID09PSAnRU5DUllQVEVEJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNvbnZlcnQgcHVibGljIGtleSBmcm9tIFBFTTsgUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5KTtcblxuICByZXR1cm4gcGtpLnB1YmxpY0tleUZyb21Bc24xKG9iaik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFJTQSBwdWJsaWMga2V5IHRvIFBFTSBmb3JtYXQgKHVzaW5nIGEgU3ViamVjdFB1YmxpY0tleUluZm8pLlxuICpcbiAqIEBwYXJhbSBrZXkgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gbWF4bGluZSB0aGUgbWF4aW11bSBjaGFyYWN0ZXJzIHBlciBsaW5lLCBkZWZhdWx0cyB0byA2NC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBQRU0tZm9ybWF0dGVkIHB1YmxpYyBrZXkuXG4gKi9cbnBraS5wdWJsaWNLZXlUb1BlbSA9IGZ1bmN0aW9uKGtleSwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ1BVQkxJQyBLRVknLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLnB1YmxpY0tleVRvQXNuMShrZXkpKS5nZXRCeXRlcygpXG4gIH07XG4gIHJldHVybiBmb3JnZS5wZW0uZW5jb2RlKG1zZywge21heGxpbmU6IG1heGxpbmV9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUlNBIHB1YmxpYyBrZXkgdG8gUEVNIGZvcm1hdCAodXNpbmcgYW4gUlNBUHVibGljS2V5KS5cbiAqXG4gKiBAcGFyYW0ga2V5IHRoZSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG1heGxpbmUgdGhlIG1heGltdW0gY2hhcmFjdGVycyBwZXIgbGluZSwgZGVmYXVsdHMgdG8gNjQuXG4gKlxuICogQHJldHVybiB0aGUgUEVNLWZvcm1hdHRlZCBwdWJsaWMga2V5LlxuICovXG5wa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXlQZW0gPSBmdW5jdGlvbihrZXksIG1heGxpbmUpIHtcbiAgLy8gY29udmVydCB0byBBU04uMSwgdGhlbiBERVIsIHRoZW4gUEVNLWVuY29kZVxuICB2YXIgbXNnID0ge1xuICAgIHR5cGU6ICdSU0EgUFVCTElDIEtFWScsXG4gICAgYm9keTogYXNuMS50b0Rlcihwa2kucHVibGljS2V5VG9SU0FQdWJsaWNLZXkoa2V5KSkuZ2V0Qnl0ZXMoKVxuICB9O1xuICByZXR1cm4gZm9yZ2UucGVtLmVuY29kZShtc2csIHttYXhsaW5lOiBtYXhsaW5lfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSBmaW5nZXJwcmludCBmb3IgdGhlIGdpdmVuIHB1YmxpYyBrZXkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW21kXSB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gKiAgICAgICAgICBbdHlwZV0gdGhlIHR5cGUgb2YgZmluZ2VycHJpbnQsIHN1Y2ggYXMgJ1JTQVB1YmxpY0tleScsXG4gKiAgICAgICAgICAgICdTdWJqZWN0UHVibGljS2V5SW5mbycgKGRlZmF1bHRzIHRvICdSU0FQdWJsaWNLZXknKS5cbiAqICAgICAgICAgIFtlbmNvZGluZ10gYW4gYWx0ZXJuYXRpdmUgb3V0cHV0IGVuY29kaW5nLCBzdWNoIGFzICdoZXgnXG4gKiAgICAgICAgICAgIChkZWZhdWx0cyB0byBub25lLCBvdXRwdXRzIGEgYnl0ZSBidWZmZXIpLlxuICogICAgICAgICAgW2RlbGltaXRlcl0gdGhlIGRlbGltaXRlciB0byB1c2UgYmV0d2VlbiBieXRlcyBmb3IgJ2hleCcgZW5jb2RlZFxuICogICAgICAgICAgICBvdXRwdXQsIGVnOiAnOicgKGRlZmF1bHRzIHRvIG5vbmUpLlxuICpcbiAqIEByZXR1cm4gdGhlIGZpbmdlcnByaW50IGFzIGEgYnl0ZSBidWZmZXIgb3Igb3RoZXIgZW5jb2RpbmcgYmFzZWQgb24gb3B0aW9ucy5cbiAqL1xucGtpLmdldFB1YmxpY0tleUZpbmdlcnByaW50ID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWQgPSBvcHRpb25zLm1kIHx8IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIHZhciB0eXBlID0gb3B0aW9ucy50eXBlIHx8ICdSU0FQdWJsaWNLZXknO1xuXG4gIHZhciBieXRlcztcbiAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlICdSU0FQdWJsaWNLZXknOlxuICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb1JTQVB1YmxpY0tleShrZXkpKS5nZXRCeXRlcygpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnU3ViamVjdFB1YmxpY0tleUluZm8nOlxuICAgICAgYnl0ZXMgPSBhc24xLnRvRGVyKHBraS5wdWJsaWNLZXlUb0FzbjEoa2V5KSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZmluZ2VycHJpbnQgdHlwZSBcIicgKyBvcHRpb25zLnR5cGUgKyAnXCIuJyk7XG4gIH1cblxuICAvLyBoYXNoIHB1YmxpYyBrZXkgYnl0ZXNcbiAgbWQuc3RhcnQoKTtcbiAgbWQudXBkYXRlKGJ5dGVzKTtcbiAgdmFyIGRpZ2VzdCA9IG1kLmRpZ2VzdCgpO1xuICBpZihvcHRpb25zLmVuY29kaW5nID09PSAnaGV4Jykge1xuICAgIHZhciBoZXggPSBkaWdlc3QudG9IZXgoKTtcbiAgICBpZihvcHRpb25zLmRlbGltaXRlcikge1xuICAgICAgcmV0dXJuIGhleC5tYXRjaCgvLnsyfS9nKS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfSBlbHNlIGlmKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKSB7XG4gICAgcmV0dXJuIGRpZ2VzdC5nZXRCeXRlcygpO1xuICB9IGVsc2UgaWYob3B0aW9ucy5lbmNvZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBcIicgKyBvcHRpb25zLmVuY29kaW5nICsgJ1wiLicpO1xuICB9XG4gIHJldHVybiBkaWdlc3Q7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUEtDUyMxMCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikgZnJvbSBQRU0gZm9ybWF0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2hcbiAqIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZS4gVGhpcyB3aWxsIHNjYW4gdGhlIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBwYXJ0IG9mXG4gKiB0aGUgQVNOLjEgb2JqZWN0IHdoaWxlIGl0IGlzIGNvbnZlcnRlZCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgY29udmVydGVkXG4gKiBiYWNrIHRvIEFTTi4xLURFUi1lbmNvZGluZyBsYXRlci5cbiAqXG4gKiBAcGFyYW0gcGVtIHRoZSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlLlxuICogQHBhcmFtIGNvbXB1dGVIYXNoIHRydWUgdG8gY29tcHV0ZSB0aGUgaGFzaCBmb3IgdmVyaWZpY2F0aW9uLlxuICogQHBhcmFtIHN0cmljdCB0cnVlIHRvIGJlIHN0cmljdCB3aGVuIGNoZWNraW5nIEFTTi4xIHZhbHVlIGxlbmd0aHMsIGZhbHNlIHRvXG4gKiAgICAgICAgICBhbGxvdyB0cnVuY2F0ZWQgdmFsdWVzIChkZWZhdWx0OiB0cnVlKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKENTUikuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEZyb21QZW0gPSBmdW5jdGlvbihwZW0sIGNvbXB1dGVIYXNoLCBzdHJpY3QpIHtcbiAgdmFyIG1zZyA9IGZvcmdlLnBlbS5kZWNvZGUocGVtKVswXTtcblxuICBpZihtc2cudHlwZSAhPT0gJ0NFUlRJRklDQVRFIFJFUVVFU1QnKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29udmVydCBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgZnJvbSBQRU07ICcgK1xuICAgICAgJ1BFTSBoZWFkZXIgdHlwZSBpcyBub3QgXCJDRVJUSUZJQ0FURSBSRVFVRVNUXCIuJyk7XG4gICAgZXJyb3IuaGVhZGVyVHlwZSA9IG1zZy50eXBlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGlmKG1zZy5wcm9jVHlwZSAmJiBtc2cucHJvY1R5cGUudHlwZSA9PT0gJ0VOQ1JZUFRFRCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGNlcnRpZmljYXRpb24gcmVxdWVzdCBmcm9tIFBFTTsgJyArXG4gICAgICAnUEVNIGlzIGVuY3J5cHRlZC4nKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgREVSIHRvIEFTTi4xIG9iamVjdFxuICB2YXIgb2JqID0gYXNuMS5mcm9tRGVyKG1zZy5ib2R5LCBzdHJpY3QpO1xuXG4gIHJldHVybiBwa2kuY2VydGlmaWNhdGlvblJlcXVlc3RGcm9tQXNuMShvYmosIGNvbXB1dGVIYXNoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKSB0byBQRU0gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqIEBwYXJhbSBtYXhsaW5lIHRoZSBtYXhpbXVtIGNoYXJhY3RlcnMgcGVyIGxpbmUsIGRlZmF1bHRzIHRvIDY0LlxuICpcbiAqIEByZXR1cm4gdGhlIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY2VydGlmaWNhdGlvblJlcXVlc3RUb1BlbSA9IGZ1bmN0aW9uKGNzciwgbWF4bGluZSkge1xuICAvLyBjb252ZXJ0IHRvIEFTTi4xLCB0aGVuIERFUiwgdGhlbiBQRU0tZW5jb2RlXG4gIHZhciBtc2cgPSB7XG4gICAgdHlwZTogJ0NFUlRJRklDQVRFIFJFUVVFU1QnLFxuICAgIGJvZHk6IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0VG9Bc24xKGNzcikpLmdldEJ5dGVzKClcbiAgfTtcbiAgcmV0dXJuIGZvcmdlLnBlbS5lbmNvZGUobXNnLCB7bWF4bGluZTogbWF4bGluZX0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IFguNTA5djMgUlNBIGNlcnRpZmljYXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlLlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNlcnQgPSB7fTtcbiAgY2VydC52ZXJzaW9uID0gMHgwMjtcbiAgY2VydC5zZXJpYWxOdW1iZXIgPSAnMDAnO1xuICBjZXJ0LnNpZ25hdHVyZU9pZCA9IG51bGw7XG4gIGNlcnQuc2lnbmF0dXJlID0gbnVsbDtcbiAgY2VydC5zaWdpbmZvID0ge307XG4gIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQgPSBudWxsO1xuICBjZXJ0LnZhbGlkaXR5ID0ge307XG4gIGNlcnQudmFsaWRpdHkubm90QmVmb3JlID0gbmV3IERhdGUoKTtcbiAgY2VydC52YWxpZGl0eS5ub3RBZnRlciA9IG5ldyBEYXRlKCk7XG5cbiAgY2VydC5pc3N1ZXIgPSB7fTtcbiAgY2VydC5pc3N1ZXIuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuaXNzdWVyLCBzbik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5pc3N1ZXIuYXR0cmlidXRlcyA9IFtdO1xuICBjZXJ0Lmlzc3Vlci5oYXNoID0gbnVsbDtcblxuICBjZXJ0LnN1YmplY3QgPSB7fTtcbiAgY2VydC5zdWJqZWN0LmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0LnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmFkZEZpZWxkID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNlcnQuc3ViamVjdC5oYXNoID0gbnVsbDtcblxuICBjZXJ0LmV4dGVuc2lvbnMgPSBbXTtcbiAgY2VydC5wdWJsaWNLZXkgPSBudWxsO1xuICBjZXJ0Lm1kID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgc3ViamVjdCBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqIEBwYXJhbSB1bmlxdWVJZCBhbiBvcHRpb25hbCBhIHVuaXF1ZSBJRCB0byB1c2UuXG4gICAqL1xuICBjZXJ0LnNldFN1YmplY3QgPSBmdW5jdGlvbihhdHRycywgdW5pcXVlSWQpIHtcbiAgICAvLyBzZXQgbmV3IGF0dHJpYnV0ZXMsIGNsZWFyIGhhc2hcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoYXR0cnMpO1xuICAgIGNlcnQuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgZGVsZXRlIGNlcnQuc3ViamVjdC51bmlxdWVJZDtcbiAgICBpZih1bmlxdWVJZCkge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhcmJpdHJhcnkgYml0IGxlbmd0aCBpZHNcbiAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIH1cbiAgICBjZXJ0LnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlzc3VlciBvZiB0aGlzIGNlcnRpZmljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIGlzc3VlciBhdHRyaWJ1dGVzIHRvIHVzZS5cbiAgICogQHBhcmFtIHVuaXF1ZUlkIGFuIG9wdGlvbmFsIGEgdW5pcXVlIElEIHRvIHVzZS5cbiAgICovXG4gIGNlcnQuc2V0SXNzdWVyID0gZnVuY3Rpb24oYXR0cnMsIHVuaXF1ZUlkKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzLCBjbGVhciBoYXNoXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgZGVsZXRlIGNlcnQuaXNzdWVyLnVuaXF1ZUlkO1xuICAgIGlmKHVuaXF1ZUlkKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgY2VydC5pc3N1ZXIudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICB9XG4gICAgY2VydC5pc3N1ZXIuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV4dGVuc2lvbnMgb2YgdGhpcyBjZXJ0aWZpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtIGV4dHMgdGhlIGFycmF5IG9mIGV4dGVuc2lvbnMgdG8gdXNlLlxuICAgKi9cbiAgY2VydC5zZXRFeHRlbnNpb25zID0gZnVuY3Rpb24oZXh0cykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBfZmlsbE1pc3NpbmdFeHRlbnNpb25GaWVsZHMoZXh0c1tpXSwge2NlcnQ6IGNlcnR9KTtcbiAgICB9XG4gICAgLy8gc2V0IG5ldyBleHRlbnNpb25zXG4gICAgY2VydC5leHRlbnNpb25zID0gZXh0cztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhbiBleHRlbnNpb24gYnkgaXRzIG5hbWUgb3IgaWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBuYW1lIHRvIHVzZSBvciBhbiBvYmplY3Qgd2l0aDpcbiAgICogICAgICAgICAgbmFtZSB0aGUgbmFtZSB0byB1c2UuXG4gICAqICAgICAgICAgIGlkIHRoZSBpZCB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbiBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIGNlcnQuZ2V0RXh0ZW5zaW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHtuYW1lOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICB2YXIgcnZhbCA9IG51bGw7XG4gICAgdmFyIGV4dDtcbiAgICBmb3IodmFyIGkgPSAwOyBydmFsID09PSBudWxsICYmIGkgPCBjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGV4dCA9IGNlcnQuZXh0ZW5zaW9uc1tpXTtcbiAgICAgIGlmKG9wdGlvbnMuaWQgJiYgZXh0LmlkID09PSBvcHRpb25zLmlkKSB7XG4gICAgICAgIHJ2YWwgPSBleHQ7XG4gICAgICB9IGVsc2UgaWYob3B0aW9ucy5uYW1lICYmIGV4dC5uYW1lID09PSBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcnZhbCA9IGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoaXMgY2VydGlmaWNhdGUgdXNpbmcgdGhlIGdpdmVuIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gICAqIEBwYXJhbSBtZCB0aGUgbWVzc2FnZSBkaWdlc3Qgb2JqZWN0IHRvIHVzZSAoZGVmYXVsdHMgdG8gZm9yZ2UubWQuc2hhMSkuXG4gICAqL1xuICBjZXJ0LnNpZ24gPSBmdW5jdGlvbihrZXksIG1kKSB7XG4gICAgLy8gVE9ETzogZ2V0IHNpZ25hdHVyZSBPSUQgZnJvbSBwcml2YXRlIGtleVxuICAgIGNlcnQubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2NlcnQubWQuYWxnb3JpdGhtICsgJ1dpdGhSU0FFbmNyeXB0aW9uJ107XG4gICAgaWYoIWFsZ29yaXRobU9pZCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0ZSBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY2VydC5tZC5hbGdvcml0aG07XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY2VydC5zaWduYXR1cmVPaWQgPSBjZXJ0LnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IFRCU0NlcnRpZmljYXRlLCBjb252ZXJ0IHRvIERFUlxuICAgIGNlcnQudGJzQ2VydGlmaWNhdGUgPSBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG4gICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjZXJ0LnRic0NlcnRpZmljYXRlKTtcblxuICAgIC8vIGRpZ2VzdCBhbmQgc2lnblxuICAgIGNlcnQubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNlcnQuc2lnbmF0dXJlID0ga2V5LnNpZ24oY2VydC5tZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHZlcmlmeSB0aGUgc2lnbmF0dXJlIG9uIHRoZSBwYXNzZWQgY2VydGlmaWNhdGUgdXNpbmcgdGhpc1xuICAgKiBjZXJ0aWZpY2F0ZSdzIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBjaGlsZCB0aGUgY2VydGlmaWNhdGUgdG8gdmVyaWZ5LlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNlcnQudmVyaWZ5ID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB2YXIgcnZhbCA9IGZhbHNlO1xuXG4gICAgaWYoIWNlcnQuaXNzdWVkKGNoaWxkKSkge1xuICAgICAgdmFyIGlzc3VlciA9IGNoaWxkLmlzc3VlcjtcbiAgICAgIHZhciBzdWJqZWN0ID0gY2VydC5zdWJqZWN0O1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBkaWQgbm90IGlzc3VlIHRoZSBnaXZlbiBjaGlsZCAnICtcbiAgICAgICAgJ2NlcnRpZmljYXRlOyB0aGUgY2hpbGQgY2VydGlmaWNhdGVcXCdzIGlzc3VlciBkb2VzIG5vdCBtYXRjaCB0aGUgJyArXG4gICAgICAgICdwYXJlbnRcXCdzIHN1YmplY3QuJyk7XG4gICAgICBlcnJvci5leHBlY3RlZElzc3VlciA9IGlzc3Vlci5hdHRyaWJ1dGVzO1xuICAgICAgZXJyb3IuYWN0dWFsSXNzdWVyID0gc3ViamVjdC5hdHRyaWJ1dGVzO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdmFyIG1kID0gY2hpbGQubWQ7XG4gICAgaWYobWQgPT09IG51bGwpIHtcbiAgICAgIC8vIGNoZWNrIHNpZ25hdHVyZSBPSUQgZm9yIHN1cHBvcnRlZCBzaWduYXR1cmUgdHlwZXNcbiAgICAgIGlmKGNoaWxkLnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICAgIHZhciBvaWQgPSBvaWRzW2NoaWxkLnNpZ25hdHVyZU9pZF07XG4gICAgICAgIHN3aXRjaChvaWQpIHtcbiAgICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGUgZGlnZXN0LiAnICtcbiAgICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgICBlcnJvci5zaWduYXR1cmVPaWQgPSBjaGlsZC5zaWduYXR1cmVPaWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIHRic0NlcnRpZmljYXRlID0gY2hpbGQudGJzQ2VydGlmaWNhdGUgfHwgcGtpLmdldFRCU0NlcnRpZmljYXRlKGNoaWxkKTtcbiAgICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIodGJzQ2VydGlmaWNhdGUpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICB2YXIgc2NoZW1lO1xuXG4gICAgICBzd2l0Y2goY2hpbGQuc2lnbmF0dXJlT2lkKSB7XG4gICAgICAgIGNhc2Ugb2lkcy5zaGExV2l0aFJTQUVuY3J5cHRpb246XG4gICAgICAgICAgc2NoZW1lID0gdW5kZWZpbmVkOyAvKiB1c2UgUEtDUyMxIHYxLjUgcGFkZGluZyBzY2hlbWUgKi9cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICAgICAgdmFyIGhhc2gsIG1nZjtcblxuICAgICAgICAgIC8qIGluaXRpYWxpemUgbWdmICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQ7XG4gICAgICAgICAgICBlcnJvci5uYW1lID0gaGFzaDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1nZiA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuYWxnb3JpdGhtT2lkXTtcbiAgICAgICAgICBpZihtZ2YgPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZ2ZbbWdmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBtZ2Y7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBmb3JnZS5tZ2ZbbWdmXS5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCkpO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5oYXNoLmFsZ29yaXRobU9pZF07XG4gICAgICAgICAgaWYoaGFzaCA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1kW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nLFxuICAgICAgICAgICAgICBvaWQ6IGNoaWxkLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWQsXG4gICAgICAgICAgICAgIG5hbWU6IGhhc2hcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZW1lID0gZm9yZ2UucHNzLmNyZWF0ZShmb3JnZS5tZFtoYXNoXS5jcmVhdGUoKSwgbWdmLFxuICAgICAgICAgICAgY2hpbGQuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHNpZ25hdHVyZSBvbiBjZXJ0IHVzaW5nIHB1YmxpYyBrZXlcbiAgICAgIHJ2YWwgPSBjZXJ0LnB1YmxpY0tleS52ZXJpZnkoXG4gICAgICAgIG1kLmRpZ2VzdCgpLmdldEJ5dGVzKCksIGNoaWxkLnNpZ25hdHVyZSwgc2NoZW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2VydGlmaWNhdGUncyBpc3N1ZXIgbWF0Y2hlcyB0aGUgcGFzc2VkXG4gICAqIGNlcnRpZmljYXRlJ3Mgc3ViamVjdC4gTm90ZSB0aGF0IG5vIHNpZ25hdHVyZSBjaGVjayBpcyBwZXJmb3JtZWQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJlbnQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIGlzc3VlciBtYXRjaGVzIHRoZSBwYXNzZWQgY2VydGlmaWNhdGUnc1xuICAgKiAgICAgICAgIHN1YmplY3QuXG4gICAqL1xuICBjZXJ0LmlzSXNzdWVyID0gZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBpID0gY2VydC5pc3N1ZXI7XG4gICAgdmFyIHMgPSBwYXJlbnQuc3ViamVjdDtcblxuICAgIC8vIGNvbXBhcmUgaGFzaGVzIGlmIHByZXNlbnRcbiAgICBpZihpLmhhc2ggJiYgcy5oYXNoKSB7XG4gICAgICBydmFsID0gKGkuaGFzaCA9PT0gcy5oYXNoKTtcbiAgICB9IGVsc2UgaWYoaS5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gcy5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgLy8gYWxsIGF0dHJpYnV0ZXMgYXJlIHRoZSBzYW1lIHNvIGlzc3VlciBtYXRjaGVzIHN1YmplY3RcbiAgICAgIHJ2YWwgPSB0cnVlO1xuICAgICAgdmFyIGlhdHRyLCBzYXR0cjtcbiAgICAgIGZvcih2YXIgbiA9IDA7IHJ2YWwgJiYgbiA8IGkuYXR0cmlidXRlcy5sZW5ndGg7ICsrbikge1xuICAgICAgICBpYXR0ciA9IGkuYXR0cmlidXRlc1tuXTtcbiAgICAgICAgc2F0dHIgPSBzLmF0dHJpYnV0ZXNbbl07XG4gICAgICAgIGlmKGlhdHRyLnR5cGUgIT09IHNhdHRyLnR5cGUgfHwgaWF0dHIudmFsdWUgIT09IHNhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgLy8gYXR0cmlidXRlIG1pc21hdGNoXG4gICAgICAgICAgcnZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNlcnRpZmljYXRlJ3Mgc3ViamVjdCBtYXRjaGVzIHRoZSBpc3N1ZXIgb2YgdGhlXG4gICAqIGdpdmVuIGNlcnRpZmljYXRlKS4gTm90ZSB0aGF0IG5vdCBzaWduYXR1cmUgY2hlY2sgaXMgcGVyZm9ybWVkLlxuICAgKlxuICAgKiBAcGFyYW0gY2hpbGQgdGhlIGNlcnRpZmljYXRlIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBjZXJ0aWZpY2F0ZSdzIHN1YmplY3QgbWF0Y2hlcyB0aGUgcGFzc2VkXG4gICAqICAgICAgICAgY2VydGlmaWNhdGUncyBpc3N1ZXIuXG4gICAqL1xuICBjZXJ0Lmlzc3VlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkLmlzSXNzdWVyKGNlcnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHN1YmplY3RLZXlJZGVudGlmaWVyIGZvciB0aGlzIGNlcnRpZmljYXRlIGFzIGJ5dGUgYnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSBzdWJqZWN0S2V5SWRlbnRpZmllciBmb3IgdGhpcyBjZXJ0aWZpY2F0ZSBhcyBieXRlIGJ1ZmZlci5cbiAgICovXG4gIGNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIFNlZTogNC4yLjEuMiBzZWN0aW9uIG9mIHRoZSB0aGUgUkZDMzI4MCwga2V5SWRlbnRpZmllciBpcyBlaXRoZXI6XG5cbiAgICAgICgxKSBUaGUga2V5SWRlbnRpZmllciBpcyBjb21wb3NlZCBvZiB0aGUgMTYwLWJpdCBTSEEtMSBoYXNoIG9mIHRoZVxuICAgICAgICB2YWx1ZSBvZiB0aGUgQklUIFNUUklORyBzdWJqZWN0UHVibGljS2V5IChleGNsdWRpbmcgdGhlIHRhZyxcbiAgICAgICAgbGVuZ3RoLCBhbmQgbnVtYmVyIG9mIHVudXNlZCBiaXRzKS5cblxuICAgICAgKDIpIFRoZSBrZXlJZGVudGlmaWVyIGlzIGNvbXBvc2VkIG9mIGEgZm91ciBiaXQgdHlwZSBmaWVsZCB3aXRoXG4gICAgICAgIHRoZSB2YWx1ZSAwMTAwIGZvbGxvd2VkIGJ5IHRoZSBsZWFzdCBzaWduaWZpY2FudCA2MCBiaXRzIG9mIHRoZVxuICAgICAgICBTSEEtMSBoYXNoIG9mIHRoZSB2YWx1ZSBvZiB0aGUgQklUIFNUUklORyBzdWJqZWN0UHVibGljS2V5XG4gICAgICAgIChleGNsdWRpbmcgdGhlIHRhZywgbGVuZ3RoLCBhbmQgbnVtYmVyIG9mIHVudXNlZCBiaXQgc3RyaW5nIGJpdHMpLlxuICAgICovXG5cbiAgICAvLyBza2lwcGluZyB0aGUgdGFnLCBsZW5ndGgsIGFuZCBudW1iZXIgb2YgdW51c2VkIGJpdHMgaXMgdGhlIHNhbWVcbiAgICAvLyBhcyBqdXN0IHVzaW5nIHRoZSBSU0FQdWJsaWNLZXkgKGZvciBSU0Ega2V5cywgd2hpY2ggYXJlIHRoZVxuICAgIC8vIG9ubHkgb25lcyBzdXBwb3J0ZWQpXG4gICAgcmV0dXJuIHBraS5nZXRQdWJsaWNLZXlGaW5nZXJwcmludChjZXJ0LnB1YmxpY0tleSwge3R5cGU6ICdSU0FQdWJsaWNLZXknfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSBzdWJqZWN0S2V5SWRlbnRpZmllciBleHRlbnNpb24gdmFsdWUgZm9yIHRoaXMgY2VydGlmaWNhdGVcbiAgICogYWdhaW5zdCBpdHMgcHVibGljIGtleS4gSWYgbm8gZXh0ZW5zaW9uIGlzIGZvdW5kLCBmYWxzZSB3aWxsIGJlXG4gICAqIHJldHVybmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdmVyaWZpZWQsIGZhbHNlIGlmIG5vdC5cbiAgICovXG4gIGNlcnQudmVyaWZ5U3ViamVjdEtleUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2lkID0gb2lkc1snc3ViamVjdEtleUlkZW50aWZpZXInXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZXh0ID0gY2VydC5leHRlbnNpb25zW2ldO1xuICAgICAgaWYoZXh0LmlkID09PSBvaWQpIHtcbiAgICAgICAgdmFyIHNraSA9IGNlcnQuZ2VuZXJhdGVTdWJqZWN0S2V5SWRlbnRpZmllcigpLmdldEJ5dGVzKCk7XG4gICAgICAgIHJldHVybiAoZm9yZ2UudXRpbC5oZXhUb0J5dGVzKGV4dC5zdWJqZWN0S2V5SWRlbnRpZmllcikgPT09IHNraSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gY2VydDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gWC41MDl2MyBSU0EgY2VydGlmaWNhdGUgZnJvbSBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGlzIHRvIGJlIHZlcmlmaWVkIHRoZW4gY29tcHV0ZSBoYXNoIHNob3VsZFxuICogYmUgc2V0IHRvIHRydWUuIFRoZXJlIGlzIGN1cnJlbnRseSBubyBpbXBsZW1lbnRhdGlvbiBmb3IgY29udmVydGluZ1xuICogYSBjZXJ0aWZpY2F0ZSBiYWNrIHRvIEFTTi4xIHNvIHRoZSBUQlNDZXJ0aWZpY2F0ZSBwYXJ0IG9mIHRoZSBBU04uMVxuICogb2JqZWN0IG5lZWRzIHRvIGJlIHNjYW5uZWQgYmVmb3JlIHRoZSBjZXJ0IG9iamVjdCBpcyBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSBvYmogdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYW4gWC41MDl2MyBSU0EgY2VydGlmaWNhdGUuXG4gKiBAcGFyYW0gY29tcHV0ZUhhc2ggdHJ1ZSB0byBjb21wdXRlIHRoZSBoYXNoIGZvciB2ZXJpZmljYXRpb24uXG4gKlxuICogQHJldHVybiB0aGUgY2VydGlmaWNhdGUuXG4gKi9cbnBraS5jZXJ0aWZpY2F0ZUZyb21Bc24xID0gZnVuY3Rpb24ob2JqLCBjb21wdXRlSGFzaCkge1xuICAvLyB2YWxpZGF0ZSBjZXJ0aWZpY2F0ZSBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCB4NTA5Q2VydGlmaWNhdGVWYWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIFguNTA5IGNlcnRpZmljYXRlLiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGFuIFg1MDl2MyBDZXJ0aWZpY2F0ZS4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgb2lkXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS4nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBjZXJ0aWZpY2F0ZVxuICB2YXIgY2VydCA9IHBraS5jcmVhdGVDZXJ0aWZpY2F0ZSgpO1xuICBjZXJ0LnZlcnNpb24gPSBjYXB0dXJlLmNlcnRWZXJzaW9uID9cbiAgICBjYXB0dXJlLmNlcnRWZXJzaW9uLmNoYXJDb2RlQXQoMCkgOiAwO1xuICB2YXIgc2VyaWFsID0gZm9yZ2UudXRpbC5jcmVhdGVCdWZmZXIoY2FwdHVyZS5jZXJ0U2VyaWFsTnVtYmVyKTtcbiAgY2VydC5zZXJpYWxOdW1iZXIgPSBzZXJpYWwudG9IZXgoKTtcbiAgY2VydC5zaWduYXR1cmVPaWQgPSBmb3JnZS5hc24xLmRlclRvT2lkKGNhcHR1cmUuY2VydFNpZ25hdHVyZU9pZCk7XG4gIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycyA9IF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyhcbiAgICBjZXJ0LnNpZ25hdHVyZU9pZCwgY2FwdHVyZS5jZXJ0U2lnbmF0dXJlUGFyYW1zLCB0cnVlKTtcbiAgY2VydC5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jZXJ0aW5mb1NpZ25hdHVyZU9pZCk7XG4gIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsXG4gICAgY2FwdHVyZS5jZXJ0aW5mb1NpZ25hdHVyZVBhcmFtcywgZmFsc2UpO1xuICBjZXJ0LnNpZ25hdHVyZSA9IGNhcHR1cmUuY2VydFNpZ25hdHVyZTtcblxuICB2YXIgdmFsaWRpdHkgPSBbXTtcbiAgaWYoY2FwdHVyZS5jZXJ0VmFsaWRpdHkxVVRDVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLnV0Y1RpbWVUb0RhdGUoY2FwdHVyZS5jZXJ0VmFsaWRpdHkxVVRDVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRpdHkucHVzaChhc24xLmdlbmVyYWxpemVkVGltZVRvRGF0ZShcbiAgICAgIGNhcHR1cmUuY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZSkpO1xuICB9XG4gIGlmKGNhcHR1cmUuY2VydFZhbGlkaXR5M1VUQ1RpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkaXR5LnB1c2goYXNuMS51dGNUaW1lVG9EYXRlKGNhcHR1cmUuY2VydFZhbGlkaXR5M1VUQ1RpbWUpKTtcbiAgfVxuICBpZihjYXB0dXJlLmNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkaXR5LnB1c2goYXNuMS5nZW5lcmFsaXplZFRpbWVUb0RhdGUoXG4gICAgICBjYXB0dXJlLmNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWUpKTtcbiAgfVxuICBpZih2YWxpZGl0eS5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBub3RCZWZvcmUvbm90QWZ0ZXIgdmFsaWRpdHkgdGltZXM7IG1vcmUgJyArXG4gICAgICAndGhhbiB0d28gdGltZXMgd2VyZSBwcm92aWRlZCBpbiB0aGUgY2VydGlmaWNhdGUuJyk7XG4gIH1cbiAgaWYodmFsaWRpdHkubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgbm90QmVmb3JlL25vdEFmdGVyIHZhbGlkaXR5IHRpbWVzOyB0aGV5ICcgK1xuICAgICAgJ3dlcmUgbm90IHByb3ZpZGVkIGFzIGVpdGhlciBVVENUaW1lIG9yIEdlbmVyYWxpemVkVGltZS4nKTtcbiAgfVxuICBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSA9IHZhbGlkaXR5WzBdO1xuICBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyID0gdmFsaWRpdHlbMV07XG5cbiAgLy8ga2VlcCBUQlNDZXJ0aWZpY2F0ZSB0byBwcmVzZXJ2ZSBzaWduYXR1cmUgd2hlbiBleHBvcnRpbmdcbiAgY2VydC50YnNDZXJ0aWZpY2F0ZSA9IGNhcHR1cmUudGJzQ2VydGlmaWNhdGU7XG5cbiAgaWYoY29tcHV0ZUhhc2gpIHtcbiAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgY2VydC5tZCA9IG51bGw7XG4gICAgaWYoY2VydC5zaWduYXR1cmVPaWQgaW4gb2lkcykge1xuICAgICAgdmFyIG9pZCA9IG9pZHNbY2VydC5zaWduYXR1cmVPaWRdO1xuICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZDVXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLm1kNS5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hhMjU2V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNlcnQubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjZXJ0Lm1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzaGE1MTJXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTUxMi5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUlNBU1NBLVBTUyc6XG4gICAgICAgICAgY2VydC5tZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoY2VydC5tZCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdDb3VsZCBub3QgY29tcHV0ZSBjZXJ0aWZpY2F0ZSBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY2VydC5zaWduYXR1cmVPaWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBwcm9kdWNlIERFUiBmb3JtYXR0ZWQgVEJTQ2VydGlmaWNhdGUgYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY2VydC50YnNDZXJ0aWZpY2F0ZSk7XG4gICAgY2VydC5tZC51cGRhdGUoYnl0ZXMuZ2V0Qnl0ZXMoKSk7XG4gIH1cblxuICAvLyBoYW5kbGUgaXNzdWVyLCBidWlsZCBpc3N1ZXIgbWVzc2FnZSBkaWdlc3RcbiAgdmFyIGltZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gIGNlcnQuaXNzdWVyLmdldEZpZWxkID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjZXJ0Lmlzc3Vlciwgc24pO1xuICB9O1xuICBjZXJ0Lmlzc3Vlci5hZGRGaWVsZCA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjZXJ0Lmlzc3Vlci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNlcnQuaXNzdWVyLmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5jZXJ0SXNzdWVyLCBpbWQpO1xuICBpZihjYXB0dXJlLmNlcnRJc3N1ZXJVbmlxdWVJZCkge1xuICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0SXNzdWVyVW5pcXVlSWQ7XG4gIH1cbiAgY2VydC5pc3N1ZXIuaGFzaCA9IGltZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjZXJ0LnN1YmplY3QuZ2V0RmllbGQgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNlcnQuc3ViamVjdCwgc24pO1xuICB9O1xuICBjZXJ0LnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgfTtcbiAgY2VydC5zdWJqZWN0LmF0dHJpYnV0ZXMgPSBwa2kuUkROQXR0cmlidXRlc0FzQXJyYXkoY2FwdHVyZS5jZXJ0U3ViamVjdCwgc21kKTtcbiAgaWYoY2FwdHVyZS5jZXJ0U3ViamVjdFVuaXF1ZUlkKSB7XG4gICAgY2VydC5zdWJqZWN0LnVuaXF1ZUlkID0gY2FwdHVyZS5jZXJ0U3ViamVjdFVuaXF1ZUlkO1xuICB9XG4gIGNlcnQuc3ViamVjdC5oYXNoID0gc21kLmRpZ2VzdCgpLnRvSGV4KCk7XG5cbiAgLy8gaGFuZGxlIGV4dGVuc2lvbnNcbiAgaWYoY2FwdHVyZS5jZXJ0RXh0ZW5zaW9ucykge1xuICAgIGNlcnQuZXh0ZW5zaW9ucyA9IHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNGcm9tQXNuMShjYXB0dXJlLmNlcnRFeHRlbnNpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBjZXJ0LmV4dGVuc2lvbnMgPSBbXTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjZXJ0LnB1YmxpY0tleSA9IHBraS5wdWJsaWNLZXlGcm9tQXNuMShjYXB0dXJlLnN1YmplY3RQdWJsaWNLZXlJbmZvKTtcblxuICByZXR1cm4gY2VydDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gQVNOLjEgZXh0ZW5zaW9ucyBvYmplY3QgKHdpdGggZXh0ZW5zaW9uIHNlcXVlbmNlcyBhcyBpdHNcbiAqIHZhbHVlcykgaW50byBhbiBhcnJheSBvZiBleHRlbnNpb24gb2JqZWN0cyB3aXRoIHR5cGVzIGFuZCB2YWx1ZXMuXG4gKlxuICogU3VwcG9ydGVkIGV4dGVuc2lvbnM6XG4gKlxuICogaWQtY2Uta2V5VXNhZ2UgT0JKRUNUIElERU5USUZJRVIgOjo9ICB7IGlkLWNlIDE1IH1cbiAqIEtleVVzYWdlIDo6PSBCSVQgU1RSSU5HIHtcbiAqICAgZGlnaXRhbFNpZ25hdHVyZSAgICAgICAgKDApLFxuICogICBub25SZXB1ZGlhdGlvbiAgICAgICAgICAoMSksXG4gKiAgIGtleUVuY2lwaGVybWVudCAgICAgICAgICgyKSxcbiAqICAgZGF0YUVuY2lwaGVybWVudCAgICAgICAgKDMpLFxuICogICBrZXlBZ3JlZW1lbnQgICAgICAgICAgICAoNCksXG4gKiAgIGtleUNlcnRTaWduICAgICAgICAgICAgICg1KSxcbiAqICAgY1JMU2lnbiAgICAgICAgICAgICAgICAgKDYpLFxuICogICBlbmNpcGhlck9ubHkgICAgICAgICAgICAoNyksXG4gKiAgIGRlY2lwaGVyT25seSAgICAgICAgICAgICg4KVxuICogfVxuICpcbiAqIGlkLWNlLWJhc2ljQ29uc3RyYWludHMgT0JKRUNUIElERU5USUZJRVIgOjo9ICB7IGlkLWNlIDE5IH1cbiAqIEJhc2ljQ29uc3RyYWludHMgOjo9IFNFUVVFTkNFIHtcbiAqICAgY0EgICAgICAgICAgICAgICAgICAgICAgQk9PTEVBTiBERUZBVUxUIEZBTFNFLFxuICogICBwYXRoTGVuQ29uc3RyYWludCAgICAgICBJTlRFR0VSICgwLi5NQVgpIE9QVElPTkFMXG4gKiB9XG4gKlxuICogc3ViamVjdEFsdE5hbWUgRVhURU5TSU9OIDo6PSB7XG4gKiAgIFNZTlRBWCBHZW5lcmFsTmFtZXNcbiAqICAgSURFTlRJRklFRCBCWSBpZC1jZS1zdWJqZWN0QWx0TmFtZVxuICogfVxuICpcbiAqIEdlbmVyYWxOYW1lcyA6Oj0gU0VRVUVOQ0UgU0laRSAoMS4uTUFYKSBPRiBHZW5lcmFsTmFtZVxuICpcbiAqIEdlbmVyYWxOYW1lIDo6PSBDSE9JQ0Uge1xuICogICBvdGhlck5hbWUgICAgICBbMF0gSU5TVEFOQ0UgT0YgT1RIRVItTkFNRSxcbiAqICAgcmZjODIyTmFtZSAgICAgWzFdIElBNVN0cmluZyxcbiAqICAgZE5TTmFtZSAgICAgICAgWzJdIElBNVN0cmluZyxcbiAqICAgeDQwMEFkZHJlc3MgICAgWzNdIE9SQWRkcmVzcyxcbiAqICAgZGlyZWN0b3J5TmFtZSAgWzRdIE5hbWUsXG4gKiAgIGVkaVBhcnR5TmFtZSAgIFs1XSBFRElQYXJ0eU5hbWUsXG4gKiAgIHVuaWZvcm1SZXNvdXJjZUlkZW50aWZpZXIgWzZdIElBNVN0cmluZyxcbiAqICAgSVBBZGRyZXNzICAgICAgWzddIE9DVEVUIFNUUklORyxcbiAqICAgcmVnaXN0ZXJlZElEICAgWzhdIE9CSkVDVCBJREVOVElGSUVSXG4gKiB9XG4gKlxuICogT1RIRVItTkFNRSA6Oj0gVFlQRS1JREVOVElGSUVSXG4gKlxuICogRURJUGFydHlOYW1lIDo6PSBTRVFVRU5DRSB7XG4gKiAgIG5hbWVBc3NpZ25lciBbMF0gRGlyZWN0b3J5U3RyaW5nIHt1Yi1uYW1lfSBPUFRJT05BTCxcbiAqICAgcGFydHlOYW1lICAgIFsxXSBEaXJlY3RvcnlTdHJpbmcge3ViLW5hbWV9XG4gKiB9XG4gKlxuICogQHBhcmFtIGV4dHMgdGhlIGV4dGVuc2lvbnMgQVNOLjEgd2l0aCBleHRlbnNpb24gc2VxdWVuY2VzIHRvIHBhcnNlLlxuICpcbiAqIEByZXR1cm4gdGhlIGFycmF5LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zRnJvbUFzbjEgPSBmdW5jdGlvbihleHRzKSB7XG4gIHZhciBydmFsID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IGV4dGVuc2lvbiBzZXF1ZW5jZVxuICAgIHZhciBleHRzZXEgPSBleHRzLnZhbHVlW2ldO1xuICAgIGZvcih2YXIgZWkgPSAwOyBlaSA8IGV4dHNlcS52YWx1ZS5sZW5ndGg7ICsrZWkpIHtcbiAgICAgIHJ2YWwucHVzaChwa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMShleHRzZXEudmFsdWVbZWldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gZnJvbSBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0IHRoZSBleHRlbnNpb24gaW4gQVNOLjEgZm9ybWF0LlxuICpcbiAqIEByZXR1cm4gdGhlIHBhcnNlZCBleHRlbnNpb24gYXMgYW4gb2JqZWN0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25Gcm9tQXNuMSA9IGZ1bmN0aW9uKGV4dCkge1xuICAvLyBhbiBleHRlbnNpb24gaGFzOlxuICAvLyBbMF0gZXh0bklEICAgICAgT0JKRUNUIElERU5USUZJRVJcbiAgLy8gWzFdIGNyaXRpY2FsICAgIEJPT0xFQU4gREVGQVVMVCBGQUxTRVxuICAvLyBbMl0gZXh0blZhbHVlICAgT0NURVQgU1RSSU5HXG4gIHZhciBlID0ge307XG4gIGUuaWQgPSBhc24xLmRlclRvT2lkKGV4dC52YWx1ZVswXS52YWx1ZSk7XG4gIGUuY3JpdGljYWwgPSBmYWxzZTtcbiAgaWYoZXh0LnZhbHVlWzFdLnR5cGUgPT09IGFzbjEuVHlwZS5CT09MRUFOKSB7XG4gICAgZS5jcml0aWNhbCA9IChleHQudmFsdWVbMV0udmFsdWUuY2hhckNvZGVBdCgwKSAhPT0gMHgwMCk7XG4gICAgZS52YWx1ZSA9IGV4dC52YWx1ZVsyXS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBlLnZhbHVlID0gZXh0LnZhbHVlWzFdLnZhbHVlO1xuICB9XG4gIC8vIGlmIHRoZSBvaWQgaXMga25vd24sIGdldCBpdHMgbmFtZVxuICBpZihlLmlkIGluIG9pZHMpIHtcbiAgICBlLm5hbWUgPSBvaWRzW2UuaWRdO1xuXG4gICAgLy8gaGFuZGxlIGtleSB1c2FnZVxuICAgIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgICAgLy8gZ2V0IHZhbHVlIGFzIEJJVCBTVFJJTkdcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIHZhciBiMiA9IDB4MDA7XG4gICAgICB2YXIgYjMgPSAweDAwO1xuICAgICAgaWYoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBza2lwIGZpcnN0IGJ5dGUsIGp1c3QgaW5kaWNhdGVzIHVudXNlZCBiaXRzIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgYmUgcGFkZGVkIHdpdGggMHMgYW55d2F5XG4gICAgICAgIC8vIGdldCBieXRlcyB3aXRoIGZsYWcgYml0c1xuICAgICAgICBiMiA9IGV2LnZhbHVlLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgIGIzID0gZXYudmFsdWUubGVuZ3RoID4gMiA/IGV2LnZhbHVlLmNoYXJDb2RlQXQoMikgOiAwO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGZsYWdzXG4gICAgICBlLmRpZ2l0YWxTaWduYXR1cmUgPSAoYjIgJiAweDgwKSA9PT0gMHg4MDtcbiAgICAgIGUubm9uUmVwdWRpYXRpb24gPSAoYjIgJiAweDQwKSA9PT0gMHg0MDtcbiAgICAgIGUua2V5RW5jaXBoZXJtZW50ID0gKGIyICYgMHgyMCkgPT09IDB4MjA7XG4gICAgICBlLmRhdGFFbmNpcGhlcm1lbnQgPSAoYjIgJiAweDEwKSA9PT0gMHgxMDtcbiAgICAgIGUua2V5QWdyZWVtZW50ID0gKGIyICYgMHgwOCkgPT09IDB4MDg7XG4gICAgICBlLmtleUNlcnRTaWduID0gKGIyICYgMHgwNCkgPT09IDB4MDQ7XG4gICAgICBlLmNSTFNpZ24gPSAoYjIgJiAweDAyKSA9PT0gMHgwMjtcbiAgICAgIGUuZW5jaXBoZXJPbmx5ID0gKGIyICYgMHgwMSkgPT09IDB4MDE7XG4gICAgICBlLmRlY2lwaGVyT25seSA9IChiMyAmIDB4ODApID09PSAweDgwO1xuICAgIH0gZWxzZSBpZihlLm5hbWUgPT09ICdiYXNpY0NvbnN0cmFpbnRzJykge1xuICAgICAgLy8gaGFuZGxlIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICAvLyBnZXQgdmFsdWUgYXMgU0VRVUVOQ0VcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIC8vIGdldCBjQSBCT09MRUFOIGZsYWcgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgICAgaWYoZXYudmFsdWUubGVuZ3RoID4gMCAmJiBldi52YWx1ZVswXS50eXBlID09PSBhc24xLlR5cGUuQk9PTEVBTikge1xuICAgICAgICBlLmNBID0gKGV2LnZhbHVlWzBdLnZhbHVlLmNoYXJDb2RlQXQoMCkgIT09IDB4MDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5jQSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZ2V0IHBhdGggbGVuZ3RoIGNvbnN0cmFpbnRcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAwICYmIGV2LnZhbHVlWzBdLnR5cGUgPT09IGFzbjEuVHlwZS5JTlRFR0VSKSB7XG4gICAgICAgIHZhbHVlID0gZXYudmFsdWVbMF0udmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZXYudmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWx1ZSA9IGV2LnZhbHVlWzFdLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZS5wYXRoTGVuQ29uc3RyYWludCA9IGFzbjEuZGVyVG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgICAvLyBoYW5kbGUgZXh0S2V5VXNhZ2VcbiAgICAgIC8vIHZhbHVlIGlzIGEgU0VRVUVOQ0Ugb2YgT0lEc1xuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgZm9yKHZhciB2aSA9IDA7IHZpIDwgZXYudmFsdWUubGVuZ3RoOyArK3ZpKSB7XG4gICAgICAgIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGV2LnZhbHVlW3ZpXS52YWx1ZSk7XG4gICAgICAgIGlmKG9pZCBpbiBvaWRzKSB7XG4gICAgICAgICAgZVtvaWRzW29pZF1dID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlW29pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgICAvLyBoYW5kbGUgbnNDZXJ0VHlwZVxuICAgICAgLy8gZ2V0IHZhbHVlIGFzIEJJVCBTVFJJTkdcbiAgICAgIHZhciBldiA9IGFzbjEuZnJvbURlcihlLnZhbHVlKTtcbiAgICAgIHZhciBiMiA9IDB4MDA7XG4gICAgICBpZihldi52YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIHNraXAgZmlyc3QgYnl0ZSwganVzdCBpbmRpY2F0ZXMgdW51c2VkIGJpdHMgd2hpY2hcbiAgICAgICAgLy8gd2lsbCBiZSBwYWRkZWQgd2l0aCAwcyBhbnl3YXlcbiAgICAgICAgLy8gZ2V0IGJ5dGVzIHdpdGggZmxhZyBiaXRzXG4gICAgICAgIGIyID0gZXYudmFsdWUuY2hhckNvZGVBdCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBmbGFnc1xuICAgICAgZS5jbGllbnQgPSAoYjIgJiAweDgwKSA9PT0gMHg4MDtcbiAgICAgIGUuc2VydmVyID0gKGIyICYgMHg0MCkgPT09IDB4NDA7XG4gICAgICBlLmVtYWlsID0gKGIyICYgMHgyMCkgPT09IDB4MjA7XG4gICAgICBlLm9ianNpZ24gPSAoYjIgJiAweDEwKSA9PT0gMHgxMDtcbiAgICAgIGUucmVzZXJ2ZWQgPSAoYjIgJiAweDA4KSA9PT0gMHgwODtcbiAgICAgIGUuc3NsQ0EgPSAoYjIgJiAweDA0KSA9PT0gMHgwNDtcbiAgICAgIGUuZW1haWxDQSA9IChiMiAmIDB4MDIpID09PSAweDAyO1xuICAgICAgZS5vYmpDQSA9IChiMiAmIDB4MDEpID09PSAweDAxO1xuICAgIH0gZWxzZSBpZihcbiAgICAgIGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fFxuICAgICAgZS5uYW1lID09PSAnaXNzdWVyQWx0TmFtZScpIHtcbiAgICAgIC8vIGhhbmRsZSBzdWJqZWN0QWx0TmFtZS9pc3N1ZXJBbHROYW1lXG4gICAgICBlLmFsdE5hbWVzID0gW107XG5cbiAgICAgIC8vIGV2IGlzIGEgU1lOVEFYIFNFUVVFTkNFXG4gICAgICB2YXIgZ247XG4gICAgICB2YXIgZXYgPSBhc24xLmZyb21EZXIoZS52YWx1ZSk7XG4gICAgICBmb3IodmFyIG4gPSAwOyBuIDwgZXYudmFsdWUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgLy8gZ2V0IEdlbmVyYWxOYW1lXG4gICAgICAgIGduID0gZXYudmFsdWVbbl07XG5cbiAgICAgICAgdmFyIGFsdE5hbWUgPSB7XG4gICAgICAgICAgdHlwZTogZ24udHlwZSxcbiAgICAgICAgICB2YWx1ZTogZ24udmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgZS5hbHROYW1lcy5wdXNoKGFsdE5hbWUpO1xuXG4gICAgICAgIC8vIE5vdGU6IFN1cHBvcnQgZm9yIHR5cGVzIDEsMiw2LDcsOFxuICAgICAgICBzd2l0Y2goZ24udHlwZSkge1xuICAgICAgICAgIC8vIHJmYzgyMk5hbWVcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gZE5TTmFtZVxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyB1bmlmb3JtUmVzb3VyY2VJZGVudGlmaWVyIChVUkkpXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gSVBBZGRyZXNzXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgLy8gY29udmVydCB0byBJUHY0L0lQdjYgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICBhbHROYW1lLmlwID0gZm9yZ2UudXRpbC5ieXRlc1RvSVAoZ24udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gcmVnaXN0ZXJlZElEXG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgYWx0TmFtZS5vaWQgPSBhc24xLmRlclRvT2lkKGduLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB1bnN1cHBvcnRlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJykge1xuICAgICAgLy8gdmFsdWUgaXMgYW4gT0NURVRTVFJJTkcgdy90aGUgaGFzaCBvZiB0aGUga2V5LXR5cGUgc3BlY2lmaWNcbiAgICAgIC8vIHB1YmxpYyBrZXkgc3RydWN0dXJlIChlZzogUlNBUHVibGljS2V5KVxuICAgICAgdmFyIGV2ID0gYXNuMS5mcm9tRGVyKGUudmFsdWUpO1xuICAgICAgZS5zdWJqZWN0S2V5SWRlbnRpZmllciA9IGZvcmdlLnV0aWwuYnl0ZXNUb0hleChldi52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpIGZyb20gYW4gQVNOLjEgb2JqZWN0LlxuICpcbiAqIE5vdGU6IElmIHRoZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgaXMgdG8gYmUgdmVyaWZpZWQgdGhlbiBjb21wdXRlIGhhc2hcbiAqIHNob3VsZCBiZSBzZXQgdG8gdHJ1ZS4gVGhlcmUgaXMgY3VycmVudGx5IG5vIGltcGxlbWVudGF0aW9uIGZvciBjb252ZXJ0aW5nXG4gKiBhIGNlcnRpZmljYXRlIGJhY2sgdG8gQVNOLjEgc28gdGhlIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBwYXJ0IG9mIHRoZVxuICogQVNOLjEgb2JqZWN0IG5lZWRzIHRvIGJlIHNjYW5uZWQgYmVmb3JlIHRoZSBjc3Igb2JqZWN0IGlzIGNyZWF0ZWQuXG4gKlxuICogQHBhcmFtIG9iaiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhIFBLQ1MjMTAgY2VydGlmaWNhdGlvbiByZXF1ZXN0IChDU1IpLlxuICogQHBhcmFtIGNvbXB1dGVIYXNoIHRydWUgdG8gY29tcHV0ZSB0aGUgaGFzaCBmb3IgdmVyaWZpY2F0aW9uLlxuICpcbiAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdCAoQ1NSKS5cbiAqL1xucGtpLmNlcnRpZmljYXRpb25SZXF1ZXN0RnJvbUFzbjEgPSBmdW5jdGlvbihvYmosIGNvbXB1dGVIYXNoKSB7XG4gIC8vIHZhbGlkYXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBhbmQgY2FwdHVyZSBkYXRhXG4gIHZhciBjYXB0dXJlID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYoIWFzbjEudmFsaWRhdGUob2JqLCBjZXJ0aWZpY2F0aW9uUmVxdWVzdFZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgUEtDUyMxMCBjZXJ0aWZpY2F0ZSByZXF1ZXN0LiAnICtcbiAgICAgICdBU04uMSBvYmplY3QgaXMgbm90IGEgUEtDUyMxMCBDZXJ0aWZpY2F0aW9uUmVxdWVzdC4nKTtcbiAgICBlcnJvci5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBnZXQgb2lkXG4gIHZhciBvaWQgPSBhc24xLmRlclRvT2lkKGNhcHR1cmUucHVibGljS2V5T2lkKTtcbiAgaWYob2lkICE9PSBwa2kub2lkcy5yc2FFbmNyeXB0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVhZCBwdWJsaWMga2V5LiBPSUQgaXMgbm90IFJTQS4nKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3RcbiAgdmFyIGNzciA9IHBraS5jcmVhdGVDZXJ0aWZpY2F0aW9uUmVxdWVzdCgpO1xuICBjc3IudmVyc2lvbiA9IGNhcHR1cmUuY3NyVmVyc2lvbiA/IGNhcHR1cmUuY3NyVmVyc2lvbi5jaGFyQ29kZUF0KDApIDogMDtcbiAgY3NyLnNpZ25hdHVyZU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jc3JTaWduYXR1cmVPaWQpO1xuICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycyA9IF9yZWFkU2lnbmF0dXJlUGFyYW1ldGVycyhcbiAgICBjc3Iuc2lnbmF0dXJlT2lkLCBjYXB0dXJlLmNzclNpZ25hdHVyZVBhcmFtcywgdHJ1ZSk7XG4gIGNzci5zaWdpbmZvLmFsZ29yaXRobU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5jc3JTaWduYXR1cmVPaWQpO1xuICBjc3Iuc2lnaW5mby5wYXJhbWV0ZXJzID0gX3JlYWRTaWduYXR1cmVQYXJhbWV0ZXJzKFxuICAgIGNzci5zaWdpbmZvLmFsZ29yaXRobU9pZCwgY2FwdHVyZS5jc3JTaWduYXR1cmVQYXJhbXMsIGZhbHNlKTtcbiAgY3NyLnNpZ25hdHVyZSA9IGNhcHR1cmUuY3NyU2lnbmF0dXJlO1xuXG4gIC8vIGtlZXAgQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHRvIHByZXNlcnZlIHNpZ25hdHVyZSB3aGVuIGV4cG9ydGluZ1xuICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gY2FwdHVyZS5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm87XG5cbiAgaWYoY29tcHV0ZUhhc2gpIHtcbiAgICAvLyBjaGVjayBzaWduYXR1cmUgT0lEIGZvciBzdXBwb3J0ZWQgc2lnbmF0dXJlIHR5cGVzXG4gICAgY3NyLm1kID0gbnVsbDtcbiAgICBpZihjc3Iuc2lnbmF0dXJlT2lkIGluIG9pZHMpIHtcbiAgICAgIHZhciBvaWQgPSBvaWRzW2Nzci5zaWduYXR1cmVPaWRdO1xuICAgICAgc3dpdGNoKG9pZCkge1xuICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgIGNzci5tZCA9IGZvcmdlLm1kLnNoYTEuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21kNVdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTI1NldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEyNTYuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGEzODQuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NoYTUxMldpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICBjc3IubWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1JTQVNTQS1QU1MnOlxuICAgICAgICAgIGNzci5tZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoY3NyLm1kID09PSBudWxsKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBzaWduYXR1cmUgT0lELicpO1xuICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ25hdHVyZU9pZDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG4gICAgY3NyLm1kLnVwZGF0ZShieXRlcy5nZXRCeXRlcygpKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzdWJqZWN0LCBidWlsZCBzdWJqZWN0IG1lc3NhZ2UgZGlnZXN0XG4gIHZhciBzbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gcGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvU3ViamVjdCwgc21kKTtcbiAgY3NyLnN1YmplY3QuaGFzaCA9IHNtZC5kaWdlc3QoKS50b0hleCgpO1xuXG4gIC8vIGNvbnZlcnQgUlNBIHB1YmxpYyBrZXkgZnJvbSBBU04uMVxuICBjc3IucHVibGljS2V5ID0gcGtpLnB1YmxpY0tleUZyb21Bc24xKGNhcHR1cmUuc3ViamVjdFB1YmxpY0tleUluZm8pO1xuXG4gIC8vIGNvbnZlcnQgYXR0cmlidXRlcyBmcm9tIEFTTi4xXG4gIGNzci5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihzbikge1xuICAgIHJldHVybiBfZ2V0QXR0cmlidXRlKGNzciwgc24pO1xuICB9O1xuICBjc3IuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xuICAgIF9maWxsTWlzc2luZ0ZpZWxkcyhbYXR0cl0pO1xuICAgIGNzci5hdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gIH07XG4gIGNzci5hdHRyaWJ1dGVzID0gcGtpLkNSSUF0dHJpYnV0ZXNBc0FycmF5KFxuICAgIGNhcHR1cmUuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvQXR0cmlidXRlcyB8fCBbXSk7XG5cbiAgcmV0dXJuIGNzcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QgKGEgQ1NSIG9yIGNlcnRpZmljYXRlIHNpZ25pbmdcbiAqIHJlcXVlc3QpLiBPbmNlIGNyZWF0ZWQsIGl0cyBwdWJsaWMga2V5IGFuZCBhdHRyaWJ1dGVzIGNhbiBiZSBzZXQgYW5kIHRoZW5cbiAqIGl0IGNhbiBiZSBzaWduZWQuXG4gKlxuICogQHJldHVybiB0aGUgZW1wdHkgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICovXG5wa2kuY3JlYXRlQ2VydGlmaWNhdGlvblJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNzciA9IHt9O1xuICBjc3IudmVyc2lvbiA9IDB4MDA7XG4gIGNzci5zaWduYXR1cmVPaWQgPSBudWxsO1xuICBjc3Iuc2lnbmF0dXJlID0gbnVsbDtcbiAgY3NyLnNpZ2luZm8gPSB7fTtcbiAgY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gbnVsbDtcblxuICBjc3Iuc3ViamVjdCA9IHt9O1xuICBjc3Iuc3ViamVjdC5nZXRGaWVsZCA9IGZ1bmN0aW9uKHNuKSB7XG4gICAgcmV0dXJuIF9nZXRBdHRyaWJ1dGUoY3NyLnN1YmplY3QsIHNuKTtcbiAgfTtcbiAgY3NyLnN1YmplY3QuYWRkRmllbGQgPSBmdW5jdGlvbihhdHRyKSB7XG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKFthdHRyXSk7XG4gICAgY3NyLnN1YmplY3QuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gW107XG4gIGNzci5zdWJqZWN0Lmhhc2ggPSBudWxsO1xuXG4gIGNzci5wdWJsaWNLZXkgPSBudWxsO1xuICBjc3IuYXR0cmlidXRlcyA9IFtdO1xuICBjc3IuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oc24pIHtcbiAgICByZXR1cm4gX2dldEF0dHJpYnV0ZShjc3IsIHNuKTtcbiAgfTtcbiAgY3NyLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICBfZmlsbE1pc3NpbmdGaWVsZHMoW2F0dHJdKTtcbiAgICBjc3IuYXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICB9O1xuICBjc3IubWQgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgdGhlIGFycmF5IG9mIHN1YmplY3QgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0U3ViamVjdCA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3Iuc3ViamVjdC5hdHRyaWJ1dGVzID0gYXR0cnM7XG4gICAgY3NyLnN1YmplY3QuaGFzaCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyB0aGUgYXJyYXkgb2YgYXR0cmlidXRlcyB0byB1c2UuXG4gICAqL1xuICBjc3Iuc2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgLy8gc2V0IG5ldyBhdHRyaWJ1dGVzXG4gICAgX2ZpbGxNaXNzaW5nRmllbGRzKGF0dHJzKTtcbiAgICBjc3IuYXR0cmlidXRlcyA9IGF0dHJzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaWducyB0aGlzIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZyB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdGhlIHByaXZhdGUga2V5IHRvIHNpZ24gd2l0aC5cbiAgICogQHBhcmFtIG1kIHRoZSBtZXNzYWdlIGRpZ2VzdCBvYmplY3QgdG8gdXNlIChkZWZhdWx0cyB0byBmb3JnZS5tZC5zaGExKS5cbiAgICovXG4gIGNzci5zaWduID0gZnVuY3Rpb24oa2V5LCBtZCkge1xuICAgIC8vIFRPRE86IGdldCBzaWduYXR1cmUgT0lEIGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjc3IubWQgPSBtZCB8fCBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgIHZhciBhbGdvcml0aG1PaWQgPSBvaWRzW2Nzci5tZC5hbGdvcml0aG0gKyAnV2l0aFJTQUVuY3J5cHRpb24nXTtcbiAgICBpZighYWxnb3JpdGhtT2lkKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb21wdXRlIGNlcnRpZmljYXRpb24gcmVxdWVzdCBkaWdlc3QuICcgK1xuICAgICAgICAnVW5rbm93biBtZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gT0lELicpO1xuICAgICAgZXJyb3IuYWxnb3JpdGhtID0gY3NyLm1kLmFsZ29yaXRobTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjc3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ2luZm8uYWxnb3JpdGhtT2lkID0gYWxnb3JpdGhtT2lkO1xuXG4gICAgLy8gZ2V0IENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbywgY29udmVydCB0byBERVJcbiAgICBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvID0gcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgIHZhciBieXRlcyA9IGFzbjEudG9EZXIoY3NyLmNlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyk7XG5cbiAgICAvLyBkaWdlc3QgYW5kIHNpZ25cbiAgICBjc3IubWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIGNzci5zaWduYXR1cmUgPSBrZXkuc2lnbihjc3IubWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB2ZXJpZnkgdGhlIHNpZ25hdHVyZSBvbiB0aGUgcGFzc2VkIGNlcnRpZmljYXRpb24gcmVxdWVzdCB1c2luZ1xuICAgKiBpdHMgcHVibGljIGtleS5cbiAgICpcbiAgICogQSBDU1IgdGhhdCBoYXMgYmVlbiBleHBvcnRlZCB0byBhIGZpbGUgaW4gUEVNIGZvcm1hdCBjYW4gYmUgdmVyaWZpZWQgdXNpbmdcbiAgICogT3BlblNTTCB1c2luZyB0aGlzIGNvbW1hbmQ6XG4gICAqXG4gICAqIG9wZW5zc2wgcmVxIC1pbiA8dGhlLWNzci1wZW0tZmlsZT4gLXZlcmlmeSAtbm9vdXQgLXRleHRcbiAgICpcbiAgICogQHJldHVybiB0cnVlIGlmIHZlcmlmaWVkLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBjc3IudmVyaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJ2YWwgPSBmYWxzZTtcblxuICAgIHZhciBtZCA9IGNzci5tZDtcbiAgICBpZihtZCA9PT0gbnVsbCkge1xuICAgICAgLy8gY2hlY2sgc2lnbmF0dXJlIE9JRCBmb3Igc3VwcG9ydGVkIHNpZ25hdHVyZSB0eXBlc1xuICAgICAgaWYoY3NyLnNpZ25hdHVyZU9pZCBpbiBvaWRzKSB7XG4gICAgICAgIC8vIFRPRE86IGNyZWF0ZSBEUlkgYE9JRCB0byBtZGAgZnVuY3Rpb25cbiAgICAgICAgdmFyIG9pZCA9IG9pZHNbY3NyLnNpZ25hdHVyZU9pZF07XG4gICAgICAgIHN3aXRjaChvaWQpIHtcbiAgICAgICAgICBjYXNlICdzaGExV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWQ1V2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5tZDUuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzaGEyNTZXaXRoUlNBRW5jcnlwdGlvbic6XG4gICAgICAgICAgICBtZCA9IGZvcmdlLm1kLnNoYTI1Ni5jcmVhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NoYTM4NFdpdGhSU0FFbmNyeXB0aW9uJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMzg0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2hhNTEyV2l0aFJTQUVuY3J5cHRpb24nOlxuICAgICAgICAgICAgbWQgPSBmb3JnZS5tZC5zaGE1MTIuY3JlYXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdSU0FTU0EtUFNTJzpcbiAgICAgICAgICAgIG1kID0gZm9yZ2UubWQuc2hhMjU2LmNyZWF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKG1kID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGNvbXB1dGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0IGRpZ2VzdC4gJyArXG4gICAgICAgICAgJ1Vua25vd24gc2lnbmF0dXJlIE9JRC4nKTtcbiAgICAgICAgZXJyb3Iuc2lnbmF0dXJlT2lkID0gY3NyLnNpZ25hdHVyZU9pZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2R1Y2UgREVSIGZvcm1hdHRlZCBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gYW5kIGRpZ2VzdCBpdFxuICAgICAgdmFyIGNyaSA9IGNzci5jZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gfHxcbiAgICAgICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuICAgICAgdmFyIGJ5dGVzID0gYXNuMS50b0RlcihjcmkpO1xuICAgICAgbWQudXBkYXRlKGJ5dGVzLmdldEJ5dGVzKCkpO1xuICAgIH1cblxuICAgIGlmKG1kICE9PSBudWxsKSB7XG4gICAgICB2YXIgc2NoZW1lO1xuXG4gICAgICBzd2l0Y2goY3NyLnNpZ25hdHVyZU9pZCkge1xuICAgICAgICBjYXNlIG9pZHMuc2hhMVdpdGhSU0FFbmNyeXB0aW9uOlxuICAgICAgICAgIC8qIHVzZSBQS0NTIzEgdjEuNSBwYWRkaW5nIHNjaGVtZSAqL1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIG9pZHNbJ1JTQVNTQS1QU1MnXTpcbiAgICAgICAgICB2YXIgaGFzaCwgbWdmO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBtZ2YgKi9cbiAgICAgICAgICBoYXNoID0gb2lkc1tjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5tZ2YuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE1HRiBoYXNoIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBvaWRzW2Nzci5zaWduYXR1cmVQYXJhbWV0ZXJzLm1nZi5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKG1nZiA9PT0gdW5kZWZpbmVkIHx8IGZvcmdlLm1nZlttZ2ZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgTUdGIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgZXJyb3Iub2lkID0gY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMubWdmLmFsZ29yaXRobU9pZDtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSBtZ2Y7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZ2YgPSBmb3JnZS5tZ2ZbbWdmXS5jcmVhdGUoZm9yZ2UubWRbaGFzaF0uY3JlYXRlKCkpO1xuXG4gICAgICAgICAgLyogaW5pdGlhbGl6ZSBoYXNoIGZ1bmN0aW9uICovXG4gICAgICAgICAgaGFzaCA9IG9pZHNbY3NyLnNpZ25hdHVyZVBhcmFtZXRlcnMuaGFzaC5hbGdvcml0aG1PaWRdO1xuICAgICAgICAgIGlmKGhhc2ggPT09IHVuZGVmaW5lZCB8fCBmb3JnZS5tZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJTQVNTQS1QU1MgaGFzaCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIGVycm9yLm9pZCA9IGNzci5zaWduYXR1cmVQYXJhbWV0ZXJzLmhhc2guYWxnb3JpdGhtT2lkO1xuICAgICAgICAgICAgZXJyb3IubmFtZSA9IGhhc2g7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlbWUgPSBmb3JnZS5wc3MuY3JlYXRlKGZvcmdlLm1kW2hhc2hdLmNyZWF0ZSgpLCBtZ2YsXG4gICAgICAgICAgICBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycy5zYWx0TGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gdmVyaWZ5IHNpZ25hdHVyZSBvbiBjc3IgdXNpbmcgaXRzIHB1YmxpYyBrZXlcbiAgICAgIHJ2YWwgPSBjc3IucHVibGljS2V5LnZlcmlmeShcbiAgICAgICAgbWQuZGlnZXN0KCkuZ2V0Qnl0ZXMoKSwgY3NyLnNpZ25hdHVyZSwgc2NoZW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfTtcblxuICByZXR1cm4gY3NyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBYLjUwOSBzdWJqZWN0IG9yIGlzc3VlciB0byBhbiBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqXG4gKiBAcGFyYW0gb2JqIHRoZSBzdWJqZWN0IG9yIGlzc3VlciAoZGlzdGluZ3Vpc2hlZCBuYW1lKS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBSRE5TZXF1ZW5jZS5cbiAqL1xuZnVuY3Rpb24gX2RuVG9Bc24xKG9iaikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgUkROU2VxdWVuY2VcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGF0dHJpYnV0ZXNcbiAgdmFyIGF0dHIsIHNldDtcbiAgdmFyIGF0dHJzID0gb2JqLmF0dHJpYnV0ZXM7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7ICsraSkge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuUFJJTlRBQkxFU1RSSU5HO1xuICAgIGlmKCd2YWx1ZVRhZ0NsYXNzJyBpbiBhdHRyKSB7XG4gICAgICB2YWx1ZVRhZ0NsYXNzID0gYXR0ci52YWx1ZVRhZ0NsYXNzO1xuXG4gICAgICBpZih2YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuVVRGOCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuZW5jb2RlVXRmOCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBGSVhNRTogaGFuZGxlIG1vcmUgZW5jb2RpbmdzXG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHNldCA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVR5cGVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgICAgLy8gQXR0cmlidXRlVmFsdWVcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIHZhbHVlVGFnQ2xhc3MsIGZhbHNlLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNldCk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBHZXRzIGFsbCBwcmludGFibGUgYXR0cmlidXRlcyAodHlwaWNhbGx5IG9mIGFuIGlzc3VlciBvciBzdWJqZWN0KSBpbiBhXG4gKiBzaW1wbGlmaWVkIEpTT04gZm9ybWF0IGZvciBkaXNwbGF5LlxuICpcbiAqIEBwYXJhbSBhdHRycyB0aGUgYXR0cmlidXRlcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBKU09OIGZvciBkaXNwbGF5LlxuICovXG5mdW5jdGlvbiBfZ2V0QXR0cmlidXRlc0FzSnNvbihhdHRycykge1xuICB2YXIgcnZhbCA9IHt9O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmKGF0dHIuc2hvcnROYW1lICYmIChcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjggfHxcbiAgICAgIGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlBSSU5UQUJMRVNUUklORyB8fFxuICAgICAgYXR0ci52YWx1ZVRhZ0NsYXNzID09PSBhc24xLlR5cGUuSUE1U1RSSU5HKSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmKGF0dHIudmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JnZS51dGlsLmVuY29kZVV0ZjgoYXR0ci52YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZighKGF0dHIuc2hvcnROYW1lIGluIHJ2YWwpKSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYoZm9yZ2UudXRpbC5pc0FycmF5KHJ2YWxbYXR0ci5zaG9ydE5hbWVdKSkge1xuICAgICAgICBydmFsW2F0dHIuc2hvcnROYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWxbYXR0ci5zaG9ydE5hbWVdID0gW3J2YWxbYXR0ci5zaG9ydE5hbWVdLCB2YWx1ZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGF0dHJzIHRoZSBhdHRyaWJ1dGVzIHRvIGZpbGwgbWlzc2luZyBmaWVsZHMgaW4uXG4gKi9cbmZ1bmN0aW9uIF9maWxsTWlzc2luZ0ZpZWxkcyhhdHRycykge1xuICB2YXIgYXR0cjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgYXR0ciA9IGF0dHJzW2ldO1xuXG4gICAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIubmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmKGF0dHIudHlwZSAmJiBhdHRyLnR5cGUgaW4gcGtpLm9pZHMpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gcGtpLm9pZHNbYXR0ci50eXBlXTtcbiAgICAgIH0gZWxzZSBpZihhdHRyLnNob3J0TmFtZSAmJiBhdHRyLnNob3J0TmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLm5hbWUgPSBwa2kub2lkc1tfc2hvcnROYW1lc1thdHRyLnNob3J0TmFtZV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3NpbmcgdHlwZSAoT0lEKVxuICAgIGlmKHR5cGVvZiBhdHRyLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZihhdHRyLm5hbWUgJiYgYXR0ci5uYW1lIGluIHBraS5vaWRzKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IHBraS5vaWRzW2F0dHIubmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB0eXBlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGVycm9yLmF0dHJpYnV0ZSA9IGF0dHI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcHVsYXRlIG1pc3Npbmcgc2hvcnRuYW1lXG4gICAgaWYodHlwZW9mIGF0dHIuc2hvcnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYoYXR0ci5uYW1lICYmIGF0dHIubmFtZSBpbiBfc2hvcnROYW1lcykge1xuICAgICAgICBhdHRyLnNob3J0TmFtZSA9IF9zaG9ydE5hbWVzW2F0dHIubmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHRlbnNpb25zIHRvIHZhbHVlXG4gICAgaWYoYXR0ci50eXBlID09PSBvaWRzLmV4dGVuc2lvblJlcXVlc3QpIHtcbiAgICAgIGF0dHIudmFsdWVDb25zdHJ1Y3RlZCA9IHRydWU7XG4gICAgICBhdHRyLnZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuU0VRVUVOQ0U7XG4gICAgICBpZighYXR0ci52YWx1ZSAmJiBhdHRyLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgYXR0ci52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IodmFyIGVpID0gMDsgZWkgPCBhdHRyLmV4dGVuc2lvbnMubGVuZ3RoOyArK2VpKSB7XG4gICAgICAgICAgYXR0ci52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvblRvQXNuMShcbiAgICAgICAgICAgIF9maWxsTWlzc2luZ0V4dGVuc2lvbkZpZWxkcyhhdHRyLmV4dGVuc2lvbnNbZWldKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIGF0dHIudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuYXR0cmlidXRlID0gYXR0cjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZpbGxzIGluIG1pc3NpbmcgZmllbGRzIGluIGNlcnRpZmljYXRlIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIGUgdGhlIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlLlxuICogICAgICAgICAgW2NlcnRdIHRoZSBjZXJ0aWZpY2F0ZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZm9yLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gX2ZpbGxNaXNzaW5nRXh0ZW5zaW9uRmllbGRzKGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gcG9wdWxhdGUgbWlzc2luZyBuYW1lXG4gIGlmKHR5cGVvZiBlLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYoZS5pZCAmJiBlLmlkIGluIHBraS5vaWRzKSB7XG4gICAgICBlLm5hbWUgPSBwa2kub2lkc1tlLmlkXTtcbiAgICB9XG4gIH1cblxuICAvLyBwb3B1bGF0ZSBtaXNzaW5nIGlkXG4gIGlmKHR5cGVvZiBlLmlkID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmKGUubmFtZSAmJiBlLm5hbWUgaW4gcGtpLm9pZHMpIHtcbiAgICAgIGUuaWQgPSBwa2kub2lkc1tlLm5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBJRCBub3Qgc3BlY2lmaWVkLicpO1xuICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGlmKHR5cGVvZiBlLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLy8gaGFuZGxlIG1pc3NpbmcgdmFsdWU6XG5cbiAgLy8gdmFsdWUgaXMgYSBCSVQgU1RSSU5HXG4gIGlmKGUubmFtZSA9PT0gJ2tleVVzYWdlJykge1xuICAgIC8vIGJ1aWxkIGZsYWdzXG4gICAgdmFyIHVudXNlZCA9IDA7XG4gICAgdmFyIGIyID0gMHgwMDtcbiAgICB2YXIgYjMgPSAweDAwO1xuICAgIGlmKGUuZGlnaXRhbFNpZ25hdHVyZSkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUubm9uUmVwdWRpYXRpb24pIHtcbiAgICAgIGIyIHw9IDB4NDA7XG4gICAgICB1bnVzZWQgPSA2O1xuICAgIH1cbiAgICBpZihlLmtleUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUuZGF0YUVuY2lwaGVybWVudCkge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUua2V5QWdyZWVtZW50KSB7XG4gICAgICBiMiB8PSAweDA4O1xuICAgICAgdW51c2VkID0gMztcbiAgICB9XG4gICAgaWYoZS5rZXlDZXJ0U2lnbikge1xuICAgICAgYjIgfD0gMHgwNDtcbiAgICAgIHVudXNlZCA9IDI7XG4gICAgfVxuICAgIGlmKGUuY1JMU2lnbikge1xuICAgICAgYjIgfD0gMHgwMjtcbiAgICAgIHVudXNlZCA9IDE7XG4gICAgfVxuICAgIGlmKGUuZW5jaXBoZXJPbmx5KSB7XG4gICAgICBiMiB8PSAweDAxO1xuICAgICAgdW51c2VkID0gMDtcbiAgICB9XG4gICAgaWYoZS5kZWNpcGhlck9ubHkpIHtcbiAgICAgIGIzIHw9IDB4ODA7XG4gICAgICB1bnVzZWQgPSA3O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBiaXQgc3RyaW5nXG4gICAgdmFyIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bnVzZWQpO1xuICAgIGlmKGIzICE9PSAwKSB7XG4gICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYjMpO1xuICAgIH0gZWxzZSBpZihiMiAhPT0gMCkge1xuICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiMik7XG4gICAgfVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYmFzaWNDb25zdHJhaW50cycpIHtcbiAgICAvLyBiYXNpY0NvbnN0cmFpbnRzIGlzIGEgU0VRVUVOQ0VcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgLy8gY0EgQk9PTEVBTiBmbGFnIGRlZmF1bHRzIHRvIGZhbHNlXG4gICAgaWYoZS5jQSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJPT0xFQU4sIGZhbHNlLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gICAgfVxuICAgIGlmKCdwYXRoTGVuQ29uc3RyYWludCcgaW4gZSkge1xuICAgICAgZS52YWx1ZS52YWx1ZS5wdXNoKGFzbjEuY3JlYXRlKFxuICAgICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihlLnBhdGhMZW5Db25zdHJhaW50KS5nZXRCeXRlcygpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnZXh0S2V5VXNhZ2UnKSB7XG4gICAgLy8gZXh0S2V5VXNhZ2UgaXMgYSBTRVFVRU5DRSBvZiBPSURzXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKFxuICAgICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuICAgIHZhciBzZXEgPSBlLnZhbHVlLnZhbHVlO1xuICAgIGZvcih2YXIga2V5IGluIGUpIHtcbiAgICAgIGlmKGVba2V5XSAhPT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGtleSBpcyBuYW1lIGluIE9JRCBtYXBcbiAgICAgIGlmKGtleSBpbiBvaWRzKSB7XG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKG9pZHNba2V5XSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfSBlbHNlIGlmKGtleS5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIGFzc3VtZSBrZXkgaXMgYW4gT0lEXG4gICAgICAgIHNlcS5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELFxuICAgICAgICAgIGZhbHNlLCBhc24xLm9pZFRvRGVyKGtleSkuZ2V0Qnl0ZXMoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ2VydFR5cGUnKSB7XG4gICAgLy8gbnNDZXJ0VHlwZSBpcyBhIEJJVCBTVFJJTkdcbiAgICAvLyBidWlsZCBmbGFnc1xuICAgIHZhciB1bnVzZWQgPSAwO1xuICAgIHZhciBiMiA9IDB4MDA7XG5cbiAgICBpZihlLmNsaWVudCkge1xuICAgICAgYjIgfD0gMHg4MDtcbiAgICAgIHVudXNlZCA9IDc7XG4gICAgfVxuICAgIGlmKGUuc2VydmVyKSB7XG4gICAgICBiMiB8PSAweDQwO1xuICAgICAgdW51c2VkID0gNjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbCkge1xuICAgICAgYjIgfD0gMHgyMDtcbiAgICAgIHVudXNlZCA9IDU7XG4gICAgfVxuICAgIGlmKGUub2Jqc2lnbikge1xuICAgICAgYjIgfD0gMHgxMDtcbiAgICAgIHVudXNlZCA9IDQ7XG4gICAgfVxuICAgIGlmKGUucmVzZXJ2ZWQpIHtcbiAgICAgIGIyIHw9IDB4MDg7XG4gICAgICB1bnVzZWQgPSAzO1xuICAgIH1cbiAgICBpZihlLnNzbENBKSB7XG4gICAgICBiMiB8PSAweDA0O1xuICAgICAgdW51c2VkID0gMjtcbiAgICB9XG4gICAgaWYoZS5lbWFpbENBKSB7XG4gICAgICBiMiB8PSAweDAyO1xuICAgICAgdW51c2VkID0gMTtcbiAgICB9XG4gICAgaWYoZS5vYmpDQSkge1xuICAgICAgYjIgfD0gMHgwMTtcbiAgICAgIHVudXNlZCA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGJpdCBzdHJpbmdcbiAgICB2YXIgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVudXNlZCk7XG4gICAgaWYoYjIgIT09IDApIHtcbiAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYjIpO1xuICAgIH1cbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RBbHROYW1lJyB8fCBlLm5hbWUgPT09ICdpc3N1ZXJBbHROYW1lJykge1xuICAgIC8vIFNZTlRBWCBTRVFVRU5DRVxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG5cbiAgICB2YXIgYWx0TmFtZTtcbiAgICBmb3IodmFyIG4gPSAwOyBuIDwgZS5hbHROYW1lcy5sZW5ndGg7ICsrbikge1xuICAgICAgYWx0TmFtZSA9IGUuYWx0TmFtZXNbbl07XG4gICAgICB2YXIgdmFsdWUgPSBhbHROYW1lLnZhbHVlO1xuICAgICAgLy8gaGFuZGxlIElQXG4gICAgICBpZihhbHROYW1lLnR5cGUgPT09IDcgJiYgYWx0TmFtZS5pcCkge1xuICAgICAgICB2YWx1ZSA9IGZvcmdlLnV0aWwuYnl0ZXNGcm9tSVAoYWx0TmFtZS5pcCk7XG4gICAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4dGVuc2lvbiBcImlwXCIgdmFsdWUgaXMgbm90IGEgdmFsaWQgSVB2NCBvciBJUHY2IGFkZHJlc3MuJyk7XG4gICAgICAgICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGFsdE5hbWUudHlwZSA9PT0gOCkge1xuICAgICAgICAvLyBoYW5kbGUgT0lEXG4gICAgICAgIGlmKGFsdE5hbWUub2lkKSB7XG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKGFzbjEub2lkVG9EZXIoYWx0TmFtZS5vaWQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZXByZWNhdGVkIC4uLiBjb252ZXJ0IHZhbHVlIHRvIE9JRFxuICAgICAgICAgIHZhbHVlID0gYXNuMS5vaWRUb0Rlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGUudmFsdWUudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ25zQ29tbWVudCcgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gc2FuaXR5IGNoZWNrIHZhbHVlIGlzIEFTQ0lJIChyZXEnZCkgYW5kIG5vdCB0b28gYmlnXG4gICAgaWYoISgvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChlLmNvbW1lbnQpKSB8fFxuICAgICAgKGUuY29tbWVudC5sZW5ndGggPCAxKSB8fCAoZS5jb21tZW50Lmxlbmd0aCA+IDEyOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcIm5zQ29tbWVudFwiIGNvbnRlbnQuJyk7XG4gICAgfVxuICAgIC8vIElBNVNUUklORyBvcGFxdWUgY29tbWVudFxuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuSUE1U1RSSU5HLCBmYWxzZSwgZS5jb21tZW50KTtcbiAgfSBlbHNlIGlmKGUubmFtZSA9PT0gJ3N1YmplY3RLZXlJZGVudGlmaWVyJyAmJiBvcHRpb25zLmNlcnQpIHtcbiAgICB2YXIgc2tpID0gb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKTtcbiAgICBlLnN1YmplY3RLZXlJZGVudGlmaWVyID0gc2tpLnRvSGV4KCk7XG4gICAgLy8gT0NURVRTVFJJTkcgdy9kaWdlc3RcbiAgICBlLnZhbHVlID0gYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9DVEVUU1RSSU5HLCBmYWxzZSwgc2tpLmdldEJ5dGVzKCkpO1xuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnYXV0aG9yaXR5S2V5SWRlbnRpZmllcicgJiYgb3B0aW9ucy5jZXJ0KSB7XG4gICAgLy8gU1lOVEFYIFNFUVVFTkNFXG4gICAgZS52YWx1ZSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcbiAgICB2YXIgc2VxID0gZS52YWx1ZS52YWx1ZTtcblxuICAgIGlmKGUua2V5SWRlbnRpZmllcikge1xuICAgICAgdmFyIGtleUlkZW50aWZpZXIgPSAoZS5rZXlJZGVudGlmaWVyID09PSB0cnVlID9cbiAgICAgICAgb3B0aW9ucy5jZXJ0LmdlbmVyYXRlU3ViamVjdEtleUlkZW50aWZpZXIoKS5nZXRCeXRlcygpIDpcbiAgICAgICAgZS5rZXlJZGVudGlmaWVyKTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIGZhbHNlLCBrZXlJZGVudGlmaWVyKSk7XG4gICAgfVxuXG4gICAgaWYoZS5hdXRob3JpdHlDZXJ0SXNzdWVyKSB7XG4gICAgICB2YXIgYXV0aG9yaXR5Q2VydElzc3VlciA9IFtcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCA0LCB0cnVlLCBbXG4gICAgICAgICAgX2RuVG9Bc24xKGUuYXV0aG9yaXR5Q2VydElzc3VlciA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBvcHRpb25zLmNlcnQuaXNzdWVyIDogZS5hdXRob3JpdHlDZXJ0SXNzdWVyKVxuICAgICAgICBdKVxuICAgICAgXTtcbiAgICAgIHNlcS5wdXNoKFxuICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDEsIHRydWUsIGF1dGhvcml0eUNlcnRJc3N1ZXIpKTtcbiAgICB9XG5cbiAgICBpZihlLnNlcmlhbE51bWJlcikge1xuICAgICAgdmFyIHNlcmlhbE51bWJlciA9IGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhlLnNlcmlhbE51bWJlciA9PT0gdHJ1ZSA/XG4gICAgICAgIG9wdGlvbnMuY2VydC5zZXJpYWxOdW1iZXIgOiBlLnNlcmlhbE51bWJlcik7XG4gICAgICBzZXEucHVzaChcbiAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCBmYWxzZSwgc2VyaWFsTnVtYmVyKSk7XG4gICAgfVxuICB9IGVsc2UgaWYoZS5uYW1lID09PSAnY1JMRGlzdHJpYnV0aW9uUG9pbnRzJykge1xuICAgIGUudmFsdWUgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gICAgdmFyIHNlcSA9IGUudmFsdWUudmFsdWU7XG5cbiAgICAvLyBDcmVhdGUgc3ViIFNFUVVFTkNFIG9mIERpc3RyaWJ1dGlvblBvaW50TmFtZVxuICAgIHZhciBzdWJTZXEgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtdKTtcblxuICAgIC8vIENyZWF0ZSBmdWxsTmFtZSBDSE9JQ0VcbiAgICB2YXIgZnVsbE5hbWVHZW5lcmFsTmFtZXMgPSBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMCwgdHJ1ZSwgW10pO1xuICAgIHZhciBhbHROYW1lO1xuICAgIGZvcih2YXIgbiA9IDA7IG4gPCBlLmFsdE5hbWVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBhbHROYW1lID0gZS5hbHROYW1lc1tuXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFsdE5hbWUudmFsdWU7XG4gICAgICAvLyBoYW5kbGUgSVBcbiAgICAgIGlmKGFsdE5hbWUudHlwZSA9PT0gNyAmJiBhbHROYW1lLmlwKSB7XG4gICAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5ieXRlc0Zyb21JUChhbHROYW1lLmlwKTtcbiAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRXh0ZW5zaW9uIFwiaXBcIiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBJUHY0IG9yIElQdjYgYWRkcmVzcy4nKTtcbiAgICAgICAgICBlcnJvci5leHRlbnNpb24gPSBlO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYWx0TmFtZS50eXBlID09PSA4KSB7XG4gICAgICAgIC8vIGhhbmRsZSBPSURcbiAgICAgICAgaWYoYWx0TmFtZS5vaWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFzbjEub2lkVG9EZXIoYXNuMS5vaWRUb0RlcihhbHROYW1lLm9pZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgLi4uIGNvbnZlcnQgdmFsdWUgdG8gT0lEXG4gICAgICAgICAgdmFsdWUgPSBhc24xLm9pZFRvRGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbE5hbWVHZW5lcmFsTmFtZXMudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgICAgYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCBhbHROYW1lLnR5cGUsIGZhbHNlLFxuICAgICAgICB2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0byB0aGUgcGFyZW50IFNFUVVFTkNFXG4gICAgc3ViU2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgICBhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtmdWxsTmFtZUdlbmVyYWxOYW1lc10pKTtcbiAgICBzZXEucHVzaChzdWJTZXEpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbHVlIGhhcyBiZWVuIGRlZmluZWQgYnkgbm93XG4gIGlmKHR5cGVvZiBlLnZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignRXh0ZW5zaW9uIHZhbHVlIG5vdCBzcGVjaWZpZWQuJyk7XG4gICAgZXJyb3IuZXh0ZW5zaW9uID0gZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgb2JqZWN0IHRvIEFTTi4xXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9pZCBTaWduYXR1cmUgYWxnb3JpdGhtIE9JRFxuICogQHBhcmFtIHBhcmFtcyBUaGUgc2lnbmF0dXJlIHBhcmFtZXRycyBvYmplY3RcbiAqIEByZXR1cm4gQVNOLjEgb2JqZWN0IHJlcHJlc2VudGluZyBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICovXG5mdW5jdGlvbiBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShvaWQsIHBhcmFtcykge1xuICBzd2l0Y2gob2lkKSB7XG4gICAgY2FzZSBvaWRzWydSU0FTU0EtUFNTJ106XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgaWYocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgICAgICAgIGFzbjEub2lkVG9EZXIocGFyYW1zLmhhc2guYWxnb3JpdGhtT2lkKS5nZXRCeXRlcygpKSxcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKTtcbiAgICAgIH1cblxuICAgICAgaWYocGFyYW1zLm1nZi5hbGdvcml0aG1PaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgYXNuMS5vaWRUb0RlcihwYXJhbXMubWdmLmFsZ29yaXRobU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuT0lELCBmYWxzZSxcbiAgICAgICAgICAgICAgICBhc24xLm9pZFRvRGVyKHBhcmFtcy5tZ2YuaGFzaC5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgICAgICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk5VTEwsIGZhbHNlLCAnJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSkpO1xuICAgICAgfVxuXG4gICAgICBpZihwYXJhbXMuc2FsdExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgICAgICAgIGFzbjEuaW50ZWdlclRvRGVyKHBhcmFtcy5zYWx0TGVuZ3RoKS5nZXRCeXRlcygpKVxuICAgICAgICBdKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBwYXJ0cyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuTlVMTCwgZmFsc2UsICcnKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgY2VydGlmaWNhdGlvbiByZXF1ZXN0J3MgYXR0cmlidXRlcyB0byBhbiBBU04uMSBzZXQgb2ZcbiAqIENSSUF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIGNzciBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKlxuICogQHJldHVybiB0aGUgQVNOLjEgc2V0IG9mIENSSUF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcikge1xuICAvLyBjcmVhdGUgYW4gZW1wdHkgY29udGV4dC1zcGVjaWZpYyBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtdKTtcblxuICAvLyBubyBhdHRyaWJ1dGVzLCByZXR1cm4gZW1wdHkgY29udGFpbmVyXG4gIGlmKGNzci5hdHRyaWJ1dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gZWFjaCBhdHRyaWJ1dGUgaGFzIGEgc2VxdWVuY2Ugd2l0aCBhIHR5cGUgYW5kIGEgc2V0IG9mIHZhbHVlc1xuICB2YXIgYXR0cnMgPSBjc3IuYXR0cmlidXRlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgLy8gcmV1c2UgdGFnIGNsYXNzIGZvciBhdHRyaWJ1dGUgdmFsdWUgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHZhbHVlVGFnQ2xhc3MgPSBhc24xLlR5cGUuVVRGODtcbiAgICBpZigndmFsdWVUYWdDbGFzcycgaW4gYXR0cikge1xuICAgICAgdmFsdWVUYWdDbGFzcyA9IGF0dHIudmFsdWVUYWdDbGFzcztcbiAgICB9XG4gICAgaWYodmFsdWVUYWdDbGFzcyA9PT0gYXNuMS5UeXBlLlVURjgpIHtcbiAgICAgIHZhbHVlID0gZm9yZ2UudXRpbC5lbmNvZGVVdGY4KHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHZhbHVlQ29uc3RydWN0ZWQgPSBmYWxzZTtcbiAgICBpZigndmFsdWVDb25zdHJ1Y3RlZCcgaW4gYXR0cikge1xuICAgICAgdmFsdWVDb25zdHJ1Y3RlZCA9IGF0dHIudmFsdWVDb25zdHJ1Y3RlZDtcbiAgICB9XG4gICAgLy8gRklYTUU6IGhhbmRsZSBtb3JlIGVuY29kaW5nc1xuXG4gICAgLy8gY3JlYXRlIGEgUmVsYXRpdmVEaXN0aW5ndWlzaGVkTmFtZSBzZXRcbiAgICAvLyBlYWNoIHZhbHVlIGluIHRoZSBzZXQgaXMgYW4gQXR0cmlidXRlVHlwZUFuZFZhbHVlIGZpcnN0XG4gICAgLy8gY29udGFpbmluZyB0aGUgdHlwZSAoYW4gT0lEKSBhbmQgc2Vjb25kIHRoZSB2YWx1ZVxuICAgIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAvLyBBdHRyaWJ1dGVUeXBlXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoYXR0ci50eXBlKS5nZXRCeXRlcygpKSxcbiAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VULCB0cnVlLCBbXG4gICAgICAgIC8vIEF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIGFzbjEuY3JlYXRlKFxuICAgICAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCB2YWx1ZVRhZ0NsYXNzLCB2YWx1ZUNvbnN0cnVjdGVkLCB2YWx1ZSlcbiAgICAgIF0pXG4gICAgXSk7XG4gICAgcnZhbC52YWx1ZS5wdXNoKHNlcSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cblxudmFyIGphbl8xXzE5NTAgPSBuZXcgRGF0ZSgnMTk1MC0wMS0wMVQwMDowMDowMFonKTtcbnZhciBqYW5fMV8yMDUwID0gbmV3IERhdGUoJzIwNTAtMDEtMDFUMDA6MDA6MDBaJyk7XG5cbi8qKlxuICogQ29udmVydHMgYSBEYXRlIG9iamVjdCB0byBBU04uMVxuICogSGFuZGxlcyB0aGUgZGlmZmVyZW50IGZvcm1hdCBiZWZvcmUgYW5kIGFmdGVyIDFzdCBKYW51YXJ5IDIwNTBcbiAqXG4gKiBAcGFyYW0gZGF0ZSBkYXRlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBBU04uMSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkYXRlLlxuICovXG5mdW5jdGlvbiBfZGF0ZVRvQXNuMShkYXRlKSB7XG4gIGlmKGRhdGUgPj0gamFuXzFfMTk1MCAmJiBkYXRlIDwgamFuXzFfMjA1MCkge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuVVRDVElNRSwgZmFsc2UsXG4gICAgICBhc24xLmRhdGVUb1V0Y1RpbWUoZGF0ZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuR0VORVJBTElaRURUSU1FLCBmYWxzZSxcbiAgICAgIGFzbjEuZGF0ZVRvR2VuZXJhbGl6ZWRUaW1lKGRhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIEFTTi4xIFRCU0NlcnRpZmljYXRlIHBhcnQgb2YgYW4gWC41MDl2MyBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSBUQlNDZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmdldFRCU0NlcnRpZmljYXRlID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICB2YXIgbm90QmVmb3JlID0gX2RhdGVUb0FzbjEoY2VydC52YWxpZGl0eS5ub3RCZWZvcmUpO1xuICB2YXIgbm90QWZ0ZXIgPSBfZGF0ZVRvQXNuMShjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKTtcbiAgdmFyIHRicyA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAvLyBpbnRlZ2VyXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLklOVEVHRVIsIGZhbHNlLFxuICAgICAgICBhc24xLmludGVnZXJUb0RlcihjZXJ0LnZlcnNpb24pLmdldEJ5dGVzKCkpXG4gICAgXSksXG4gICAgLy8gc2VyaWFsTnVtYmVyXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGZvcmdlLnV0aWwuaGV4VG9CeXRlcyhjZXJ0LnNlcmlhbE51bWJlcikpLFxuICAgIC8vIHNpZ25hdHVyZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIC8vIGFsZ29yaXRobVxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PSUQsIGZhbHNlLFxuICAgICAgICBhc24xLm9pZFRvRGVyKGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoXG4gICAgICAgIGNlcnQuc2lnaW5mby5hbGdvcml0aG1PaWQsIGNlcnQuc2lnaW5mby5wYXJhbWV0ZXJzKVxuICAgIF0pLFxuICAgIC8vIGlzc3VlclxuICAgIF9kblRvQXNuMShjZXJ0Lmlzc3VlciksXG4gICAgLy8gdmFsaWRpdHlcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBub3RCZWZvcmUsXG4gICAgICBub3RBZnRlclxuICAgIF0pLFxuICAgIC8vIHN1YmplY3RcbiAgICBfZG5Ub0FzbjEoY2VydC5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY2VydC5wdWJsaWNLZXkpXG4gIF0pO1xuXG4gIGlmKGNlcnQuaXNzdWVyLnVuaXF1ZUlkKSB7XG4gICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuaXNzdWVyLnVuaXF1ZUlkXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgKTtcbiAgfVxuICBpZihjZXJ0LnN1YmplY3QudW5pcXVlSWQpIHtcbiAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKFxuICAgICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAyLCB0cnVlLCBbXG4gICAgICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGFyYml0cmFyeSBiaXQgbGVuZ3RoIGlkc1xuICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgK1xuICAgICAgICAgIGNlcnQuc3ViamVjdC51bmlxdWVJZFxuICAgICAgICApXG4gICAgICBdKVxuICAgICk7XG4gIH1cblxuICBpZihjZXJ0LmV4dGVuc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIC8vIGV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgIHRicy52YWx1ZS5wdXNoKHBraS5jZXJ0aWZpY2F0ZUV4dGVuc2lvbnNUb0FzbjEoY2VydC5leHRlbnNpb25zKSk7XG4gIH1cblxuICByZXR1cm4gdGJzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBBU04uMSBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm8gcGFydCBvZiBhXG4gKiBQS0NTIzEwIENlcnRpZmljYXRpb25SZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBjc3IgdGhlIGNlcnRpZmljYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJuIHRoZSBhc24xIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mby5cbiAqL1xucGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBDZXJ0aWZpY2F0aW9uUmVxdWVzdEluZm9cbiAgdmFyIGNyaSA9IGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyB2ZXJzaW9uXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSxcbiAgICAgIGFzbjEuaW50ZWdlclRvRGVyKGNzci52ZXJzaW9uKS5nZXRCeXRlcygpKSxcbiAgICAvLyBzdWJqZWN0XG4gICAgX2RuVG9Bc24xKGNzci5zdWJqZWN0KSxcbiAgICAvLyBTdWJqZWN0UHVibGljS2V5SW5mb1xuICAgIHBraS5wdWJsaWNLZXlUb0FzbjEoY3NyLnB1YmxpY0tleSksXG4gICAgLy8gYXR0cmlidXRlc1xuICAgIF9DUklBdHRyaWJ1dGVzVG9Bc24xKGNzcilcbiAgXSk7XG5cbiAgcmV0dXJuIGNyaTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBEaXN0aW5ndWlzaGVkTmFtZSAoc3ViamVjdCBvciBpc3N1ZXIpIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gZG4gdGhlIERpc3Rpbmd1aXNoZWROYW1lLlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0aW5ndWlzaGVkTmFtZS5cbiAqL1xucGtpLmRpc3Rpbmd1aXNoZWROYW1lVG9Bc24xID0gZnVuY3Rpb24oZG4pIHtcbiAgcmV0dXJuIF9kblRvQXNuMShkbik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIFguNTA5djMgUlNBIGNlcnRpZmljYXRlIHRvIGFuIEFTTi4xIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUuXG4gKlxuICogQHJldHVybiB0aGUgYXNuMSByZXByZXNlbnRhdGlvbiBvZiBhbiBYLjUwOXYzIFJTQSBjZXJ0aWZpY2F0ZS5cbiAqL1xucGtpLmNlcnRpZmljYXRlVG9Bc24xID0gZnVuY3Rpb24oY2VydCkge1xuICAvLyBwcmVmZXIgY2FjaGVkIFRCU0NlcnRpZmljYXRlIG92ZXIgZ2VuZXJhdGluZyBvbmVcbiAgdmFyIHRic0NlcnRpZmljYXRlID0gY2VydC50YnNDZXJ0aWZpY2F0ZSB8fCBwa2kuZ2V0VEJTQ2VydGlmaWNhdGUoY2VydCk7XG5cbiAgLy8gQ2VydGlmaWNhdGVcbiAgcmV0dXJuIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAvLyBUQlNDZXJ0aWZpY2F0ZVxuICAgIHRic0NlcnRpZmljYXRlLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY2VydC5zaWduYXR1cmVPaWQpLmdldEJ5dGVzKCkpLFxuICAgICAgLy8gcGFyYW1ldGVyc1xuICAgICAgX3NpZ25hdHVyZVBhcmFtZXRlcnNUb0FzbjEoY2VydC5zaWduYXR1cmVPaWQsIGNlcnQuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgIGFzbjEuY3JlYXRlKGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoMHgwMCkgKyBjZXJ0LnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIFguNTA5djMgY2VydGlmaWNhdGUgZXh0ZW5zaW9ucyB0byBBU04uMS5cbiAqXG4gKiBAcGFyYW0gZXh0cyB0aGUgZXh0ZW5zaW9ucyB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGV4dGVuc2lvbnMgaW4gQVNOLjEgZm9ybWF0LlxuICovXG5wa2kuY2VydGlmaWNhdGVFeHRlbnNpb25zVG9Bc24xID0gZnVuY3Rpb24oZXh0cykge1xuICAvLyBjcmVhdGUgdG9wLWxldmVsIGV4dGVuc2lvbiBjb250YWluZXJcbiAgdmFyIHJ2YWwgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDMsIHRydWUsIFtdKTtcblxuICAvLyBjcmVhdGUgZXh0ZW5zaW9uIHNlcXVlbmNlIChzdG9yZXMgYSBzZXF1ZW5jZSBmb3IgZWFjaCBleHRlbnNpb24pXG4gIHZhciBzZXEgPSBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXSk7XG4gIHJ2YWwudmFsdWUucHVzaChzZXEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG4gICAgc2VxLnZhbHVlLnB1c2gocGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xKGV4dHNbaV0pKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNpbmdsZSBjZXJ0aWZpY2F0ZSBleHRlbnNpb24gdG8gQVNOLjEuXG4gKlxuICogQHBhcmFtIGV4dCB0aGUgZXh0ZW5zaW9uIHRvIGNvbnZlcnQuXG4gKlxuICogQHJldHVybiB0aGUgZXh0ZW5zaW9uIGluIEFTTi4xIGZvcm1hdC5cbiAqL1xucGtpLmNlcnRpZmljYXRlRXh0ZW5zaW9uVG9Bc24xID0gZnVuY3Rpb24oZXh0KSB7XG4gIC8vIGNyZWF0ZSBhIHNlcXVlbmNlIGZvciBlYWNoIGV4dGVuc2lvblxuICB2YXIgZXh0c2VxID0gYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW10pO1xuXG4gIC8vIGV4dG5JRCAoT0lEKVxuICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICBhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgYXNuMS5vaWRUb0RlcihleHQuaWQpLmdldEJ5dGVzKCkpKTtcblxuICAvLyBjcml0aWNhbCBkZWZhdWx0cyB0byBmYWxzZVxuICBpZihleHQuY3JpdGljYWwpIHtcbiAgICAvLyBjcml0aWNhbCBCT09MRUFOIERFRkFVTFQgRkFMU0VcbiAgICBleHRzZXEudmFsdWUucHVzaChhc24xLmNyZWF0ZShcbiAgICAgIGFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBhc24xLlR5cGUuQk9PTEVBTiwgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkYpKSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBleHQudmFsdWU7XG4gIGlmKHR5cGVvZiBleHQudmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUgaXMgYXNuLjFcbiAgICB2YWx1ZSA9IGFzbjEudG9EZXIodmFsdWUpLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBleHRuVmFsdWUgKE9DVEVUIFNUUklORylcbiAgZXh0c2VxLnZhbHVlLnB1c2goYXNuMS5jcmVhdGUoXG4gICAgYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIHZhbHVlKSk7XG5cbiAgcmV0dXJuIGV4dHNlcTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQS0NTIzEwIGNlcnRpZmljYXRpb24gcmVxdWVzdCB0byBhbiBBU04uMSBvYmplY3QuXG4gKlxuICogQHBhcmFtIGNzciB0aGUgY2VydGlmaWNhdGlvbiByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm4gdGhlIGFzbjEgcmVwcmVzZW50YXRpb24gb2YgYSBjZXJ0aWZpY2F0aW9uIHJlcXVlc3QuXG4gKi9cbnBraS5jZXJ0aWZpY2F0aW9uUmVxdWVzdFRvQXNuMSA9IGZ1bmN0aW9uKGNzcikge1xuICAvLyBwcmVmZXIgY2FjaGVkIENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyBvdmVyIGdlbmVyYXRpbmcgb25lXG4gIHZhciBjcmkgPSBjc3IuY2VydGlmaWNhdGlvblJlcXVlc3RJbmZvIHx8XG4gICAgcGtpLmdldENlcnRpZmljYXRpb25SZXF1ZXN0SW5mbyhjc3IpO1xuXG4gIC8vIENlcnRpZmljYXRlXG4gIHJldHVybiBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgLy8gQ2VydGlmaWNhdGlvblJlcXVlc3RJbmZvXG4gICAgY3JpLFxuICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgYXNuMS5jcmVhdGUoYXNuMS5DbGFzcy5VTklWRVJTQUwsIGFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLk9JRCwgZmFsc2UsXG4gICAgICAgIGFzbjEub2lkVG9EZXIoY3NyLnNpZ25hdHVyZU9pZCkuZ2V0Qnl0ZXMoKSksXG4gICAgICAvLyBwYXJhbWV0ZXJzXG4gICAgICBfc2lnbmF0dXJlUGFyYW1ldGVyc1RvQXNuMShjc3Iuc2lnbmF0dXJlT2lkLCBjc3Iuc2lnbmF0dXJlUGFyYW1ldGVycylcbiAgICBdKSxcbiAgICAvLyBzaWduYXR1cmVcbiAgICBhc24xLmNyZWF0ZShhc24xLkNsYXNzLlVOSVZFUlNBTCwgYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MDApICsgY3NyLnNpZ25hdHVyZSlcbiAgXSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBDQSBzdG9yZS5cbiAqXG4gKiBAcGFyYW0gY2VydHMgYW4gb3B0aW9uYWwgYXJyYXkgb2YgY2VydGlmaWNhdGUgb2JqZWN0cyBvciBQRU0tZm9ybWF0dGVkXG4gKiAgICAgICAgICBjZXJ0aWZpY2F0ZSBzdHJpbmdzIHRvIGFkZCB0byB0aGUgQ0Egc3RvcmUuXG4gKlxuICogQHJldHVybiB0aGUgQ0Egc3RvcmUuXG4gKi9cbnBraS5jcmVhdGVDYVN0b3JlID0gZnVuY3Rpb24oY2VydHMpIHtcbiAgLy8gY3JlYXRlIENBIHN0b3JlXG4gIHZhciBjYVN0b3JlID0ge1xuICAgIC8vIHN0b3JlZCBjZXJ0aWZpY2F0ZXNcbiAgICBjZXJ0czoge31cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY2VydGlmaWNhdGUgdGhhdCBpc3N1ZWQgdGhlIHBhc3NlZCBjZXJ0aWZpY2F0ZSBvciBpdHNcbiAgICogJ3BhcmVudCcuXG4gICAqXG4gICAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHBhcmVudCBjZXJ0aWZpY2F0ZSBvciBudWxsIGlmIG5vbmUgd2FzIGZvdW5kLlxuICAgKi9cbiAgY2FTdG9yZS5nZXRJc3N1ZXIgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJ2YWwgPSBnZXRCeVN1YmplY3QoY2VydC5pc3N1ZXIpO1xuXG4gICAgLy8gc2VlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzXG4gICAgLyppZihmb3JnZS51dGlsLmlzQXJyYXkocnZhbCkpIHtcbiAgICAgIC8vIFRPRE86IHJlc29sdmUgbXVsdGlwbGUgbWF0Y2hlcyBieSBjaGVja2luZ1xuICAgICAgLy8gYXV0aG9yaXR5S2V5L3N1YmplY3RLZXkvaXNzdWVyVW5pcXVlSUQvb3RoZXIgaWRlbnRpZmllcnMsIGV0Yy5cbiAgICAgIC8vIEZJWE1FOiBvciBhbHRlcm5hdGl2ZWx5IGRvIGF1dGhvcml0eSBrZXkgbWFwcGluZ1xuICAgICAgLy8gaWYgcG9zc2libGUgKFguNTA5djEgY2VydHMgY2FuJ3Qgd29yaz8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBtdWx0aXBsZSBpc3N1ZXIgbWF0Y2hlcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0qL1xuXG4gICAgcmV0dXJuIHJ2YWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0cnVzdGVkIGNlcnRpZmljYXRlIHRvIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIGFkZCBhcyBhIHRydXN0ZWQgY2VydGlmaWNhdGUgKGVpdGhlciBhXG4gICAqICAgICAgICAgIHBraS5jZXJ0aWZpY2F0ZSBvYmplY3Qgb3IgYSBQRU0tZm9ybWF0dGVkIGNlcnRpZmljYXRlKS5cbiAgICovXG4gIGNhU3RvcmUuYWRkQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgLy8gY29udmVydCBmcm9tIHBlbSBpZiBuZWNlc3NhcnlcbiAgICBpZih0eXBlb2YgY2VydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNlcnQgPSBmb3JnZS5wa2kuY2VydGlmaWNhdGVGcm9tUGVtKGNlcnQpO1xuICAgIH1cblxuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkgeyAvLyBhdm9pZCBkdXBsaWNhdGUgY2VydGlmaWNhdGVzIGluIHN0b3JlXG4gICAgICBpZihjZXJ0LnN1YmplY3QuaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICAgIC8vIHN1YmplY3QgaGFzaCBhbHJlYWR5IGV4aXN0cywgYXBwZW5kIHRvIGFycmF5XG4gICAgICAgIHZhciB0bXAgPSBjYVN0b3JlLmNlcnRzW2NlcnQuc3ViamVjdC5oYXNoXTtcbiAgICAgICAgaWYoIWZvcmdlLnV0aWwuaXNBcnJheSh0bXApKSB7XG4gICAgICAgICAgdG1wID0gW3RtcF07XG4gICAgICAgIH1cbiAgICAgICAgdG1wLnB1c2goY2VydCk7XG4gICAgICAgIGNhU3RvcmUuY2VydHNbY2VydC5zdWJqZWN0Lmhhc2hdID0gdG1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF0gPSBjZXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgaXMgaW4gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0gY2VydCB0aGUgY2VydGlmaWNhdGUgdG8gY2hlY2sgKGVpdGhlciBhIHBraS5jZXJ0aWZpY2F0ZSBvciBhXG4gICAqICAgICAgICAgIFBFTS1mb3JtYXR0ZWQgY2VydGlmaWNhdGUpLlxuICAgKlxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGluIHRoZSBzdG9yZSwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZSA9IGZ1bmN0aW9uKGNlcnQpIHtcbiAgICAvLyBjb252ZXJ0IGZyb20gcGVtIGlmIG5lY2Vzc2FyeVxuICAgIGlmKHR5cGVvZiBjZXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2VydCA9IGZvcmdlLnBraS5jZXJ0aWZpY2F0ZUZyb21QZW0oY2VydCk7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG4gICAgaWYoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgICBtYXRjaCA9IFttYXRjaF07XG4gICAgfVxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdHMgYWxsIG9mIHRoZSBjZXJ0aWZpY2F0ZXMga2VwdCBpbiB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIG9mIHRoZSBwa2kuY2VydGlmaWNhdGUgb2JqZWN0cyBpbiB0aGUgc3RvcmUuXG4gICAqL1xuICBjYVN0b3JlLmxpc3RBbGxDZXJ0aWZpY2F0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VydExpc3QgPSBbXTtcblxuICAgIGZvcih2YXIgaGFzaCBpbiBjYVN0b3JlLmNlcnRzKSB7XG4gICAgICBpZihjYVN0b3JlLmNlcnRzLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNhU3RvcmUuY2VydHNbaGFzaF07XG4gICAgICAgIGlmKCFmb3JnZS51dGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY2VydExpc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjZXJ0TGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2VydExpc3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjZXJ0aWZpY2F0ZSBmcm9tIHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnQgdGhlIGNlcnRpZmljYXRlIHRvIHJlbW92ZSAoZWl0aGVyIGEgcGtpLmNlcnRpZmljYXRlIG9yIGFcbiAgICogICAgICAgICAgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZSkuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIGNlcnRpZmljYXRlIHRoYXQgd2FzIHJlbW92ZWQgb3IgbnVsbCBpZiB0aGUgY2VydGlmaWNhdGVcbiAgICogICAgICAgICAgIHdhc24ndCBpbiBzdG9yZS5cbiAgICovXG4gIGNhU3RvcmUucmVtb3ZlQ2VydGlmaWNhdGUgPSBmdW5jdGlvbihjZXJ0KSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGNvbnZlcnQgZnJvbSBwZW0gaWYgbmVjZXNzYXJ5XG4gICAgaWYodHlwZW9mIGNlcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjZXJ0ID0gZm9yZ2UucGtpLmNlcnRpZmljYXRlRnJvbVBlbShjZXJ0KTtcbiAgICB9XG4gICAgZW5zdXJlU3ViamVjdEhhc0hhc2goY2VydC5zdWJqZWN0KTtcbiAgICBpZighY2FTdG9yZS5oYXNDZXJ0aWZpY2F0ZShjZXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoID0gZ2V0QnlTdWJqZWN0KGNlcnQuc3ViamVjdCk7XG5cbiAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KG1hdGNoKSkge1xuICAgICAgcmVzdWx0ID0gY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgREVSLWVuY29kaW5nIG9mIGNlcnRpZmljYXRlc1xuICAgIHZhciBkZXIxID0gYXNuMS50b0Rlcihwa2kuY2VydGlmaWNhdGVUb0FzbjEoY2VydCkpLmdldEJ5dGVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZGVyMiA9IGFzbjEudG9EZXIocGtpLmNlcnRpZmljYXRlVG9Bc24xKG1hdGNoW2ldKSkuZ2V0Qnl0ZXMoKTtcbiAgICAgIGlmKGRlcjEgPT09IGRlcjIpIHtcbiAgICAgICAgcmVzdWx0ID0gbWF0Y2hbaV07XG4gICAgICAgIG1hdGNoLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYobWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgY2FTdG9yZS5jZXJ0c1tjZXJ0LnN1YmplY3QuaGFzaF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCeVN1YmplY3Qoc3ViamVjdCkge1xuICAgIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpO1xuICAgIHJldHVybiBjYVN0b3JlLmNlcnRzW3N1YmplY3QuaGFzaF0gfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVN1YmplY3RIYXNIYXNoKHN1YmplY3QpIHtcbiAgICAvLyBwcm9kdWNlIHN1YmplY3QgaGFzaCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYoIXN1YmplY3QuaGFzaCkge1xuICAgICAgdmFyIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgIHN1YmplY3QuYXR0cmlidXRlcyA9IHBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShfZG5Ub0FzbjEoc3ViamVjdCksIG1kKTtcbiAgICAgIHN1YmplY3QuaGFzaCA9IG1kLmRpZ2VzdCgpLnRvSGV4KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXV0by1hZGQgcGFzc2VkIGluIGNlcnRzXG4gIGlmKGNlcnRzKSB7XG4gICAgLy8gcGFyc2UgUEVNLWZvcm1hdHRlZCBjZXJ0aWZpY2F0ZXMgYXMgbmVjZXNzYXJ5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNlcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY2VydCA9IGNlcnRzW2ldO1xuICAgICAgY2FTdG9yZS5hZGRDZXJ0aWZpY2F0ZShjZXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FTdG9yZTtcbn07XG5cbi8qKlxuICogQ2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uIGVycm9ycywgYmFzZWQgb24gVExTLlxuICovXG5wa2kuY2VydGlmaWNhdGVFcnJvciA9IHtcbiAgYmFkX2NlcnRpZmljYXRlOiAnZm9yZ2UucGtpLkJhZENlcnRpZmljYXRlJyxcbiAgdW5zdXBwb3J0ZWRfY2VydGlmaWNhdGU6ICdmb3JnZS5wa2kuVW5zdXBwb3J0ZWRDZXJ0aWZpY2F0ZScsXG4gIGNlcnRpZmljYXRlX3Jldm9rZWQ6ICdmb3JnZS5wa2kuQ2VydGlmaWNhdGVSZXZva2VkJyxcbiAgY2VydGlmaWNhdGVfZXhwaXJlZDogJ2ZvcmdlLnBraS5DZXJ0aWZpY2F0ZUV4cGlyZWQnLFxuICBjZXJ0aWZpY2F0ZV91bmtub3duOiAnZm9yZ2UucGtpLkNlcnRpZmljYXRlVW5rbm93bicsXG4gIHVua25vd25fY2E6ICdmb3JnZS5wa2kuVW5rbm93bkNlcnRpZmljYXRlQXV0aG9yaXR5J1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIGNlcnRpZmljYXRlIGNoYWluIGFnYWluc3QgdGhlIGdpdmVuIENlcnRpZmljYXRlIEF1dGhvcml0eSBzdG9yZVxuICogd2l0aCBhbiBvcHRpb25hbCBjdXN0b20gdmVyaWZ5IGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBjYVN0b3JlIGEgY2VydGlmaWNhdGUgc3RvcmUgdG8gdmVyaWZ5IGFnYWluc3QuXG4gKiBAcGFyYW0gY2hhaW4gdGhlIGNlcnRpZmljYXRlIGNoYWluIHRvIHZlcmlmeSwgd2l0aCB0aGUgcm9vdCBvciBoaWdoZXN0XG4gKiAgICAgICAgICBhdXRob3JpdHkgYXQgdGhlIGVuZCAoYW4gYXJyYXkgb2YgY2VydGlmaWNhdGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBldmVyeSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY2hhaW4gb3JcbiAqICAgICAgICAgICAgICAgICAgYW4gb2JqZWN0IHdpdGg6XG4gKiAgICAgICAgICAgICAgICAgIHZlcmlmeSBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgaW4gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgY2hhaW5cbiAqICAgICAgICAgICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgdGhlIGRhdGUgYWdhaW5zdCB3aGljaCB0aGUgY2VydGlmaWNhdGVcbiAqICAgICAgICAgICAgICAgICAgICB2YWxpZGl0eSBwZXJpb2Qgc2hvdWxkIGJlIGNoZWNrZWQuIFBhc3MgbnVsbCB0byBub3QgY2hlY2tcbiAqICAgICAgICAgICAgICAgICAgICB0aGUgdmFsaWRpdHkgcGVyaW9kLiBCeSBkZWZhdWx0LCB0aGUgY3VycmVudCBkYXRlIGlzIHVzZWQuXG4gKlxuICogVGhlIHZlcmlmeSBjYWxsYmFjayBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogdmVyaWZpZWQgLSBTZXQgdG8gdHJ1ZSBpZiBjZXJ0aWZpY2F0ZSB3YXMgdmVyaWZpZWQsIG90aGVyd2lzZSB0aGVcbiAqICAgcGtpLmNlcnRpZmljYXRlRXJyb3IgZm9yIHdoeSB0aGUgY2VydGlmaWNhdGUgZmFpbGVkLlxuICogZGVwdGggLSBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgY2hhaW4sIHdoZXJlIDAgaXMgdGhlIGVuZCBwb2ludCdzIGNlcnQuXG4gKiBjZXJ0cyAtIFRoZSBjZXJ0aWZpY2F0ZSBjaGFpbiwgKk5PVEUqIGFuIGVtcHR5IGNoYWluIGluZGljYXRlcyBhbiBhbm9ueW1vdXNcbiAqICAgZW5kIHBvaW50LlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgb24gc3VjY2VzcyBhbmQgb24gZmFpbHVyZSBlaXRoZXIgdGhlIGFwcHJvcHJpYXRlXG4gKiBwa2kuY2VydGlmaWNhdGVFcnJvciBvciBhbiBvYmplY3Qgd2l0aCAnZXJyb3InIHNldCB0byB0aGUgYXBwcm9wcmlhdGVcbiAqIHBraS5jZXJ0aWZpY2F0ZUVycm9yIGFuZCAnbWVzc2FnZScgc2V0IHRvIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIHRocm93biBpZiBub3QuXG4gKi9cbnBraS52ZXJpZnlDZXJ0aWZpY2F0ZUNoYWluID0gZnVuY3Rpb24oY2FTdG9yZSwgY2hhaW4sIG9wdGlvbnMpIHtcbiAgLyogRnJvbTogUkZDMzI4MCAtIEludGVybmV0IFguNTA5IFB1YmxpYyBLZXkgSW5mcmFzdHJ1Y3R1cmUgQ2VydGlmaWNhdGVcbiAgICBTZWN0aW9uIDY6IENlcnRpZmljYXRpb24gUGF0aCBWYWxpZGF0aW9uXG4gICAgU2VlIGlubGluZSBwYXJlbnRoZXRpY2FscyByZWxhdGVkIHRvIHRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbi5cblxuICAgIFRoZSBwcmltYXJ5IGdvYWwgb2YgcGF0aCB2YWxpZGF0aW9uIGlzIHRvIHZlcmlmeSB0aGUgYmluZGluZyBiZXR3ZWVuXG4gICAgYSBzdWJqZWN0IGRpc3Rpbmd1aXNoZWQgbmFtZSBvciBhIHN1YmplY3QgYWx0ZXJuYXRpdmUgbmFtZSBhbmQgc3ViamVjdFxuICAgIHB1YmxpYyBrZXksIGFzIHJlcHJlc2VudGVkIGluIHRoZSBlbmQgZW50aXR5IGNlcnRpZmljYXRlLCBiYXNlZCBvbiB0aGVcbiAgICBwdWJsaWMga2V5IG9mIHRoZSB0cnVzdCBhbmNob3IuIFRoaXMgcmVxdWlyZXMgb2J0YWluaW5nIGEgc2VxdWVuY2Ugb2ZcbiAgICBjZXJ0aWZpY2F0ZXMgdGhhdCBzdXBwb3J0IHRoYXQgYmluZGluZy4gVGhhdCBzZXF1ZW5jZSBzaG91bGQgYmUgcHJvdmlkZWRcbiAgICBpbiB0aGUgcGFzc2VkICdjaGFpbicuIFRoZSB0cnVzdCBhbmNob3Igc2hvdWxkIGJlIGluIHRoZSBnaXZlbiBDQVxuICAgIHN0b3JlLiBUaGUgJ2VuZCBlbnRpdHknIGNlcnRpZmljYXRlIGlzIHRoZSBjZXJ0aWZpY2F0ZSBwcm92aWRlZCBieSB0aGVcbiAgICBlbmQgcG9pbnQgKHR5cGljYWxseSBhIHNlcnZlcikgYW5kIGlzIHRoZSBmaXJzdCBpbiB0aGUgY2hhaW4uXG5cbiAgICBUbyBtZWV0IHRoaXMgZ29hbCwgdGhlIHBhdGggdmFsaWRhdGlvbiBwcm9jZXNzIHZlcmlmaWVzLCBhbW9uZyBvdGhlclxuICAgIHRoaW5ncywgdGhhdCBhIHByb3NwZWN0aXZlIGNlcnRpZmljYXRpb24gcGF0aCAoYSBzZXF1ZW5jZSBvZiBuXG4gICAgY2VydGlmaWNhdGVzIG9yIGEgJ2NoYWluJykgc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgIChhKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbi0xfSwgdGhlIHN1YmplY3Qgb2YgY2VydGlmaWNhdGUgeCBpc1xuICAgICAgICAgIHRoZSBpc3N1ZXIgb2YgY2VydGlmaWNhdGUgeCsxO1xuXG4gICAgKGIpIGNlcnRpZmljYXRlIDEgaXMgaXNzdWVkIGJ5IHRoZSB0cnVzdCBhbmNob3I7XG5cbiAgICAoYykgY2VydGlmaWNhdGUgbiBpcyB0aGUgY2VydGlmaWNhdGUgdG8gYmUgdmFsaWRhdGVkOyBhbmRcblxuICAgIChkKSBmb3IgYWxsIHggaW4gezEsIC4uLiwgbn0sIHRoZSBjZXJ0aWZpY2F0ZSB3YXMgdmFsaWQgYXQgdGhlXG4gICAgICAgICAgdGltZSBpbiBxdWVzdGlvbi5cblxuICAgIE5vdGUgdGhhdCBoZXJlICduJyBpcyBpbmRleCAwIGluIHRoZSBjaGFpbiBhbmQgMSBpcyB0aGUgbGFzdCBjZXJ0aWZpY2F0ZVxuICAgIGluIHRoZSBjaGFpbiBhbmQgaXQgbXVzdCBiZSBzaWduZWQgYnkgYSBjZXJ0aWZpY2F0ZSBpbiB0aGUgY29ubmVjdGlvbidzXG4gICAgQ0Egc3RvcmUuXG5cbiAgICBUaGUgcGF0aCB2YWxpZGF0aW9uIHByb2Nlc3MgYWxzbyBkZXRlcm1pbmVzIHRoZSBzZXQgb2YgY2VydGlmaWNhdGVcbiAgICBwb2xpY2llcyB0aGF0IGFyZSB2YWxpZCBmb3IgdGhpcyBwYXRoLCBiYXNlZCBvbiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXNcbiAgICBleHRlbnNpb24sIHBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiwgcG9saWN5IGNvbnN0cmFpbnRzIGV4dGVuc2lvbiwgYW5kXG4gICAgaW5oaWJpdCBhbnktcG9saWN5IGV4dGVuc2lvbi5cblxuICAgIE5vdGU6IFBvbGljeSBtYXBwaW5nIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkIChOb3QgUmVxdWlyZWQpLlxuXG4gICAgTm90ZTogSWYgdGhlIGNlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24sIHRoZW4gaXRcbiAgICBtdXN0IGJlIHJlamVjdGVkLlxuXG4gICAgTm90ZTogQSBjZXJ0aWZpY2F0ZSBpcyBzZWxmLWlzc3VlZCBpZiB0aGUgRE5zIHRoYXQgYXBwZWFyIGluIHRoZSBzdWJqZWN0XG4gICAgYW5kIGlzc3VlciBmaWVsZHMgYXJlIGlkZW50aWNhbCBhbmQgYXJlIG5vdCBlbXB0eS5cblxuICAgIFRoZSBwYXRoIHZhbGlkYXRpb24gYWxnb3JpdGhtIGFzc3VtZXMgdGhlIGZvbGxvd2luZyBzZXZlbiBpbnB1dHMgYXJlXG4gICAgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZyBsb2dpYy4gV2hhdCB0aGlzIHNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgd2lsbCB1c2UgaXMgcHJvdmlkZWQgcGFyZW50aGV0aWNhbGx5OlxuXG4gICAgKGEpIGEgcHJvc3BlY3RpdmUgY2VydGlmaWNhdGlvbiBwYXRoIG9mIGxlbmd0aCBuICh0aGUgJ2NoYWluJylcbiAgICAoYikgdGhlIGN1cnJlbnQgZGF0ZS90aW1lOiAoJ25vdycpLlxuICAgIChjKSB1c2VyLWluaXRpYWwtcG9saWN5LXNldDogQSBzZXQgb2YgY2VydGlmaWNhdGUgcG9saWN5IGlkZW50aWZpZXJzXG4gICAgICAgICAgbmFtaW5nIHRoZSBwb2xpY2llcyB0aGF0IGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBjZXJ0aWZpY2F0ZSB1c2VyLlxuICAgICAgICAgIFRoZSB1c2VyLWluaXRpYWwtcG9saWN5LXNldCBjb250YWlucyB0aGUgc3BlY2lhbCB2YWx1ZSBhbnktcG9saWN5XG4gICAgICAgICAgaWYgdGhlIHVzZXIgaXMgbm90IGNvbmNlcm5lZCBhYm91dCBjZXJ0aWZpY2F0ZSBwb2xpY3lcbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLiBBbnkgcG9saWN5IGlzIGFjY2VwdGVkKS5cbiAgICAoZCkgdHJ1c3QgYW5jaG9yIGluZm9ybWF0aW9uLCBkZXNjcmliaW5nIGEgQ0EgdGhhdCBzZXJ2ZXMgYXMgYSB0cnVzdFxuICAgICAgICAgIGFuY2hvciBmb3IgdGhlIGNlcnRpZmljYXRpb24gcGF0aC4gVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvblxuICAgICAgICAgIGluY2x1ZGVzOlxuXG4gICAgICAoMSkgIHRoZSB0cnVzdGVkIGlzc3VlciBuYW1lLFxuICAgICAgKDIpICB0aGUgdHJ1c3RlZCBwdWJsaWMga2V5IGFsZ29yaXRobSxcbiAgICAgICgzKSAgdGhlIHRydXN0ZWQgcHVibGljIGtleSwgYW5kXG4gICAgICAoNCkgIG9wdGlvbmFsbHksIHRoZSB0cnVzdGVkIHB1YmxpYyBrZXkgcGFyYW1ldGVycyBhc3NvY2lhdGVkXG4gICAgICAgICAgICAgd2l0aCB0aGUgcHVibGljIGtleS5cblxuICAgICAgKFRydXN0IGFuY2hvcnMgYXJlIHByb3ZpZGVkIHZpYSBjZXJ0aWZpY2F0ZXMgaW4gdGhlIENBIHN0b3JlKS5cblxuICAgICAgVGhlIHRydXN0IGFuY2hvciBpbmZvcm1hdGlvbiBtYXkgYmUgcHJvdmlkZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGluIHRoZSBmb3JtIG9mIGEgc2VsZi1zaWduZWQgY2VydGlmaWNhdGUuIFRoZSB0cnVzdGVkIGFuY2hvclxuICAgICAgaW5mb3JtYXRpb24gaXMgdHJ1c3RlZCBiZWNhdXNlIGl0IHdhcyBkZWxpdmVyZWQgdG8gdGhlIHBhdGggcHJvY2Vzc2luZ1xuICAgICAgcHJvY2VkdXJlIGJ5IHNvbWUgdHJ1c3R3b3J0aHkgb3V0LW9mLWJhbmQgcHJvY2VkdXJlLiBJZiB0aGUgdHJ1c3RlZFxuICAgICAgcHVibGljIGtleSBhbGdvcml0aG0gcmVxdWlyZXMgcGFyYW1ldGVycywgdGhlbiB0aGUgcGFyYW1ldGVycyBhcmVcbiAgICAgIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIHRydXN0ZWQgcHVibGljIGtleSAoTm8gcGFyYW1ldGVycyB1c2VkIGluIHRoaXNcbiAgICAgIGltcGxlbWVudGF0aW9uKS5cblxuICAgIChlKSBpbml0aWFsLXBvbGljeS1tYXBwaW5nLWluaGliaXQsIHdoaWNoIGluZGljYXRlcyBpZiBwb2xpY3kgbWFwcGluZyBpc1xuICAgICAgICAgIGFsbG93ZWQgaW4gdGhlIGNlcnRpZmljYXRpb24gcGF0aC5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBubyBwb2xpY3kgY2hlY2tpbmcpXG5cbiAgICAoZikgaW5pdGlhbC1leHBsaWNpdC1wb2xpY3ksIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgcGF0aCBtdXN0IGJlIHZhbGlkXG4gICAgICAgICAgZm9yIGF0IGxlYXN0IG9uZSBvZiB0aGUgY2VydGlmaWNhdGUgcG9saWNpZXMgaW4gdGhlIHVzZXItaW5pdGlhbC1cbiAgICAgICAgICBwb2xpY3ktc2V0LlxuICAgICAgICAgIChOb3QgaW1wbGVtZW50ZWQsIG5vIHBvbGljeSBjaGVja2luZylcblxuICAgIChnKSBpbml0aWFsLWFueS1wb2xpY3ktaW5oaWJpdCwgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlXG4gICAgICAgICAgYW55UG9saWN5IE9JRCBzaG91bGQgYmUgcHJvY2Vzc2VkIGlmIGl0IGlzIGluY2x1ZGVkIGluIGFcbiAgICAgICAgICBjZXJ0aWZpY2F0ZS5cbiAgICAgICAgICAoTm90IGltcGxlbWVudGVkLCBzbyBhbnkgcG9saWN5IGlzIHZhbGlkIHByb3ZpZGVkIHRoYXQgaXQgaXNcbiAgICAgICAgICBub3QgbWFya2VkIGFzIGNyaXRpY2FsKSAqL1xuXG4gIC8qIEJhc2ljIFBhdGggUHJvY2Vzc2luZzpcblxuICAgIEZvciBlYWNoIGNlcnRpZmljYXRlIGluIHRoZSAnY2hhaW4nLCB0aGUgZm9sbG93aW5nIGlzIGNoZWNrZWQ6XG5cbiAgICAxLiBUaGUgY2VydGlmaWNhdGUgdmFsaWRpdHkgcGVyaW9kIGluY2x1ZGVzIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgMi4gVGhlIGNlcnRpZmljYXRlIHdhcyBzaWduZWQgYnkgaXRzIHBhcmVudCAod2hlcmUgdGhlIHBhcmVudCBpcyBlaXRoZXJcbiAgICAgICB0aGUgbmV4dCBpbiB0aGUgY2hhaW4gb3IgZnJvbSB0aGUgQ0Egc3RvcmUpLiBBbGxvdyBwcm9jZXNzaW5nIHRvXG4gICAgICAgY29udGludWUgdG8gdGhlIG5leHQgc3RlcCBpZiBubyBwYXJlbnQgaXMgZm91bmQgYnV0IHRoZSBjZXJ0aWZpY2F0ZSBpc1xuICAgICAgIGluIHRoZSBDQSBzdG9yZS5cbiAgICAzLiBUT0RPOiBUaGUgY2VydGlmaWNhdGUgaGFzIG5vdCBiZWVuIHJldm9rZWQuXG4gICAgNC4gVGhlIGNlcnRpZmljYXRlIGlzc3VlciBuYW1lIG1hdGNoZXMgdGhlIHBhcmVudCdzIHN1YmplY3QgbmFtZS5cbiAgICA1LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBvZiBYLjUwMCBkaXN0aW5ndWlzaGVkIG5hbWVzXG4gICAgICAgYW5kIHRoYXQgZWFjaCBvZiB0aGUgYWx0ZXJuYXRpdmUgbmFtZXMgaW4gdGhlIHN1YmplY3RBbHROYW1lIGV4dGVuc2lvblxuICAgICAgIChjcml0aWNhbCBvciBub24tY3JpdGljYWwpIGlzIHdpdGhpbiBvbmUgb2YgdGhlIHBlcm1pdHRlZCBzdWJ0cmVlcyBmb3JcbiAgICAgICB0aGF0IG5hbWUgdHlwZS5cbiAgICA2LiBUT0RPOiBJZiB0aGUgY2VydGlmaWNhdGUgaXMgc2VsZi1pc3N1ZWQgYW5kIG5vdCB0aGUgZmluYWwgY2VydGlmaWNhdGVcbiAgICAgICBpbiB0aGUgY2hhaW4sIHNraXAgdGhpcyBzdGVwLCBvdGhlcndpc2UgdmVyaWZ5IHRoYXQgdGhlIHN1YmplY3QgbmFtZVxuICAgICAgIGlzIG5vdCB3aXRoaW4gb25lIG9mIHRoZSBleGNsdWRlZCBzdWJ0cmVlcyBmb3IgWC41MDAgZGlzdGluZ3Vpc2hlZFxuICAgICAgIG5hbWVzIGFuZCBub25lIG9mIHRoZSBzdWJqZWN0QWx0TmFtZSBleHRlbnNpb24gbmFtZXMgYXJlIGV4Y2x1ZGVkIGZvclxuICAgICAgIHRoYXQgbmFtZSB0eXBlLlxuICAgIDcuIFRoZSBvdGhlciBzdGVwcyBpbiB0aGUgYWxnb3JpdGhtIGZvciBiYXNpYyBwYXRoIHByb2Nlc3NpbmcgaW52b2x2ZVxuICAgICAgIGhhbmRsaW5nIHRoZSBwb2xpY3kgZXh0ZW5zaW9uIHdoaWNoIGlzIG5vdCBwcmVzZW50bHkgc3VwcG9ydGVkIGluIHRoaXNcbiAgICAgICBpbXBsZW1lbnRhdGlvbi4gSW5zdGVhZCwgaWYgYSBjcml0aWNhbCBwb2xpY3kgZXh0ZW5zaW9uIGlzIGZvdW5kLCB0aGVcbiAgICAgICBjZXJ0aWZpY2F0ZSBpcyByZWplY3RlZCBhcyBub3Qgc3VwcG9ydGVkLlxuICAgIDguIElmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgdGhlIGZpcnN0IG9yIGlmIGl0cyB0aGUgb25seSBjZXJ0aWZpY2F0ZSBpblxuICAgICAgIHRoZSBjaGFpbiAoaGF2aW5nIG5vIHBhcmVudCBmcm9tIHRoZSBDQSBzdG9yZSBvciBpcyBzZWxmLXNpZ25lZCkgYW5kIGl0XG4gICAgICAgaGFzIGEgY3JpdGljYWwga2V5IHVzYWdlIGV4dGVuc2lvbiwgdmVyaWZ5IHRoYXQgdGhlIGtleUNlcnRTaWduIGJpdCBpc1xuICAgICAgIHNldC4gSWYgdGhlIGtleSB1c2FnZSBleHRlbnNpb24gZXhpc3RzLCB2ZXJpZnkgdGhhdCB0aGUgYmFzaWNcbiAgICAgICBjb25zdHJhaW50cyBleHRlbnNpb24gZXhpc3RzLiBJZiB0aGUgYmFzaWMgY29uc3RyYWludHMgZXh0ZW5zaW9uIGV4aXN0cyxcbiAgICAgICB2ZXJpZnkgdGhhdCB0aGUgY0EgZmxhZyBpcyBzZXQuIElmIHBhdGhMZW5Db25zdHJhaW50IGlzIHNldCwgZW5zdXJlIHRoYXRcbiAgICAgICB0aGUgbnVtYmVyIG9mIGNlcnRpZmljYXRlcyB0aGF0IHByZWNlZGUgaW4gdGhlIGNoYWluIChjb21lIGVhcmxpZXJcbiAgICAgICBpbiB0aGUgY2hhaW4gYXMgaW1wbGVtZW50ZWQgYmVsb3cpLCBleGNsdWRpbmcgdGhlIHZlcnkgZmlyc3QgaW4gdGhlXG4gICAgICAgY2hhaW4gKHR5cGljYWxseSB0aGUgZW5kLWVudGl0eSBvbmUpLCBpc24ndCBncmVhdGVyIHRoYW4gdGhlXG4gICAgICAgcGF0aExlbkNvbnN0cmFpbnQuIFRoaXMgY29uc3RyYWludCBsaW1pdHMgdGhlIG51bWJlciBvZiBpbnRlcm1lZGlhdGVcbiAgICAgICBDQXMgdGhhdCBtYXkgYXBwZWFyIGJlbG93IGEgQ0EgYmVmb3JlIG9ubHkgZW5kLWVudGl0eSBjZXJ0aWZpY2F0ZXNcbiAgICAgICBtYXkgYmUgaXNzdWVkLiAqL1xuXG4gIC8vIGlmIGEgdmVyaWZ5IGNhbGxiYWNrIGlzIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyLCBwYWNrYWdlIGl0IHdpdGhpblxuICAvLyB0aGUgb3B0aW9ucyBvYmplY3QuIFRoaXMgaXMgdG8gc3VwcG9ydCBhIGxlZ2FjeSBmdW5jdGlvbiBzaWduYXR1cmUgdGhhdFxuICAvLyBleHBlY3RlZCB0aGUgdmVyaWZ5IGNhbGxiYWNrIGFzIHRoZSB0aGlyZCBwYXJhbWV0ZXIuXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHt2ZXJpZnk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNvcHkgY2VydCBjaGFpbiByZWZlcmVuY2VzIHRvIGFub3RoZXIgYXJyYXkgdG8gcHJvdGVjdCBhZ2FpbnN0IGNoYW5nZXNcbiAgLy8gaW4gdmVyaWZ5IGNhbGxiYWNrXG4gIGNoYWluID0gY2hhaW4uc2xpY2UoMCk7XG4gIHZhciBjZXJ0cyA9IGNoYWluLnNsaWNlKDApO1xuXG4gIHZhciB2YWxpZGl0eUNoZWNrRGF0ZSA9IG9wdGlvbnMudmFsaWRpdHlDaGVja0RhdGU7XG4gIC8vIGlmIG5vIHZhbGlkaXR5Q2hlY2tEYXRlIGlzIHNwZWNpZmllZCwgZGVmYXVsdCB0byB0aGUgY3VycmVudCBkYXRlLiBNYWtlXG4gIC8vIHN1cmUgdG8gbWFpbnRhaW4gdGhlIHZhbHVlIG51bGwgYmVjYXVzZSBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgdmFsaWRpdHlcbiAgLy8gcGVyaW9kIHNob3VsZCBub3QgYmUgY2hlY2tlZC5cbiAgaWYodHlwZW9mIHZhbGlkaXR5Q2hlY2tEYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhbGlkaXR5Q2hlY2tEYXRlID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIC8vIHZlcmlmeSBlYWNoIGNlcnQgaW4gdGhlIGNoYWluIHVzaW5nIGl0cyBwYXJlbnQsIHdoZXJlIHRoZSBwYXJlbnRcbiAgLy8gaXMgZWl0aGVyIHRoZSBuZXh0IGluIHRoZSBjaGFpbiBvciBmcm9tIHRoZSBDQSBzdG9yZVxuICB2YXIgZmlyc3QgPSB0cnVlO1xuICB2YXIgZXJyb3IgPSBudWxsO1xuICB2YXIgZGVwdGggPSAwO1xuICBkbyB7XG4gICAgdmFyIGNlcnQgPSBjaGFpbi5zaGlmdCgpO1xuICAgIHZhciBwYXJlbnQgPSBudWxsO1xuICAgIHZhciBzZWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICBpZih2YWxpZGl0eUNoZWNrRGF0ZSkge1xuICAgICAgLy8gMS4gY2hlY2sgdmFsaWQgdGltZVxuICAgICAgaWYodmFsaWRpdHlDaGVja0RhdGUgPCBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSB8fFxuICAgICAgICAgdmFsaWRpdHlDaGVja0RhdGUgPiBjZXJ0LnZhbGlkaXR5Lm5vdEFmdGVyKSB7XG4gICAgICAgIGVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpcyBub3QgdmFsaWQgeWV0IG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgICAgZXJyb3I6IHBraS5jZXJ0aWZpY2F0ZUVycm9yLmNlcnRpZmljYXRlX2V4cGlyZWQsXG4gICAgICAgICAgbm90QmVmb3JlOiBjZXJ0LnZhbGlkaXR5Lm5vdEJlZm9yZSxcbiAgICAgICAgICBub3RBZnRlcjogY2VydC52YWxpZGl0eS5ub3RBZnRlcixcbiAgICAgICAgICAvLyBUT0RPOiB3ZSBtaWdodCB3YW50IHRvIHJlY29uc2lkZXIgcmVuYW1pbmcgJ25vdycgdG9cbiAgICAgICAgICAvLyAndmFsaWRpdHlDaGVja0RhdGUnIHNob3VsZCB0aGlzIEFQSSBiZSBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgbm93OiB2YWxpZGl0eUNoZWNrRGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDIuIHZlcmlmeSB3aXRoIHBhcmVudCBmcm9tIGNoYWluIG9yIENBIHN0b3JlXG4gICAgaWYoZXJyb3IgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGNoYWluWzBdIHx8IGNhU3RvcmUuZ2V0SXNzdWVyKGNlcnQpO1xuICAgICAgaWYocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzZWxmLXNpZ25lZCBjZXJ0XG4gICAgICAgIGlmKGNlcnQuaXNJc3N1ZXIoY2VydCkpIHtcbiAgICAgICAgICBzZWxmU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICBwYXJlbnQgPSBjZXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAvLyBGSVhNRTogY3VycmVudCBDQSBzdG9yZSBpbXBsZW1lbnRhdGlvbiBtaWdodCBoYXZlIG11bHRpcGxlXG4gICAgICAgIC8vIGNlcnRpZmljYXRlcyB3aGVyZSB0aGUgaXNzdWVyIGNhbid0IGJlIGRldGVybWluZWQgZnJvbSB0aGVcbiAgICAgICAgLy8gY2VydGlmaWNhdGUgKGhhcHBlbnMgcmFyZWx5IHdpdGgsIGVnOiBvbGQgY2VydGlmaWNhdGVzKSBzbyBub3JtYWxpemVcbiAgICAgICAgLy8gYnkgYWx3YXlzIHB1dHRpbmcgcGFyZW50cyBpbnRvIGFuIGFycmF5XG4gICAgICAgIC8vIFRPRE86IHRoZXJlJ3MgbWF5IGJlIGFuIGV4dHJlbWUgZGVnZW5lcmF0ZSBjYXNlIGN1cnJlbnRseSB1bmNvdmVyZWRcbiAgICAgICAgLy8gd2hlcmUgYW4gb2xkIGludGVybWVkaWF0ZSBjZXJ0aWZpY2F0ZSBzZWVtcyB0byBoYXZlIGEgbWF0Y2hpbmcgcGFyZW50XG4gICAgICAgIC8vIGJ1dCBub25lIG9mIHRoZSBwYXJlbnRzIGFjdHVhbGx5IHZlcmlmeSAuLi4gYnV0IHRoZSBpbnRlcm1lZGlhdGVcbiAgICAgICAgLy8gaXMgaW4gdGhlIENBIGFuZCBpdCBzaG91bGQgcGFzcyB0aGlzIGNoZWNrOyBuZWVkcyBpbnZlc3RpZ2F0aW9uXG4gICAgICAgIHZhciBwYXJlbnRzID0gcGFyZW50O1xuICAgICAgICBpZighZm9yZ2UudXRpbC5pc0FycmF5KHBhcmVudHMpKSB7XG4gICAgICAgICAgcGFyZW50cyA9IFtwYXJlbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byB2ZXJpZnkgd2l0aCBlYWNoIHBvc3NpYmxlIHBhcmVudCAodHlwaWNhbGx5IG9ubHkgb25lKVxuICAgICAgICB2YXIgdmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUoIXZlcmlmaWVkICYmIHBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudHMuc2hpZnQoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmVyaWZpZWQgPSBwYXJlbnQudmVyaWZ5KGNlcnQpO1xuICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgIC8vIGZhaWx1cmUgdG8gdmVyaWZ5LCBkb24ndCBjYXJlIHdoeSwgdHJ5IG5leHQgb25lXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgZXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgc2lnbmF0dXJlIGlzIGludmFsaWQuJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpICYmXG4gICAgICAgICFjYVN0b3JlLmhhc0NlcnRpZmljYXRlKGNlcnQpKSB7XG4gICAgICAgIC8vIG5vIHBhcmVudCBpc3N1ZXIgYW5kIGNlcnRpZmljYXRlIGl0c2VsZiBpcyBub3QgdHJ1c3RlZFxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnQ2VydGlmaWNhdGUgaXMgbm90IHRydXN0ZWQuJyxcbiAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IudW5rbm93bl9jYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IDMuIGNoZWNrIHJldm9rZWRcblxuICAgIC8vIDQuIGNoZWNrIGZvciBtYXRjaGluZyBpc3N1ZXIvc3ViamVjdFxuICAgIGlmKGVycm9yID09PSBudWxsICYmIHBhcmVudCAmJiAhY2VydC5pc0lzc3VlcihwYXJlbnQpKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGlzc3VlclxuICAgICAgZXJyb3IgPSB7XG4gICAgICAgIG1lc3NhZ2U6ICdDZXJ0aWZpY2F0ZSBpc3N1ZXIgaXMgaW52YWxpZC4nLFxuICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIDUuIFRPRE86IGNoZWNrIG5hbWVzIHdpdGggcGVybWl0dGVkIG5hbWVzIHRyZWVcblxuICAgIC8vIDYuIFRPRE86IGNoZWNrIG5hbWVzIGFnYWluc3QgZXhjbHVkZWQgbmFtZXMgdHJlZVxuXG4gICAgLy8gNy4gY2hlY2sgZm9yIHVuc3VwcG9ydGVkIGNyaXRpY2FsIGV4dGVuc2lvbnNcbiAgICBpZihlcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gc3VwcG9ydGVkIGV4dGVuc2lvbnNcbiAgICAgIHZhciBzZSA9IHtcbiAgICAgICAga2V5VXNhZ2U6IHRydWUsXG4gICAgICAgIGJhc2ljQ29uc3RyYWludHM6IHRydWVcbiAgICAgIH07XG4gICAgICBmb3IodmFyIGkgPSAwOyBlcnJvciA9PT0gbnVsbCAmJiBpIDwgY2VydC5leHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBleHQgPSBjZXJ0LmV4dGVuc2lvbnNbaV07XG4gICAgICAgIGlmKGV4dC5jcml0aWNhbCAmJiAhKGV4dC5uYW1lIGluIHNlKSkge1xuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGhhcyBhbiB1bnN1cHBvcnRlZCBjcml0aWNhbCBleHRlbnNpb24uJyxcbiAgICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci51bnN1cHBvcnRlZF9jZXJ0aWZpY2F0ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA4LiBjaGVjayBmb3IgQ0EgaWYgY2VydCBpcyBub3QgZmlyc3Qgb3IgaXMgdGhlIG9ubHkgY2VydGlmaWNhdGVcbiAgICAvLyByZW1haW5pbmcgaW4gY2hhaW4gd2l0aCBubyBwYXJlbnQgb3IgaXMgc2VsZi1zaWduZWRcbiAgICBpZihlcnJvciA9PT0gbnVsbCAmJlxuICAgICAgKCFmaXJzdCB8fCAoY2hhaW4ubGVuZ3RoID09PSAwICYmICghcGFyZW50IHx8IHNlbGZTaWduZWQpKSkpIHtcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGtleVVzYWdlIGV4dGVuc2lvbiBhbmQgdGhlbiBiYXNpYyBjb25zdHJhaW50c1xuICAgICAgdmFyIGJjRXh0ID0gY2VydC5nZXRFeHRlbnNpb24oJ2Jhc2ljQ29uc3RyYWludHMnKTtcbiAgICAgIHZhciBrZXlVc2FnZUV4dCA9IGNlcnQuZ2V0RXh0ZW5zaW9uKCdrZXlVc2FnZScpO1xuICAgICAgaWYoa2V5VXNhZ2VFeHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8ga2V5Q2VydFNpZ24gbXVzdCBiZSB0cnVlIGFuZCB0aGVyZSBtdXN0IGJlIGEgYmFzaWNcbiAgICAgICAgLy8gY29uc3RyYWludHMgZXh0ZW5zaW9uXG4gICAgICAgIGlmKCFrZXlVc2FnZUV4dC5rZXlDZXJ0U2lnbiB8fCBiY0V4dCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGtleVVzYWdlIG9yIGJhc2ljQ29uc3RyYWludHMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAgICdvciBpbmRpY2F0ZSB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSBpcyBub3QgYSBDQS4gJyArXG4gICAgICAgICAgICAgICdJZiB0aGUgY2VydGlmaWNhdGUgaXMgdGhlIG9ubHkgb25lIGluIHRoZSBjaGFpbiBvciAnICtcbiAgICAgICAgICAgICAgJ2lzblxcJ3QgdGhlIGZpcnN0IHRoZW4gdGhlIGNlcnRpZmljYXRlIG11c3QgYmUgYSAnICtcbiAgICAgICAgICAgICAgJ3ZhbGlkIENBLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYmFzaWMgY29uc3RyYWludHMgY0EgZmxhZyBtdXN0IGJlIHNldFxuICAgICAgaWYoZXJyb3IgPT09IG51bGwgJiYgYmNFeHQgIT09IG51bGwgJiYgIWJjRXh0LmNBKSB7XG4gICAgICAgIC8vIGJhZCBjZXJ0aWZpY2F0ZVxuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ0NlcnRpZmljYXRlIGJhc2ljQ29uc3RyYWludHMgaW5kaWNhdGVzIHRoZSBjZXJ0aWZpY2F0ZSAnICtcbiAgICAgICAgICAgICdpcyBub3QgYSBDQS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGVycm9yIGlzIG5vdCBudWxsIGFuZCBrZXlVc2FnZSBpcyBhdmFpbGFibGUsIHRoZW4gd2Uga25vdyBpdFxuICAgICAgLy8gaGFzIGtleUNlcnRTaWduIGFuZCB0aGVyZSBpcyBhIGJhc2ljIGNvbnN0cmFpbnRzIGV4dGVuc2lvbiB0b28sXG4gICAgICAvLyB3aGljaCBtZWFucyB3ZSBjYW4gY2hlY2sgcGF0aExlbkNvbnN0cmFpbnQgKGlmIGl0IGV4aXN0cylcbiAgICAgIGlmKGVycm9yID09PSBudWxsICYmIGtleVVzYWdlRXh0ICE9PSBudWxsICYmXG4gICAgICAgICdwYXRoTGVuQ29uc3RyYWludCcgaW4gYmNFeHQpIHtcbiAgICAgICAgLy8gcGF0aExlbiBpcyB0aGUgbWF4aW11bSAjIG9mIGludGVybWVkaWF0ZSBDQSBjZXJ0cyB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBmb3VuZCBiZXR3ZWVuIHRoZSBjdXJyZW50IGNlcnRpZmljYXRlIGFuZCB0aGUgZW5kLWVudGl0eSAoZGVwdGggMClcbiAgICAgICAgLy8gY2VydGlmaWNhdGU7IHRoaXMgbnVtYmVyIGRvZXMgbm90IGluY2x1ZGUgdGhlIGVuZC1lbnRpdHkgKGRlcHRoIDAsXG4gICAgICAgIC8vIGxhc3QgaW4gdGhlIGNoYWluKSBldmVuIGlmIGl0IGhhcHBlbnMgdG8gYmUgYSBDQSBjZXJ0aWZpY2F0ZSBpdHNlbGZcbiAgICAgICAgdmFyIHBhdGhMZW4gPSBkZXB0aCAtIDE7XG4gICAgICAgIGlmKHBhdGhMZW4gPiBiY0V4dC5wYXRoTGVuQ29uc3RyYWludCkge1xuICAgICAgICAgIC8vIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLCBiYWQgY2VydGlmaWNhdGVcbiAgICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdDZXJ0aWZpY2F0ZSBiYXNpY0NvbnN0cmFpbnRzIHBhdGhMZW5Db25zdHJhaW50IHZpb2xhdGVkLicsXG4gICAgICAgICAgICBlcnJvcjogcGtpLmNlcnRpZmljYXRlRXJyb3IuYmFkX2NlcnRpZmljYXRlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGwgYXBwbGljYXRpb24gY2FsbGJhY2tcbiAgICB2YXIgdmZkID0gKGVycm9yID09PSBudWxsKSA/IHRydWUgOiBlcnJvci5lcnJvcjtcbiAgICB2YXIgcmV0ID0gb3B0aW9ucy52ZXJpZnkgPyBvcHRpb25zLnZlcmlmeSh2ZmQsIGRlcHRoLCBjZXJ0cykgOiB2ZmQ7XG4gICAgaWYocmV0ID09PSB0cnVlKSB7XG4gICAgICAvLyBjbGVhciBhbnkgc2V0IGVycm9yXG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHBhc3NlZCBiYXNpYyB0ZXN0cywgc2V0IGRlZmF1bHQgbWVzc2FnZSBhbmQgYWxlcnRcbiAgICAgIGlmKHZmZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlcnJvciA9IHtcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIGFwcGxpY2F0aW9uIHJlamVjdGVkIHRoZSBjZXJ0aWZpY2F0ZS4nLFxuICAgICAgICAgIGVycm9yOiBwa2kuY2VydGlmaWNhdGVFcnJvci5iYWRfY2VydGlmaWNhdGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGN1c3RvbSBlcnJvciBpbmZvXG4gICAgICBpZihyZXQgfHwgcmV0ID09PSAwKSB7XG4gICAgICAgIC8vIHNldCBjdXN0b20gbWVzc2FnZSBhbmQgZXJyb3JcbiAgICAgICAgaWYodHlwZW9mIHJldCA9PT0gJ29iamVjdCcgJiYgIWZvcmdlLnV0aWwuaXNBcnJheShyZXQpKSB7XG4gICAgICAgICAgaWYocmV0Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSByZXQubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmV0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5lcnJvciA9IHJldC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHNldCBjdXN0b20gZXJyb3JcbiAgICAgICAgICBlcnJvci5lcnJvciA9IHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvclxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gbm8gbG9uZ2VyIGZpcnN0IGNlcnQgaW4gY2hhaW5cbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgICsrZGVwdGg7XG4gIH0gd2hpbGUoY2hhaW4ubGVuZ3RoID4gMCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBfY3VycnkxID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTFcIik7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IGZvclxuICogbm9uLXByaW1pdGl2ZXMgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGtub3duIGFzIGBjb25zdGAsIGBjb25zdGFudGAsIG9yIGBLYCAoZm9yIEsgY29tYmluYXRvcikgaW5cbiAqIG90aGVyIGxhbmd1YWdlcyBhbmQgbGlicmFyaWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6ICogLT4gdmFsLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gKiAgICAgIHQoKTsgLy89PiAnVGVlJ1xuICovXG5cblxudmFyIGFsd2F5cyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGFsd2F5cyh2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWx3YXlzOyIsInZhciBfYXJpdHkgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2FyaXR5XCIpO1xuXG52YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkyXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyBib3VuZCB0byBhIGNvbnRleHQuXG4gKiBOb3RlOiBgUi5iaW5kYCBkb2VzIG5vdCBwcm92aWRlIHRoZSBhZGRpdGlvbmFsIGFyZ3VtZW50LWJpbmRpbmcgY2FwYWJpbGl0aWVzIG9mXG4gKiBbRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL2JpbmQpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgqIC0+ICopIC0+IHsqfSAtPiAoKiAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJpbmQgdG8gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNPYmogVGhlIGNvbnRleHQgdG8gYmluZCBgZm5gIHRvXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBpbiB0aGUgY29udGV4dCBvZiBgdGhpc09iamAuXG4gKiBAc2VlIFIucGFydGlhbFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGxvZyA9IFIuYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gKiAgICAgIFIucGlwZShSLmFzc29jKCdhJywgMiksIFIudGFwKGxvZyksIFIuYXNzb2MoJ2EnLCAzKSkoe2E6IDF9KTsgLy89PiB7YTogM31cbiAqICAgICAgLy8gbG9ncyB7YTogMn1cbiAqIEBzeW1iIFIuYmluZChmLCBvKShhLCBiKSA9IGYuY2FsbChvLCBhLCBiKVxuICovXG5cblxudmFyIGJpbmQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBiaW5kKGZuLCB0aGlzT2JqKSB7XG4gIHJldHVybiBfYXJpdHkoZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNPYmosIGFyZ3VtZW50cyk7XG4gIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZDsiLCJ2YXIgX2FyaXR5ID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19hcml0eVwiKTtcblxudmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MVwiKTtcblxudmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MlwiKTtcblxudmFyIF9jdXJyeU4gPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5TlwiKTtcbi8qKlxuICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlIHNwZWNpZmllZFxuICogYXJpdHkuIFRoZSBjdXJyaWVkIGZ1bmN0aW9uIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHNcbiAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSkoMikoMylgXG4gKiAgIC0gYGcoMSkoMiwgMylgXG4gKiAgIC0gYGcoMSwgMikoMylgXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKlxuICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIFtgUi5fX2BdKCNfXykgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBbYFIuX19gXSgjX18pLFxuICogdGhlIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3Qgc3VtQXJncyA9ICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKTtcbiAqXG4gKiAgICAgIGNvbnN0IGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICogICAgICBjb25zdCBmID0gY3VycmllZEFkZEZvdXJOdW1iZXJzKDEsIDIpO1xuICogICAgICBjb25zdCBnID0gZigzKTtcbiAqICAgICAgZyg0KTsgLy89PiAxMFxuICovXG5cblxudmFyIGN1cnJ5TiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGN1cnJ5TihsZW5ndGgsIGZuKSB7XG4gIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gX2N1cnJ5MShmbik7XG4gIH1cblxuICByZXR1cm4gX2FyaXR5KGxlbmd0aCwgX2N1cnJ5TihsZW5ndGgsIFtdLCBmbikpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY3VycnlOOyIsInZhciBfY3VycnkyID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTJcIik7XG4vKipcbiAqIFJldHVybnMgdGhlIHNlY29uZCBhcmd1bWVudCBpZiBpdCBpcyBub3QgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYDtcbiAqIG90aGVyd2lzZSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHthfSBkZWZhdWx0IFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtifSB2YWwgYHZhbGAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBkZWZhdWx0YCB1bmxlc3MgYHZhbGAgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCBvciBgTmFOYC5cbiAqIEByZXR1cm4geyp9IFRoZSBzZWNvbmQgdmFsdWUgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmAsIG90aGVyd2lzZSB0aGUgZGVmYXVsdCB2YWx1ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGRlZmF1bHRUbzQyID0gUi5kZWZhdWx0VG8oNDIpO1xuICpcbiAqICAgICAgZGVmYXVsdFRvNDIobnVsbCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKHVuZGVmaW5lZCk7ICAvLz0+IDQyXG4gKiAgICAgIGRlZmF1bHRUbzQyKGZhbHNlKTsgIC8vPT4gZmFsc2VcbiAqICAgICAgZGVmYXVsdFRvNDIoJ1JhbWRhJyk7ICAvLz0+ICdSYW1kYSdcbiAqICAgICAgLy8gcGFyc2VJbnQoJ3N0cmluZycpIHJlc3VsdHMgaW4gTmFOXG4gKiAgICAgIGRlZmF1bHRUbzQyKHBhcnNlSW50KCdzdHJpbmcnKSk7IC8vPT4gNDJcbiAqL1xuXG5cbnZhciBkZWZhdWx0VG8gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBkZWZhdWx0VG8oZCwgdikge1xuICByZXR1cm4gdiA9PSBudWxsIHx8IHYgIT09IHYgPyBkIDogdjtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRUbzsiLCJ2YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkyXCIpO1xuXG52YXIgX2VxdWFscyA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fZXF1YWxzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBlcXVpdmFsZW50LCBgZmFsc2VgIG90aGVyd2lzZS4gSGFuZGxlc1xuICogY3ljbGljYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIERpc3BhdGNoZXMgc3ltbWV0cmljYWxseSB0byB0aGUgYGVxdWFsc2AgbWV0aG9kcyBvZiBib3RoIGFyZ3VtZW50cywgaWZcbiAqIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmVxdWFscygxLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZXF1YWxzKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5lcXVhbHMoWzEsIDIsIDNdLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqXG4gKiAgICAgIGNvbnN0IGEgPSB7fTsgYS52ID0gYTtcbiAqICAgICAgY29uc3QgYiA9IHt9OyBiLnYgPSBiO1xuICogICAgICBSLmVxdWFscyhhLCBiKTsgLy89PiB0cnVlXG4gKi9cblxuXG52YXIgZXF1YWxzID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgW10sIFtdKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsczsiLCJ2YXIgX2N1cnJ5MSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkxXCIpO1xuXG52YXIgY3VycnlOID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2N1cnJ5TlwiKTtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiBtdWNoIGxpa2UgdGhlIHN1cHBsaWVkIG9uZSwgZXhjZXB0IHRoYXQgdGhlIGZpcnN0IHR3b1xuICogYXJndW1lbnRzJyBvcmRlciBpcyByZXZlcnNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIsIGMsIC4uLikgLT4geikgLT4gKGIgLT4gYSAtPiBjIC0+IC4uLiAtPiB6KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZSB3aXRoIGl0cyBmaXJzdCB0d28gcGFyYW1ldGVycyByZXZlcnNlZC5cbiAqIEByZXR1cm4geyp9IFRoZSByZXN1bHQgb2YgaW52b2tpbmcgYGZuYCB3aXRoIGl0cyBmaXJzdCB0d28gcGFyYW1ldGVycycgb3JkZXIgcmV2ZXJzZWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbWVyZ2VUaHJlZSA9IChhLCBiLCBjKSA9PiBbXS5jb25jYXQoYSwgYiwgYyk7XG4gKlxuICogICAgICBtZXJnZVRocmVlKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCAzXVxuICpcbiAqICAgICAgUi5mbGlwKG1lcmdlVGhyZWUpKDEsIDIsIDMpOyAvLz0+IFsyLCAxLCAzXVxuICogQHN5bWIgUi5mbGlwKGYpKGEsIGIsIGMpID0gZihiLCBhLCBjKVxuICovXG5cblxudmFyIGZsaXAgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBmbGlwKGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzWzBdID0gYjtcbiAgICBhcmdzWzFdID0gYTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gIH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmxpcDsiLCJ2YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkyXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndGUoMiwgMik7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndGUoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAqL1xuXG5cbnZhciBndGUgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBndGUoYSwgYikge1xuICByZXR1cm4gYSA+PSBiO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ3RlOyIsInZhciBfY3VycnkzID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTNcIik7XG5cbnZhciBjdXJyeU4gPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vY3VycnlOXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gKiBmdW5jdGlvbiBkZXBlbmRpbmcgdXBvbiB0aGUgcmVzdWx0IG9mIHRoZSBgY29uZGl0aW9uYCBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKikgLT4gKCouLi4gLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvbiBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25UcnVlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uRmFsc2UgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYGNvbmRpdGlvbmAgZXZhbHVhdGVzIHRvIGEgZmFsc3kgdmFsdWUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIHByb2Nlc3MgZWl0aGVyIHRoZSBgb25UcnVlYCBvciB0aGUgYG9uRmFsc2VgXG4gKiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICogQHNlZSBSLnVubGVzcywgUi53aGVuLCBSLmNvbmRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpbmNDb3VudCA9IFIuaWZFbHNlKFxuICogICAgICAgIFIuaGFzKCdjb3VudCcpLFxuICogICAgICAgIFIub3ZlcihSLmxlbnNQcm9wKCdjb3VudCcpLCBSLmluYyksXG4gKiAgICAgICAgUi5hc3NvYygnY291bnQnLCAxKVxuICogICAgICApO1xuICogICAgICBpbmNDb3VudCh7fSk7ICAgICAgICAgICAvLz0+IHsgY291bnQ6IDEgfVxuICogICAgICBpbmNDb3VudCh7IGNvdW50OiAxIH0pOyAvLz0+IHsgY291bnQ6IDIgfVxuICovXG5cblxudmFyIGlmRWxzZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIGlmRWxzZShjb25kaXRpb24sIG9uVHJ1ZSwgb25GYWxzZSkge1xuICByZXR1cm4gY3VycnlOKE1hdGgubWF4KGNvbmRpdGlvbi5sZW5ndGgsIG9uVHJ1ZS5sZW5ndGgsIG9uRmFsc2UubGVuZ3RoKSwgZnVuY3Rpb24gX2lmRWxzZSgpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBvblRydWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9uRmFsc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpZkVsc2U7IiwidmFyIF9pbmNsdWRlcyA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9faW5jbHVkZXNcIik7XG5cbnZhciBfY3VycnkyID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTJcIik7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZXF1YWwsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIHRvIGF0IGxlYXN0IG9uZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIFdvcmtzIGFsc28gd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBpdGVtIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGFuIGVxdWl2YWxlbnQgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbmNsdWRlcygzLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5pbmNsdWRlcyg0LCBbMSwgMiwgM10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaW5jbHVkZXMoeyBuYW1lOiAnRnJlZCcgfSwgW3sgbmFtZTogJ0ZyZWQnIH1dKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaW5jbHVkZXMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaW5jbHVkZXMoJ2JhJywgJ2JhbmFuYScpOyAvLz0+dHJ1ZVxuICovXG5cblxudmFyIGluY2x1ZGVzID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoX2luY2x1ZGVzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbmNsdWRlczsiLCJmdW5jdGlvbiBfYXJpdHkobiwgZm4pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJpdHk7IiwiZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgdmFyIG5leHQ7XG5cbiAgd2hpbGUgKCEobmV4dCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgbGlzdC5wdXNoKG5leHQudmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5RnJvbUl0ZXJhdG9yOyIsInZhciBfaXNBcnJheSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9faXNBcnJheVwiKTtcbi8qKlxuICogVGhpcyBjaGVja3Mgd2hldGhlciBhIGZ1bmN0aW9uIGhhcyBhIFttZXRob2RuYW1lXSBmdW5jdGlvbi4gSWYgaXQgaXNuJ3QgYW5cbiAqIGFycmF5IGl0IHdpbGwgZXhlY3V0ZSB0aGF0IGZ1bmN0aW9uIG90aGVyd2lzZSBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIHJhbWRhXG4gKiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcmFtZGEgaW1wbGVtdGF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kbmFtZSBwcm9wZXJ0eSB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge09iamVjdH0gV2hhdGV2ZXIgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbWV0aG9kIGlzLlxuICovXG5cblxuZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmpbbWV0aG9kbmFtZV0gIT09ICdmdW5jdGlvbicgPyBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NoZWNrRm9yTWV0aG9kOyIsIi8qKlxuICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IFtzZXQyPVtdXSBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgbWVyZ2VkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgc2V0MSA9IHNldDEgfHwgW107XG4gIHNldDIgPSBzZXQyIHx8IFtdO1xuICB2YXIgaWR4O1xuICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbjEpIHtcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICBpZHggPSAwO1xuXG4gIHdoaWxlIChpZHggPCBsZW4yKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uY2F0OyIsInZhciBfaXNQbGFjZWhvbGRlciA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9faXNQbGFjZWhvbGRlclwiKTtcbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTE7IiwidmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2N1cnJ5MVwiKTtcblxudmFyIF9pc1BsYWNlaG9sZGVyID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19pc1BsYWNlaG9sZGVyXCIpO1xuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdHdvLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIF9jdXJyeTIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGYyKGEsIGIpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGYyO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYyIDogX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjIgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iKTtcbiAgICAgICAgfSkgOiBmbihhLCBiKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MjsiLCJ2YXIgX2N1cnJ5MSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9fY3VycnkxXCIpO1xuXG52YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9fY3VycnkyXCIpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2lzUGxhY2Vob2xkZXJcIik7XG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBfY3VycnkzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMyhhLCBiLCBjKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgPyBmMyA6IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYiwgX2MpO1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfY3VycnkxKGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBiLCBfYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmMyA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBfYiwgYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYSwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9iLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYiwgX2MpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgX2MpO1xuICAgICAgICB9KSA6IGZuKGEsIGIsIGMpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzOyIsInZhciBfYXJpdHkgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2FyaXR5XCIpO1xuXG52YXIgX2lzUGxhY2Vob2xkZXIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2lzUGxhY2Vob2xkZXJcIik7XG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIF9jdXJyeU4obGVuZ3RoLCByZWNlaXZlZCwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tYmluZWQgPSBbXTtcbiAgICB2YXIgYXJnc0lkeCA9IDA7XG4gICAgdmFyIGxlZnQgPSBsZW5ndGg7XG4gICAgdmFyIGNvbWJpbmVkSWR4ID0gMDtcblxuICAgIHdoaWxlIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCB8fCBhcmdzSWR4IDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoICYmICghX2lzUGxhY2Vob2xkZXIocmVjZWl2ZWRbY29tYmluZWRJZHhdKSB8fCBhcmdzSWR4ID49IGFyZ3VtZW50cy5sZW5ndGgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2VpdmVkW2NvbWJpbmVkSWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1thcmdzSWR4XTtcbiAgICAgICAgYXJnc0lkeCArPSAxO1xuICAgICAgfVxuXG4gICAgICBjb21iaW5lZFtjb21iaW5lZElkeF0gPSByZXN1bHQ7XG5cbiAgICAgIGlmICghX2lzUGxhY2Vob2xkZXIocmVzdWx0KSkge1xuICAgICAgICBsZWZ0IC09IDE7XG4gICAgICB9XG5cbiAgICAgIGNvbWJpbmVkSWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKSA6IF9hcml0eShsZWZ0LCBfY3VycnlOKGxlbmd0aCwgY29tYmluZWQsIGZuKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5TjsiLCJ2YXIgX2lzQXJyYXkgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2lzQXJyYXlcIik7XG5cbnZhciBfaXNUcmFuc2Zvcm1lciA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9faXNUcmFuc2Zvcm1lclwiKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyB3aXRoIGRpZmZlcmVudCBzdHJhdGVnaWVzIGJhc2VkIG9uIHRoZVxuICogb2JqZWN0IGluIGxpc3QgcG9zaXRpb24gKGxhc3QgYXJndW1lbnQpLiBJZiBpdCBpcyBhbiBhcnJheSwgZXhlY3V0ZXMgW2ZuXS5cbiAqIE90aGVyd2lzZSwgaWYgaXQgaGFzIGEgZnVuY3Rpb24gd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG1ldGhvZCBuYW1lcywgaXQgd2lsbFxuICogZXhlY3V0ZSB0aGF0IGZ1bmN0aW9uIChmdW5jdG9yIGNhc2UpLiBPdGhlcndpc2UsIGlmIGl0IGlzIGEgdHJhbnNmb3JtZXIsXG4gKiB1c2VzIHRyYW5zZHVjZXIgW3hmXSB0byByZXR1cm4gYSBuZXcgdHJhbnNmb3JtZXIgKHRyYW5zZHVjZXIgY2FzZSkuXG4gKiBPdGhlcndpc2UsIGl0IHdpbGwgZGVmYXVsdCB0byBleGVjdXRpbmcgW2ZuXS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gbWV0aG9kTmFtZXMgcHJvcGVydGllcyB0byBjaGVjayBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHhmIHRyYW5zZHVjZXIgdG8gaW5pdGlhbGl6ZSBpZiBvYmplY3QgaXMgdHJhbnNmb3JtZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGRlZmF1bHQgcmFtZGEgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyBvbiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvblxuICovXG5cblxuZnVuY3Rpb24gX2Rpc3BhdGNoYWJsZShtZXRob2ROYW1lcywgeGYsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB2YXIgb2JqID0gYXJncy5wb3AoKTtcblxuICAgIGlmICghX2lzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgIHdoaWxlIChpZHggPCBtZXRob2ROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZE5hbWVzW2lkeF1dLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZHggKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgICAgdmFyIHRyYW5zZHVjZXIgPSB4Zi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZHVjZXIob2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGlzcGF0Y2hhYmxlOyIsInZhciBfYXJyYXlGcm9tSXRlcmF0b3IgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2FycmF5RnJvbUl0ZXJhdG9yXCIpO1xuXG52YXIgX2luY2x1ZGVzV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9faW5jbHVkZXNXaXRoXCIpO1xuXG52YXIgX2Z1bmN0aW9uTmFtZSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9fZnVuY3Rpb25OYW1lXCIpO1xuXG52YXIgX2hhcyA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9faGFzXCIpO1xuXG52YXIgX29iamVjdElzID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19vYmplY3RJc1wiKTtcblxudmFyIGtleXMgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4uL2tleXNcIik7XG5cbnZhciB0eXBlID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuLi90eXBlXCIpO1xuLyoqXG4gKiBwcml2YXRlIF91bmlxQ29udGVudEVxdWFscyBmdW5jdGlvbi5cbiAqIFRoYXQgZnVuY3Rpb24gaXMgY2hlY2tpbmcgZXF1YWxpdHkgb2YgMiBpdGVyYXRvciBjb250ZW50cyB3aXRoIDIgYXNzdW1wdGlvbnNcbiAqIC0gaXRlcmF0b3JzIGxlbmd0aHMgYXJlIHRoZSBzYW1lXG4gKiAtIGl0ZXJhdG9ycyB2YWx1ZXMgYXJlIHVuaXF1ZVxuICpcbiAqIGZhbHNlLXBvc2l0aXZlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGZvciBjb21wYXJpc2lvbiBvZiwgZS5nLlxuICogLSBbMSwyLDNdIGFuZCBbMSwyLDMsNF1cbiAqIC0gWzEsMSwxXSBhbmQgWzEsMiwzXVxuICogKi9cblxuXG5mdW5jdGlvbiBfdW5pcUNvbnRlbnRFcXVhbHMoYUl0ZXJhdG9yLCBiSXRlcmF0b3IsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBhID0gX2FycmF5RnJvbUl0ZXJhdG9yKGFJdGVyYXRvcik7XG5cbiAgdmFyIGIgPSBfYXJyYXlGcm9tSXRlcmF0b3IoYkl0ZXJhdG9yKTtcblxuICBmdW5jdGlvbiBlcShfYSwgX2IpIHtcbiAgICByZXR1cm4gX2VxdWFscyhfYSwgX2IsIHN0YWNrQS5zbGljZSgpLCBzdGFja0Iuc2xpY2UoKSk7XG4gIH0gLy8gaWYgKmEqIGFycmF5IGNvbnRhaW5zIGFueSBlbGVtZW50IHRoYXQgaXMgbm90IGluY2x1ZGVkIGluICpiKlxuXG5cbiAgcmV0dXJuICFfaW5jbHVkZXNXaXRoKGZ1bmN0aW9uIChiLCBhSXRlbSkge1xuICAgIHJldHVybiAhX2luY2x1ZGVzV2l0aChlcSwgYUl0ZW0sIGIpO1xuICB9LCBiLCBhKTtcbn1cblxuZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAoX29iamVjdElzKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdHlwZUEgPSB0eXBlKGEpO1xuXG4gIGlmICh0eXBlQSAhPT0gdHlwZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlb2YgYVsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGFbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShiKSAmJiB0eXBlb2YgYlsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShhKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmVxdWFscyhiKSAmJiB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYi5lcXVhbHMoYSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVBKSB7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgIGlmICh0eXBlb2YgYS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBfZnVuY3Rpb25OYW1lKGEuY29uc3RydWN0b3IpID09PSAnUHJvbWlzZScpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgaWYgKCEodHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIF9vYmplY3RJcyhhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoIV9vYmplY3RJcyhhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG5cbiAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgaWYgKCEoYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJiBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSAmJiBhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUgJiYgYS5zdGlja3kgPT09IGIuc3RpY2t5ICYmIGEudW5pY29kZSA9PT0gYi51bmljb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgcmV0dXJuIHN0YWNrQltpZHhdID09PSBiO1xuICAgIH1cblxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlQSkge1xuICAgIGNhc2UgJ01hcCc6XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3VuaXFDb250ZW50RXF1YWxzKGEuZW50cmllcygpLCBiLmVudHJpZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiXSkpO1xuXG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS52YWx1ZXMoKSwgYi52YWx1ZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiXSkpO1xuXG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVmFsdWVzIG9mIG90aGVyIHR5cGVzIGFyZSBvbmx5IGVxdWFsIGlmIGlkZW50aWNhbC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IGtleXMoYSk7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXh0ZW5kZWRTdGFja0EgPSBzdGFja0EuY29uY2F0KFthXSk7XG4gIHZhciBleHRlbmRlZFN0YWNrQiA9IHN0YWNrQi5jb25jYXQoW2JdKTtcbiAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBleHRlbmRlZFN0YWNrQSwgZXh0ZW5kZWRTdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2VxdWFsczsiLCJmdW5jdGlvbiBfZnVuY3Rpb25OYW1lKGYpIHtcbiAgLy8gU3RyaW5nKHggPT4geCkgZXZhbHVhdGVzIHRvIFwieCA9PiB4XCIsIHNvIHRoZSBwYXR0ZXJuIG1heSBub3QgbWF0Y2guXG4gIHZhciBtYXRjaCA9IFN0cmluZyhmKS5tYXRjaCgvXmZ1bmN0aW9uIChcXHcqKS8pO1xuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Z1bmN0aW9uTmFtZTsiLCJmdW5jdGlvbiBfaGFzKHByb3AsIG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2hhczsiLCJ2YXIgX2luZGV4T2YgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2luZGV4T2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmNsdWRlcyhhLCBsaXN0KSB7XG4gIHJldHVybiBfaW5kZXhPZihsaXN0LCBhLCAwKSA+PSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmNsdWRlczsiLCJmdW5jdGlvbiBfaW5jbHVkZXNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKHByZWQoeCwgbGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luY2x1ZGVzV2l0aDsiLCJ2YXIgZXF1YWxzID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuLi9lcXVhbHNcIik7XG5cbmZ1bmN0aW9uIF9pbmRleE9mKGxpc3QsIGEsIGlkeCkge1xuICB2YXIgaW5mLCBpdGVtOyAvLyBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBkb2Vzbid0IGV4aXN0IGJlbG93IElFOVxuXG4gIGlmICh0eXBlb2YgbGlzdC5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgICAgICAgIGluZiA9IDEgLyBhO1xuXG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gMCAmJiAxIC8gaXRlbSA9PT0gaW5mKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpZHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhICE9PSBhKSB7XG4gICAgICAgICAgLy8gTmFOXG4gICAgICAgICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gbGlzdFtpZHhdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdudW1iZXInICYmIGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IC8vIG5vbi16ZXJvIG51bWJlcnMgY2FuIHV0aWxpc2UgU2V0XG5cblxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG4gICAgICAvLyBhbGwgdGhlc2UgdHlwZXMgY2FuIHV0aWxpc2UgU2V0XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBudWxsIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9IC8vIGFueXRoaW5nIGVsc2Ugbm90IGNvdmVyZWQgYWJvdmUsIGRlZmVyIHRvIFIuZXF1YWxzXG5cblxuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoZXF1YWxzKGxpc3RbaWR4XSwgYSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luZGV4T2Y7IiwidmFyIF9oYXMgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2hhc1wiKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudmFyIF9pc0FyZ3VtZW50cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFyZ3VtZW50cykgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nID8gZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG4gIH0gOiBmdW5jdGlvbiBfaXNBcmd1bWVudHMoeCkge1xuICAgIHJldHVybiBfaGFzKCdjYWxsZWUnLCB4KTtcbiAgfTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBfaXNBcmd1bWVudHM7IiwiLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsYCBpcyBhbiBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXkoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXkoe30pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBfaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGggPj0gMCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07IiwidmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2N1cnJ5MVwiKTtcblxudmFyIF9pc0FycmF5ID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19pc0FycmF5XCIpO1xuXG52YXIgX2lzU3RyaW5nID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19pc1N0cmluZ1wiKTtcbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGlzIHNpbWlsYXIgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGhhcyBhIG51bWVyaWMgbGVuZ3RoIHByb3BlcnR5IGFuZCBleHRyZW1lIGluZGljZXMgZGVmaW5lZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXlMaWtlKFtdKTsgLy89PiB0cnVlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7bGVuZ3RoOiAxMH0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIF9pc0FycmF5TGlrZSh7MDogJ3plcm8nLCA5OiAnbmluZScsIGxlbmd0aDogMTB9KTsgLy89PiB0cnVlXG4gKi9cblxuXG52YXIgX2lzQXJyYXlMaWtlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICBpZiAoX2lzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICgheCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX2lzU3RyaW5nKHgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHgubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gISF4Lmxlbmd0aDtcbiAgfVxuXG4gIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHgubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB4Lmhhc093blByb3BlcnR5KDApICYmIHguaGFzT3duUHJvcGVydHkoeC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc0FycmF5TGlrZTsiLCIvKipcbiAqIERldGVybWluZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGFuIGludGVnZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gblxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBfaXNJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIG4gPDwgMCA9PT0gbjtcbn07IiwiZnVuY3Rpb24gX2lzUGxhY2Vob2xkZXIoYSkge1xuICByZXR1cm4gYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNQbGFjZWhvbGRlcjsiLCJmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNTdHJpbmc7IiwiZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqWydAQHRyYW5zZHVjZXIvc3RlcCddID09PSAnZnVuY3Rpb24nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc1RyYW5zZm9ybWVyOyIsIi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuZnVuY3Rpb24gX29iamVjdElzKGEsIGIpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBfb2JqZWN0SXM7IiwiZnVuY3Rpb24gX3BpcGUoZiwgZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnLmNhbGwodGhpcywgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcGlwZTsiLCJ2YXIgX2lzQXJyYXlMaWtlID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19pc0FycmF5TGlrZVwiKTtcblxudmFyIF94d3JhcCA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9feHdyYXBcIik7XG5cbnZhciBiaW5kID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuLi9iaW5kXCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlSZWR1Y2UoeGYsIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBhY2MgPSB4ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShhY2MsIGxpc3RbaWR4XSk7XG5cbiAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlUmVkdWNlKHhmLCBhY2MsIGl0ZXIpIHtcbiAgdmFyIHN0ZXAgPSBpdGVyLm5leHQoKTtcblxuICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgc3RlcC52YWx1ZSk7XG5cbiAgICBpZiAoYWNjICYmIGFjY1snQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKGFjYyk7XG59XG5cbmZ1bmN0aW9uIF9tZXRob2RSZWR1Y2UoeGYsIGFjYywgb2JqLCBtZXRob2ROYW1lKSB7XG4gIHJldHVybiB4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKG9ialttZXRob2ROYW1lXShiaW5kKHhmWydAQHRyYW5zZHVjZXIvc3RlcCddLCB4ZiksIGFjYykpO1xufVxuXG52YXIgc3ltSXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5pdGVyYXRvciA6ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gX3JlZHVjZShmbiwgYWNjLCBsaXN0KSB7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IF94d3JhcChmbik7XG4gIH1cblxuICBpZiAoX2lzQXJyYXlMaWtlKGxpc3QpKSB7XG4gICAgcmV0dXJuIF9hcnJheVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdFsnZmFudGFzeS1sYW5kL3JlZHVjZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCwgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnKTtcbiAgfVxuXG4gIGlmIChsaXN0W3N5bUl0ZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0W3N5bUl0ZXJhdG9yXSgpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdC5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdC5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21ldGhvZFJlZHVjZShmbiwgYWNjLCBsaXN0LCAncmVkdWNlJyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9yZWR1Y2U7IiwiZnVuY3Rpb24gX3JlZHVjZWQoeCkge1xuICByZXR1cm4geCAmJiB4WydAQHRyYW5zZHVjZXIvcmVkdWNlZCddID8geCA6IHtcbiAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnOiB0cnVlXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3JlZHVjZWQ7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH1cbn07IiwidmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vX2N1cnJ5MlwiKTtcblxudmFyIF9yZWR1Y2VkID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL19yZWR1Y2VkXCIpO1xuXG52YXIgX3hmQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9feGZCYXNlXCIpO1xuXG52YXIgWFRha2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVGFrZShuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLm4gPSBuO1xuICAgIHRoaXMuaSA9IDA7XG4gIH1cblxuICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG5cbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmkgKz0gMTtcbiAgICB2YXIgcmV0ID0gdGhpcy5uID09PSAwID8gcmVzdWx0IDogdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5uID49IDAgJiYgdGhpcy5pID49IHRoaXMubiA/IF9yZWR1Y2VkKHJldCkgOiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIFhUYWtlO1xufSgpO1xuXG52YXIgX3h0YWtlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3h0YWtlKG4sIHhmKSB7XG4gIHJldHVybiBuZXcgWFRha2UobiwgeGYpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX3h0YWtlOyIsInZhciBYV3JhcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhXcmFwKGZuKSB7XG4gICAgdGhpcy5mID0gZm47XG4gIH1cblxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbml0IG5vdCBpbXBsZW1lbnRlZCBvbiBYV3JhcCcpO1xuICB9O1xuXG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKGFjYykge1xuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKGFjYywgeCkge1xuICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgfTtcblxuICByZXR1cm4gWFdyYXA7XG59KCk7XG5cbmZ1bmN0aW9uIF94d3JhcChmbikge1xuICByZXR1cm4gbmV3IFhXcmFwKGZuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfeHdyYXA7IiwidmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MVwiKTtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgeGAgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmlzTmlsKG51bGwpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pc05pbCh1bmRlZmluZWQpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pc05pbCgwKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzTmlsKFtdKTsgLy89PiBmYWxzZVxuICovXG5cblxudmFyIGlzTmlsID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gaXNOaWwoeCkge1xuICByZXR1cm4geCA9PSBudWxsO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOaWw7IiwidmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MVwiKTtcblxudmFyIF9oYXMgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2hhc1wiKTtcblxudmFyIF9pc0FyZ3VtZW50cyA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9faXNBcmd1bWVudHNcIik7IC8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xuXG5cbnZhciBoYXNFbnVtQnVnID0gIVxuLyojX19QVVJFX18qL1xue1xuICB0b1N0cmluZzogbnVsbFxufS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbnZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ2NvbnN0cnVjdG9yJywgJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddOyAvLyBTYWZhcmkgYnVnXG5cbnZhciBoYXNBcmdzRW51bUJ1ZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbn0oKTtcblxudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgaXRlbSkge1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAobGlzdFtpZHhdID09PSBpdGVtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZlxuICogdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLmtleXNJbiwgUi52YWx1ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmtleXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqL1xuXG5cbnZhciBrZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xufSkgOlxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBwcm9wLCBuSWR4O1xuICB2YXIga3MgPSBbXTtcblxuICB2YXIgY2hlY2tBcmdzTGVuZ3RoID0gaGFzQXJnc0VudW1CdWcgJiYgX2lzQXJndW1lbnRzKG9iaik7XG5cbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgKCFjaGVja0FyZ3NMZW5ndGggfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG4gICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzRW51bUJ1Zykge1xuICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG5cbiAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgIH1cblxuICAgICAgbklkeCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrcztcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBrZXlzOyIsInZhciBfY3VycnkyID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTJcIik7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZDtcbiAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZ3RlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sdGUoMiwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdGUoMiwgMik7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0ZSgyLCAzKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHRlKCdhJywgJ3onKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHRlKCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICovXG5cblxudmFyIGx0ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGx0ZShhLCBiKSB7XG4gIHJldHVybiBhIDw9IGI7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsdGU7IiwidmFyIF9jdXJyeTEgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MVwiKTtcbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGAhYCBvZiBpdHMgYXJndW1lbnQuIEl0IHdpbGwgcmV0dXJuIGB0cnVlYCB3aGVuXG4gKiBwYXNzZWQgZmFsc2UteSB2YWx1ZSwgYW5kIGBmYWxzZWAgd2hlbiBwYXNzZWQgYSB0cnV0aC15IG9uZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYSBhbnkgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRoZSBsb2dpY2FsIGludmVyc2Ugb2YgcGFzc2VkIGFyZ3VtZW50LlxuICogQHNlZSBSLmNvbXBsZW1lbnRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm5vdCh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBSLm5vdChmYWxzZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vdCgwKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubm90KDEpOyAvLz0+IGZhbHNlXG4gKi9cblxuXG52YXIgbm90ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gbm90KGEpIHtcbiAgcmV0dXJuICFhO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm90OyIsInZhciBfY3VycnkyID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTJcIik7XG5cbnZhciBfaXNTdHJpbmcgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2lzU3RyaW5nXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gKiBlbGVtZW50IGF0IGluZGV4IGxlbmd0aCArIG4gaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBsaXN0ID0gWydmb28nLCAnYmFyJywgJ2JheicsICdxdXV4J107XG4gKiAgICAgIFIubnRoKDEsIGxpc3QpOyAvLz0+ICdiYXInXG4gKiAgICAgIFIubnRoKC0xLCBsaXN0KTsgLy89PiAncXV1eCdcbiAqICAgICAgUi5udGgoLTk5LCBsaXN0KTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIubnRoKDIsICdhYmMnKTsgLy89PiAnYydcbiAqICAgICAgUi5udGgoMywgJ2FiYycpOyAvLz0+ICcnXG4gKiBAc3ltYiBSLm50aCgtMSwgW2EsIGIsIGNdKSA9IGNcbiAqIEBzeW1iIFIubnRoKDAsIFthLCBiLCBjXSkgPSBhXG4gKiBAc3ltYiBSLm50aCgxLCBbYSwgYiwgY10pID0gYlxuICovXG5cblxudmFyIG50aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG50aChvZmZzZXQsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IG9mZnNldCA8IDAgPyBsaXN0Lmxlbmd0aCArIG9mZnNldCA6IG9mZnNldDtcbiAgcmV0dXJuIF9pc1N0cmluZyhsaXN0KSA/IGxpc3QuY2hhckF0KGlkeCkgOiBsaXN0W2lkeF07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBudGg7IiwidmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MlwiKTtcblxudmFyIHBhdGhzID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL3BhdGhzXCIpO1xuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBbSWR4XSAtPiB7YX0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSBmcm9tLlxuICogQHJldHVybiB7Kn0gVGhlIGRhdGEgYXQgYHBhdGhgLlxuICogQHNlZSBSLnByb3AsIFIubnRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHthOiB7YjogMn19KTsgLy89PiAyXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYiddLCB7Yzoge2I6IDJ9fSk7IC8vPT4gdW5kZWZpbmVkXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYicsIDBdLCB7YToge2I6IFsxLCAyLCAzXX19KTsgLy89PiAxXG4gKiAgICAgIFIucGF0aChbJ2EnLCAnYicsIC0yXSwge2E6IHtiOiBbMSwgMiwgM119fSk7IC8vPT4gMlxuICovXG5cblxudmFyIHBhdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhBciwgb2JqKSB7XG4gIHJldHVybiBwYXRocyhbcGF0aEFyXSwgb2JqKVswXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGg7IiwidmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MlwiKTtcblxudmFyIF9pc0ludGVnZXIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2lzSW50ZWdlclwiKTtcblxudmFyIG50aCA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9udGhcIik7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgdmFsdWVzIGF0IGdpdmVuIHBhdGhzIG9mIGFuIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNy4xXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gW1N0cmluZyB8IEludF1cbiAqIEBzaWcgW0lkeF0gLT4ge2F9IC0+IFthIHwgVW5kZWZpbmVkXVxuICogQHBhcmFtIHtBcnJheX0gcGF0aHNBcnJheSBUaGUgYXJyYXkgb2YgcGF0aHMgdG8gYmUgZmV0Y2hlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnRpZXMgZnJvbS5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3QgY29uc2lzdGluZyBvZiB2YWx1ZXMgYXQgcGF0aHMgc3BlY2lmaWVkIGJ5IFwicGF0aHNBcnJheVwiLlxuICogQHNlZSBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhzKFtbJ2EnLCAnYiddLCBbJ3AnLCAwLCAncSddXSwge2E6IHtiOiAyfSwgcDogW3txOiAzfV19KTsgLy89PiBbMiwgM11cbiAqICAgICAgUi5wYXRocyhbWydhJywgJ2InXSwgWydwJywgJ3InXV0sIHthOiB7YjogMn0sIHA6IFt7cTogM31dfSk7IC8vPT4gWzIsIHVuZGVmaW5lZF1cbiAqL1xuXG5cbnZhciBwYXRocyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHBhdGhzKHBhdGhzQXJyYXksIG9iaikge1xuICByZXR1cm4gcGF0aHNBcnJheS5tYXAoZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgdmFyIHZhbCA9IG9iajtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcDtcblxuICAgIHdoaWxlIChpZHggPCBwYXRocy5sZW5ndGgpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHAgPSBwYXRoc1tpZHhdO1xuICAgICAgdmFsID0gX2lzSW50ZWdlcihwKSA/IG50aChwLCB2YWwpIDogdmFsW3BdO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoczsiLCJ2YXIgX2FyaXR5ID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19hcml0eVwiKTtcblxudmFyIF9waXBlID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19waXBlXCIpO1xuXG52YXIgcmVkdWNlID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL3JlZHVjZVwiKTtcblxudmFyIHRhaWwgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vdGFpbFwiKTtcbi8qKlxuICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBmdW5jdGlvbiBjb21wb3NpdGlvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IG1heSBoYXZlXG4gKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgYXJndW1lbnRzIG11c3QgYmUgdW5hcnkuXG4gKlxuICogSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgc2VxdWVuY2VgLlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIHBpcGUgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKChhLCBiLCAuLi4sIG4pIC0+IG8pLCAobyAtPiBwKSwgLi4uLCAoeCAtPiB5KSwgKHkgLT4geikpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5jb21wb3NlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAqXG4gKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAqIEBzeW1iIFIucGlwZShmLCBnLCBoKShhLCBiKSA9IGgoZyhmKGEsIGIpKSlcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGUoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIF9hcml0eShhcmd1bWVudHNbMF0ubGVuZ3RoLCByZWR1Y2UoX3BpcGUsIGFyZ3VtZW50c1swXSwgdGFpbChhcmd1bWVudHMpKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZTsiLCJ2YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkyXCIpO1xuXG52YXIgcGF0aCA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9wYXRoXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIHN1cHBsaWVkIGFuIG9iamVjdCByZXR1cm5zIHRoZSBpbmRpY2F0ZWRcbiAqIHByb3BlcnR5IG9mIHRoYXQgb2JqZWN0LCBpZiBpdCBleGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIElkeCAtPiB7czogYX0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwIFRoZSBwcm9wZXJ0eSBuYW1lIG9yIGFycmF5IGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnlcbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBhdCBgb2JqLnBgLlxuICogQHNlZSBSLnBhdGgsIFIubnRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9wKCd4Jywge3g6IDEwMH0pOyAvLz0+IDEwMFxuICogICAgICBSLnByb3AoJ3gnLCB7fSk7IC8vPT4gdW5kZWZpbmVkXG4gKiAgICAgIFIucHJvcCgwLCBbMTAwXSk7IC8vPT4gMTAwXG4gKiAgICAgIFIuY29tcG9zZShSLmluYywgUi5wcm9wKCd4JykpKHsgeDogMyB9KSAvLz0+IDRcbiAqL1xuXG5cbnZhciBwcm9wID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gcHJvcChwLCBvYmopIHtcbiAgcmV0dXJuIHBhdGgoW3BdLCBvYmopO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcDsiLCJ2YXIgX2N1cnJ5MyA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkzXCIpO1xuXG52YXIgX3JlZHVjZSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fcmVkdWNlXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nXG4gKiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICooYWNjLCB2YWx1ZSkqLiBJdCBtYXkgdXNlXG4gKiBbYFIucmVkdWNlZGBdKCNyZWR1Y2VkKSB0byBzaG9ydGN1dCB0aGUgaXRlcmF0aW9uLlxuICpcbiAqIFRoZSBhcmd1bWVudHMnIG9yZGVyIG9mIFtgcmVkdWNlUmlnaHRgXSgjcmVkdWNlUmlnaHQpJ3MgaXRlcmF0b3IgZnVuY3Rpb25cbiAqIGlzICoodmFsdWUsIGFjYykqLlxuICpcbiAqIE5vdGU6IGBSLnJlZHVjZWAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kLiBGb3IgbW9yZSBkZXRhaWxzXG4gKiBvbiB0aGlzIGJlaGF2aW9yLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UjRGVzY3JpcHRpb25cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgcmVkdWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LiBXaGVuXG4gKiBkb2luZyBzbywgaXQgaXMgdXAgdG8gdGhlIHVzZXIgdG8gaGFuZGxlIHRoZSBbYFIucmVkdWNlZGBdKCNyZWR1Y2VkKVxuICogc2hvcnRjdXRpbmcsIGFzIHRoaXMgaXMgbm90IGltcGxlbWVudGVkIGJ5IGByZWR1Y2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZSBhY2N1bXVsYXRvciBhbmQgdGhlXG4gKiAgICAgICAgY3VycmVudCBlbGVtZW50IGZyb20gdGhlIGFycmF5LlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZWQsIFIuYWRkSW5kZXgsIFIucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlZHVjZShSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgoKCgwIC0gMSkgLSAyKSAtIDMpIC0gNCkgPSAtMTBcbiAqICAgICAgLy8gICAgICAgICAgLSAgICAgICAgICAgICAgIC0xMFxuICogICAgICAvLyAgICAgICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgICAgIC0gICA0ICAgICAgICAgICAtNiAgIDRcbiAqICAgICAgLy8gICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgIC0gICAzICAgPT0+ICAgICAtMyAgIDNcbiAqICAgICAgLy8gICAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gICAgLSAgIDIgICAgICAgICAgIC0xICAgMlxuICogICAgICAvLyAgIC8gXFwgICAgICAgICAgICAgIC8gXFxcbiAqICAgICAgLy8gIDAgICAxICAgICAgICAgICAgMCAgIDFcbiAqXG4gKiBAc3ltYiBSLnJlZHVjZShmLCBhLCBbYiwgYywgZF0pID0gZihmKGYoYSwgYiksIGMpLCBkKVxuICovXG5cblxudmFyIHJlZHVjZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKF9yZWR1Y2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTsiLCJ2YXIgX2NoZWNrRm9yTWV0aG9kID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZFwiKTtcblxudmFyIF9jdXJyeTMgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5M1wiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAqIG1ldGhvZCkgZnJvbSBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAqICAgICAgUi5zbGljZSgwLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqL1xuXG5cbnZhciBzbGljZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKFxuLyojX19QVVJFX18qL1xuX2NoZWNrRm9yTWV0aG9kKCdzbGljZScsIGZ1bmN0aW9uIHNsaWNlKGZyb21JbmRleCwgdG9JbmRleCwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbn0pKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzbGljZTsiLCJ2YXIgX2N1cnJ5MiA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkyXCIpO1xuXG52YXIgZXF1YWxzID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2VxdWFsc1wiKTtcblxudmFyIHRha2UgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vdGFrZVwiKTtcbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBzdGFydHMgd2l0aCB0aGUgcHJvdmlkZWQgc3VibGlzdC5cbiAqXG4gKiBTaW1pbGFybHksIGNoZWNrcyBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCB0aGUgcHJvdmlkZWQgc3Vic3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gcHJlZml4XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZW5kc1dpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN0YXJ0c1dpdGgoJ2EnLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuc3RhcnRzV2l0aCgnYicsICdhYmMnKSAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuc3RhcnRzV2l0aChbJ2EnXSwgWydhJywgJ2InLCAnYyddKSAgICAvLz0+IHRydWVcbiAqICAgICAgUi5zdGFydHNXaXRoKFsnYiddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gZmFsc2VcbiAqL1xuXG5cbnZhciBzdGFydHNXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gKHByZWZpeCwgbGlzdCkge1xuICByZXR1cm4gZXF1YWxzKHRha2UocHJlZml4Lmxlbmd0aCwgbGlzdCksIHByZWZpeCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFydHNXaXRoOyIsInZhciBfY2hlY2tGb3JNZXRob2QgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kXCIpO1xuXG52YXIgX2N1cnJ5MSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9fY3VycnkxXCIpO1xuXG52YXIgc2xpY2UgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vc2xpY2VcIik7XG4vKipcbiAqIFJldHVybnMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdFxuICogd2l0aCBhIGB0YWlsYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBzbGljZWAgbWV0aG9kIG9mIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmhlYWQsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50YWlsKFsxLCAyLCAzXSk7ICAvLz0+IFsyLCAzXVxuICogICAgICBSLnRhaWwoWzEsIDJdKTsgICAgIC8vPT4gWzJdXG4gKiAgICAgIFIudGFpbChbMV0pOyAgICAgICAgLy89PiBbXVxuICogICAgICBSLnRhaWwoW10pOyAgICAgICAgIC8vPT4gW11cbiAqXG4gKiAgICAgIFIudGFpbCgnYWJjJyk7ICAvLz0+ICdiYydcbiAqICAgICAgUi50YWlsKCdhYicpOyAgIC8vPT4gJ2InXG4gKiAgICAgIFIudGFpbCgnYScpOyAgICAvLz0+ICcnXG4gKiAgICAgIFIudGFpbCgnJyk7ICAgICAvLz0+ICcnXG4gKi9cblxuXG52YXIgdGFpbCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKFxuLyojX19QVVJFX18qL1xuX2NoZWNrRm9yTWV0aG9kKCd0YWlsJyxcbi8qI19fUFVSRV9fKi9cbnNsaWNlKDEsIEluZmluaXR5KSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRhaWw7IiwidmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MlwiKTtcblxudmFyIF9kaXNwYXRjaGFibGUgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZVwiKTtcblxudmFyIF94dGFrZSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9pbnRlcm5hbC9feHRha2VcIik7XG5cbnZhciBzbGljZSA9XG4vKiNfX1BVUkVfXyovXG5yZXF1aXJlKFwiLi9zbGljZVwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gKiB0cmFuc2R1Y2VyL3RyYW5zZm9ybWVyIChvciBvYmplY3Qgd2l0aCBhIGB0YWtlYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmRyb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRha2UoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gKiAgICAgIFIudGFrZSgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKiAgICAgIFIudGFrZSgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2UoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlKDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqXG4gKiAgICAgIGNvbnN0IHBlcnNvbm5lbCA9IFtcbiAqICAgICAgICAnRGF2ZSBCcnViZWNrJyxcbiAqICAgICAgICAnUGF1bCBEZXNtb25kJyxcbiAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gKiAgICAgICAgJ0pvZSBNb3JlbGxvJyxcbiAqICAgICAgICAnR2VycnkgTXVsbGlnYW4nLFxuICogICAgICAgICdCb2IgQmF0ZXMnLFxuICogICAgICAgICdKb2UgRG9kZ2UnLFxuICogICAgICAgICdSb24gQ3JvdHR5J1xuICogICAgICBdO1xuICpcbiAqICAgICAgY29uc3QgdGFrZUZpdmUgPSBSLnRha2UoNSk7XG4gKiAgICAgIHRha2VGaXZlKHBlcnNvbm5lbCk7XG4gKiAgICAgIC8vPT4gWydEYXZlIEJydWJlY2snLCAnUGF1bCBEZXNtb25kJywgJ0V1Z2VuZSBXcmlnaHQnLCAnSm9lIE1vcmVsbG8nLCAnR2VycnkgTXVsbGlnYW4nXVxuICogQHN5bWIgUi50YWtlKC0xLCBbYSwgYl0pID0gW2EsIGJdXG4gKiBAc3ltYiBSLnRha2UoMCwgW2EsIGJdKSA9IFtdXG4gKiBAc3ltYiBSLnRha2UoMSwgW2EsIGJdKSA9IFthXVxuICogQHN5bWIgUi50YWtlKDIsIFthLCBiXSkgPSBbYSwgYl1cbiAqL1xuXG5cbnZhciB0YWtlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fZGlzcGF0Y2hhYmxlKFsndGFrZSddLCBfeHRha2UsIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgcmV0dXJuIHNsaWNlKDAsIG4gPCAwID8gSW5maW5pdHkgOiBuLCB4cyk7XG59KSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGFrZTsiLCJ2YXIgX2FyaXR5ID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19hcml0eVwiKTtcblxudmFyIF9jb25jYXQgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2NvbmNhdFwiKTtcblxudmFyIF9jdXJyeTIgPVxuLyojX19QVVJFX18qL1xucmVxdWlyZShcIi4vaW50ZXJuYWwvX2N1cnJ5MlwiKTtcbi8qKlxuICogYHRyeUNhdGNoYCB0YWtlcyB0d28gZnVuY3Rpb25zLCBhIGB0cnllcmAgYW5kIGEgYGNhdGNoZXJgLiBUaGUgcmV0dXJuZWRcbiAqIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGUgYHRyeWVyYDsgaWYgaXQgZG9lcyBub3QgdGhyb3csIGl0IHNpbXBseSByZXR1cm5zIHRoZVxuICogcmVzdWx0LiBJZiB0aGUgYHRyeWVyYCAqZG9lcyogdGhyb3csIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBldmFsdWF0ZXMgdGhlXG4gKiBgY2F0Y2hlcmAgZnVuY3Rpb24gYW5kIHJldHVybnMgaXRzIHJlc3VsdC4gTm90ZSB0aGF0IGZvciBlZmZlY3RpdmVcbiAqIGNvbXBvc2l0aW9uIHdpdGggdGhpcyBmdW5jdGlvbiwgYm90aCB0aGUgYHRyeWVyYCBhbmQgYGNhdGNoZXJgIGZ1bmN0aW9uc1xuICogbXVzdCByZXR1cm4gdGhlIHNhbWUgdHlwZSBvZiByZXN1bHRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoLi4ueCAtPiBhKSAtPiAoKGUsIC4uLngpIC0+IGEpIC0+ICguLi54IC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cnllciBUaGUgZnVuY3Rpb24gdGhhdCBtYXkgdGhyb3cuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXRjaGVyIFRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkIGlmIGB0cnllcmAgdGhyb3dzLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBjYXRjaCBleGNlcHRpb25zIGFuZCBzZW5kIHRoZW4gdG8gdGhlIGNhdGNoZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cnlDYXRjaChSLnByb3AoJ3gnKSwgUi5GKSh7eDogdHJ1ZX0pOyAvLz0+IHRydWVcbiAqICAgICAgUi50cnlDYXRjaCgoKSA9PiB7IHRocm93ICdmb28nfSwgUi5hbHdheXMoJ2NhdGNoZWQnKSkoJ2JhcicpIC8vID0+ICdjYXRjaGVkJ1xuICogICAgICBSLnRyeUNhdGNoKFIudGltZXMoUi5pZGVudGl0eSksIFIuYWx3YXlzKFtdKSkoJ3MnKSAvLyA9PiBbXVxuICogICAgICBSLnRyeUNhdGNoKCgpID0+IHsgdGhyb3cgJ3RoaXMgaXMgbm90IGEgdmFsaWQgdmFsdWUnfSwgKGVyciwgdmFsdWUpPT4oe2Vycm9yIDogZXJyLCAgdmFsdWUgfSkpKCdiYXInKSAvLyA9PiB7J2Vycm9yJzogJ3RoaXMgaXMgbm90IGEgdmFsaWQgdmFsdWUnLCAndmFsdWUnOiAnYmFyJ31cbiAqL1xuXG5cbnZhciB0cnlDYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF90cnlDYXRjaCh0cnllciwgY2F0Y2hlcikge1xuICByZXR1cm4gX2FyaXR5KHRyeWVyLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHJ5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2F0Y2hlci5hcHBseSh0aGlzLCBfY29uY2F0KFtlXSwgYXJndW1lbnRzKSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyeUNhdGNoOyIsInZhciBfY3VycnkxID1cbi8qI19fUFVSRV9fKi9cbnJlcXVpcmUoXCIuL2ludGVybmFsL19jdXJyeTFcIik7XG4vKipcbiAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gKiByZXR1cm5pbmcgc3VjaCBhbnN3ZXJzIGFzICdPYmplY3QnLCAnTnVtYmVyJywgJ0FycmF5Jywgb3IgJ051bGwnLiBEb2VzIG5vdFxuICogYXR0ZW1wdCB0byBkaXN0aW5ndWlzaCB1c2VyIE9iamVjdCB0eXBlcyBhbnkgZnVydGhlciwgcmVwb3J0aW5nIHRoZW0gYWxsIGFzXG4gKiAnT2JqZWN0Jy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICgqIC0+IHsqfSkgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHlwZSh7fSk7IC8vPT4gXCJPYmplY3RcIlxuICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICogICAgICBSLnR5cGUoZmFsc2UpOyAvLz0+IFwiQm9vbGVhblwiXG4gKiAgICAgIFIudHlwZSgncycpOyAvLz0+IFwiU3RyaW5nXCJcbiAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gKiAgICAgIFIudHlwZShbXSk7IC8vPT4gXCJBcnJheVwiXG4gKiAgICAgIFIudHlwZSgvW0Etel0vKTsgLy89PiBcIlJlZ0V4cFwiXG4gKiAgICAgIFIudHlwZSgoKSA9PiB7fSk7IC8vPT4gXCJGdW5jdGlvblwiXG4gKiAgICAgIFIudHlwZSh1bmRlZmluZWQpOyAvLz0+IFwiVW5kZWZpbmVkXCJcbiAqL1xuXG5cbnZhciB0eXBlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/ICdOdWxsJyA6IHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG4iLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkV2ZW50RW1pdHRlcj1lKCk6dC5FdmVudEVtaXR0ZXI9ZSgpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybigoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXs2NjA6KHQsZSk9PntlLl9fZXNNb2R1bGU9ITAsZS5FdmVudEVtaXR0ZXI9dm9pZCAwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmNhdGNoSGFuZGxlcj10fHxmdW5jdGlvbigpe319cmV0dXJuIHQucHJvdG90eXBlLmhhc0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4hKCF0aGlzLl9ldmVudHNbdF18fCF0aGlzLl9ldmVudHNbdF0ubGVuZ3RoKX0sdC5wcm90b3R5cGUuZ2V0QWN0aXZlRXZlbnRzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXZlbnRzKS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiB0Lmhhc0xpc3RlbmVycyhlKX0pKX0sdC5wcm90b3R5cGUudHJpZ2dlcj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5fZXZlbnRzW3RdJiYodGhpcy5fZXZlbnRzW3RdLnNsaWNlKCkuZm9yRWFjaCgoZnVuY3Rpb24obyl7dHJ5e28uaGFuZGxlci5jYWxsKG8uY29udGV4dCxlKX1jYXRjaCh0KXtuLmNhdGNoSGFuZGxlcih0KX1vLm9uY2UmJm4ub2ZmKHQsby5oYW5kbGVyKX0pKSx0aGlzLl9ldmVudHNbdF0ubGVuZ3RofHxkZWxldGUgdGhpcy5fZXZlbnRzW3RdKX0sdC5wcm90b3R5cGUub249ZnVuY3Rpb24odCxlLG4pe3RoaXMuX29uKHQsZSxuLCExKX0sdC5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUsbil7dGhpcy5fb24odCxlLG4sITApfSx0LnByb3RvdHlwZS5vZmY9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLG89XCJzdHJpbmdcIj09dHlwZW9mIHQ/dDpudWxsLGk9XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOlwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDpudWxsO2lmKG8paWYoaSl7aWYobyBpbiB0aGlzLl9ldmVudHMpe3ZhciByPXRoaXMuX2V2ZW50c1tvXS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmhhbmRsZXJ9KSkuaW5kZXhPZihpKTt0aGlzLl9ldmVudHNbb10uc3BsaWNlKHIsMSl9fWVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50c1tvXTtlbHNlIE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50cykuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5vZmYodCxpKX0pKX0sdC5wcm90b3R5cGUuX29uPWZ1bmN0aW9uKHQsZSxuLG8pe3RoaXMuX2V2ZW50c1t0XXx8KHRoaXMuX2V2ZW50c1t0XT1bXSksdGhpcy5fZXZlbnRzW3RdLnB1c2goe2hhbmRsZXI6ZSxjb250ZXh0Om4sb25jZTpvfSl9LHR9KCk7ZS5FdmVudEVtaXR0ZXI9bn0sNjA3OmZ1bmN0aW9uKHQsZSxuKXt2YXIgbz10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxlLG4sbyl7dm9pZCAwPT09byYmKG89biksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbyx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZVtuXX19KX06ZnVuY3Rpb24odCxlLG4sbyl7dm9pZCAwPT09byYmKG89biksdFtvXT1lW25dfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gdClcImRlZmF1bHRcIj09PW58fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfHxvKGUsdCxuKX07ZS5fX2VzTW9kdWxlPSEwO3ZhciByPW4oNjYwKTtpKG4oNjYwKSxlKSxlLmRlZmF1bHQ9ci5FdmVudEVtaXR0ZXJ9fSxlPXt9O3JldHVybiBmdW5jdGlvbiBuKG8pe2lmKGVbb10pcmV0dXJuIGVbb10uZXhwb3J0czt2YXIgaT1lW29dPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtvXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmV4cG9ydHN9KDYwNyl9KSgpfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLm1pbi5qcy5tYXAiLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiaW1wb3J0IHsgU2lnbmVyIH0gZnJvbSAnQHdhdmVzL3NpZ25lcic7XHJcbmltcG9ydCB7IFByb3ZpZGVyV2ViIH0gZnJvbSAnQHdhdmVzLmV4Y2hhbmdlL3Byb3ZpZGVyLXdlYic7XHJcbmltcG9ydCB7IFByb3ZpZGVyU2VlZCB9IGZyb20gJ0B3YXZlcy9wcm92aWRlci1zZWVkJztcclxuXHJcbmNvbnN0IHNlZWQgPSBcInJpdHVhbCB0b3JuYWRvIHJpY2ggYXV0dW1uIHNrZXRjaCBjcmVlayBvdXRwdXQgaG9zcGl0YWwgcXVlc3Rpb24gbmVlZCBjcmF6eSBjb2xvciBwaWxvdCBoYW1zdGVyIG5vdGVcIjsvL2xpYnMuY3J5cHRvLnJhbmRvbVNlZWQoMTUpO1xyXG5jb25zdCBzaWduZXIgID0gbmV3IFNpZ25lcih7Tk9ERV9VUkw6ICdodHRwczovL25vZGVzLXRlc3RuZXQud2F2ZXNub2Rlcy5jb20nfSk7XHJcbmNvbnN0IHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyV2ViKCdodHRwczovL3Rlc3RuZXQud2F2ZXMuZXhjaGFuZ2Uvc2lnbmVyLycpO1xyXG5cclxuc2lnbmVyLnNldFByb3ZpZGVyKG5ldyBQcm92aWRlclNlZWQoc2VlZCkpO1xyXG4vL3NpZ25lci5zZXRQcm92aWRlcihwcm92aWRlcik7XHJcblxyXG5cclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy1sb2dpblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgc2lnbmVyLmxvZ2luKCk7XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoXCJjbGlja2VkXCIpO1xyXG4gICAgICAgIGV2ZW50LnRhcmdldC5pbm5lckhUTUwgPSBgXHJcbiAgICAgICAgICAgIGF1dGhvcml6ZWQgYXMgPGJyPlxyXG4gICAgICAgICAgICAke3VzZXJEYXRhLmFkZHJlc3N9YDtcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmV4cGxvcmVyLWxpbmtcIikuaW5uZXJIVE1MID0gYDxhIGhyZWY9XCJodHRwczovL3dhdmVzZXhwbG9yZXIuY29tL3Rlc3RuZXQvYWRkcmVzcy8ke3VzZXJEYXRhLmFkZHJlc3N9XCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q2hlY2sgdGhlIEV4cGxvcmVyPC9hPmA7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignbG9naW4gcmVqZWN0ZWQnKVxyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG4vLyBjYWxsaW5nIGEgXCJmYXVjZXRcIiBzY3JpcHQgd2F2ZXNleHBsb3Jlci5jb20vdGVzbmV0L2FkZHJlc3MvM011TjdEOHIxOXpkdlNwQWQxTDkxR3M4OGJjZ3dVRnkybW4vc2NyaXB0XHJcbi8vIHRoaXMgd2lsbCB0b3AgdXAgdGhlIGFjY291bnQgYmFsYW5jZSwgYnV0IG9ubHkgb25jZVxyXG4vKlxyXG5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmpzLWludm9rZVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgc2lnbmVyLmludm9rZSh7XHJcbiAgICAgICAgZEFwcDogXCIzTXVON0Q4cjE5emR2U3BBZDFMOTFHczg4YmNnd1VGeTJtblwiLFxyXG4gICAgICAgIGNhbGw6IHtcclxuICAgICAgICAgICAgZnVuY3Rpb246IFwiZmF1Y2V0XCJcclxuICAgICAgICB9XHJcbiAgICB9KS5icm9hZGNhc3QoKS50aGVuKGNvbnNvbGUubG9nKVxyXG59KTtcclxuKi9cclxuXHJcblxyXG4vLyBqdXN0IHB1dHRpbmcgc29tZSBkYXRhIGludG8gYWNjb3VudCBzdG9yYWdlXHJcbi8qXHJcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuanMtZGF0YVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBzaWduZXIuZGF0YSh7XHJcbiAgICAgICAgZGF0YTogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBrZXk6IFwibGFzdENhbGxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtkYXRlLmdldERhdGUoKX0uJHtkYXRlLmdldE1vbnRoKCkgKyAxfS4ke2RhdGUuZ2V0RnVsbFllYXIoKX0gJHtkYXRlLmdldEhvdXJzKCl9OiR7ZGF0ZS5nZXRNaW51dGVzKCl9OiR7ZGF0ZS5nZXRTZWNvbmRzKCl9YCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICB9KS5icm9hZGNhc3QoKS50aGVuKGNvbnNvbGUubG9nKVxyXG59KTtcclxuKi9cclxuXHJcbi8vIGp1c3QgdHJhbnNmZXJyaW5nIHNvbWUgV0FWRVMgdG9rZW4gdG8gQWxpY2VcclxuLypcclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5qcy10cmFuc2ZlclwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgc2lnbmVyLnRyYW5zZmVyKHtcclxuICAgICAgICByZWNpcGllbnQ6IFwiM011TjdEOHIxOXpkdlNwQWQxTDkxR3M4OGJjZ3dVRnkybW5cIixcclxuICAgICAgICBhbW91bnQ6IDFcclxuICAgIH0pLmJyb2FkY2FzdCgpLnRoZW4oY29uc29sZS5sb2cpXHJcbn0pO1xyXG4qLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=